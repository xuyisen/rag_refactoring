[
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "sourceCodeBeforeRefactoring": "public WndEnergizeItem(Item item, WndBag owner) {\n\t\tsuper(item);\n\n\t\tthis.owner = owner;\n\n\t\tfloat pos = height;\n\n\t\tif (item.quantity() == 1) {\n\n\t\t\tRedButton btnEnergize = new RedButton( Messages.get(this, \"energize\", item.energyVal()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergize( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize );\n\n\t\t\tpos = btnEnergize.bottom();\n\n\t\t} else {\n\n\t\t\tint energyAll = item.energyVal();\n\t\t\tRedButton btnEnergize1 = new RedButton( Messages.get(this, \"energize_1\", energyAll / item.quantity()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeOne( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize1.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize1 );\n\t\t\tRedButton btnEnergizeAll = new RedButton( Messages.get(this, \"energize_all\", energyAll ) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergize( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergizeAll.setRect( 0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT );\n\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergizeAll );\n\n\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t}\n\n\t\tresize( width, (int)pos );\n\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic WndEnergizeItem(Item item, WndBag owner) {\n    super(item);\n\n    this.owner = owner;\n\n    float pos = height;\n\n    if (item.quantity() == 1) {\n\n        RedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n            @Override\n            protected void onClick() {\n                energize(item);\n                hide();\n            }\n        };\n        btnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n        btnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n        add(btnEnergize);\n\n        pos = btnEnergize.bottom();\n\n    } else {\n\n        int energyAll = item.energyVal();\n        RedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n            @Override\n            protected void onClick() {\n                energizeOne(item);\n                hide();\n            }\n        };\n        btnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n        btnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n        add(btnEnergize1);\n        RedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n            @Override\n            protected void onClick() {\n                energize(item);\n                hide();\n            }\n        };\n        btnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n        btnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n        add(btnEnergizeAll);\n\n        pos = btnEnergizeAll.bottom();\n\n    }\n\n    resize(width, (int)pos);\n}\n```\n\n### Refactored Code:\n```java\npublic WndEnergizeItem(Item item, WndBag owner) {\n    super(item);\n    this.owner = owner;\n\n    float pos = height;\n\n    if (item.quantity() == 1) {\n        createSingleEnergizeButton(item, pos);\n    } else {\n        createMultipleEnergizeButtons(item, pos);\n    }\n\n    resize(width, (int) pos);\n}\n\nprivate void createSingleEnergizeButton(Item item, float pos) {\n    RedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n        @Override\n        protected void onClick() {\n            energize(item);\n            hide();\n        }\n    };\n    btnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergize);\n}\n\nprivate void createMultipleEnergizeButtons(Item item, float pos) {\n    int energyAll = item.energyVal();\n    \n    RedButton btnEnergizeOne = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n        @Override\n        protected void onClick() {\n            energizeOne(item);\n            hide();\n        }\n    };\n    btnEnergizeOne.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnEnergizeOne.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergizeOne);\n\n    RedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n        @Override\n        protected void onClick() {\n            energize(item);\n            hide();\n        }\n    };\n    btnEnergizeAll.setRect(0, btnEnergizeOne.bottom() + 1, width, BTN_HEIGHT);\n    btnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergizeAll);\n}\n```\n\n### Summary of Changes:\n- Extracted the logic for creating buttons into separate methods (`createSingleEnergizeButton` and `createMultipleEnergizeButtons`) to improve readability and maintainability.\n- This reduces the complexity of the constructor and makes it easier to understand the flow of button creation based on the item quantity.",
        "sourceCodeAfterRefactoring": "public WndEnergizeItem(Item item, WndBag owner) {\n\t\tsuper(item);\n\n\t\tthis.owner = owner;\n\n\t\tfloat pos = height;\n\n\t\tif (item.quantity() == 1) {\n\n\t\t\tRedButton btnEnergize = new RedButton( Messages.get(this, \"energize\", item.energyVal()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeAll( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize );\n\n\t\t\tpos = btnEnergize.bottom();\n\n\t\t} else {\n\n\t\t\tint energyAll = item.energyVal();\n\t\t\tRedButton btnEnergize1 = new RedButton( Messages.get(this, \"energize_1\", energyAll / item.quantity()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeOne( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize1.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize1 );\n\t\t\tRedButton btnEnergizeAll = new RedButton( Messages.get(this, \"energize_all\", energyAll ) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeAll( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergizeAll.setRect( 0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT );\n\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergizeAll );\n\n\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t}\n\n\t\tresize( width, (int)pos );\n\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static void energizeAll(Item item ) {\n\n\t\tif (item.isEquipped( Dungeon.hero ) && !((EquipableItem)item).doUnequip( Dungeon.hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( Dungeon.hero.belongings.backpack );\n\t\tenergize(item);\n\t}",
        "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_44_96_110_117_45_97",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nAfter Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}\nExample 2:\n Before Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.thrownException().getMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.thrownException() instanceof AssertionFailedError) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nAfter Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.exceptionMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.isFailure()) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nExtractedCodeFragments:\n}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\nExample 3:\n Before Refactoring:\nprotected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}\n\nAfter Refactoring:\nprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\nExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "sourceCodeBeforeRefactoring": "public static void energizeOne( Item item ) {\n\n\t\tif (item.quantity() <= 1) {\n\t\t\tenergize( item );\n\t\t} else {\n\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\titem = item.detach( hero.belongings.backpack );\n\n\t\t\tif (ShatteredPixelDungeon.scene() instanceof AlchemyScene){\n\n\t\t\t\tDungeon.energy += item.energyVal();\n\t\t\t\t((AlchemyScene) ShatteredPixelDungeon.scene()).createEnergy();\n\n\t\t\t} else {\n\n\t\t\t\t\n\t\t\t\thero.spend(-hero.cooldown());\n\n\t\t\t\tnew EnergyCrystal(item.energyVal()).doPickUp(hero);\n\t\t\t}\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static void energizeOne(Item item) {\n    if (item.quantity() <= 1) {\n        energize(item);\n    } else {\n        Hero hero = Dungeon.hero;\n        item = item.detach(hero.belongings.backpack);\n\n        if (ShatteredPixelDungeon.scene() instanceof AlchemyScene) {\n            Dungeon.energy += item.energyVal();\n            ((AlchemyScene) ShatteredPixelDungeon.scene()).createEnergy();\n        } else {\n            hero.spend(-hero.cooldown());\n            new EnergyCrystal(item.energyVal()).doPickUp(hero);\n        }\n    }\n}\n```\n\n### Refactored Code:\n```java\npublic static void energizeOne(Item item) {\n    if (item.quantity() <= 1) {\n        energize(item);\n    } else {\n        Hero hero = Dungeon.hero;\n        item = item.detach(hero.belongings.backpack);\n        processEnergizeItem(item, hero);\n    }\n}\n\nprivate static void processEnergizeItem(Item item, Hero hero) {\n    if (ShatteredPixelDungeon.scene() instanceof AlchemyScene) {\n        handleAlchemyScene(item);\n    } else {\n        handleStandardScene(item, hero);\n    }\n}\n\nprivate static void handleAlchemyScene(Item item) {\n    Dungeon.energy += item.energyVal();\n    ((AlchemyScene) ShatteredPixelDungeon.scene()).createEnergy();\n}\n\nprivate static void handleStandardScene(Item item, Hero hero) {\n    hero.spend(-hero.cooldown());\n    new EnergyCrystal(item.energyVal()).doPickUp(hero);\n}\n```\n\n### Explanation of Refactoring:\n1. **Extract Method**: The logic for processing the energize item was extracted into a separate method (`processEnergizeItem`) to improve readability and maintainability.\n2. **Further Extraction**: The handling of the two different scenes (Alchemy and Standard) was further broken down into their own methods (`handleAlchemyScene` and `handleStandardScene`) to encapsulate the behavior and make the main method cleaner.\n3. **Improved Readability**: The refactored code is easier to read and understand, as each method has a clear purpose and the main logic flow is more straightforward.",
        "sourceCodeAfterRefactoring": "public static void energizeOne( Item item ) {\n\n\t\tif (item.quantity() <= 1) {\n\t\t\tenergizeAll( item );\n\t\t} else {\n\t\t\tenergize(item.detach( Dungeon.hero.belongings.backpack ));\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static void energizeAll(Item item ) {\n\n\t\tif (item.isEquipped( Dungeon.hero ) && !((EquipableItem)item).doUnequip( Dungeon.hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( Dungeon.hero.belongings.backpack );\n\t\tenergize(item);\n\t}",
        "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_133_156_110_117_119_126",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t\n    \t\t\n    \t\t\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\nExample 2:\n Before Refactoring:\n\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading)\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\nAfter Refactoring:\n\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (useReoadingTestSuiteLoader())\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\nExtractedCodeFragments:\nprotected boolean useReoadingTestSuiteLoader() {\n\t\treturn getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading;\n\t}\nExample 3:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        \n        \n        \n        \n        \n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
        "sourceCodeBeforeRefactoring": "public WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\n\t\t\tthis.owner = owner;\n\n\t\t\tfloat pos = height;\n\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\n\t\t\t\t\tpos = btnSell.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\n\t\t\t\t\tpos = btnSellAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\n\t\t\t\t\tpos = btnEnergize.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\n\n\t\t\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresize( width, (int)pos );\n\n\t\t}",
        "refactoredCode": "### Original Code:\n```java\npublic WndAlchemizeItem(Item item, WndBag owner) {\n    super(item);\n    this.owner = owner;\n\n    float pos = height;\n\n    if (Shopkeeper.canSell(item)) {\n        if (item.quantity() == 1) {\n            RedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n                @Override\n                protected void onClick() {\n                    WndTradeItem.sell(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n            btnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n            add(btnSell);\n            pos = btnSell.bottom();\n        } else {\n            int priceAll = item.value();\n            RedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n                @Override\n                protected void onClick() {\n                    WndTradeItem.sellOne(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n            btnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n            add(btnSell1);\n            RedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n                @Override\n                protected void onClick() {\n                    WndTradeItem.sell(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n            btnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n            add(btnSellAll);\n            pos = btnSellAll.bottom();\n        }\n    }\n\n    if (item.energyVal() > 0) {\n        if (item.quantity() == 1) {\n            RedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n                @Override\n                protected void onClick() {\n                    WndEnergizeItem.energize(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n            btnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n            add(btnEnergize);\n            pos = btnEnergize.bottom();\n        } else {\n            int energyAll = item.energyVal();\n            RedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n                @Override\n                protected void onClick() {\n                    WndEnergizeItem.energizeOne(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n            btnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n            add(btnEnergize1);\n            RedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n                @Override\n                protected void onClick() {\n                    WndEnergizeItem.energize(item);\n                    hide();\n                    consumeAlchemize();\n                }\n            };\n            btnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n            btnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n            add(btnEnergizeAll);\n            pos = btnEnergizeAll.bottom();\n        }\n    }\n\n    resize(width, (int)pos);\n}\n```\n\n### Refactored Code:\n```java\npublic WndAlchemizeItem(Item item, WndBag owner) {\n    super(item);\n    this.owner = owner;\n\n    float pos = height;\n\n    if (Shopkeeper.canSell(item)) {\n        createSellButtons(item, pos);\n    }\n\n    if (item.energyVal() > 0) {\n        createEnergizeButtons(item, pos);\n    }\n\n    resize(width, (int)pos);\n}\n\nprivate void createSellButtons(Item item, float pos) {\n    if (item.quantity() == 1) {\n        addSellButton(item, pos);\n    } else {\n        addSellOneButton(item, pos);\n        addSellAllButton(item, pos);\n    }\n}\n\nprivate void addSellButton(Item item, float pos) {\n    RedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n        @Override\n        protected void onClick() {\n            WndTradeItem.sell(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n    add(btnSell);\n}\n\nprivate void addSellOneButton(Item item, float pos) {\n    int priceAll = item.value();\n    RedButton btnSellOne = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n        @Override\n        protected void onClick() {\n            WndTradeItem.sellOne(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnSellOne.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnSellOne.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n    add(btnSellOne);\n}\n\nprivate void addSellAllButton(Item item, float pos) {\n    int priceAll = item.value();\n    RedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n        @Override\n        protected void onClick() {\n            WndTradeItem.sell(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnSellAll.setRect(0, btnSellOne.bottom() + 1, width, BTN_HEIGHT);\n    btnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n    add(btnSellAll);\n}\n\nprivate void createEnergizeButtons(Item item, float pos) {\n    if (item.quantity() == 1) {\n        addEnergizeButton(item, pos);\n    } else {\n        addEnergizeOneButton(item, pos);\n        addEnergizeAllButton(item, pos);\n    }\n}\n\nprivate void addEnergizeButton(Item item, float pos) {\n    RedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n        @Override\n        protected void onClick() {\n            WndEnergizeItem.energize(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergize);\n}\n\nprivate void addEnergizeOneButton(Item item, float pos) {\n    int energyAll = item.energyVal();\n    RedButton btnEnergizeOne = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n        @Override\n        protected void onClick() {\n            WndEnergizeItem.energizeOne(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnEnergizeOne.setRect(0, pos + GAP, width, BTN_HEIGHT);\n    btnEnergizeOne.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergizeOne);\n}\n\nprivate void addEnergizeAllButton(Item item, float pos) {\n    int energyAll = item.energyVal();\n    RedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n        @Override\n        protected void onClick() {\n            WndEnergizeItem.energize(item);\n            hide();\n            consumeAlchemize();\n        }\n    };\n    btnEnergizeAll.setRect(0, btnEnergizeOne.bottom() + 1, width, BTN_HEIGHT);\n    btnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n    add(btnEnergizeAll);\n}\n```\n\n### Summary of Changes:\n- Extracted button creation logic into separate methods (`createSellButtons`, `addSellButton`, `addSellOneButton`, `addSellAllButton`, `createEnergizeButtons`, `addEnergizeButton`, `addEnergizeOneButton`, `addEnergizeAllButton`) to improve readability and maintainability.\n- Reduced code duplication by consolidating similar button creation logic into reusable methods.",
        "sourceCodeAfterRefactoring": "public WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\n\t\t\tthis.owner = owner;\n\n\t\t\tfloat pos = height;\n\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\n\t\t\t\t\tpos = btnSell.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\n\t\t\t\t\tpos = btnSellAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeAll(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\n\t\t\t\t\tpos = btnEnergize.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeAll(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\n\n\t\t\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresize( width, (int)pos );\n\n\t\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static WndBag.ItemSelector itemSelector = new WndBag.ItemSelector() {\n\t\t@Override\n\t\tpublic String textPrompt() {\n\t\t\treturn Messages.get(Alchemize.class, \"prompt\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean itemSelectable(Item item) {",
        "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_141_246_110_117_141_246",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nAfter Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}\nExample 2:\n Before Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.thrownException().getMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.thrownException() instanceof AssertionFailedError) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nAfter Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.exceptionMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.isFailure()) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nExtractedCodeFragments:\n}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\nExample 3:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "92905ae81c0eb272c9a62d5f6914bda253fc571d",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/92905ae81c0eb272c9a62d5f6914bda253fc571d",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tString loadingAsset;\n\t\tint loadingDepth;\n\t\tfadeTime = NORM_FADE;\n\n\t\tlong seed = Dungeon.seed;\n\t\tswitch (mode){\n\t\t\tdefault:\n\t\t\t\tloadingDepth = Dungeon.depth;\n\t\t\t\tbreak;\n\t\t\tcase CONTINUE:\n\t\t\t\tloadingDepth = GamesInProgress.check(GamesInProgress.curSlot).depth;\n\t\t\t\tseed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n\t\t\t\tbreak;\n\t\t\tcase DESCEND:\n\t\t\t\tif (Dungeon.hero == null){\n\t\t\t\t\tloadingDepth = 1;\n\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t} else {\n\t\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\t\telse                        loadingDepth = Dungeon.depth+1;\n\t\t\t\t\tif (Statistics.deepestFloor >= loadingDepth) {\n\t\t\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\t\t} else if (loadingDepth == 6 || loadingDepth == 11\n\t\t\t\t\t\t\t|| loadingDepth == 16 || loadingDepth == 21) {\n\t\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FALL:\n\t\t\t\tloadingDepth = Dungeon.depth+1;\n\t\t\t\tbreak;\n\t\t\tcase ASCEND:\n\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\telse                        loadingDepth = Dungeon.depth-1;\n\t\t\t\tbreak;\n\t\t\tcase RETURN:\n\t\t\t\tloadingDepth = returnDepth;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tint region = (int)Math.ceil(loadingDepth / 5f);\n\t\tif (region != lastRegion){\n\t\t\tTextureCache.clear();\n\t\t\tlastRegion = region;\n\t\t}\n\n\t\tint loadingCenter = 400;\n\n\t\t\n\t\t\n\t\tRandom.pushGenerator(seed+lastRegion);\n\t\t\tswitch (lastRegion){\n\t\t\t\tcase 1:\n\t\t\t\t\tloadingAsset = Assets.Splashes.SEWERS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 180; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 485; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 700; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingAsset = Assets.Splashes.PRISON;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 190; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 402; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 650; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CAVES;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 120; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 340; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CITY;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 275; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 460; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: default:\n\t\t\t\t\tloadingAsset = Assets.Splashes.HALLS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 145; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 400; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 615; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tRandom.popGenerator();\n\t\t\n\t\tif (DeviceCompat.isDebug()){\n\t\t\tfadeTime = 0f;\n\t\t}\n\n\t\tImage background = new Image(loadingAsset);\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tif (Camera.main.width >= background.width()){\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\t} else {\n\t\t\tbackground.x = Camera.main.width/2f - loadingCenter*background.scale.x;\n\t\t\tbackground.x = GameMath.gate(Camera.main.width - background.width(), background.x, 0);\n\t\t}\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tImage fadeLeft, fadeRight;\n\t\tfadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n\t\tfadeLeft.x = background.x-2;\n\t\tfadeLeft.scale.set(3, background.height());\n\t\tfadeLeft.visible = background.x > 0;\n\t\tadd(fadeLeft);\n\n\t\tfadeRight = new Image(fadeLeft);\n\t\tfadeRight.x = background.x + background.width() + 2;\n\t\tfadeRight.y = background.y + background.height();\n\t\tfadeRight.angle = 180;\n\t\tfadeRight.visible = fadeLeft.visible;\n\t\tadd(fadeRight);\n\n\t\tImage im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tif (lastRegion == 6)                aa = 1;\n\t\t\t\telse if (phase == Phase.FADE_IN)    aa = Math.max( 0, 2*(timeLeft - (fadeTime - 0.333f)));\n\t\t\t\telse if (phase == Phase.FADE_OUT)   aa = Math.max( 0, 2*(0.333f - timeLeft));\n\t\t\t\telse                                aa = 0;\n\t\t\t}\n\t\t};\n\t\tim.angle = 90;\n\t\tim.x = Camera.main.width;\n\t\tim.scale.x = Camera.main.height/5f;\n\t\tim.scale.y = Camera.main.width;\n\t\tadd(im);\n\n\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\n\t\tmessage = PixelScene.renderTextBlock( text, 9 );\n\t\tmessage.setPos(\n\t\t\t\t(Camera.main.width - message.width() - 8),\n\t\t\t\t(Camera.main.height - message.height() - 6)\n\t\t);\n\t\talign(message);\n\t\tadd( message );\n\n\t\tphase = Phase.FADE_IN;\n\t\ttimeLeft = fadeTime;\n\t\t\n\t\tif (thread == null) {\n\t\t\tthread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tActor.fixTime();\n\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase DESCEND:\n\t\t\t\t\t\t\t\tdescend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASCEND:\n\t\t\t\t\t\t\t\tascend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\t\trestore();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESURRECT:\n\t\t\t\t\t\t\t\tresurrect();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RETURN:\n\t\t\t\t\t\t\t\treturnTo();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FALL:\n\t\t\t\t\t\t\t\tfall();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESET:\n\t\t\t\t\t\t\t\treset();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (thread) {\n\t\t\t\t\t\tif (phase == Phase.STATIC && error == null) {\n\t\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthread.start();\n\t\t}\n\t\twaitingTime = 0f;\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tString loadingAsset;\n\t\tint loadingDepth;\n\t\tfadeTime = NORM_FADE;\n\n\t\tlong seed = Dungeon.seed;\n\t\tswitch (mode){\n\t\t\tdefault:\n\t\t\t\tloadingDepth = Dungeon.depth;\n\t\t\t\tbreak;\n\t\t\tcase CONTINUE:\n\t\t\t\tloadingDepth = GamesInProgress.check(GamesInProgress.curSlot).depth;\n\t\t\t\tseed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n\t\t\t\tbreak;\n\t\t\tcase DESCEND:\n\t\t\t\tif (Dungeon.hero == null){\n\t\t\t\t\tloadingDepth = 1;\n\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t} else {\n\t\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\t\telse                        loadingDepth = Dungeon.depth+1;\n\t\t\t\t\tif (Statistics.deepestFloor >= loadingDepth) {\n\t\t\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\t\t} else if (loadingDepth == 6 || loadingDepth == 11\n\t\t\t\t\t\t\t|| loadingDepth == 16 || loadingDepth == 21) {\n\t\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FALL:\n\t\t\t\tloadingDepth = Dungeon.depth+1;\n\t\t\t\tbreak;\n\t\t\tcase ASCEND:\n\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\telse                        loadingDepth = Dungeon.depth-1;\n\t\t\t\tbreak;\n\t\t\tcase RETURN:\n\t\t\t\tloadingDepth = returnDepth;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tint region = (int)Math.ceil(loadingDepth / 5f);\n\t\tif (region != lastRegion){\n\t\t\tTextureCache.clear();\n\t\t\tlastRegion = region;\n\t\t}\n\n\t\tint loadingCenter = 400;\n\n\t\t\n\t\t\n\t\tRandom.pushGenerator(seed+lastRegion);\n\t\t\tswitch (lastRegion){\n\t\t\t\tcase 1:\n\t\t\t\t\tloadingAsset = Assets.Splashes.SEWERS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 180; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 485; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 700; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingAsset = Assets.Splashes.PRISON;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 190; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 402; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 650; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CAVES;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 120; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 340; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CITY;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 275; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 460; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: default:\n\t\t\t\t\tloadingAsset = Assets.Splashes.HALLS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 145; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 400; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 615; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tRandom.popGenerator();\n\t\t\n\t\tif (DeviceCompat.isDebug()){\n\t\t\tfadeTime = 0f;\n\t\t}\n\n\t\tImage background = new Image(loadingAsset);\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tif (Camera.main.width >= background.width()){\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\t} else {\n\t\t\tbackground.x = Camera.main.width/2f - loadingCenter*background.scale.x;\n\t\t\tbackground.x = GameMath.gate(Camera.main.width - background.width(), background.x, 0);\n\t\t}\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tImage fadeLeft, fadeRight;\n\t\tfadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n\t\tfadeLeft.x = background.x-2;\n\t\tfadeLeft.scale.set(3, background.height());\n\t\tfadeLeft.visible = background.x > 0;\n\t\tadd(fadeLeft);\n\n\t\tfadeRight = new Image(fadeLeft);\n\t\tfadeRight.x = background.x + background.width() + 2;\n\t\tfadeRight.y = background.y + background.height();\n\t\tfadeRight.angle = 180;\n\t\tfadeRight.visible = fadeLeft.visible;\n\t\tadd(fadeRight);\n\n\t\tImage im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tif (lastRegion == 6)                aa = 1;\n\t\t\t\telse if (phase == Phase.FADE_IN)    aa = Math.max( 0, 2*(timeLeft - (fadeTime - 0.333f)));\n\t\t\t\telse if (phase == Phase.FADE_OUT)   aa = Math.max( 0, 2*(0.333f - timeLeft));\n\t\t\t\telse                                aa = 0;\n\t\t\t}\n\t\t};\n\t\tim.angle = 90;\n\t\tim.x = Camera.main.width;\n\t\tim.scale.x = Camera.main.height/5f;\n\t\tim.scale.y = Camera.main.width;\n\t\tadd(im);\n\n\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\n\t\tmessage = PixelScene.renderTextBlock( text, 9 );\n\t\tmessage.setPos(\n\t\t\t\t(Camera.main.width - message.width() - 8),\n\t\t\t\t(Camera.main.height - message.height() - 6)\n\t\t);\n\t\talign(message);\n\t\tadd( message );\n\n\t\tphase = Phase.FADE_IN;\n\t\ttimeLeft = fadeTime;\n\t\t\n\t\tif (thread == null) {\n\t\t\tthread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tActor.fixTime();\n\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase DESCEND:\n\t\t\t\t\t\t\t\tdescend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASCEND:\n\t\t\t\t\t\t\t\tascend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\t\trestore();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESURRECT:\n\t\t\t\t\t\t\t\tresurrect();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RETURN:\n\t\t\t\t\t\t\t\treturnTo();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FALL:\n\t\t\t\t\t\t\t\tfall();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESET:\n\t\t\t\t\t\t\t\treset();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (thread) {\n\t\t\t\t\t\tif (phase == Phase.STATIC && error == null) {\n\t\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthread.start();\n\t\t}\n\t\twaitingTime = 0f;\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\npublic void create() {\n    super.create();\n\n    String loadingAsset;\n    int loadingDepth;\n    fadeTime = NORM_FADE;\n\n    long seed = Dungeon.seed;\n    loadingDepth = determineLoadingDepth();\n    seed = updateSeedIfContinuing(seed);\n\n    int region = (int) Math.ceil(loadingDepth / 5f);\n    updateRegion(region);\n\n    int loadingCenter = getLoadingCenter(region);\n    loadingAsset = getLoadingAsset(region);\n\n    Random.pushGenerator(seed + lastRegion);\n    Random.popGenerator();\n\n    if (DeviceCompat.isDebug()) {\n        fadeTime = 0f;\n    }\n\n    Image background = createBackgroundImage(loadingAsset);\n    add(background);\n\n    addFadeImages(background);\n    addLoadingIndicator();\n\n    String text = Messages.get(Mode.class, mode.name());\n    message = PixelScene.renderTextBlock(text, 9);\n    positionMessage(message);\n    add(message);\n\n    phase = Phase.FADE_IN;\n    timeLeft = fadeTime;\n\n    startLoadingThread();\n    waitingTime = 0f;\n}\n\nprivate int determineLoadingDepth() {\n    switch (mode) {\n        case CONTINUE:\n            return GamesInProgress.check(GamesInProgress.curSlot).depth;\n        case DESCEND:\n            return Dungeon.hero == null ? 1 : (curTransition != null ? curTransition.destDepth : Dungeon.depth + 1);\n        case FALL:\n            return Dungeon.depth + 1;\n        case ASCEND:\n            fadeTime = FAST_FADE;\n            return curTransition != null ? curTransition.destDepth : Dungeon.depth - 1;\n        case RETURN:\n            return returnDepth;\n        default:\n            return Dungeon.depth;\n    }\n}\n\nprivate long updateSeedIfContinuing(long seed) {\n    if (mode == Mode.CONTINUE) {\n        seed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n    }\n    return seed;\n}\n\nprivate void updateRegion(int region) {\n    if (region != lastRegion) {\n        TextureCache.clear();\n        lastRegion = region;\n    }\n}\n\nprivate int getLoadingCenter(int region) {\n    switch (region) {\n        case 1: return Random.Int(3) == 0 ? 180 : (Random.Int(3) == 1 ? 485 : 700);\n        case 2: return Random.Int(3) == 0 ? 190 : (Random.Int(3) == 1 ? 402 : 650);\n        case 3: return Random.Int(3) == 0 ? 120 : (Random.Int(3) == 1 ? 340 : 625);\n        case 4: return Random.Int(3) == 0 ? 275 : (Random.Int(3) == 1 ? 460 : 625);\n        case 5: \n        default: return Random.Int(3) == 0 ? 145 : (Random.Int(3) == 1 ? 400 : 615);\n    }\n}\n\nprivate String getLoadingAsset(int region) {\n    switch (region) {\n        case 1: return Assets.Splashes.SEWERS;\n        case 2: return Assets.Splashes.PRISON;\n        case 3: return Assets.Splashes.CAVES;\n        case 4: return Assets.Splashes.CITY;\n        case 5: \n        default: return Assets.Splashes.HALLS;\n    }\n}\n\nprivate Image createBackgroundImage(String loadingAsset) {\n    Image background = new Image(loadingAsset);\n    background.scale.set(Camera.main.height / background.height);\n    background.x = (Camera.main.width >= background.width()) ? \n        (Camera.main.width - background.width()) / 2f : \n        GameMath.gate(Camera.main.width - background.width(), Camera.main.width / 2f - getLoadingCenter(lastRegion) * background.scale.x, 0);\n    background.y = (Camera.main.height - background.height()) / 2f;\n    PixelScene.align(background);\n    return background;\n}\n\nprivate void addFadeImages(Image background) {\n    Image fadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n    fadeLeft.x = background.x - 2;\n    fadeLeft.scale.set(3, background.height());\n    fadeLeft.visible = background.x > 0;\n    add(fadeLeft);\n\n    Image fadeRight = new Image(fadeLeft);\n    fadeRight.x = background.x + background.width() + 2;\n    fadeRight.y = background.y + background.height();\n    fadeRight.angle = 180;\n    fadeRight.visible = fadeLeft.visible;\n    add(fadeRight);\n}\n\nprivate void addLoadingIndicator() {\n    Image im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)) {\n        @Override\n        public void update() {\n            super.update();\n            if (lastRegion == 6) aa = 1;\n            else if (phase == Phase.FADE_IN) aa = Math.max(0, 2 * (timeLeft - (fadeTime - 0.333f)));\n            else if (phase == Phase.FADE_OUT) aa = Math.max(0, 2 * (0.333f - timeLeft));\n            else aa = 0;\n        }\n    };\n    im.angle = 90;\n    im.x = Camera.main.width;\n    im.scale.x = Camera.main.height / 5f;\n    im.scale.y = Camera.main.width;\n    add(im);\n}\n\nprivate void positionMessage(Image message) {\n    message.setPos(\n        (Camera.main.width - message.width() - 8),\n        (Camera.main.height - message.height() - 6)\n    );\n    align(message);\n}\n\nprivate void startLoadingThread() {\n    if (thread == null) {\n        thread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Actor.fixTime();\n                    switch (mode) {\n                        case DESCEND: descend(); break;\n                        case ASCEND: ascend(); break;\n                        case CONTINUE: restore(); break;\n                        case RESURRECT: resurrect(); break;\n                        case RETURN: returnTo(); break;\n                        case FALL: fall(); break;\n                        case RESET: reset(); break;\n                    }\n                } catch (Exception e) {\n                    error = e;\n                }\n\n                synchronized (thread) {\n                    if (phase == Phase.STATIC && error == null) {\n                        phase = Phase.FADE_OUT;\n                        timeLeft = fadeTime;\n                    }\n                }\n            }\n        };\n        thread.start();\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: The code was broken down into smaller, more manageable methods to improve readability and maintainability.\n2. **Simplified Logic**: The logic for determining loading depth, loading asset, and loading center was encapsulated in dedicated methods.\n3. **Reduced Repetition**: The logic for setting loading center and asset was consolidated to avoid repetition.\n4. **Improved Clarity**: The overall structure of the `create` method was simplified, making it easier to follow the flow of the code.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tString loadingAsset;\n\t\tint loadingDepth;\n\t\tfadeTime = NORM_FADE;\n\n\t\tlong seed = Dungeon.seed;\n\t\tswitch (mode){\n\t\t\tdefault:\n\t\t\t\tloadingDepth = Dungeon.depth;\n\t\t\t\tbreak;\n\t\t\tcase CONTINUE:\n\t\t\t\tloadingDepth = GamesInProgress.check(GamesInProgress.curSlot).depth;\n\t\t\t\tseed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n\t\t\t\tbreak;\n\t\t\tcase DESCEND:\n\t\t\t\tif (Dungeon.hero == null){\n\t\t\t\t\tloadingDepth = 1;\n\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t} else {\n\t\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\t\telse                        loadingDepth = Dungeon.depth+1;\n\t\t\t\t\tif (Statistics.deepestFloor >= loadingDepth) {\n\t\t\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\t\t} else if (loadingDepth == 6 || loadingDepth == 11\n\t\t\t\t\t\t\t|| loadingDepth == 16 || loadingDepth == 21) {\n\t\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FALL:\n\t\t\t\tloadingDepth = Dungeon.depth+1;\n\t\t\t\tbreak;\n\t\t\tcase ASCEND:\n\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\telse                        loadingDepth = Dungeon.depth-1;\n\t\t\t\tbreak;\n\t\t\tcase RETURN:\n\t\t\t\tloadingDepth = returnDepth;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tint region = (int)Math.ceil(loadingDepth / 5f);\n\t\tif (region != lastRegion){\n\t\t\tTextureCache.clear();\n\t\t\tlastRegion = region;\n\t\t}\n\n\t\tint loadingCenter = 400;\n\n\t\t\n\t\t\n\t\tRandom.pushGenerator(seed+lastRegion);\n\t\t\tswitch (lastRegion){\n\t\t\t\tcase 1:\n\t\t\t\t\tloadingAsset = Assets.Splashes.SEWERS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 180; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 485; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 700; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingAsset = Assets.Splashes.PRISON;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 190; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 402; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 650; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CAVES;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 120; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 340; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CITY;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 275; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 460; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: default:\n\t\t\t\t\tloadingAsset = Assets.Splashes.HALLS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 145; break; \n\t\t\t\t\t\tcase 1: loadingCenter = 400; break; \n\t\t\t\t\t\tcase 2: loadingCenter = 615; break; \n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tRandom.popGenerator();\n\t\t\n\t\tif (DeviceCompat.isDebug()){\n\t\t\tfadeTime = 1f;\n\t\t}\n\n\t\tImage background = new Image(loadingAsset);\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tif (Camera.main.width >= background.width()){\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\t} else {\n\t\t\tbackground.x = Camera.main.width/2f - loadingCenter*background.scale.x;\n\t\t\tbackground.x = GameMath.gate(Camera.main.width - background.width(), background.x, 0);\n\t\t}\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tImage fadeLeft, fadeRight;\n\t\tfadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n\t\tfadeLeft.x = background.x-2;\n\t\tfadeLeft.scale.set(3, background.height());\n\t\tfadeLeft.visible = background.x > 0;\n\t\tadd(fadeLeft);\n\n\t\tfadeRight = new Image(fadeLeft);\n\t\tfadeRight.x = background.x + background.width() + 2;\n\t\tfadeRight.y = background.y + background.height();\n\t\tfadeRight.angle = 180;\n\t\tfadeRight.visible = fadeLeft.visible;\n\t\tadd(fadeRight);\n\n\t\tImage im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tif (lastRegion == 6)                aa = 1;\n\t\t\t\telse if (phase == Phase.FADE_IN)    aa = Math.max( 0, 2*(timeLeft - (fadeTime - 0.333f)));\n\t\t\t\telse if (phase == Phase.FADE_OUT)   aa = Math.max( 0, 2*(0.333f - timeLeft));\n\t\t\t\telse                                aa = 0;\n\t\t\t}\n\t\t};\n\t\tim.angle = 90;\n\t\tim.x = Camera.main.width;\n\t\tim.scale.x = Camera.main.height/5f;\n\t\tim.scale.y = Camera.main.width;\n\t\tadd(im);\n\n\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\n\t\tloadingText = PixelScene.renderTextBlock( text, 9 );\n\t\tloadingText.setPos(\n\t\t\t\t(Camera.main.width - loadingText.width() - 8),\n\t\t\t\t(Camera.main.height - loadingText.height() - 6)\n\t\t);\n\t\talign(loadingText);\n\t\tadd(loadingText);\n\n\t\t\n\t\tif (mode == Mode.DESCEND){\n\t\t\tif (Dungeon.hero == null || (loadingDepth > Statistics.deepestFloor && loadingDepth % 5 == 1)){\n\t\t\t\t\tstoryMessage = PixelScene.renderTextBlock(Document.INTROS.pageBody(region), 6);\n\t\t\t\t\tstoryMessage.maxWidth( PixelScene.landscape() ? 180 : 125);\n\t\t\t\t\tstoryMessage.setPos((Camera.main.width-storyMessage.width())/2f, (Camera.main.height-storyMessage.height())/2f);\n\n\t\t\t\t\tstoryBG = new ShadowBox();\n\t\t\t\t\tstoryBG.boxRect(storyMessage.left()-10, storyMessage.top()-10, storyMessage.width()+20, storyMessage.height()+20);\n\t\t\t\t\tstoryBG.alpha(0.75f);\n\t\t\t\t\tadd(storyBG);\n\t\t\t\t\tadd(storyMessage);\n\n\t\t\t\t\tbtnContinue = new StyledButton(Chrome.Type.TOAST_TR, \"Continue\", 9){\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\t\ttimeLeft = fadeTime;\n\n\t\t\t\t\t\t\tbtnContinue.enable(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnContinue.icon(Icons.STAIRS.get());\n\t\t\t\t\tbtnContinue.setSize(btnContinue.reqWidth()+10, 22);\n\t\t\t\t\tbtnContinue.enable(false);\n\n\t\t\t\t\tbtnContinue.setPos((Camera.main.width - btnContinue.width())/2f, storyMessage.bottom()+10);\n\t\t\t\t\tadd(btnContinue);\n\t\t\t}\n\t\t}\n\n\t\tphase = Phase.FADE_IN;\n\t\ttimeLeft = fadeTime;\n\t\t\n\t\tif (thread == null) {\n\t\t\tthread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tActor.fixTime();\n\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase DESCEND:\n\t\t\t\t\t\t\t\tdescend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASCEND:\n\t\t\t\t\t\t\t\tascend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\t\trestore();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESURRECT:\n\t\t\t\t\t\t\t\tresurrect();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RETURN:\n\t\t\t\t\t\t\t\treturnTo();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FALL:\n\t\t\t\t\t\t\t\tfall();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESET:\n\t\t\t\t\t\t\t\treset();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (thread) {\n\t\t\t\t\t\tif (phase == Phase.STATIC && error == null) {\n\t\t\t\t\t\t\tafterLoading();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthread.start();\n\t\t}\n\t\twaitingTime = 0f;\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void afterLoading(){\n\t\tif (btnContinue != null){\n\t\t\tbtnContinue.enable(true);\n\t\t} else {\n\t\t\tphase = Phase.FADE_OUT;\n\t\t\ttimeLeft = fadeTime;\n\t\t}\n\n\t}",
        "uniqueId": "92905ae81c0eb272c9a62d5f6914bda253fc571d_97_308_444_452_106_347",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t\n    \t\t\n    \t\t\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\nExample 2:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        \n        \n        \n        \n        \n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }\nExample 3:\n Before Refactoring:\n\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading)\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\nAfter Refactoring:\n\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (useReoadingTestSuiteLoader())\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}\n\nExtractedCodeFragments:\nprotected boolean useReoadingTestSuiteLoader() {\n\t\treturn getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading;\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "92905ae81c0eb272c9a62d5f6914bda253fc571d",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/92905ae81c0eb272c9a62d5f6914bda253fc571d",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\n\t\twaitingTime += Game.elapsed;\n\n\t\tif (mode != Mode.FALL && dots != Math.ceil(waitingTime / ((2*fadeTime)/3f))) {\n\t\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\tdots = (int)Math.ceil(waitingTime / ((2*fadeTime)/3f))%3;\n\t\t\tswitch (dots){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tmessage.text(text + \".\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmessage.text(text + \"..\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tmessage.text(text + \"...\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch (phase) {\n\t\t\n\t\tcase FADE_IN:\n\t\t\tmessage.alpha( Math.max(0, fadeTime - (timeLeft-0.333f)));\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tsynchronized (thread) {\n\t\t\t\t\tif (!thread.isAlive() && error == null) {\n\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphase = Phase.STATIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FADE_OUT:\n\t\t\tmessage.alpha( Math.min(1, timeLeft+0.333f) );\n\t\t\t\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tGame.switchScene( GameScene.class );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase STATIC:\n\t\t\tif (error != null) {\n\t\t\t\tString errorMsg;\n\t\t\t\tif (error instanceof FileNotFoundException)     errorMsg = Messages.get(this, \"file_not_found\");\n\t\t\t\telse if (error instanceof IOException)          errorMsg = Messages.get(this, \"io_error\");\n\t\t\t\telse if (error.getMessage() != null &&\n\t\t\t\t\t\terror.getMessage().equals(\"old save\")) errorMsg = Messages.get(this, \"io_error\");\n\n\t\t\t\telse throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n\n\t\t\t\tadd( new WndError( errorMsg ) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\tGame.switchScene( StartScene.class );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t} else if (thread != null && (int)waitingTime == 10){\n\t\t\t\twaitingTime = 11f;\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (StackTraceElement t : thread.getStackTrace()){\n\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\ts += t.toString();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!s.contains(\"FileUtils.bundleToFile\")){\n\t\t\t\t\tShatteredPixelDungeon.reportException(\n\t\t\t\t\t\t\tnew RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n\t\t\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n\t\t\t\t\t\t\t\t\ts));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == Mode.FALL) {\n\t\t\tmessage.setPos(\n\t\t\t\t\t(Camera.main.width - message.width() - 4) + Random.NormalFloat(-1, 1),\n\t\t\t\t\t(Camera.main.height - message.height() - 6) + Random.NormalFloat(-1, 1)\n\t\t\t);\n\t\t\talign(message);\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic void update() {\n\t\tsuper.update();\n\n\t\twaitingTime += Game.elapsed;\n\n\t\tif (mode != Mode.FALL && dots != Math.ceil(waitingTime / ((2*fadeTime)/3f))) {\n\t\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\tdots = (int)Math.ceil(waitingTime / ((2*fadeTime)/3f))%3;\n\t\t\tswitch (dots){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tmessage.text(text + \".\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmessage.text(text + \"..\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tmessage.text(text + \"...\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch (phase) {\n\t\t\n\t\tcase FADE_IN:\n\t\t\tmessage.alpha( Math.max(0, fadeTime - (timeLeft-0.333f)));\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tsynchronized (thread) {\n\t\t\t\t\tif (!thread.isAlive() && error == null) {\n\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphase = Phase.STATIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FADE_OUT:\n\t\t\tmessage.alpha( Math.min(1, timeLeft+0.333f) );\n\t\t\t\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tGame.switchScene( GameScene.class );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase STATIC:\n\t\t\tif (error != null) {\n\t\t\t\tString errorMsg;\n\t\t\t\tif (error instanceof FileNotFoundException)     errorMsg = Messages.get(this, \"file_not_found\");\n\t\t\t\telse if (error instanceof IOException)          errorMsg = Messages.get(this, \"io_error\");\n\t\t\t\telse if (error.getMessage() != null &&\n\t\t\t\t\t\terror.getMessage().equals(\"old save\")) errorMsg = Messages.get(this, \"io_error\");\n\n\t\t\t\telse throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n\n\t\t\t\tadd( new WndError( errorMsg ) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\tGame.switchScene( StartScene.class );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t} else if (thread != null && (int)waitingTime == 10){\n\t\t\t\twaitingTime = 11f;\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (StackTraceElement t : thread.getStackTrace()){\n\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\ts += t.toString();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!s.contains(\"FileUtils.bundleToFile\")){\n\t\t\t\t\tShatteredPixelDungeon.reportException(\n\t\t\t\t\t\t\tnew RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n\t\t\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n\t\t\t\t\t\t\t\t\ts));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == Mode.FALL) {\n\t\t\tmessage.setPos(\n\t\t\t\t\t(Camera.main.width - message.width() - 4) + Random.NormalFloat(-1, 1),\n\t\t\t\t\t(Camera.main.height - message.height() - 6) + Random.NormalFloat(-1, 1)\n\t\t\t);\n\t\t\talign(message);\n\t\t}\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\npublic void update() {\n    super.update();\n    waitingTime += Game.elapsed;\n\n    updateDots();\n    updatePhase();\n    \n    if (mode == Mode.FALL) {\n        updateMessagePosition();\n    }\n}\n\nprivate void updateDots() {\n    if (mode != Mode.FALL && dots != calculateDots()) {\n        String text = Messages.get(Mode.class, mode.name());\n        dots = calculateDots();\n        message.text(text + getDotSuffix(dots));\n    }\n}\n\nprivate int calculateDots() {\n    return (int) Math.ceil(waitingTime / ((2 * fadeTime) / 3f)) % 3;\n}\n\nprivate String getDotSuffix(int dots) {\n    switch (dots) {\n        case 1: \n        default: return \".\";\n        case 2: return \"..\";\n        case 0: return \"...\";\n    }\n}\n\nprivate void updatePhase() {\n    switch (phase) {\n        case FADE_IN:\n            handleFadeIn();\n            break;\n        case FADE_OUT:\n            handleFadeOut();\n            break;\n        case STATIC:\n            handleStaticPhase();\n            break;\n    }\n}\n\nprivate void handleFadeIn() {\n    message.alpha(Math.max(0, fadeTime - (timeLeft - 0.333f)));\n    if ((timeLeft -= Game.elapsed) <= 0) {\n        synchronized (thread) {\n            if (!thread.isAlive() && error == null) {\n                phase = Phase.FADE_OUT;\n                timeLeft = fadeTime;\n            } else {\n                phase = Phase.STATIC;\n            }\n        }\n    }\n}\n\nprivate void handleFadeOut() {\n    message.alpha(Math.min(1, timeLeft + 0.333f));\n    if ((timeLeft -= Game.elapsed) <= 0) {\n        Game.switchScene(GameScene.class);\n        thread = null;\n        error = null;\n    }\n}\n\nprivate void handleStaticPhase() {\n    if (error != null) {\n        handleError();\n    } else if (thread != null && (int) waitingTime == 10) {\n        handleLongWait();\n    }\n}\n\nprivate void handleError() {\n    String errorMsg = getErrorMessage();\n    add(new WndError(errorMsg) {\n        public void onBackPressed() {\n            super.onBackPressed();\n            Game.switchScene(StartScene.class);\n        }\n    });\n    thread = null;\n    error = null;\n}\n\nprivate String getErrorMessage() {\n    if (error instanceof FileNotFoundException) return Messages.get(this, \"file_not_found\");\n    if (error instanceof IOException) return Messages.get(this, \"io_error\");\n    if (error.getMessage() != null && error.getMessage().equals(\"old save\")) return Messages.get(this, \"io_error\");\n    \n    throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n            \"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n}\n\nprivate void handleLongWait() {\n    waitingTime = 11f;\n    String stackTrace = getStackTrace();\n    \n    if (!stackTrace.contains(\"FileUtils.bundleToFile\")) {\n        ShatteredPixelDungeon.reportException(\n                new RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n                        \"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n                        stackTrace));\n    }\n}\n\nprivate String getStackTrace() {\n    StringBuilder stackTrace = new StringBuilder();\n    for (StackTraceElement t : thread.getStackTrace()) {\n        stackTrace.append(\"\\n\").append(t.toString());\n    }\n    return stackTrace.toString();\n}\n\nprivate void updateMessagePosition() {\n    message.setPos(\n            (Camera.main.width - message.width() - 4) + Random.NormalFloat(-1, 1),\n            (Camera.main.height - message.height() - 6) + Random.NormalFloat(-1, 1)\n    );\n    align(message);\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: The code was broken down into smaller, more manageable methods to improve readability and maintainability.\n2. **Descriptive Method Names**: Each extracted method has a name that describes its purpose, making the code easier to understand.\n3. **Reduced Complexity**: The main `update` method is now cleaner and focuses on high-level logic, delegating specific tasks to helper methods.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\n\t\twaitingTime += Game.elapsed;\n\n\t\tif (mode != Mode.FALL && dots != Math.ceil(waitingTime / ((2*fadeTime)/3f))) {\n\t\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\tdots = (int)Math.ceil(waitingTime / ((2*fadeTime)/3f))%3;\n\t\t\tswitch (dots){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tloadingText.text(text + \".\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingText.text(text + \"..\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tloadingText.text(text + \"...\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch (phase) {\n\t\t\n\t\tcase FADE_IN:\n\t\t\tloadingText.alpha( Math.max(0, fadeTime - (timeLeft-0.333f)));\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tsynchronized (thread) {\n\t\t\t\t\tif (!thread.isAlive() && error == null) {\n\t\t\t\t\t\tafterLoading();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphase = Phase.STATIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FADE_OUT:\n\t\t\tloadingText.alpha( Math.min(1, timeLeft+0.333f) );\n\t\t\t\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tGame.switchScene( GameScene.class );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase STATIC:\n\t\t\tif (error != null) {\n\t\t\t\tString errorMsg;\n\t\t\t\tif (error instanceof FileNotFoundException)     errorMsg = Messages.get(this, \"file_not_found\");\n\t\t\t\telse if (error instanceof IOException)          errorMsg = Messages.get(this, \"io_error\");\n\t\t\t\telse if (error.getMessage() != null &&\n\t\t\t\t\t\terror.getMessage().equals(\"old save\")) errorMsg = Messages.get(this, \"io_error\");\n\n\t\t\t\telse throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n\n\t\t\t\tadd( new WndError( errorMsg ) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\tGame.switchScene( StartScene.class );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t} else if (thread != null && (int)waitingTime == 10){\n\t\t\t\twaitingTime = 11f;\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (StackTraceElement t : thread.getStackTrace()){\n\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\ts += t.toString();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!s.contains(\"FileUtils.bundleToFile\")){\n\t\t\t\t\tShatteredPixelDungeon.reportException(\n\t\t\t\t\t\t\tnew RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n\t\t\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n\t\t\t\t\t\t\t\t\ts));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == Mode.FALL) {\n\t\t\tloadingText.setPos(\n\t\t\t\t\t(Camera.main.width - loadingText.width() - 4) + Random.NormalFloat(-1, 1),\n\t\t\t\t\t(Camera.main.height - loadingText.height() - 6) + Random.NormalFloat(-1, 1)\n\t\t\t);\n\t\t\talign(loadingText);\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void afterLoading(){\n\t\tif (btnContinue != null){\n\t\t\tbtnContinue.enable(true);\n\t\t} else {\n\t\t\tphase = Phase.FADE_OUT;\n\t\t\ttimeLeft = fadeTime;\n\t\t}\n\n\t}",
        "uniqueId": "92905ae81c0eb272c9a62d5f6914bda253fc571d_312_404_444_452_351_442",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t\n    \t\t\n    \t\t\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\nExample 2:\n Before Refactoring:\n@Override\n    public void evaluate() throws Throwable {\n        CallableStatement callable = new CallableStatement();\n        FutureTask<Throwable> task = new FutureTask<Throwable>(callable);\n        ThreadGroup threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        if (!threadGroup.isDaemon()) {\n            try {\n                threadGroup.setDaemon(true);\n            } catch (SecurityException e) {\n                \n            }\n        }\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        callable.awaitStarted();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }\n\nAfter Refactoring:\n@Override\n    public void evaluate() throws Throwable {\n        CallableStatement callable = new CallableStatement();\n        FutureTask<Throwable> task = new FutureTask<Throwable>(callable);\n        ThreadGroup threadGroup = threadGroupForNewThread();\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        callable.awaitStarted();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }\n\nExtractedCodeFragments:\nprivate ThreadGroup threadGroupForNewThread() {\n        if (!lookForStuckThread) {\n            // Use the default ThreadGroup (usually the one from the current\n            // thread).\n            return null;\n        }\n\n        // Create the thread in a new ThreadGroup, so if the time-limited thread\n        // becomes stuck, getStuckThread() can find the thread likely to be the\n        // culprit.\n        ThreadGroup threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        if (!threadGroup.isDaemon()) {\n            // Mark the new ThreadGroup as a daemon thread group, so it will be\n            // destroyed after the time-limited thread completes. By ensuring the\n            // ThreadGroup is destroyed, any data associated with the ThreadGroup\n            // (ex: via java.beans.ThreadGroupContext) is destroyed.\n            try {\n                threadGroup.setDaemon(true);\n            } catch (SecurityException e) {\n                // Swallow the exception to keep the same behavior as in JUnit 4.12.\n            }\n        }\n        return threadGroup;\n    }\nExample 3:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        \n        \n        \n        \n        \n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "fe66e03e74ddc86c62a2ba58c43466fc3996d8ff",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fe66e03e74ddc86c62a2ba58c43466fc3996d8ff",
        "sourceCodeBeforeRefactoring": "public static void blast(int pos) {\n\t\t\tGroup parent = Dungeon.hero.sprite.parent;\n\t\t\tBlastWave b = (BlastWave) parent.recycle(BlastWave.class);\n\t\t\tparent.bringToFront(b);\n\t\t\tb.reset(pos);\n\t\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static void blast(int pos) {\n    Group parent = Dungeon.hero.sprite.parent;\n    BlastWave b = (BlastWave) parent.recycle(BlastWave.class);\n    parent.bringToFront(b);\n    b.reset(pos);\n}\n```\n\n### Refactored Code:\n```java\npublic static void blast(int pos) {\n    Group parent = getParentGroup();\n    BlastWave blastWave = createBlastWave(parent);\n    parent.bringToFront(blastWave);\n    blastWave.reset(pos);\n}\n\nprivate static Group getParentGroup() {\n    return Dungeon.hero.sprite.parent;\n}\n\nprivate static BlastWave createBlastWave(Group parent) {\n    return (BlastWave) parent.recycle(BlastWave.class);\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: The logic to get the parent group and to create a `BlastWave` has been extracted into separate methods (`getParentGroup` and `createBlastWave`). This improves readability by giving context to what each part of the code is doing.\n2. **Variable Naming**: Changed the variable name `b` to `blastWave` for better clarity on what the variable represents.",
        "sourceCodeAfterRefactoring": "public static void blast(int pos) {\n\t\t\tblast(pos, 3);\n\t\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static void blast(int pos, float radius) {\n\t\t\tGroup parent = Dungeon.hero.sprite.parent;\n\t\t\tBlastWave b = (BlastWave) parent.recycle(BlastWave.class);\n\t\t\tparent.bringToFront(b);\n\t\t\tb.reset(pos, radius);\n\t\t}",
        "uniqueId": "fe66e03e74ddc86c62a2ba58c43466fc3996d8ff_279_284_285_290_281_283",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\npublic void reset() {\n\t\tfError= false;\n\t\tsetForeground(getStatusColor());\n\t\tsetValue(0);\n\t}\n\nAfter Refactoring:\npublic void reset() {\n\t\tfError= false;\n\t\tupdateBarColor();\n\t\tsetValue(0);\n\t}\n\nExtractedCodeFragments:\nprotected void updateBarColor() {\n\t\tsetForeground(getStatusColor());\n\t}\nExample 3:\n Before Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nAfter Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "70df007bcf55364711b9682f0e975e5bcfabd0cd",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/70df007bcf55364711b9682f0e975e5bcfabd0cd",
        "sourceCodeBeforeRefactoring": "public static int spawnImages( Hero hero, int nImages ){\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\tif (Actor.findChar( p ) == null && Dungeon.level.passable[p]) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint spawned = 0;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( hero );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t\tspawned++;\n\t\t}\n\t\t\n\t\treturn spawned;\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static int spawnImages(Hero hero, int nImages) {\n    ArrayList<Integer> respawnPoints = new ArrayList<>();\n    \n    for (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n        int p = hero.pos + PathFinder.NEIGHBOURS8[i];\n        if (Actor.findChar(p) == null && Dungeon.level.passable[p]) {\n            respawnPoints.add(p);\n        }\n    }\n    \n    int spawned = 0;\n    while (nImages > 0 && respawnPoints.size() > 0) {\n        int index = Random.index(respawnPoints);\n        \n        MirrorImage mob = new MirrorImage();\n        mob.duplicate(hero);\n        GameScene.add(mob);\n        ScrollOfTeleportation.appear(mob, respawnPoints.get(index));\n        \n        respawnPoints.remove(index);\n        nImages--;\n        spawned++;\n    }\n    \n    return spawned;\n}\n```\n\n### Refactored Code:\n```java\npublic static int spawnImages(Hero hero, int nImages) {\n    List<Integer> respawnPoints = findRespawnPoints(hero);\n    \n    int spawned = 0;\n    while (nImages > 0 && !respawnPoints.isEmpty()) {\n        int index = Random.index(respawnPoints);\n        spawnMirrorImage(hero, respawnPoints.get(index));\n        \n        respawnPoints.remove(index);\n        nImages--;\n        spawned++;\n    }\n    \n    return spawned;\n}\n\nprivate static List<Integer> findRespawnPoints(Hero hero) {\n    List<Integer> respawnPoints = new ArrayList<>();\n    for (int offset : PathFinder.NEIGHBOURS8) {\n        int position = hero.pos + offset;\n        if (Actor.findChar(position) == null && Dungeon.level.passable[position]) {\n            respawnPoints.add(position);\n        }\n    }\n    return respawnPoints;\n}\n\nprivate static void spawnMirrorImage(Hero hero, int position) {\n    MirrorImage mob = new MirrorImage();\n    mob.duplicate(hero);\n    GameScene.add(mob);\n    ScrollOfTeleportation.appear(mob, position);\n}\n```\n\n### Changes Made:\n1. **Extracted Method for Finding Respawn Points**: The logic for finding respawn points was extracted into a separate method `findRespawnPoints`, improving readability and separation of concerns.\n2. **Extracted Method for Spawning Mirror Images**: The logic for spawning a mirror image was extracted into a separate method `spawnMirrorImage`, which encapsulates the spawning logic and makes the main method cleaner.\n3. **Used Enhanced For Loop**: Replaced the traditional for loop with an enhanced for loop for better readability when iterating over `PathFinder.NEIGHBOURS8`. \n\nThese changes enhance the readability and maintainability of the code without altering its functionality.",
        "sourceCodeAfterRefactoring": "public static int spawnImages( Hero hero, int nImages ){\n\t\treturn spawnImages( hero, hero.pos, nImages);\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static int spawnImages( Hero hero, int pos, int nImages ){\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS9.length; i++) {\n\t\t\tint p = pos + PathFinder.NEIGHBOURS9[i];\n\t\t\tif (Actor.findChar( p ) == null && Dungeon.level.passable[p]) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint spawned = 0;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( hero );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t\tspawned++;\n\t\t}\n\t\t\n\t\treturn spawned;\n\t}",
        "uniqueId": "70df007bcf55364711b9682f0e975e5bcfabd0cd_63_89_67_93_62_64",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\nTestTreeCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"ok.gif\");\n\t    \tfOkIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"failure.gif\");\n\t    \tfFailureIcon= new ImageIcon(url);\n\t\t}\n\nAfter Refactoring:\nTestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}\n\nExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} \n\t\t\treturn new ImageIcon(url);\n\t\t}\nExample 3:\n Before Refactoring:\nprivate Description(String displayName, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tfDisplayName= displayName;\n\t\tfAnnotations= annotations;\n\t}\n\nAfter Refactoring:\nprivate Description(String displayName, Annotation... annotations) {\n\t\tthis(displayName, displayName, annotations);\n\t}\n\nExtractedCodeFragments:\nprivate Description(String displayName, Object uniqueId, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tif ((uniqueId == null))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The unique id must not be null.\");\n\t\tfDisplayName= displayName;\n\t\tfUniqueId= uniqueId;\n\t\tfAnnotations= annotations;\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "70df007bcf55364711b9682f0e975e5bcfabd0cd",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/70df007bcf55364711b9682f0e975e5bcfabd0cd",
        "sourceCodeBeforeRefactoring": "private static boolean rareEffect(final Item origin, final Char user, final int targetPos){\n\t\tboolean positiveOnly = user == Dungeon.hero && Random.Float() < WondrousResin.positiveCurseEffectChance();\n\t\tswitch(Random.Int(4)){\n\n\t\t\t\n\t\t\tcase 0: default:\n\n\t\t\t\tChar ch = Actor.findChar( targetPos );\n\t\t\t\tif (ch != null && !(ch instanceof Hero)\n\t\t\t\t\t\t\n\t\t\t\t\t\t&& !ch.properties().contains(Char.Property.BOSS)\n\t\t\t\t\t\t&& !ch.properties().contains(Char.Property.MINIBOSS)\n\t\t\t\t\t\t&& !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL)){\n\t\t\t\t\tSheep sheep = new Sheep();\n\t\t\t\t\tsheep.lifespan = 10;\n\t\t\t\t\tsheep.pos = ch.pos;\n\t\t\t\t\tch.destroy();\n\t\t\t\t\tch.sprite.killAndErase();\n\t\t\t\t\tDungeon.level.mobs.remove(ch);\n\t\t\t\t\tTargetHealthIndicator.instance.target(null);\n\t\t\t\t\tGameScene.add(sheep);\n\t\t\t\t\tCellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.PUFF);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.SHEEP);\n\t\t\t\t\tDungeon.level.occupyCell(sheep);\n\t\t\t\t} else {\n\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tif (positiveOnly){\n\t\t\t\t\tch = Actor.findChar( targetPos );\n\t\t\t\t\tif (ch != null){\n\t\t\t\t\t\tBuff.affect(ch, Hex.class, Hex.DURATION);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (user instanceof Hero) {\n\t\t\t\t\tCursingTrap.curse( (Hero) user );\n\t\t\t\t} else {\n\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t\n\t\t\t\n\t\t\tcase 2:\n\t\t\t\tif (!positiveOnly && Dungeon.depth > 1 && Dungeon.interfloorTeleportAllowed() && user == Dungeon.hero) {\n\n\t\t\t\t\t\n\t\t\t\t\tfloat[] depths = new float[Dungeon.depth-1];\n\t\t\t\t\tfor (int i = 1; i < Dungeon.depth; i++) depths[i-1] = i;\n\t\t\t\t\tint depth = 1+Random.chances(depths);\n\n\t\t\t\t\tLevel.beforeTransition();\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.RETURN;\n\t\t\t\t\tInterlevelScene.returnDepth = depth;\n\t\t\t\t\tInterlevelScene.returnBranch = 0;\n\t\t\t\t\tInterlevelScene.returnPos = -1;\n\t\t\t\t\tGame.switchScene(InterlevelScene.class);\n\n\t\t\t\t} else {\n\t\t\t\t\tScrollOfTeleportation.teleportChar(user);\n\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tif (positiveOnly && user == Dungeon.hero){\n\t\t\t\t\tScrollOfMirrorImage.spawnImages(Dungeon.hero, 2);\n\t\t\t\t} else {\n\t\t\t\t\tnew SummoningTrap().set(targetPos).activate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\nprivate static boolean rareEffect(final Item origin, final Char user, final int targetPos){\n    boolean positiveOnly = user == Dungeon.hero && Random.Float() < WondrousResin.positiveCurseEffectChance();\n    switch(Random.Int(4)){\n        case 0: default:\n            Char ch = Actor.findChar(targetPos);\n            if (ch != null && !(ch instanceof Hero)\n                    && !ch.properties().contains(Char.Property.BOSS)\n                    && !ch.properties().contains(Char.Property.MINIBOSS)\n                    && !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL)){\n                Sheep sheep = new Sheep();\n                sheep.lifespan = 10;\n                sheep.pos = ch.pos;\n                ch.destroy();\n                ch.sprite.killAndErase();\n                Dungeon.level.mobs.remove(ch);\n                TargetHealthIndicator.instance.target(null);\n                GameScene.add(sheep);\n                CellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n                Sample.INSTANCE.play(Assets.Sounds.PUFF);\n                Sample.INSTANCE.play(Assets.Sounds.SHEEP);\n                Dungeon.level.occupyCell(sheep);\n            } else {\n                return cursedEffect(origin, user, targetPos);\n            }\n            return true;\n\n        case 1:\n            if (positiveOnly){\n                ch = Actor.findChar(targetPos);\n                if (ch != null){\n                    Buff.affect(ch, Hex.class, Hex.DURATION);\n                }\n                return true;\n            }\n            if (user instanceof Hero) {\n                CursingTrap.curse((Hero) user);\n            } else {\n                return cursedEffect(origin, user, targetPos);\n            }\n            return true;\n\n        case 2:\n            if (!positiveOnly && Dungeon.depth > 1 && Dungeon.interfloorTeleportAllowed() && user == Dungeon.hero) {\n                float[] depths = new float[Dungeon.depth-1];\n                for (int i = 1; i < Dungeon.depth; i++) depths[i-1] = i;\n                int depth = 1 + Random.chances(depths);\n\n                Level.beforeTransition();\n                InterlevelScene.mode = InterlevelScene.Mode.RETURN;\n                InterlevelScene.returnDepth = depth;\n                InterlevelScene.returnBranch = 0;\n                InterlevelScene.returnPos = -1;\n                Game.switchScene(InterlevelScene.class);\n            } else {\n                ScrollOfTeleportation.teleportChar(user);\n            }\n            return true;\n\n        case 3:\n            if (positiveOnly && user == Dungeon.hero){\n                ScrollOfMirrorImage.spawnImages(Dungeon.hero, 2);\n            } else {\n                new SummoningTrap().set(targetPos).activate();\n            }\n            return true;\n    }\n}\n```\n\n### Refactored Code:\n```java\nprivate static boolean rareEffect(final Item origin, final Char user, final int targetPos) {\n    boolean positiveOnly = isPositiveOnly(user);\n    switch (Random.Int(4)) {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n            return handleEffectCase(origin, user, targetPos, positiveOnly);\n        default:\n            return false; // This case should not occur, but added for safety.\n    }\n}\n\nprivate static boolean isPositiveOnly(Char user) {\n    return user == Dungeon.hero && Random.Float() < WondrousResin.positiveCurseEffectChance();\n}\n\nprivate static boolean handleEffectCase(final Item origin, final Char user, final int targetPos, boolean positiveOnly) {\n    Char ch;\n    switch (Random.Int(4)) {\n        case 0:\n            ch = Actor.findChar(targetPos);\n            if (isValidTarget(ch)) {\n                transformToSheep(ch);\n            } else {\n                return cursedEffect(origin, user, targetPos);\n            }\n            return true;\n\n        case 1:\n            ch = Actor.findChar(targetPos);\n            if (positiveOnly) {\n                if (ch != null) {\n                    Buff.affect(ch, Hex.class, Hex.DURATION);\n                }\n                return true;\n            }\n            return handleCursing(user, origin, targetPos);\n\n        case 2:\n            return handleTeleportation(user, positiveOnly);\n\n        case 3:\n            return handleSummoning(user, positiveOnly, targetPos);\n    }\n    return false; // This case should not occur, but added for safety.\n}\n\nprivate static boolean isValidTarget(Char ch) {\n    return ch != null && !(ch instanceof Hero)\n            && !ch.properties().contains(Char.Property.BOSS)\n            && !ch.properties().contains(Char.Property.MINIBOSS)\n            && !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL);\n}\n\nprivate static void transformToSheep(Char ch) {\n    Sheep sheep = new Sheep();\n    sheep.lifespan = 10;\n    sheep.pos = ch.pos;\n    ch.destroy();\n    ch.sprite.killAndErase();\n    Dungeon.level.mobs.remove(ch);\n    TargetHealthIndicator.instance.target(null);\n    GameScene.add(sheep);\n    CellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n    Sample.INSTANCE.play(Assets.Sounds.PUFF);\n    Sample.INSTANCE.play(Assets.Sounds.SHEEP);\n    Dungeon.level.occupyCell(sheep);\n}\n\nprivate static boolean handleCursing(Char user, final Item origin, final int targetPos) {\n    if (user instanceof Hero) {\n        CursingTrap.curse((Hero) user);\n    } else {\n        return cursedEffect(origin, user, targetPos);\n    }\n    return true;\n}\n\nprivate static boolean handleTeleportation(Char user, boolean positiveOnly) {\n    if (!positiveOnly && Dungeon.depth > 1 && Dungeon.interfloorTeleportAllowed() && user == Dungeon.hero) {\n        float[] depths = new float[Dungeon.depth - 1];\n        for (int i = 1; i < Dungeon.depth; i++) depths[i - 1] = i;\n        int depth = 1 + Random.chances(depths);\n\n        Level.beforeTransition();\n        InterlevelScene.mode = InterlevelScene.Mode.RETURN;\n        InterlevelScene.returnDepth = depth;\n        InterlevelScene.returnBranch = 0;\n        InterlevelScene.returnPos = -1;\n        Game.switchScene(InterlevelScene.class);\n    } else {\n        ScrollOfTeleportation.teleportChar(user);\n    }\n    return true;\n}\n\nprivate static boolean handleSummoning(Char user, boolean positiveOnly, int targetPos) {\n    if (positiveOnly && user == Dungeon.hero) {\n        ScrollOfMirrorImage.spawnImages(Dungeon.hero, 2);\n    } else {\n        new SummoningTrap().set(targetPos).activate();\n    }\n    return true;\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: Created helper methods to handle specific cases and improve readability.\n2. **Simplified Logic**: Reduced complexity in the main method by delegating responsibilities to smaller methods.\n3. **Improved Naming**: Used descriptive method names to clarify the purpose of each section of the code.",
        "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean effect(Item origin, Char user, Ballistica bolt, boolean positiveOnly) {\n\t\t\tif (valid(origin, user, bolt, positiveOnly)){\n\t\t\t\tChar ch = Actor.findChar( bolt.collisionPos );\n\t\t\t\tSheep sheep = new Sheep();\n\t\t\t\tsheep.lifespan = 10;\n\t\t\t\tsheep.pos = ch.pos;\n\t\t\t\tch.destroy();\n\t\t\t\tch.sprite.killAndErase();\n\t\t\t\tDungeon.level.mobs.remove(ch);\n\t\t\t\tTargetHealthIndicator.instance.target(null);\n\t\t\t\tGameScene.add(sheep);\n\t\t\t\tCellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.PUFF);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.SHEEP);\n\t\t\t\tDungeon.level.occupyCell(sheep);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tpublic boolean valid(Item origin, Char user, Ballistica bolt, boolean positiveOnly) {\n\t\t\tChar ch = Actor.findChar( bolt.collisionPos );\n\t\t\tif (ch != null && !(ch instanceof Hero)\n\t\t\t\t\t\n\t\t\t\t\t&& !ch.properties().contains(Char.Property.BOSS)\n\t\t\t\t\t&& !ch.properties().contains(Char.Property.MINIBOSS)\n\t\t\t\t\t&& !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL)){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}",
        "uniqueId": "70df007bcf55364711b9682f0e975e5bcfabd0cd_275_355_418_430_432_452",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\nprivate Matcher<Throwable> createCompositeMatcher() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}\n\nAfter Refactoring:\nprivate Matcher<Throwable> createCompositeMatcher() {\n\t\treturn withStacktrace(allOfTheMatchers());\n\t}\n\nExtractedCodeFragments:\nprivate Matcher<Throwable> allOfTheMatchers() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}\nExample 3:\n Before Refactoring:\npublic int compare(Description o1, Description o2) {\n\t\t\t\n\t\t\tif (isNew(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNew(o2))\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t\n\t\t\t\t: fDurations.get(o1).compareTo(fDurations.get(o2));\n\t\t}\n\nAfter Refactoring:\npublic int compare(Description o1, Description o2) {\n\t\t\t\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\nExtractedCodeFragments:\nprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "543bc3f587038ae4de4a9612f59a9a1d912be727",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/543bc3f587038ae4de4a9612f59a9a1d912be727",
        "sourceCodeBeforeRefactoring": "public static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass ) {\n\t\tif ((!Dungeon.level.solid[pos] || Dungeon.level.passable[pos]) && Actor.findChar( pos ) == null) {\n\n\t\t\tWraith w;\n\t\t\t\n\t\t\tif (wraithClass == null){\n\t\t\t\tfloat altChance = 1/100f * RatSkull.exoticChanceMultiplier();\n\t\t\t\tif (Random.Float() < altChance){\n\t\t\t\t\tw = new TormentedSpirit();\n\t\t\t\t} else {\n\t\t\t\t\tw = new Wraith();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw = Reflection.newInstance(wraithClass);\n\t\t\t}\n\t\t\tw.adjustStats( Dungeon.scalingDepth() );\n\t\t\tw.pos = pos;\n\t\t\tw.state = w.HUNTING;\n\t\t\tGameScene.add( w, SPAWN_DELAY );\n\t\t\tDungeon.level.occupyCell(w);\n\n\t\t\tw.sprite.alpha( 0 );\n\t\t\tw.sprite.parent.add( new AlphaTweener( w.sprite, 1, 0.5f ) );\n\n\t\t\tif (w instanceof TormentedSpirit){\n\t\t\t\tw.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n\t\t\t} else {\n\t\t\t\tw.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n\t\t\t}\n\n\t\t\treturn w;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static Wraith spawnAt(int pos, Class<? extends Wraith> wraithClass) {\n    if ((!Dungeon.level.solid[pos] || Dungeon.level.passable[pos]) && Actor.findChar(pos) == null) {\n\n        Wraith w;\n\n        if (wraithClass == null) {\n            float altChance = 1 / 100f * RatSkull.exoticChanceMultiplier();\n            if (Random.Float() < altChance) {\n                w = new TormentedSpirit();\n            } else {\n                w = new Wraith();\n            }\n        } else {\n            w = Reflection.newInstance(wraithClass);\n        }\n        w.adjustStats(Dungeon.scalingDepth());\n        w.pos = pos;\n        w.state = w.HUNTING;\n        GameScene.add(w, SPAWN_DELAY);\n        Dungeon.level.occupyCell(w);\n\n        w.sprite.alpha(0);\n        w.sprite.parent.add(new AlphaTweener(w.sprite, 1, 0.5f));\n\n        if (w instanceof TormentedSpirit) {\n            w.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n        } else {\n            w.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n        }\n\n        return w;\n    } else {\n        return null;\n    }\n}\n```\n\n### Refactored Code:\n```java\npublic static Wraith spawnAt(int pos, Class<? extends Wraith> wraithClass) {\n    if (!isSpawnable(pos)) {\n        return null;\n    }\n\n    Wraith w = createWraith(wraithClass);\n    initializeWraith(w, pos);\n    return w;\n}\n\nprivate static boolean isSpawnable(int pos) {\n    return (!Dungeon.level.solid[pos] || Dungeon.level.passable[pos]) && Actor.findChar(pos) == null;\n}\n\nprivate static Wraith createWraith(Class<? extends Wraith> wraithClass) {\n    if (wraithClass == null) {\n        return Random.Float() < (1 / 100f * RatSkull.exoticChanceMultiplier()) \n            ? new TormentedSpirit() \n            : new Wraith();\n    }\n    return Reflection.newInstance(wraithClass);\n}\n\nprivate static void initializeWraith(Wraith w, int pos) {\n    w.adjustStats(Dungeon.scalingDepth());\n    w.pos = pos;\n    w.state = w.HUNTING;\n    GameScene.add(w, SPAWN_DELAY);\n    Dungeon.level.occupyCell(w);\n\n    w.sprite.alpha(0);\n    w.sprite.parent.add(new AlphaTweener(w.sprite, 1, 0.5f));\n\n    if (w instanceof TormentedSpirit) {\n        w.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n    } else {\n        w.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: Created `isSpawnable`, `createWraith`, and `initializeWraith` methods to improve readability and separation of concerns.\n2. **Simplified Logic**: The main method now clearly outlines the flow of spawning a Wraith, making it easier to understand.",
        "sourceCodeAfterRefactoring": "public static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass ) {\n\t\treturn spawnAt( pos, wraithClass, true );\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass, boolean allowAdjacent ) {\n\n\t\t\n\t\tif (Dungeon.level.solid[pos] || Actor.findChar( pos ) != null){\n\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\n\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\tif (!Dungeon.level.solid[pos+i] && Actor.findChar( pos+i ) == null){\n\t\t\t\t\tcandidates.add(pos+i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (allowAdjacent && !candidates.isEmpty()){\n\t\t\t\tpos = Random.element(candidates);\n\t\t\t} else {\n\t\t\t\tpos = -1;\n\t\t\t}\n\n\t\t}\n\n\t\tif (pos != -1) {\n\n\t\t\tWraith w;\n\t\t\t\n\t\t\tif (wraithClass == null){\n\t\t\t\tfloat altChance = 1/100f * RatSkull.exoticChanceMultiplier();\n\t\t\t\tif (Random.Float() < altChance){\n\t\t\t\t\tw = new TormentedSpirit();\n\t\t\t\t} else {\n\t\t\t\t\tw = new Wraith();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw = Reflection.newInstance(wraithClass);\n\t\t\t}\n\t\t\tw.adjustStats( Dungeon.scalingDepth() );\n\t\t\tw.pos = pos;\n\t\t\tw.state = w.HUNTING;\n\t\t\tGameScene.add( w, SPAWN_DELAY );\n\t\t\tDungeon.level.occupyCell(w);\n\n\t\t\tw.sprite.alpha( 0 );\n\t\t\tw.sprite.parent.add( new AlphaTweener( w.sprite, 1, 0.5f ) );\n\n\t\t\tif (w instanceof TormentedSpirit){\n\t\t\t\tw.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n\t\t\t} else {\n\t\t\t\tw.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n\t\t\t}\n\n\t\t\treturn w;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
        "uniqueId": "543bc3f587038ae4de4a9612f59a9a1d912be727_114_148_120_173_116_118",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate Matcher<Throwable> createCompositeMatcher() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}\n\nAfter Refactoring:\nprivate Matcher<Throwable> createCompositeMatcher() {\n\t\treturn withStacktrace(allOfTheMatchers());\n\t}\n\nExtractedCodeFragments:\nprivate Matcher<Throwable> allOfTheMatchers() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}\nExample 2:\n Before Refactoring:\n\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}\n\nAfter Refactoring:\n\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tvalidatePublicVoid(isStatic, errors);\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}\n\nExtractedCodeFragments:\npublic void validatePublicVoid(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t}\nExample 3:\n Before Refactoring:\npublic List<Method> getTestMethods(Class<? extends Annotation> annotationClass) {\n\t\tList<Method> results= new ArrayList<Method>();\n\t\tfor (Class<?> eachClass : getSuperClasses(fTestClass)) {\n\t\t\tMethod[] methods= eachClass.getDeclaredMethods();\n\t\t\tfor (Method eachMethod : methods) {\n\t\t\t\tAnnotation annotation= eachMethod.getAnnotation(annotationClass);\n\t\t\t\tif (annotation != null && ! isShadowed(eachMethod, results)) \n\t\t\t\t\tresults.add(eachMethod);\n\t\t\t}\n\t\t}\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}\n\nAfter Refactoring:\npublic List<Method> getTestMethods(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tList<Method> results= new MethodCollector(annotationClass).addMethods(\n\t\t\t\tfTestClass).getMethods();\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}\n\nExtractedCodeFragments:\npublic MethodCollector addMethods(Class<?> testClass) {\n\t\t\tfor (Method eachMethod : testClass.getDeclaredMethods()) {\n\t\t\t\tAnnotation annotation= eachMethod\n\t\t\t\t\t\t.getAnnotation(annotationClass);\n\t\t\t\tif (annotation != null && !isShadowed(eachMethod))\n\t\t\t\t\tmethods.add(eachMethod);\n\t\t\t}\n\t\t\t\n\t\t\taddSuperclasses(testClass);\t\t\t\n\t\t\taddMixins(testClass);\n\t\t\treturn this;\n\t\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
        "sourceCodeBeforeRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tfloat spawnMulti = enemySpawnMultiplier();\n\t\tif (spawnMulti > 1f) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn spawnMulti;\n\t\t\t} else {\n\t\t\t\treturn 1f;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static float spawnMultiplierAtCurrentTime(){\n    float spawnMulti = enemySpawnMultiplier();\n    if (spawnMulti > 1f) {\n        Calendar cal = GregorianCalendar.getInstance();\n        if (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n            if (!sundialWarned){\n                GLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n                sundialWarned = true;\n            }\n            return spawnMulti;\n        } else {\n            return 1f;\n        }\n    } else {\n        return 1f;\n    }\n}\n```\n\n### Refactored Code:\n```java\npublic static float spawnMultiplierAtCurrentTime() {\n    float spawnMulti = enemySpawnMultiplier();\n    if (isSpawnMultiplierValid(spawnMulti)) {\n        if (isNightTime()) {\n            warnIfNeeded();\n            return spawnMulti;\n        }\n        return 1f;\n    }\n    return 1f;\n}\n\nprivate static boolean isSpawnMultiplierValid(float spawnMulti) {\n    return spawnMulti > 1f;\n}\n\nprivate static boolean isNightTime() {\n    int hourOfDay = GregorianCalendar.getInstance().get(Calendar.HOUR_OF_DAY);\n    return hourOfDay >= 21 || hourOfDay <= 6;\n}\n\nprivate static void warnIfNeeded() {\n    if (!sundialWarned) {\n        GLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n        sundialWarned = true;\n    }\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: Created helper methods `isSpawnMultiplierValid`, `isNightTime`, and `warnIfNeeded` to improve readability and encapsulate logic.\n2. **Simplified Logic**: Reduced nested conditions and made the flow of the method clearer by using early returns.\n3. **Improved Naming**: Used descriptive method names to clarify the purpose of each check, enhancing overall code readability.",
        "sourceCodeAfterRefactoring": "public static float enemySpawnMultiplierDaytime( int level ){\n\t\tif (level == -1){\n\t\t\treturn 1f;\n\t\t} else {\n\t\t\treturn 0.95f - 0.05f*level;\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static float enemySpawnMultiplierDaytime( int level ){\n\t\tif (level == -1){\n\t\t\treturn 1f;\n\t\t} else {\n\t\t\treturn 0.95f - 0.05f*level;\n\t\t}\n\t}",
        "uniqueId": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea_55_71_80_86_80_86",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nAfter Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nExtractedCodeFragments:\nstatic private boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\nExample 2:\n Before Refactoring:\nprivate void starting() {\n        fStartNanos= System.nanoTime();\n    }\n\nAfter Refactoring:\nprivate void starting() {\n        fStartNanos= currentNanoTime();\n    }\n\nExtractedCodeFragments:\nprivate long currentNanoTime() {\n        return System.nanoTime();\n    }\nExample 3:\n Before Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (expected.getClass().isArray() && actual.getClass().isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nAfter Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate static boolean isArray(Object expected) {\n\t\treturn expected != null && expected.getClass().isArray();\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
        "sourceCodeBeforeRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tfloat spawnMulti = enemySpawnMultiplier();\n\t\tif (spawnMulti > 1f) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn spawnMulti;\n\t\t\t} else {\n\t\t\t\treturn 1f;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static float spawnMultiplierAtCurrentTime(){\n    float spawnMulti = enemySpawnMultiplier();\n    if (spawnMulti > 1f) {\n        Calendar cal = GregorianCalendar.getInstance();\n        if (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n            if (!sundialWarned){\n                GLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n                sundialWarned = true;\n            }\n            return spawnMulti;\n        } else {\n            return 1f;\n        }\n    } else {\n        return 1f;\n    }\n}\n```\n\n### Refactored Code:\n```java\npublic static float spawnMultiplierAtCurrentTime() {\n    float spawnMulti = enemySpawnMultiplier();\n    if (isSpawnMultiplierValid(spawnMulti)) {\n        if (isNightTime()) {\n            warnIfNeeded();\n            return spawnMulti;\n        }\n        return 1f;\n    }\n    return 1f;\n}\n\nprivate static boolean isSpawnMultiplierValid(float spawnMulti) {\n    return spawnMulti > 1f;\n}\n\nprivate static boolean isNightTime() {\n    Calendar cal = GregorianCalendar.getInstance();\n    int hour = cal.get(Calendar.HOUR_OF_DAY);\n    return hour >= 21 || hour <= 6;\n}\n\nprivate static void warnIfNeeded() {\n    if (!sundialWarned) {\n        GLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n        sundialWarned = true;\n    }\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: Created helper methods `isSpawnMultiplierValid`, `isNightTime`, and `warnIfNeeded` to improve readability and encapsulate logic.\n2. **Simplified Logic**: The main method now reads more clearly, focusing on the high-level logic rather than the details of the implementation.\n3. **Reduced Nesting**: By extracting methods, the nesting of conditions is reduced, making the code easier to follow.",
        "sourceCodeAfterRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tif (trinketLevel(DimensionalSundial.class) != -1) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 20 || cal.get(Calendar.HOUR_OF_DAY) <= 7) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn enemySpawnMultiplierNighttime();\n\t\t\t} else {\n\t\t\t\treturn enemySpawnMultiplierDaytime();\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static float enemySpawnMultiplierDaytime(){\n\t\treturn enemySpawnMultiplierDaytime(trinketLevel(DimensionalSundial.class));\n\t}",
        "uniqueId": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea_55_71_76_78_59_74",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nAfter Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nExtractedCodeFragments:\nstatic private boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\nExample 2:\n Before Refactoring:\nprivate void starting() {\n        fStartNanos= System.nanoTime();\n    }\n\nAfter Refactoring:\nprivate void starting() {\n        fStartNanos= currentNanoTime();\n    }\n\nExtractedCodeFragments:\nprivate long currentNanoTime() {\n        return System.nanoTime();\n    }\nExample 3:\n Before Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (expected.getClass().isArray() && actual.getClass().isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nAfter Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate static boolean isArray(Object expected) {\n\t\treturn expected != null && expected.getClass().isArray();\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "4071a47a5612e5cc0744f1dbcafe7c335603bdc8",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4071a47a5612e5cc0744f1dbcafe7c335603bdc8",
        "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onClick() {\n\t\tsuper.onClick();\n\n\t\t\n\t\tNotes.CustomRecord custom = new Notes.CustomRecord(Messages.get(this, \"default_title_text\"), \"\");\n\t\tNotes.add(custom);\n\t\trefreshScene(custom);\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\nprotected void onClick() {\n    super.onClick();\n\n    Notes.CustomRecord custom = new Notes.CustomRecord(Messages.get(this, \"default_title_text\"), \"\");\n    Notes.add(custom);\n    refreshScene(custom);\n}\n```\n\n### Refactored Code:\n```java\n@Override\nprotected void onClick() {\n    super.onClick();\n    createAndRefreshCustomRecord();\n}\n\nprivate void createAndRefreshCustomRecord() {\n    Notes.CustomRecord custom = new Notes.CustomRecord(Messages.get(this, \"default_title_text\"), \"\");\n    Notes.add(custom);\n    refreshScene(custom);\n}\n```\n\n### Explanation:\nIn the refactored code, I extracted the logic for creating and refreshing the custom record into a separate method `createAndRefreshCustomRecord()`. This improves readability by clearly separating the concerns of the `onClick` method and making it easier to understand the flow of actions that occur when the click event is triggered.",
        "sourceCodeAfterRefactoring": "@Override\n\tprotected void onClick() {\n\t\tsuper.onClick();\n\n\t\tif (Notes.getRecords(Notes.CustomRecord.class).size() >= Notes.customRecordLimit()){\n\t\t\tGameScene.show(new WndTitledMessage(Icons.INFO.get(),\n\t\t\t\t\tMessages.get(this, \"limit_title\"),\n\t\t\t\t\tMessages.get(this, \"limit_text\")));\n\t\t\treturn;\n\t\t}\n\n\t\tGameScene.show(new WndOptions(Icons.SCROLL_COLOR.get(),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"title\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"desc\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_floor\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_inv\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_type\")){\n\t\t\t@Override\n\t\t\tprotected void onSelect(int index) {\n\t\t\t\tif (index == 0){\n\t\t\t\t\tNotes.CustomRecord custom = new Notes.CustomRecord(\"\", \"\");\n\t\t\t\t\taddNote(custom,\n\t\t\t\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text\"),\n\t\t\t\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text_title\"));\n\t\t\t\t} else if (index == 1){\n\t\t\t\t\tGameScene.show(new WndDepthSelect());\n\t\t\t\t} else if (index == 2){\n\t\t\t\t\tGameScene.selectItem(itemSelector);\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show(new WndItemtypeSelect());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void hide() {\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onBackPressed() {\n\t\t\t\tsuper.hide(); \n\t\t\t}\n\t\t});\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static void addNote(Notes.CustomRecord note, String promptTitle, String prompttext){\n\t\tGameScene.show(new WndTextInput(promptTitle,\n\t\t\t\tprompttext,\n\t\t\t\t\"\",\n\t\t\t\t50,\n\t\t\t\tfalse,\n\t\t\t\tMessages.get(CustomNoteWindow.class, \"confirm\"),\n\t\t\t\tMessages.get(CustomNoteWindow.class, \"cancel\")){\n\t\t\t@Override\n\t\t\tpublic void onSelect(boolean positive, String text) {\n\t\t\t\tif (positive && !text.isEmpty()){\n\t\t\t\t\tNotes.add(note);\n\t\t\t\t\tnote.editText(text, \"\");\n\t\t\t\t\trefreshScene(null);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
        "uniqueId": "4071a47a5612e5cc0744f1dbcafe7c335603bdc8_45_53_329_346_58_102",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, clazz.getName()), annotations);\n\t}\n\nAfter Refactoring:\n\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn createTestDescription(clazz.getName(), name, annotations);\n\t}\n\nExtractedCodeFragments:\n/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the 'class' named <code>className</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param className the class name of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(String className, String name, Annotation... annotations) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, className), annotations);\n\t}\nExample 2:\n Before Refactoring:\nprivate Description(String displayName, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tfDisplayName= displayName;\n\t\tfAnnotations= annotations;\n\t}\n\nAfter Refactoring:\nprivate Description(String displayName, Annotation... annotations) {\n\t\tthis(displayName, displayName, annotations);\n\t}\n\nExtractedCodeFragments:\nprivate Description(String displayName, Object uniqueId, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tif ((uniqueId == null))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The unique id must not be null.\");\n\t\tfDisplayName= displayName;\n\t\tfUniqueId= uniqueId;\n\t\tfAnnotations= annotations;\n\t}\nExample 3:\n Before Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.thrownException().getMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.thrownException() instanceof AssertionFailedError) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nAfter Refactoring:\npublic Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.exceptionMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.isFailure()) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}\n\nExtractedCodeFragments:\n}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "sourceCodeBeforeRefactoring": "public void sacrifice( Char ch ) {\n\n\t\tint firePos = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (volume > 0 && cur[ch.pos+i] > 0){\n\t\t\t\tfirePos = ch.pos+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firePos != -1) {\n\n\t\t\tint exp = 0;\n\t\t\tif (ch instanceof Mob) {\n\t\t\t\t\n\t\t\t\tif (ch instanceof Statue || ch instanceof Mimic){\n\t\t\t\t\texp = 1 + Dungeon.depth;\n\t\t\t\t} else if (ch instanceof Piranha || ch instanceof Bee) {\n\t\t\t\t\texp = 1 + Dungeon.depth/2;\n\t\t\t\t} else if (ch instanceof Wraith) {\n\t\t\t\t\texp = 1 + Dungeon.depth/3;\n\t\t\t\t} else if (ch instanceof Swarm && ((Swarm) ch).EXP == 0){\n\t\t\t\t\t\n\t\t\t\t\texp = 1;\n\t\t\t\t} else if (((Mob) ch).EXP > 0) {\n\t\t\t\t\texp = 1 + ((Mob)ch).EXP;\n\t\t\t\t}\n\t\t\t\texp *= Random.IntRange( 2, 3 );\n\t\t\t} else if (ch instanceof Hero) {\n\t\t\t\texp = 1_000_000; \n\t\t\t\tBadges.validateDeathFromSacrifice();\n\t\t\t}\n\n\t\t\tif (exp > 0) {\n\n\t\t\t\tint volumeLeft = cur[firePos] - exp;\n\t\t\t\tif (volumeLeft > 0) {\n\t\t\t\t\tcur[firePos] -= exp;\n\t\t\t\t\tvolume -= exp;\n\t\t\t\t\tbonusSpawns++;\n\t\t\t\t\tCellEmitter.get(firePos).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"worthy\"));\n\t\t\t\t} else {\n\t\t\t\t\tclear(firePos);\n\t\t\t\t\tNotes.remove(Notes.Landmark.SACRIFICIAL_FIRE);\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tCellEmitter.get(firePos+i).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\t}\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"reward\"));\n\t\t\t\t\tif (prize != null) {\n\t\t\t\t\t\tDungeon.level.drop(prize, firePos).sprite.drop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"unworthy\"));\n\n\t\t\t}\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic void sacrifice(Char ch) {\n    int firePos = -1;\n    for (int i : PathFinder.NEIGHBOURS9) {\n        if (volume > 0 && cur[ch.pos + i] > 0) {\n            firePos = ch.pos + i;\n            break;\n        }\n    }\n\n    if (firePos != -1) {\n        int exp = 0;\n        if (ch instanceof Mob) {\n            if (ch instanceof Statue || ch instanceof Mimic) {\n                exp = 1 + Dungeon.depth;\n            } else if (ch instanceof Piranha || ch instanceof Bee) {\n                exp = 1 + Dungeon.depth / 2;\n            } else if (ch instanceof Wraith) {\n                exp = 1 + Dungeon.depth / 3;\n            } else if (ch instanceof Swarm && ((Swarm) ch).EXP == 0) {\n                exp = 1;\n            } else if (((Mob) ch).EXP > 0) {\n                exp = 1 + ((Mob) ch).EXP;\n            }\n            exp *= Random.IntRange(2, 3);\n        } else if (ch instanceof Hero) {\n            exp = 1_000_000;\n            Badges.validateDeathFromSacrifice();\n        }\n\n        if (exp > 0) {\n            int volumeLeft = cur[firePos] - exp;\n            if (volumeLeft > 0) {\n                cur[firePos] -= exp;\n                volume -= exp;\n                bonusSpawns++;\n                CellEmitter.get(firePos).burst(SacrificialParticle.FACTORY, 20);\n                Sample.INSTANCE.play(Assets.Sounds.BURNING);\n                GLog.w(Messages.get(SacrificialFire.class, \"worthy\"));\n            } else {\n                clear(firePos);\n                Notes.remove(Notes.Landmark.SACRIFICIAL_FIRE);\n\n                for (int i : PathFinder.NEIGHBOURS9) {\n                    CellEmitter.get(firePos + i).burst(SacrificialParticle.FACTORY, 20);\n                }\n                Sample.INSTANCE.play(Assets.Sounds.BURNING);\n                Sample.INSTANCE.play(Assets.Sounds.BURNING);\n                Sample.INSTANCE.play(Assets.Sounds.BURNING);\n                GLog.w(Messages.get(SacrificialFire.class, \"reward\"));\n                if (prize != null) {\n                    Dungeon.level.drop(prize, firePos).sprite.drop();\n                } else {\n                    Dungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n                }\n            }\n        } else {\n            GLog.w(Messages.get(SacrificialFire.class, \"unworthy\"));\n        }\n    }\n}\n```\n\n### Refactored Code:\n```java\npublic void sacrifice(Char ch) {\n    int firePos = findFirePosition(ch);\n    if (firePos != -1) {\n        int exp = calculateExperience(ch);\n        processSacrifice(firePos, exp);\n    }\n}\n\nprivate int findFirePosition(Char ch) {\n    for (int i : PathFinder.NEIGHBOURS9) {\n        if (volume > 0 && cur[ch.pos + i] > 0) {\n            return ch.pos + i;\n        }\n    }\n    return -1;\n}\n\nprivate int calculateExperience(Char ch) {\n    if (ch instanceof Mob) {\n        return calculateMobExperience((Mob) ch);\n    } else if (ch instanceof Hero) {\n        Badges.validateDeathFromSacrifice();\n        return 1_000_000;\n    }\n    return 0;\n}\n\nprivate int calculateMobExperience(Mob mob) {\n    int exp = 0;\n    if (mob instanceof Statue || mob instanceof Mimic) {\n        exp = 1 + Dungeon.depth;\n    } else if (mob instanceof Piranha || mob instanceof Bee) {\n        exp = 1 + Dungeon.depth / 2;\n    } else if (mob instanceof Wraith) {\n        exp = 1 + Dungeon.depth / 3;\n    } else if (mob instanceof Swarm && ((Swarm) mob).EXP == 0) {\n        exp = 1;\n    } else if (mob.EXP > 0) {\n        exp = 1 + mob.EXP;\n    }\n    return exp * Random.IntRange(2, 3);\n}\n\nprivate void processSacrifice(int firePos, int exp) {\n    if (exp > 0) {\n        int volumeLeft = cur[firePos] - exp;\n        if (volumeLeft > 0) {\n            cur[firePos] -= exp;\n            volume -= exp;\n            bonusSpawns++;\n            CellEmitter.get(firePos).burst(SacrificialParticle.FACTORY, 20);\n            Sample.INSTANCE.play(Assets.Sounds.BURNING);\n            GLog.w(Messages.get(SacrificialFire.class, \"worthy\"));\n        } else {\n            clear(firePos);\n            Notes.remove(Notes.Landmark.SACRIFICIAL_FIRE);\n            burstParticlesAroundFire(firePos);\n            GLog.w(Messages.get(SacrificialFire.class, \"reward\"));\n            dropPrize(firePos);\n        }\n    } else {\n        GLog.w(Messages.get(SacrificialFire.class, \"unworthy\"));\n    }\n}\n\nprivate void burstParticlesAroundFire(int firePos) {\n    for (int i : PathFinder.NEIGHBOURS9) {\n        CellEmitter.get(firePos + i).burst(SacrificialParticle.FACTORY, 20);\n    }\n    Sample.INSTANCE.play(Assets.Sounds.BURNING);\n    Sample.INSTANCE.play(Assets.Sounds.BURNING);\n    Sample.INSTANCE.play(Assets.Sounds.BURNING);\n}\n\nprivate void dropPrize(int firePos) {\n    if (prize != null) {\n        Dungeon.level.drop(prize, firePos).sprite.drop();\n    } else {\n        Dungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: The code was broken down into smaller, more manageable methods (`findFirePosition`, `calculateExperience`, `calculateMobExperience`, `processSacrifice`, `burstParticlesAroundFire`, and `dropPrize`) to improve readability and maintainability.\n2. **Simplified Logic**: The logic for calculating experience and processing the sacrifice was encapsulated in dedicated methods, making the main `sacrifice` method cleaner and easier to understand.\n3. **Reduced Nesting**: By extracting methods, the nesting of conditions was reduced, which enhances readability.",
        "sourceCodeAfterRefactoring": "public void sacrifice( Char ch ) {\n\n\t\tint firePos = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (volume > 0 && cur[ch.pos+i] > 0){\n\t\t\t\tfirePos = ch.pos+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firePos != -1) {\n\n\t\t\tint exp = 0;\n\t\t\tif (ch instanceof Mob) {\n\t\t\t\t\n\t\t\t\tif (ch instanceof Statue || ch instanceof Mimic){\n\t\t\t\t\texp = 1 + Dungeon.depth;\n\t\t\t\t} else if (ch instanceof Piranha || ch instanceof Bee) {\n\t\t\t\t\texp = 1 + Dungeon.depth/2;\n\t\t\t\t} else if (ch instanceof Wraith) {\n\t\t\t\t\texp = 1 + Dungeon.depth/3;\n\t\t\t\t} else if (ch instanceof Swarm && ((Swarm) ch).EXP == 0){\n\t\t\t\t\t\n\t\t\t\t\texp = 1;\n\t\t\t\t} else if (((Mob) ch).EXP > 0) {\n\t\t\t\t\texp = 1 + ((Mob)ch).EXP;\n\t\t\t\t}\n\t\t\t\texp *= Random.IntRange( 2, 3 );\n\t\t\t} else if (ch instanceof Hero) {\n\t\t\t\texp = 1_000_000; \n\t\t\t\tBadges.validateDeathFromSacrifice();\n\t\t\t}\n\n\t\t\tif (exp > 0) {\n\n\t\t\t\tint volumeLeft = cur[firePos] - exp;\n\t\t\t\tif (volumeLeft > 0) {\n\t\t\t\t\tcur[firePos] -= exp;\n\t\t\t\t\tvolume -= exp;\n\t\t\t\t\tbonusSpawns++;\n\t\t\t\t\tCellEmitter.get(firePos).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"worthy\"));\n\t\t\t\t} else {\n\t\t\t\t\tclear(firePos);\n\t\t\t\t\tif (volume <= 0) Notes.remove( landmark() );\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tCellEmitter.get(firePos+i).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\t}\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"reward\"));\n\t\t\t\t\tif (prize != null) {\n\t\t\t\t\t\tDungeon.level.drop(prize, firePos).sprite.drop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"unworthy\"));\n\n\t\t\t}\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.SACRIFICIAL_FIRE;\n\t}",
        "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_145_211_67_70_148_214",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n\tpublic String getMessage() {\n\t\tString formatted= \"\";\n\t\tString message= super.getMessage();\n\t\t\n\t\tint end= Math.min(fExpected.length(), fActual.length());\n\t\t\n\t\tint i= 0;\n\t\tfor(; i < end; i++) {\n\t\t\tif (fExpected.charAt(i) != fActual.charAt(i))\n\t\t\t\tbreak;\n\t\t}\n\t\tint j= fExpected.length()-1;\n\t\tint k= fActual.length()-1;\n\t\tfor (; k >= i && j >= i; k--,j--) {\n\t\t\tif (fExpected.charAt(j) != fActual.charAt(k))\n\t\t\t\tbreak;\n\t\t}\n\t\tString actual, expected;\n\t\t\n\t\t\n\t\tif (j < i && k < i) {\n\t\t\texpected= fExpected;\n\t\t\tactual= fActual;\n\t\t} else {\n\t\t\texpected= fExpected.substring(i, j+1);\n\t\t\tactual= fActual.substring(i, k+1);\n\t\t\tif (i <= end && i > 0) {\n\t\t\t\texpected= \"...\"+expected;\n\t\t\t\tactual= \"...\"+actual;\n\t\t\t}\n\t\t\t\n\t\t\tif (j < fExpected.length()-1)\n\t\t\t\texpected= expected+\"...\";\n\t\t\tif (k < fActual.length()-1)\n\t\t\t\tactual= actual+\"...\";\n\t\t}\t\n\t\tif (message != null)\n\t\t\tformatted= message+\": \";\t\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}\n\nAfter Refactoring:\n\n\tpublic String getMessage() {\n\t\tif (fExpected == null || fActual == null)\n\t\t\treturn format(fActual, fExpected);\n\t\t\t\n\t\tint end= Math.min(fExpected.length(), fActual.length());\n\t\t\n\t\tint i= 0;\n\t\tfor(; i < end; i++) {\n\t\t\tif (fExpected.charAt(i) != fActual.charAt(i))\n\t\t\t\tbreak;\n\t\t}\n\t\tint j= fExpected.length()-1;\n\t\tint k= fActual.length()-1;\n\t\tfor (; k >= i && j >= i; k--,j--) {\n\t\t\tif (fExpected.charAt(j) != fActual.charAt(k))\n\t\t\t\tbreak;\n\t\t}\n\t\tString actual, expected;\n\t\t\n\t\t\n\t\tif (j < i && k < i) {\n\t\t\texpected= fExpected;\n\t\t\tactual= fActual;\n\t\t} else {\n\t\t\texpected= fExpected.substring(i, j+1);\n\t\t\tactual= fActual.substring(i, k+1);\n\t\t\tif (i <= end && i > 0) {\n\t\t\t\texpected= \"...\"+expected;\n\t\t\t\tactual= \"...\"+actual;\n\t\t\t}\n\t\t\t\n\t\t\tif (j < fExpected.length()-1)\n\t\t\t\texpected= expected+\"...\";\n\t\t\tif (k < fActual.length()-1)\n\t\t\t\tactual= actual+\"...\";\n\t\t}\t\n\t\treturn format(actual, expected);\n\t}\n\nExtractedCodeFragments:\nprivate String format(String actual, String expected) {\n\t\tString message= super.getMessage();\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\": \";\t\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}\nExample 2:\n Before Refactoring:\npublic int compare(Description o1, Description o2) {\n\t\t\t\n\t\t\tif (isNew(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNew(o2))\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t\n\t\t\t\t: fDurations.get(o1).compareTo(fDurations.get(o2));\n\t\t}\n\nAfter Refactoring:\npublic int compare(Description o1, Description o2) {\n\t\t\t\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}\n\nExtractedCodeFragments:\nprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}\nExample 3:\n Before Refactoring:\n\n\tpublic void printFailures(TestResult result) {\n\t\tif (result.failureCount() != 0) {\n\t\t\tif (result.failureCount() == 1)\n\t\t\t\tgetWriter().println(\"There was \" + result.failureCount() + \" failure:\");\n\t\t\telse\n\t\t\t\tgetWriter().println(\"There were \" + result.failureCount() + \" failures:\");\n\t\t\tint i = 1;\n\t\t\tfor (Enumeration e= result.failures(); e.hasMoreElements(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure) e.nextElement();\n\t\t\t\tgetWriter().print(i + \") \" + failure.failedTest());\n\t\t\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(failure.trace()));\n\t\t\t}\n\t\t}\n\t}\n\nAfter Refactoring:\nprotected void printBooBoos(Enumeration booBoos, int count, String type) {\n\t\tif (count == 0) return;\n\t\tif (count == 1)\n\t\t\tgetWriter().println(\"There was \" + count + \" \" + type + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + count + \" \" + type + \"s:\");\n\t\tfor (int i= 1; booBoos.hasMoreElements(); i++) {\n\t\t\tprintBooBoo((TestFailure) booBoos.nextElement(), i);\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprotected void printBooBoo(TestFailure booBoo,int count) {\n\t\tgetWriter().print(count + \") \" + booBoo.failedTest());\n\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(booBoo.trace()));\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tif (spawnRecorded){\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(Notes.Landmark.DEMON_SPAWNER);\n\t\t}\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t\tsuper.die(cause);\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic void die(Object cause) {\n\t\tif (spawnRecorded){\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(Notes.Landmark.DEMON_SPAWNER);\n\t\t}\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t\tsuper.die(cause);\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\n\tpublic void die(Object cause) {\n\t\thandleSpawnRecorded();\n\t\tlogDeathMessage();\n\t\tsuper.die(cause);\n\t}\n\nprivate void handleSpawnRecorded() {\n\t\tif (spawnRecorded) {\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(Notes.Landmark.DEMON_SPAWNER);\n\t\t}\n\t}\n\nprivate void logDeathMessage() {\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t}\n```\n\nIn the refactored code, I extracted the logic for handling the `spawnRecorded` condition and logging the death message into separate private methods (`handleSpawnRecorded` and `logDeathMessage`). This improves readability by clearly separating concerns and making the `die` method easier to understand at a glance.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tif (spawnRecorded){\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(landmark());\n\t\t}\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t\tsuper.die(cause);\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.DEMON_SPAWNER;\n\t}",
        "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_148_156_144_147_149_157",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@Test public void noRunnableMethods() {\n\t\tJUnitCore core = new JUnitCore();\n\t\tResult result = core.run(new Class[] {NoTests.class});\n\t\tFailure failure = result.getFailures().get(0);\n\t\tassertEquals(\"No runnable methods\", failure.getException().getMessage());\n\t}\n\nAfter Refactoring:\n@Test\n\tpublic void noRunnableMethods() {\n\t\tassertEquals(\"No runnable methods\", exceptionMessageFrom(NoTests.class));\n\t}\n\nExtractedCodeFragments:\nprivate String exceptionMessageFrom(Class<?> testClass) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tResult result= core.run(testClass);\n\t\tFailure failure= result.getFailures().get(0);\n\t\tString message= failure.getException().getMessage();\n\t\treturn message;\n\t}\nExample 2:\n Before Refactoring:\n@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\nAfter Refactoring:\n@Override\n\tpublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\nExample 3:\n Before Refactoring:\n@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}\n\nAfter Refactoring:\n@Override\n\tpublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic void destroy() {\n\t\tif (levelGenStatue) {\n\t\t\tNotes.remove( Notes.Landmark.STATUE );\n\t\t}\n\t\tsuper.destroy();\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic void destroy() {\n\t\tif (levelGenStatue) {\n\t\t\tNotes.remove( Notes.Landmark.STATUE );\n\t\t}\n\t\tsuper.destroy();\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\n\tpublic void destroy() {\n\t\tremoveStatueIfNeeded();\n\t\tsuper.destroy();\n\t}\n\nprivate void removeStatueIfNeeded() {\n\t\tif (levelGenStatue) {\n\t\t\tNotes.remove(Notes.Landmark.STATUE);\n\t\t}\n\t}\n```\n\nIn this refactoring, I extracted the logic for removing the statue into a separate method `removeStatueIfNeeded()`. This improves readability by clearly indicating the purpose of that block of code and adheres to the Single Responsibility Principle.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void destroy() {\n\t\tif (landmark() != null) {\n\t\t\tNotes.remove( landmark() );\n\t\t}\n\t\tsuper.destroy();\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn levelGenStatue ? Notes.Landmark.STATUE : null;\n\t}",
        "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_164_170_156_159_161_167",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\tsuper(addParent(klass), Request.classes(klass.getName(), annotatedClasses).getRunner());\n\t\tparents.remove(klass);\n\t}\n\nAfter Refactoring:\nprotected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\t\n\t\tsuper(klass.getName());\n\t\t\n\t\taddParent(klass);\n\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\tif (childRunner != null)\n\t\t\t\tadd(childRunner);\n\t\t}\n\t\tremoveParent(klass);\n\n\t\tfTestClass= new TestClass(klass);\n\t\tMethodValidator methodValidator= new MethodValidator(fTestClass);\n\t\tmethodValidator.validateStaticMethods();\n\t\tmethodValidator.assertValid();\n\t}\n\nExtractedCodeFragments:\nprivate void removeParent(Class<?> klass) {\n\t\tparents.remove(klass);\n\t}\nExample 2:\n Before Refactoring:\n\n    public void delete() {\n        if (folder != null) {\n            recursiveDelete(folder);\n        }\n    }\n\nAfter Refactoring:\n\n    public void delete() {\n        if (!tryDelete()) {\n            if (assureDeletion) {\n                fail(\"Unable to clean up temporary folder \" + folder);\n            }\n        }\n    }\n\nExtractedCodeFragments:\n/**\n     * Tries to delete all files and folders under the temporary folder and\n     * returns whether deletion was successful or not.\n     *\n     * @return {@code true} if all resources are deleted successfully,\n     *         {@code false} otherwise.\n     */\n    protected boolean tryDelete() {\n        if (folder == null) {\n            return true;\n        }\n        \n        return recursiveDelete(folder);\n    }\nExample 3:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (Dungeon.hero.buff(AscensionChallenge.class) != null){\n\t\t\tdie(null);\n\t\t\treturn true;\n\t\t}\n\t\tif (Dungeon.level.heroFOV[pos] && !Quest.completed()){\n\t\t\tNotes.add( Notes.Landmark.GHOST );\n\t\t}\n\t\treturn super.act();\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tprotected boolean act() {\n\t\tif (Dungeon.hero.buff(AscensionChallenge.class) != null){\n\t\t\tdie(null);\n\t\t\treturn true;\n\t\t}\n\t\tif (Dungeon.level.heroFOV[pos] && !Quest.completed()){\n\t\t\tNotes.add( Notes.Landmark.GHOST );\n\t\t}\n\t\treturn super.act();\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\nprotected boolean act() {\n    if (isAscensionChallengeActive()) {\n        die(null);\n        return true;\n    }\n    if (isHeroInFOVAndQuestNotCompleted()) {\n        Notes.add(Notes.Landmark.GHOST);\n    }\n    return super.act();\n}\n\nprivate boolean isAscensionChallengeActive() {\n    return Dungeon.hero.buff(AscensionChallenge.class) != null;\n}\n\nprivate boolean isHeroInFOVAndQuestNotCompleted() {\n    return Dungeon.level.heroFOV[pos] && !Quest.completed();\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: The conditions for checking the Ascension Challenge and the hero's visibility in the field of view (FOV) have been extracted into separate methods (`isAscensionChallengeActive` and `isHeroInFOVAndQuestNotCompleted`). This improves readability by giving meaningful names to the checks, making the `act` method easier to understand at a glance.\n2. **Consistent Formatting**: The formatting has been slightly adjusted for better readability, such as consistent indentation and spacing.",
        "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (Dungeon.hero.buff(AscensionChallenge.class) != null){\n\t\t\tdie(null);\n\t\t\tNotes.remove( landmark() );\n\t\t\treturn true;\n\t\t}\n\t\treturn super.act();\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.GHOST;\n\t}",
        "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_84_94_84_87_89_97",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@Test public void noRunnableMethods() {\n\t\tJUnitCore core = new JUnitCore();\n\t\tResult result = core.run(new Class[] {NoTests.class});\n\t\tFailure failure = result.getFailures().get(0);\n\t\tassertEquals(\"No runnable methods\", failure.getException().getMessage());\n\t}\n\nAfter Refactoring:\n@Test\n\tpublic void noRunnableMethods() {\n\t\tassertEquals(\"No runnable methods\", exceptionMessageFrom(NoTests.class));\n\t}\n\nExtractedCodeFragments:\nprivate String exceptionMessageFrom(Class<?> testClass) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tResult result= core.run(testClass);\n\t\tFailure failure= result.getFailures().get(0);\n\t\tString message= failure.getException().getMessage();\n\t\treturn message;\n\t}\nExample 2:\n Before Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nAfter Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }\n\nExtractedCodeFragments:\nprivate boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\nExample 3:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
        "sourceCodeBeforeRefactoring": "public void flee() {\n\t\tdestroy();\n\n\t\tNotes.remove(Notes.Landmark.SHOP);\n\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic void flee() {\n\t\tdestroy();\n\n\t\tNotes.remove(Notes.Landmark.SHOP);\n\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t\t}\n\t}\n```\n\n### Refactored Code:\n```java\npublic void flee() {\n\t\tdestroy();\n\t\tremoveShopLandmark();\n\t\teraseSpriteIfPresent();\n\t}\n\nprivate void removeShopLandmark() {\n\t\tNotes.remove(Notes.Landmark.SHOP);\n\t}\n\nprivate void eraseSpriteIfPresent() {\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tburstParticles();\n\t\t}\n\t}\n\nprivate void burstParticles() {\n\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t}\n```\n\n### Explanation:\nThe refactored code improves readability by extracting specific actions into their own methods. This makes the `flee` method clearer and easier to understand at a glance, while also adhering to the Single Responsibility Principle. Each extracted method has a clear purpose, which enhances maintainability.",
        "sourceCodeAfterRefactoring": "public void flee() {\n\t\tdestroy();\n\n\t\tNotes.remove( landmark() );\n\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.SHOP;\n\t}",
        "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_148_157_72_75_149_158",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\nTestTreeCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"ok.gif\");\n\t    \tfOkIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"failure.gif\");\n\t    \tfFailureIcon= new ImageIcon(url);\n\t\t}\n\nAfter Refactoring:\nTestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}\n\nExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} \n\t\t\treturn new ImageIcon(url);\n\t\t}\nExample 3:\n Before Refactoring:\nprivate void stopping() {\n        fEndNanos= System.nanoTime();\n    }\n\nAfter Refactoring:\nprivate void stopping() {\n        fEndNanos= currentNanoTime();\n    }\n\nExtractedCodeFragments:\nprivate long currentNanoTime() {\n        return System.nanoTime();\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "be3de2d883d043596bb274ac7796e30bca891583",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/be3de2d883d043596bb274ac7796e30bca891583",
        "sourceCodeBeforeRefactoring": "private int chargeLimit( int heroLvl ){\n\t\tif (level() >= 10){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfloat lvl = level();\n\t\t\treturn Math.round(20 + heroLvl * (2+lvl) * (1f + (lvl/(50 - 5*lvl))));\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\nprivate int chargeLimit(int heroLvl) {\n    if (level() >= 10) {\n        return Integer.MAX_VALUE;\n    } else {\n        float lvl = level();\n        return Math.round(20 + heroLvl * (2 + lvl) * (1f + (lvl / (50 - 5 * lvl))));\n    }\n}\n```\n\n### Refactored Code:\n```java\nprivate int chargeLimit(int heroLvl) {\n    if (isMaxLevel()) {\n        return Integer.MAX_VALUE;\n    } else {\n        return Math.round(calculateChargeLimit(heroLvl, level()));\n    }\n}\n\nprivate boolean isMaxLevel() {\n    return level() >= 10;\n}\n\nprivate float calculateChargeLimit(int heroLvl, float lvl) {\n    return 20 + heroLvl * (2 + lvl) * (1f + (lvl / (50 - 5 * lvl)));\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Method for Level Check**: The check for whether the level is at maximum (10) was extracted into a separate method `isMaxLevel()`, improving readability.\n2. **Extracted Method for Charge Limit Calculation**: The calculation of the charge limit was extracted into a separate method `calculateChargeLimit(int heroLvl, float lvl)`, which clarifies the purpose of the calculation and reduces complexity in the main method.\n3. **Improved Readability**: The refactored code is easier to read and understand, as it clearly separates the logic for checking the level and calculating the charge limit.",
        "sourceCodeAfterRefactoring": "private int chargeLimit( int heroLvl ){\n\t\treturn chargeLimit(  heroLvl, level() );\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate int chargeLimit( int heroLvl, int wndLvl ){\n\t\tif (wndLvl >= 10){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn Math.round(20 + heroLvl * (2+wndLvl) * (1f + (wndLvl/(50 - 5*wndLvl))));\n\t\t}\n\t}",
        "uniqueId": "be3de2d883d043596bb274ac7796e30bca891583_203_213_207_216_203_205",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nAfter Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nExtractedCodeFragments:\nstatic private boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\nExample 2:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t\n    \t\t\n    \t\t\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }\nExample 3:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        \n        \n        \n        \n        \n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "be3de2d883d043596bb274ac7796e30bca891583",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/be3de2d883d043596bb274ac7796e30bca891583",
        "sourceCodeBeforeRefactoring": "public WndUpgrade( Item upgrader, Item toUpgrade, boolean force){\n\n\t\tthis.force = force;\n\n\t\tIconTitle title = new IconTitle( new ItemSprite(upgrader), Messages.get(this, \"title\") );\n\n\t\ttitle.setRect(0, 0, WIDTH, 0);\n\t\tadd(title);\n\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock( 6 );\n\t\tmessage.text( Messages.get(this, \"desc\"), WIDTH);\n\t\tmessage.setPos(0, title.bottom()+GAP);\n\t\tadd(message);\n\n\t\t\n\n\t\tint levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n\t\tint levelTo = levelFrom + 1;\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tlevelTo--;\n\t\t}\n\n\t\tboolean curseInfused = (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n\n\t\tif (curseInfused){\n\t\t\tif (toUpgrade.trueLevel()/6 < (toUpgrade.trueLevel()+1)/6){\n\t\t\t\t\n\t\t\t\tlevelTo++;\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tItemSprite i1 = new ItemSprite();\n\t\tadd(i1);\n\t\ti1.view(toUpgrade);\n\t\ti1.x = COL_2 - i1.width()/2f;\n\t\ti1.y = message.bottom() + GAP + (16-i1.height())/2f;\n\t\tPixelScene.align(i1);\n\t\tadd(i1);\n\n\t\tItemSprite i2 = new ItemSprite();\n\t\tadd(i2);\n\t\ti2.view(toUpgrade);\n\t\ti2.x = COL_3 - i2.width()/2f;\n\t\ti2.y = i1.y;\n\t\tPixelScene.align(i2);\n\t\tadd(i2);\n\n\t\tBitmapText t1 = new BitmapText(PixelScene.pixelFont);\n\t\tBitmapText t2 = new BitmapText(PixelScene.pixelFont);\n\t\tif (toUpgrade.isIdentified()){\n\t\t\tif (levelFrom > 0){\n\t\t\t\tt1.text(\"+\" + levelFrom);\n\t\t\t} else {\n\t\t\t\tt1.text(\"\");\n\t\t\t}\n\t\t\tt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);\n\n\t\t\tif (curseInfused){\n\t\t\t\tt1.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t\tt2.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t}\n\n\t\t} else {\n\t\t\tt1.text(\"?\");\n\t\t\tt1.hardlight(0.6f, 0.3f, 0.6f);\n\t\t\tt2.text(\"+1?\");\n\t\t\tt2.hardlight(0.6f, 0.3f, 0.6f);\n\t\t}\n\t\tt1.measure();\n\t\tt1.x = COL_2 + 8 - t1.width();\n\t\tt1.y = message.bottom() + GAP + 16 - t1.baseLine();\n\t\tadd(t1);\n\n\t\tt2.measure();\n\t\tt2.x = COL_3 + 8 - t2.width();\n\t\tt2.y = message.bottom() + GAP + 16 - t2.baseLine();\n\t\tadd(t2);\n\n\t\tfloat bottom = i1.y + 16 + GAP;\n\n\t\tfinal String LINE = Messages.lang() == Languages.CHINESE ? \"~\" : \"-\";\n\n\t\t\n\n\t\t\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"damage\"),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelFrom) + LINE + ((Weapon) toUpgrade).max(levelFrom),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelTo) + LINE + ((Weapon) toUpgrade).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Armor){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelFrom) + LINE + ((Armor) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelTo) + LINE + ((Armor) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof RoundShield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Greatshield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Armor) {\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof MissileWeapon){\n\t\t\t\n\t\t\tint uses1 = (int)Math.ceil(100f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tint uses2 = (int)Math.ceil(300f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tbottom = fillFields(Messages.get(this, \"durability\"),\n\t\t\t\t\tuses1 >= 100 ? \"\u221e\" : Integer.toString(uses1),\n\t\t\t\t\tuses2 >= 100 ? \"\u221e\" : Integer.toString(uses2),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tItem wand = toUpgrade;\n\t\tif (toUpgrade instanceof MagesStaff && ((MagesStaff) toUpgrade).wandClass() != null){\n\t\t\twand = Reflection.newInstance(((MagesStaff) toUpgrade).wandClass());\n\t\t}\n\n\t\t\n\t\tif (wand instanceof DamageWand) {\n\t\t\tbottom = fillFields(Messages.get(this, \"zap_damage\"),\n\t\t\t\t\t((DamageWand) wand).min(levelFrom) + LINE + ((DamageWand) wand).max(levelFrom),\n\t\t\t\t\t((DamageWand) wand).min(levelTo) + LINE + ((DamageWand) wand).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfCorrosion){\n\t\t\t\n\t\t\tbottom = fillFields(Messages.get(this, \"corrosion_damage\"),\n\t\t\t\t\tInteger.toString(2+levelFrom),\n\t\t\t\t\tInteger.toString(2+levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfWarding){\n\t\t\t\n\t\t\tbottom = fillFields(Messages.get(this, \"ward_damage\"),\n\t\t\t\t\t(2 + levelFrom) + LINE + (8 + 4*levelFrom),\n\t\t\t\t\t(2 + levelTo) + LINE + (8 + 4*levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\n\t\t\n\t\tif (wand instanceof Wand){\n\t\t\tint chargeboost = levelFrom + (toUpgrade instanceof MagesStaff ? 1 : 0);\n\t\t\tbottom = fillFields(Messages.get(this, \"charges\"),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost)),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost + 1)),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Ring){\n\n\t\t}\n\n\t\t\n\t\tColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = WIDTH/2f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\tsep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = 3*WIDTH/4f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\t\n\n\t\t\n\t\tif (!toUpgrade.isIdentified()){\n\t\t\tbottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t\n\t\tif (!(upgrader instanceof MagicalInfusion)) {\n\n\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n\t\t\t\tint lossChance;\n\t\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n\t\t\t\t} else {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n\t\t\t\t}\n\n\t\t\t\tif (lossChance >= 10) {\n\t\t\t\t\tString warn;\n\t\t\t\t\tif (toUpgrade instanceof Weapon) {\n\t\t\t\t\t\tif (((Weapon) toUpgrade).enchantHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"enchant\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((Armor) toUpgrade).glyphHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"glyph\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbottom = addMessage(warn, CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((toUpgrade.cursed\n\t\t\t\t\t|| (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph()))\n\t\t\t\t\t&& toUpgrade.cursedKnown) {\n\n\t\t\t\tif (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())){\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t} else {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t}\n\n\t\t\t\tif (curseInfused) {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"curse_infusion\"), CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tbottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t\n\n\t\tbtnUpgrade = new RedButton(Messages.get(this, \"upgrade\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tScrollOfUpgrade.upgrade(Dungeon.hero);\n\n\t\t\t\tItem upgraded = toUpgrade;\n\t\t\t\tif (upgrader instanceof ScrollOfUpgrade){\n\t\t\t\t\t((ScrollOfUpgrade) upgrader).readAnimation();\n\t\t\t\t\tupgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t\t\t\t} else if (upgrader instanceof MagicalInfusion){\n\t\t\t\t\t((MagicalInfusion) upgrader).useAnimation();\n\t\t\t\t\tupgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t}\n\n\t\t\t\tItem moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n\n\t\t\t\thide();\n\n\t\t\t\tif (moreUpgradeItem != null && toUpgrade.isIdentified()){\n\t\t\t\t\tmoreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\t\tGameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnUpgrade.setRect(0, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnUpgrade);\n\n\t\tbtnCancel = new RedButton(Messages.get(this, \"cancel\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tif (!force) {\n\t\t\t\t\tupgrader.collect();\n\t\t\t\t\thide();\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show( new WndOptions(new ItemSprite(upgrader),\n\t\t\t\t\t\t\tMessages.titleCase(upgrader.name()),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tWndUpgrade.this.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onBackPressed() {}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t\tbtnCancel.setRect(btnUpgrade.right()+1, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnCancel);\n\n\t\tbtnUpgrade.enable(Dungeon.hero.ready);\n\n\t\tbottom = (int)btnCancel.bottom();\n\n\t\tresize(WIDTH, (int)bottom);\n\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic WndUpgrade( Item upgrader, Item toUpgrade, boolean force){\n\n\t\tthis.force = force;\n\n\t\tIconTitle title = new IconTitle( new ItemSprite(upgrader), Messages.get(this, \"title\") );\n\n\t\ttitle.setRect(0, 0, WIDTH, 0);\n\t\tadd(title);\n\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock( 6 );\n\t\tmessage.text( Messages.get(this, \"desc\"), WIDTH);\n\t\tmessage.setPos(0, title.bottom()+GAP);\n\t\tadd(message);\n\n\t\tint levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n\t\tint levelTo = levelFrom + 1;\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tlevelTo--;\n\t\t}\n\n\t\tboolean curseInfused = (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n\n\t\tif (curseInfused){\n\t\t\tif (toUpgrade.trueLevel()/6 < (toUpgrade.trueLevel()+1)/6){\n\t\t\t\tlevelTo++;\n\t\t\t}\n\t\t}\n\n\t\tItemSprite i1 = new ItemSprite();\n\t\tadd(i1);\n\t\ti1.view(toUpgrade);\n\t\ti1.x = COL_2 - i1.width()/2f;\n\t\ti1.y = message.bottom() + GAP + (16-i1.height())/2f;\n\t\tPixelScene.align(i1);\n\t\tadd(i1);\n\n\t\tItemSprite i2 = new ItemSprite();\n\t\tadd(i2);\n\t\ti2.view(toUpgrade);\n\t\ti2.x = COL_3 - i2.width()/2f;\n\t\ti2.y = i1.y;\n\t\tPixelScene.align(i2);\n\t\tadd(i2);\n\n\t\tBitmapText t1 = new BitmapText(PixelScene.pixelFont);\n\t\tBitmapText t2 = new BitmapText(PixelScene.pixelFont);\n\t\tif (toUpgrade.isIdentified()){\n\t\t\tif (levelFrom > 0){\n\t\t\t\tt1.text(\"+\" + levelFrom);\n\t\t\t} else {\n\t\t\t\tt1.text(\"\");\n\t\t\t}\n\t\t\tt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);\n\n\t\t\tif (curseInfused){\n\t\t\t\tt1.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t\tt2.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t}\n\n\t\t} else {\n\t\t\tt1.text(\"?\");\n\t\t\tt1.hardlight(0.6f, 0.3f, 0.6f);\n\t\t\tt2.text(\"+1?\");\n\t\t\tt2.hardlight(0.6f, 0.3f, 0.6f);\n\t\t}\n\t\tt1.measure();\n\t\tt1.x = COL_2 + 8 - t1.width();\n\t\tt1.y = message.bottom() + GAP + 16 - t1.baseLine();\n\t\tadd(t1);\n\n\t\tt2.measure();\n\t\tt2.x = COL_3 + 8 - t2.width();\n\t\tt2.y = message.bottom() + GAP + 16 - t2.baseLine();\n\t\tadd(t2);\n\n\t\tfloat bottom = i1.y + 16 + GAP;\n\n\t\tfinal String LINE = Messages.lang() == Languages.CHINESE ? \"~\" : \"-\";\n\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"damage\"),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelFrom) + LINE + ((Weapon) toUpgrade).max(levelFrom),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelTo) + LINE + ((Weapon) toUpgrade).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tif (toUpgrade instanceof Armor){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelFrom) + LINE + ((Armor) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelTo) + LINE + ((Armor) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof RoundShield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Greatshield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Armor) {\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tif (toUpgrade instanceof MissileWeapon){\n\t\t\tint uses1 = (int)Math.ceil(100f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tint uses2 = (int)Math.ceil(300f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tbottom = fillFields(Messages.get(this, \"durability\"),\n\t\t\t\t\tuses1 >= 100 ? \"\u221e\" : Integer.toString(uses1),\n\t\t\t\t\tuses2 >= 100 ? \"\u221e\" : Integer.toString(uses2),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tItem wand = toUpgrade;\n\t\tif (toUpgrade instanceof MagesStaff && ((MagesStaff) toUpgrade).wandClass() != null){\n\t\t\twand = Reflection.newInstance(((MagesStaff) toUpgrade).wandClass());\n\t\t}\n\n\t\tif (wand instanceof DamageWand) {\n\t\t\tbottom = fillFields(Messages.get(this, \"zap_damage\"),\n\t\t\t\t\t((DamageWand) wand).min(levelFrom) + LINE + ((DamageWand) wand).max(levelFrom),\n\t\t\t\t\t((DamageWand) wand).min(levelTo) + LINE + ((DamageWand) wand).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfCorrosion){\n\t\t\tbottom = fillFields(Messages.get(this, \"corrosion_damage\"),\n\t\t\t\t\tInteger.toString(2+levelFrom),\n\t\t\t\t\tInteger.toString(2+levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfWarding){\n\t\t\tbottom = fillFields(Messages.get(this, \"ward_damage\"),\n\t\t\t\t\t(2 + levelFrom) + LINE + (8 + 4*levelFrom),\n\t\t\t\t\t(2 + levelTo) + LINE + (8 + 4*levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tif (wand instanceof Wand){\n\t\t\tint chargeboost = levelFrom + (toUpgrade instanceof MagesStaff ? 1 : 0);\n\t\t\tbottom = fillFields(Messages.get(this, \"charges\"),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost)),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost + 1)),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\tif (toUpgrade instanceof Ring){\n\n\t\t}\n\n\t\tColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = WIDTH/2f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\tsep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = 3*WIDTH/4f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\tif (!toUpgrade.isIdentified()){\n\t\t\tbottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\tif (!(upgrader instanceof MagicalInfusion)) {\n\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n\t\t\t\tint lossChance;\n\t\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n\t\t\t\t} else {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n\t\t\t\t}\n\n\t\t\t\tif (lossChance >= 10) {\n\t\t\t\t\tString warn;\n\t\t\t\t\tif (toUpgrade instanceof Weapon) {\n\t\t\t\t\t\tif (((Weapon) toUpgrade).enchantHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"enchant\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((Armor) toUpgrade).glyphHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"glyph\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbottom = addMessage(warn, CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((toUpgrade.cursed\n\t\t\t\t\t|| (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph()))\n\t\t\t\t\t&& toUpgrade.cursedKnown) {\n\n\t\t\t\tif (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())){\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t} else {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t}\n\n\t\t\t\tif (curseInfused) {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"curse_infusion\"), CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tbottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\tbtnUpgrade = new RedButton(Messages.get(this, \"upgrade\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tScrollOfUpgrade.upgrade(Dungeon.hero);\n\n\t\t\t\tItem upgraded = toUpgrade;\n\t\t\t\tif (upgrader instanceof ScrollOfUpgrade){\n\t\t\t\t\t((ScrollOfUpgrade) upgrader).readAnimation();\n\t\t\t\t\tupgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t\t\t\t} else if (upgrader instanceof MagicalInfusion){\n\t\t\t\t\t((MagicalInfusion) upgrader).useAnimation();\n\t\t\t\t\tupgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t}\n\n\t\t\t\tItem moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n\n\t\t\t\thide();\n\n\t\t\t\tif (moreUpgradeItem != null && toUpgrade.isIdentified()){\n\t\t\t\t\tmoreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\t\tGameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnUpgrade.setRect(0, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnUpgrade);\n\n\t\tbtnCancel = new RedButton(Messages.get(this, \"cancel\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tif (!force) {\n\t\t\t\t\tupgrader.collect();\n\t\t\t\t\thide();\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show( new WndOptions(new ItemSprite(upgrader),\n\t\t\t\t\t\t\tMessages.titleCase(upgrader.name()),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tWndUpgrade.this.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onBackPressed() {}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t\tbtnCancel.setRect(btnUpgrade.right()+1, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnCancel);\n\n\t\tbtnUpgrade.enable(Dungeon.hero.ready);\n\n\t\tbottom = (int)btnCancel.bottom();\n\n\t\tresize(WIDTH, (int)bottom);\n\t}\n```\n\n### Refactored Code:\n```java\npublic WndUpgrade(Item upgrader, Item toUpgrade, boolean force) {\n    this.force = force;\n\n    addTitle(upgrader);\n    RenderedTextBlock message = addDescription();\n\n    int levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n    int levelTo = calculateLevelTo(toUpgrade, levelFrom);\n\n    boolean curseInfused = isCurseInfused(toUpgrade);\n    if (curseInfused && toUpgrade.trueLevel() / 6 < (toUpgrade.trueLevel() + 1) / 6) {\n        levelTo++;\n    }\n\n    addItemSprites(toUpgrade, message);\n    BitmapText t1 = createLevelText(levelFrom, curseInfused);\n    BitmapText t2 = createLevelText(levelTo, curseInfused);\n    addLevelTexts(t1, t2, message);\n\n    float bottom = addItemStats(toUpgrade, levelFrom, levelTo, message);\n    addSeparator(bottom, message);\n\n    if (!toUpgrade.isIdentified()) {\n        bottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n    }\n\n    handleEnchantments(upgrader, toUpgrade, levelFrom, bottom);\n    handleWandResinBonus(toUpgrade, bottom);\n\n    addUpgradeButton(upgrader, toUpgrade, bottom);\n    addCancelButton(upgrader, bottom);\n\n    btnUpgrade.enable(Dungeon.hero.ready);\n    resize(WIDTH, (int) bottom);\n}\n\nprivate void addTitle(Item upgrader) {\n    IconTitle title = new IconTitle(new ItemSprite(upgrader), Messages.get(this, \"title\"));\n    title.setRect(0, 0, WIDTH, 0);\n    add(title);\n}\n\nprivate RenderedTextBlock addDescription() {\n    RenderedTextBlock message = PixelScene.renderTextBlock(6);\n    message.text(Messages.get(this, \"desc\"), WIDTH);\n    message.setPos(0, title.bottom() + GAP);\n    add(message);\n    return message;\n}\n\nprivate int calculateLevelTo(Item toUpgrade, int levelFrom) {\n    int levelTo = levelFrom + 1;\n    if (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0) {\n        levelTo--;\n    }\n    return levelTo;\n}\n\nprivate boolean isCurseInfused(Item toUpgrade) {\n    return (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n            || (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n            || (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n}\n\nprivate void addItemSprites(Item toUpgrade, RenderedTextBlock message) {\n    ItemSprite i1 = new ItemSprite();\n    add(i1);\n    i1.view(toUpgrade);\n    i1.x = COL_2 - i1.width() / 2f;\n    i1.y = message.bottom() + GAP + (16 - i1.height()) / 2f;\n    PixelScene.align(i1);\n    add(i1);\n\n    ItemSprite i2 = new ItemSprite();\n    add(i2);\n    i2.view(toUpgrade);\n    i2.x = COL_3 - i2.width() / 2f;\n    i2.y = i1.y;\n    PixelScene.align(i2);\n    add(i2);\n}\n\nprivate BitmapText createLevelText(int level, boolean curseInfused) {\n    BitmapText text = new BitmapText(PixelScene.pixelFont);\n    if (level > 0) {\n        text.text(\"+\" + level);\n    } else {\n        text.text(\"\");\n    }\n    text.hardlight(ItemSlot.UPGRADED);\n    if (curseInfused) {\n        text.hardlight(ItemSlot.CURSE_INFUSED);\n    }\n    return text;\n}\n\nprivate void addLevelTexts(BitmapText t1, BitmapText t2, RenderedTextBlock message) {\n    t1.measure();\n    t1.x = COL_2 + 8 - t1.width();\n    t1.y = message.bottom() + GAP + 16 - t1.baseLine();\n    add(t1);\n\n    t2.measure();\n    t2.x = COL_3 + 8 - t2.width();\n    t2.y = message.bottom() + GAP + 16 - t2.baseLine();\n    add(t2);\n}\n\nprivate float addItemStats(Item toUpgrade, int levelFrom, int levelTo, RenderedTextBlock message) {\n    float bottom = i1.y + 16 + GAP;\n    final String LINE = Messages.lang() == Languages.CHINESE ? \"~\" : \"-\";\n\n    if (toUpgrade instanceof Weapon) {\n        bottom = fillFields(Messages.get(this, \"damage\"),\n                ((Weapon) toUpgrade).min(levelFrom) + LINE + ((Weapon) toUpgrade).max(levelFrom),\n                ((Weapon) toUpgrade).min(levelTo) + LINE + ((Weapon) toUpgrade).max(levelTo),\n                bottom);\n    }\n\n    if (toUpgrade instanceof Armor) {\n        bottom = fillFields(Messages.get(this, \"blocking\"),\n                ((Armor) toUpgrade).DRMin(levelFrom) + LINE + ((Armor) toUpgrade).DRMax(levelFrom),\n                ((Armor) toUpgrade).DRMin(levelTo) + LINE + ((Armor) toUpgrade).DRMax(levelTo),\n                bottom);\n    } else if (toUpgrade instanceof RoundShield) {\n        bottom = fillFields(Messages.get(this, \"blocking\"),\n                0 + LINE + ((RoundShield) toUpgrade).DRMax(levelFrom),\n                0 + LINE + ((RoundShield) toUpgrade).DRMax(levelTo),\n                bottom);\n    } else if (toUpgrade instanceof Greatshield) {\n        bottom = fillFields(Messages.get(this, \"blocking\"),\n                0 + LINE + ((Greatshield) toUpgrade).DRMax(levelFrom),\n                0 + LINE + ((Greatshield) toUpgrade).DRMax(levelTo),\n                bottom);\n    }\n\n    if (toUpgrade instanceof Weapon) {\n        bottom = fillFields(Messages.get(this, \"weight\"),\n                Integer.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n                Integer.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n                bottom);\n    } else if (toUpgrade instanceof Armor) {\n        bottom = fillFields(Messages.get(this, \"weight\"),\n                Integer.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n                Integer.toString((((Armor) toUpgrade).STRReq(levelTo))),\n                bottom);\n    }\n\n    if (toUpgrade instanceof MissileWeapon) {\n        int uses1 = (int) Math.ceil(100f / ((MissileWeapon) toUpgrade).durabilityPerUse());\n        int uses2 = (int) Math.ceil(300f / ((MissileWeapon) toUpgrade).durabilityPerUse());\n        bottom = fillFields(Messages.get(this, \"durability\"),\n                uses1 >= 100 ? \"\u221e\" : Integer.toString(uses1),\n                uses2 >= 100 ? \"\u221e\" : Integer.toString(uses2),\n                bottom);\n    }\n\n    return bottom;\n}\n\nprivate void addSeparator(float bottom, RenderedTextBlock message) {\n    ColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n    sep.size(1, bottom - message.bottom());\n    sep.x = WIDTH / 2f;\n    sep.y = message.bottom();\n    add(sep);\n\n    sep = new ColorBlock(1, 1, 0xFF222222);\n    sep.size(1, bottom - message.bottom());\n    sep.x = 3 * WIDTH / 4f;\n    sep.y = message.bottom();\n    add(sep);\n}\n\nprivate void handleEnchantments(Item upgrader, Item toUpgrade, int levelFrom, float bottom) {\n    if (!(upgrader instanceof MagicalInfusion)) {\n        if ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n                || (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n            int lossChance = calculateLossChance(toUpgrade, levelFrom);\n            if (lossChance >= 10) {\n                String warn = getEnchantmentWarning(toUpgrade, lossChance);\n                bottom = addMessage(warn, CharSprite.WARNING, bottom);\n            }\n        }\n\n        if (toUpgrade.cursed || (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n                || (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())) {\n            if (toUpgrade.cursedKnown) {\n                if (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n                        || (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())) {\n                    bottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n                } else {\n                    bottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n                }\n            }\n        }\n    }\n}\n\nprivate int calculateLossChance(Item toUpgrade, int levelFrom) {\n    int lossChance;\n    if ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n            || (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n        lossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n    } else {\n        lossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n    }\n    return lossChance;\n}\n\nprivate String getEnchantmentWarning(Item toUpgrade, int lossChance) {\n    String warn;\n    if (toUpgrade instanceof Weapon) {\n        if (((Weapon) toUpgrade).enchantHardened) {\n            warn = Messages.get(this, \"harden\", lossChance);\n        } else {\n            warn = Messages.get(this, \"enchant\", lossChance);\n        }\n    } else {\n        if (((Armor) toUpgrade).glyphHardened) {\n            warn = Messages.get(this, \"harden\", lossChance);\n        } else {\n            warn = Messages.get(this, \"glyph\", lossChance);\n        }\n    }\n    return warn;\n}\n\nprivate void handleWandResinBonus(Item toUpgrade, float bottom) {\n    if (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0) {\n        bottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n    }\n}\n\nprivate void addUpgradeButton(Item upgrader, Item toUpgrade, float bottom) {\n    btnUpgrade = new RedButton(Messages.get(this, \"upgrade\")) {\n        @Override\n        protected void onClick() {\n            super.onClick();\n            ScrollOfUpgrade.upgrade(Dungeon.hero);\n            Item upgraded = toUpgrade;\n            if (upgrader instanceof ScrollOfUpgrade) {\n                ((ScrollOfUpgrade) upgrader).readAnimation();\n                upgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n                Sample.INSTANCE.play(Assets.Sounds.READ);\n            } else if (upgrader instanceof MagicalInfusion) {\n                ((MagicalInfusion) upgrader).useAnimation();\n                upgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n            }\n\n            Item moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n            hide();\n\n            if (moreUpgradeItem != null && toUpgrade.isIdentified()) {\n                moreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n                GameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n            }\n        }\n    };\n    btnUpgrade.setRect(0, bottom + 2 * GAP, WIDTH / 2f, 16);\n    add(btnUpgrade);\n}\n\nprivate void addCancelButton(Item upgrader, float bottom) {\n    btnCancel = new RedButton(Messages.get(this, \"cancel\")) {\n        @Override\n        protected void onClick() {\n            super.onClick();\n            if (!force) {\n                upgrader.collect();\n                hide();\n            } else {\n                GameScene.show(new WndOptions(new ItemSprite(upgrader),\n                        Messages.titleCase(upgrader.name()),\n                        Messages.get(InventoryScroll.class, \"warning\"),\n                        Messages.get(InventoryScroll.class, \"yes\"),\n                        Messages.get(InventoryScroll.class, \"no\")) {\n                    @Override\n                    protected void onSelect(int index) {\n                        if (index == 0) {\n                            WndUpgrade.this.hide();\n                        }\n                    }\n\n                    public void onBackPressed() {}\n                });\n            }\n        }\n    };\n    btnCancel.setRect(btnUpgrade.right() + 1, bottom + 2 * GAP, WIDTH / 2f, 16);\n    add(btnCancel);\n}\n```\n\n### Summary of Changes:\n1. **Modularization**: The code has been broken down into smaller, more manageable methods, each responsible for a specific task (e.g., `addTitle`, `addDescription`, `calculateLevelTo`, etc.). This improves readability and maintainability.\n2. **Reduced Duplication**: Common logic has been extracted into methods to avoid code duplication, such as the creation of level texts and handling enchantments.\n3. **Improved Clarity**: The use of descriptive method names makes it easier to understand the purpose of each section of the code at a glance.",
        "sourceCodeAfterRefactoring": "public WndUpgrade( Item upgrader, Item toUpgrade, boolean force){\n\n\t\tthis.force = force;\n\n\t\tIconTitle title = new IconTitle( new ItemSprite(upgrader), Messages.get(this, \"title\") );\n\n\t\ttitle.setRect(0, 0, WIDTH, 0);\n\t\tadd(title);\n\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock( 6 );\n\t\tmessage.text( Messages.get(this, \"desc\"), WIDTH);\n\t\tmessage.setPos(0, title.bottom()+GAP);\n\t\tadd(message);\n\n\t\t\n\n\t\tint levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n\t\tint levelTo = levelFrom + 1;\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tlevelTo--;\n\t\t}\n\n\t\tboolean curseInfused = (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n\n\t\tif (curseInfused){\n\t\t\tif (toUpgrade.trueLevel()/6 < (toUpgrade.trueLevel()+1)/6){\n\t\t\t\t\n\t\t\t\tlevelTo++;\n\t\t\t}\n\t\t}\n\n\t\t\n\n\t\tItemSprite i1 = new ItemSprite();\n\t\tadd(i1);\n\t\ti1.view(toUpgrade);\n\t\ti1.x = COL_2 - i1.width()/2f;\n\t\ti1.y = message.bottom() + GAP + (16-i1.height())/2f;\n\t\tPixelScene.align(i1);\n\t\tadd(i1);\n\n\t\tItemSprite i2 = new ItemSprite();\n\t\tadd(i2);\n\t\ti2.view(toUpgrade);\n\t\ti2.x = COL_3 - i2.width()/2f;\n\t\ti2.y = i1.y;\n\t\tPixelScene.align(i2);\n\t\tadd(i2);\n\n\t\tBitmapText t1 = new BitmapText(PixelScene.pixelFont);\n\t\tBitmapText t2 = new BitmapText(PixelScene.pixelFont);\n\t\tif (toUpgrade.isIdentified()){\n\t\t\tif (levelFrom > 0){\n\t\t\t\tt1.text(\"+\" + levelFrom);\n\t\t\t} else {\n\t\t\t\tt1.text(\"\");\n\t\t\t}\n\t\t\tt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);\n\n\t\t\tif (curseInfused){\n\t\t\t\tt1.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t\tt2.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t}\n\n\t\t} else {\n\t\t\tt1.text(\"?\");\n\t\t\tt1.hardlight(0.6f, 0.3f, 0.6f);\n\t\t\tt2.text(\"+1?\");\n\t\t\tt2.hardlight(0.6f, 0.3f, 0.6f);\n\t\t}\n\t\tt1.measure();\n\t\tt1.x = COL_2 + 8 - t1.width();\n\t\tt1.y = message.bottom() + GAP + 16 - t1.baseLine();\n\t\tadd(t1);\n\n\t\tt2.measure();\n\t\tt2.x = COL_3 + 8 - t2.width();\n\t\tt2.y = message.bottom() + GAP + 16 - t2.baseLine();\n\t\tadd(t2);\n\n\t\tfloat bottom = i1.y + 16 + GAP;\n\n\t\t\n\n\t\t\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"damage\"),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelFrom) + \"-\" + ((Weapon) toUpgrade).max(levelFrom),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelTo) + \"-\" + ((Weapon) toUpgrade).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Armor){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelFrom) + \"-\" + ((Armor) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelTo) + \"-\" + ((Armor) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof RoundShield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + \"-\" + ((RoundShield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + \"-\" + ((RoundShield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Greatshield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + \"-\" + ((Greatshield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + \"-\" + ((Greatshield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Armor) {\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\n\t\t\n\t\tif (toUpgrade instanceof MissileWeapon){\n\t\t\t\n\t\t\tint uses1 = (int)Math.ceil(100f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tint uses2 = (int)Math.ceil(300f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tbottom = fillFields(Messages.get(this, \"durability\"),\n\t\t\t\t\tuses1 >= 100 ? \"\u221e\" : Integer.toString(uses1),\n\t\t\t\t\tuses2 >= 100 ? \"\u221e\" : Integer.toString(uses2),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tItem wand = toUpgrade;\n\t\tif (toUpgrade instanceof MagesStaff && ((MagesStaff) toUpgrade).wandClass() != null){\n\t\t\twand = Reflection.newInstance(((MagesStaff) toUpgrade).wandClass());\n\t\t}\n\n\t\t\n\t\tif (wand instanceof Wand){\n\t\t\tif (((Wand) wand).upgradeStat1(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_1\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat1(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat1(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t\tif (((Wand) wand).upgradeStat2(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_2\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat2(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat2(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t\tif (((Wand) wand).upgradeStat3(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_3\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat3(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat3(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (wand instanceof Wand){\n\t\t\tint chargeboost = levelFrom + (toUpgrade instanceof MagesStaff ? 1 : 0);\n\t\t\tbottom = fillFields(Messages.get(this, \"charges\"),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost)),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost + 1)),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Ring){\n\n\t\t}\n\n\t\t\n\t\tColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = WIDTH/2f;\n\t\tsep.y = message.bottom() + GAP;\n\t\tadd(sep);\n\n\t\tsep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = 3*WIDTH/4f;\n\t\tsep.y = message.bottom() + GAP;\n\t\tadd(sep);\n\n\t\t\n\n\t\t\n\t\tif (!toUpgrade.isIdentified()){\n\t\t\tbottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t\n\t\tif (!(upgrader instanceof MagicalInfusion)) {\n\n\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n\t\t\t\tint lossChance;\n\t\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n\t\t\t\t} else {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n\t\t\t\t}\n\n\t\t\t\tif (lossChance >= 10) {\n\t\t\t\t\tString warn;\n\t\t\t\t\tif (toUpgrade instanceof Weapon) {\n\t\t\t\t\t\tif (((Weapon) toUpgrade).enchantHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"enchant\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((Armor) toUpgrade).glyphHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"glyph\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbottom = addMessage(warn, CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((toUpgrade.cursed\n\t\t\t\t\t|| (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph()))\n\t\t\t\t\t&& toUpgrade.cursedKnown) {\n\n\t\t\t\tif (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())){\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t} else {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t}\n\n\t\t\t\tif (curseInfused) {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"curse_infusion\"), CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tbottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t\n\n\t\tbtnUpgrade = new RedButton(Messages.get(this, \"upgrade\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tScrollOfUpgrade.upgrade(Dungeon.hero);\n\n\t\t\t\tItem upgraded = toUpgrade;\n\t\t\t\tif (upgrader instanceof ScrollOfUpgrade){\n\t\t\t\t\t((ScrollOfUpgrade) upgrader).readAnimation();\n\t\t\t\t\tupgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t\t\t\t} else if (upgrader instanceof MagicalInfusion){\n\t\t\t\t\t((MagicalInfusion) upgrader).useAnimation();\n\t\t\t\t\tupgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t}\n\n\t\t\t\tItem moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n\n\t\t\t\thide();\n\n\t\t\t\tif (moreUpgradeItem != null && toUpgrade.isIdentified()){\n\t\t\t\t\tmoreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\t\tGameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnUpgrade.setRect(0, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnUpgrade);\n\n\t\tbtnCancel = new RedButton(Messages.get(this, \"cancel\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tif (!force) {\n\t\t\t\t\tupgrader.collect();\n\t\t\t\t\thide();\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show( new WndOptions(new ItemSprite(upgrader),\n\t\t\t\t\t\t\tMessages.titleCase(upgrader.name()),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tWndUpgrade.this.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onBackPressed() {}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t\tbtnCancel.setRect(btnUpgrade.right()+1, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnCancel);\n\n\t\tbtnUpgrade.enable(Dungeon.hero.ready);\n\n\t\tbottom = (int)btnCancel.bottom();\n\n\t\tresize(WIDTH, (int)bottom);\n\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\nt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);",
        "uniqueId": "be3de2d883d043596bb274ac7796e30bca891583_71_405_128_131_68_392",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nAfter Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}\nExample 2:\n Before Refactoring:\nprotected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}\n\nAfter Refactoring:\nprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\nExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\nExample 3:\n Before Refactoring:\nTestTreeCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"ok.gif\");\n\t    \tfOkIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"failure.gif\");\n\t    \tfFailureIcon= new ImageIcon(url);\n\t\t}\n\nAfter Refactoring:\nTestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}\n\nExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} \n\t\t\treturn new ImageIcon(url);\n\t\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "40e7a4093fce70d72587f903be21237da2d02f8c",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40e7a4093fce70d72587f903be21237da2d02f8c",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 6+2*buffedLvl();             \n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic int defenseFactor(Char owner) {\n\t\treturn 6 + 2 * buffedLvl();             \n\t}\n```\n\n### Refactored Code:\n```java\n@Override\n\tpublic int defenseFactor(Char owner) {\n\t\treturn calculateDefenseFactor(buffedLvl());\n\t}\n\nprivate int calculateDefenseFactor(int buffedLevel) {\n\t\treturn 6 + 2 * buffedLevel;\n\t}\n```\n\nIn this refactoring, I extracted the calculation of the defense factor into a separate method `calculateDefenseFactor`. This improves readability by clearly separating the logic of calculating the defense factor from the method that defines the behavior of the `defenseFactor` method.",
        "sourceCodeAfterRefactoring": "public int DRMax(int lvl){\n\t\treturn 6 + 2*lvl;\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(int lvl){\n\t\treturn 6 + 2*lvl;\n\t}",
        "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_43_46_53_55_53_55",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 2:\n Before Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nAfter Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}\nExample 3:\n Before Refactoring:\n@Override\n\tprotected void runUnprotected() {\n\t\ttry {\n\t\t\texecuteMethodBody();\n\t\t\tif (expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + expectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + expectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}\n\nAfter Refactoring:\npublic void runTest() {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprotected void runTestMethod() {\n\t\ttry {\n\t\t\tfMethod.invoke(fTest);\n\t\t\tif (fTestMethod.expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + fTestMethod.getExpectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!fTestMethod.expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (fTestMethod.isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + fTestMethod.getExpectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "40e7a4093fce70d72587f903be21237da2d02f8c",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40e7a4093fce70d72587f903be21237da2d02f8c",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 6+2*buffedLvl();             \n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic int defenseFactor(Char owner) {\n\t\treturn 6 + 2 * buffedLvl();             \n\t}\n```\n\n### Refactored Code:\n```java\n@Override\n\tpublic int defenseFactor(Char owner) {\n\t\treturn calculateDefenseFactor(buffedLvl());\n\t}\n\nprivate int calculateDefenseFactor(int buffedLevel) {\n\t\treturn 6 + 2 * buffedLevel;\n\t}\n```\n\nIn this refactoring, I extracted the calculation of the defense factor into a separate method `calculateDefenseFactor`. This improves readability by clearly separating the logic of calculating the defense factor from the method that defines the behavior of the `defenseFactor` method.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn DRMax();\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(){\n\t\treturn DRMax(buffedLvl());\n\t}",
        "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_43_46_48_50_43_46",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 2:\n Before Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nAfter Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}\nExample 3:\n Before Refactoring:\n@Override\n\tprotected void runUnprotected() {\n\t\ttry {\n\t\t\texecuteMethodBody();\n\t\t\tif (expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + expectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + expectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}\n\nAfter Refactoring:\npublic void runTest() {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprotected void runTestMethod() {\n\t\ttry {\n\t\t\tfMethod.invoke(fTest);\n\t\t\tif (fTestMethod.expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + fTestMethod.getExpectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!fTestMethod.expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (fTestMethod.isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + fTestMethod.getExpectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "40e7a4093fce70d72587f903be21237da2d02f8c",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40e7a4093fce70d72587f903be21237da2d02f8c",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 4+buffedLvl();               \n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\npublic int defenseFactor(Char owner) {\n    return 4 + buffedLvl();               \n}\n```\n\n### Refactored Code:\n```java\n@Override\npublic int defenseFactor(Char owner) {\n    return calculateDefenseFactor();\n}\n\nprivate int calculateDefenseFactor() {\n    return 4 + buffedLvl();\n}\n```\n\nIn this refactoring, I extracted the calculation of the defense factor into a separate method (`calculateDefenseFactor`). This improves readability by clearly separating the logic of calculating the defense factor from the method that is responsible for it.",
        "sourceCodeAfterRefactoring": "public int DRMax(int lvl){\n\t\treturn 4 + lvl;\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(int lvl){\n\t\treturn 4 + lvl;\n\t}",
        "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_52_55_62_64_62_64",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 2:\n Before Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 3:\n Before Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nAfter Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "40e7a4093fce70d72587f903be21237da2d02f8c",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40e7a4093fce70d72587f903be21237da2d02f8c",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 4+buffedLvl();               \n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\npublic int defenseFactor(Char owner) {\n    return 4 + buffedLvl();               \n}\n```\n\n### Refactored Code:\n```java\n@Override\npublic int defenseFactor(Char owner) {\n    return calculateDefenseFactor();\n}\n\nprivate int calculateDefenseFactor() {\n    return 4 + buffedLvl();\n}\n```\n\nIn this refactoring, I extracted the calculation of the defense factor into a separate method (`calculateDefenseFactor`). This improves readability by clearly separating the logic of calculating the defense factor from the method that overrides the original functionality.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn DRMax();\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(){\n\t\treturn DRMax(buffedLvl());\n\t}",
        "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_52_55_57_59_52_55",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 2:\n Before Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 3:\n Before Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nAfter Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "f0542ebf1e3b9f654c66a6303e4849b592811355",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f0542ebf1e3b9f654c66a6303e4849b592811355",
        "sourceCodeBeforeRefactoring": "public static void countEncounter(Class<?> cls){\n\t\tif (classConversions.containsKey(cls)){\n\t\t\tcls = classConversions.get(cls);\n\t\t}\n\t\tfor (Bestiary cat : values()) {\n\t\t\tif (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE){\n\t\t\t\tcat.encounterCount.put(cls, cat.encounterCount.get(cls)+1);\n\t\t\t\tJournal.saveNeeded = true;\n\t\t\t}\n\t\t}\n\t\tBadges.validateCatalogBadges();\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static void countEncounter(Class<?> cls){\n    if (classConversions.containsKey(cls)){\n        cls = classConversions.get(cls);\n    }\n    for (Bestiary cat : values()) {\n        if (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE){\n            cat.encounterCount.put(cls, cat.encounterCount.get(cls)+1);\n            Journal.saveNeeded = true;\n        }\n    }\n    Badges.validateCatalogBadges();\n}\n```\n\n### Refactored Code:\n```java\npublic static void countEncounter(Class<?> cls) {\n    cls = getConvertedClass(cls);\n    for (Bestiary cat : values()) {\n        incrementEncounterCount(cat, cls);\n    }\n    Badges.validateCatalogBadges();\n}\n\nprivate static Class<?> getConvertedClass(Class<?> cls) {\n    return classConversions.getOrDefault(cls, cls);\n}\n\nprivate static void incrementEncounterCount(Bestiary cat, Class<?> cls) {\n    if (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE) {\n        cat.encounterCount.put(cls, cat.encounterCount.get(cls) + 1);\n        Journal.saveNeeded = true;\n    }\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Method for Class Conversion**: The logic to convert the class using `classConversions` was extracted into a separate method `getConvertedClass`. This improves readability by clearly defining the purpose of that logic.\n  \n2. **Extracted Method for Encounter Count Increment**: The logic to increment the encounter count was extracted into a separate method `incrementEncounterCount`. This encapsulates the logic related to updating the encounter count and makes the main method cleaner.\n\n3. **Use of `getOrDefault`**: The `getConvertedClass` method uses `getOrDefault` to simplify the retrieval of the converted class, reducing the need for an explicit check with `containsKey`.\n\nThese changes enhance the readability and maintainability of the code without altering its functionality.",
        "sourceCodeAfterRefactoring": "public static void countEncounter(Class<?> cls){\n\t\tcountEncounters(cls, 1);\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static void countEncounters(Class<?> cls, int encounters){\n\t\tif (classConversions.containsKey(cls)){\n\t\t\tcls = classConversions.get(cls);\n\t\t}\n\t\tfor (Bestiary cat : values()) {\n\t\t\tif (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE){\n\t\t\t\tcat.encounterCount.put(cls, cat.encounterCount.get(cls)+encounters);\n\t\t\t\tif (cat.encounterCount.get(cls) < -1_000_000_000){ \n\t\t\t\t\tcat.encounterCount.put(cls, Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t\tJournal.saveNeeded = true;\n\t\t\t}\n\t\t}\n\t}",
        "uniqueId": "f0542ebf1e3b9f654c66a6303e4849b592811355_307_318_311_324_307_309",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@Override\n\t\tprotected void validateFields(List<Throwable> errors) {\n\t\t\tsuper.validateFields(errors);\n\t\t\tList<FrameworkField> annotatedFieldsByParameter = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (annotatedFieldsByParameter.size() > 0) {\n\t\t\t\tint[] usedIndices = new int[annotatedFieldsByParameter.size()];\n\t\t\t\tfor (FrameworkField f : annotatedFieldsByParameter) {\n\t\t\t\t\tint index = f.getField().getAnnotation(Parameter.class).value();\n\t\t\t\t\tif (index < 0 || index > annotatedFieldsByParameter.size()-1) {\n\t\t\t\t\t\terrors.add(\n\t\t\t\t\t\t\tnew Exception(\"Invalid @Parameter value: \"+index+\". @Parameter fields counted: \"+\n\t\t\t\t\t\t\t\tannotatedFieldsByParameter.size()+\". Please use an index between 0 and \"+\n\t\t\t\t\t\t\t\t(annotatedFieldsByParameter.size()-1)+\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusedIndices[index]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int index = 0 ; index < usedIndices.length ; index++) {\n\t\t\t\t\tint numberOfUse = usedIndices[index];\n\t\t\t\t\tif (numberOfUse == 0) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is never used.\"));\n\t\t\t\t\t} else if (numberOfUse > 1) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is used more than once (\"+numberOfUse+\").\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nAfter Refactoring:\n@Override\n\t\tprotected void validateFields(List<Throwable> errors) {\n\t\t\tsuper.validateFields(errors);\n\t\t\tif (fieldsAreAnnotated()) {\n                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n\t\t\t\tint[] usedIndices = new int[annotatedFieldsByParameter.size()];\n\t\t\t\tfor (FrameworkField f : annotatedFieldsByParameter) {\n\t\t\t\t\tint index = f.getField().getAnnotation(Parameter.class).value();\n\t\t\t\t\tif (index < 0 || index > annotatedFieldsByParameter.size()-1) {\n\t\t\t\t\t\terrors.add(\n\t\t\t\t\t\t\tnew Exception(\"Invalid @Parameter value: \"+index+\". @Parameter fields counted: \"+\n\t\t\t\t\t\t\t\tannotatedFieldsByParameter.size()+\". Please use an index between 0 and \"+\n\t\t\t\t\t\t\t\t(annotatedFieldsByParameter.size()-1)+\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusedIndices[index]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int index = 0 ; index < usedIndices.length ; index++) {\n\t\t\t\t\tint numberOfUse = usedIndices[index];\n\t\t\t\t\tif (numberOfUse == 0) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is never used.\"));\n\t\t\t\t\t} else if (numberOfUse > 1) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is used more than once (\"+numberOfUse+\").\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nExtractedCodeFragments:\nprivate List<FrameworkField> getAnnotatedFieldsByParameter() {\n        return getTestClass().getAnnotatedFields(Parameter.class);\n    }\nExample 2:\n Before Refactoring:\n@Override\n    protected void validateFields(List<Throwable> errors) {\n        super.validateFields(errors);\n        if (fieldsAreAnnotated()) {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                int index = each.getField().getAnnotation(Parameter.class)\n                        .value();\n                if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                    errors.add(new Exception(\"Invalid @Parameter value: \"\n                            + index + \". @Parameter fields counted: \"\n                            + annotatedFieldsByParameter.size()\n                            + \". Please use an index between 0 and \"\n                            + (annotatedFieldsByParameter.size() - 1) + \".\"));\n                } else {\n                    usedIndices[index]++;\n                }\n            }\n            for (int index = 0; index < usedIndices.length; index++) {\n                int numberOfUse = usedIndices[index];\n                if (numberOfUse == 0) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is never used.\"));\n                } else if (numberOfUse > 1) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is used more than once (\" + numberOfUse + \").\"));\n                }\n            }\n        }\n    }\n\nAfter Refactoring:\n@Override\n    protected void validateFields(List<Throwable> errors) {\n        super.validateFields(errors);\n        if (getInjectionType() == InjectionType.FIELD) {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                int index = each.getField().getAnnotation(Parameter.class)\n                        .value();\n                if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                    errors.add(new Exception(\"Invalid @Parameter value: \"\n                            + index + \". @Parameter fields counted: \"\n                            + annotatedFieldsByParameter.size()\n                            + \". Please use an index between 0 and \"\n                            + (annotatedFieldsByParameter.size() - 1) + \".\"));\n                } else {\n                    usedIndices[index]++;\n                }\n            }\n            for (int index = 0; index < usedIndices.length; index++) {\n                int numberOfUse = usedIndices[index];\n                if (numberOfUse == 0) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is never used.\"));\n                } else if (numberOfUse > 1) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is used more than once (\" + numberOfUse + \").\"));\n                }\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate InjectionType getInjectionType() {\n        if (fieldsAreAnnotated()) {\n            return InjectionType.FIELD;\n        } else {\n            return InjectionType.CONSTRUCTOR;\n        }\n    }\nExample 3:\n Before Refactoring:\nprivate void validateTestMethods(Class<? extends Annotation> annotation,\n\t\t\tboolean isStatic) {\n\t\tList<Method> methods= fIntrospector.getTestMethods(annotation);\n\t\tfor (Method each : methods) {\n\t\t\tif (Modifier.isStatic(each.getModifiers()) != isStatic) {\n\t\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ state + \" be static\"));\n\t\t\t}\n\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (!Modifier.isPublic(each.getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (each.getReturnType() != Void.TYPE)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be void\"));\n\t\t\tif (each.getParameterTypes().length != 0)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should have no parameters\"));\n\t\t}\n\t}\n\nAfter Refactoring:\nprivate void validateTestMethods(Class<? extends Annotation> annotation,\n\t\t\tboolean shouldBeStatic) {\n\t\tList<Method> methods= fIntrospector.getTestMethods(annotation);\n\t\tfor (Method each : methods) {\n\t\t\tif (shouldBeStatic && !isStatic(each))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ \"should be static\"));\n\t\t\tif (!shouldBeStatic && runsAsStatic(each))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ \"should not be static\"));\n\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (!Modifier.isPublic(each.getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (each.getReturnType() != Void.TYPE)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be void\"));\n\t\t\tif (effectiveParameterCount(each, shouldBeStatic) != 0)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should have no parameters\"));\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate boolean isStatic(Method method) {\n\t\treturn Modifier.isStatic(method.getModifiers());\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "2763cf42ca71fce0e4e942721d9db6509306daf3",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2763cf42ca71fce0e4e942721d9db6509306daf3",
        "sourceCodeBeforeRefactoring": "public static void add_v2_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v2.3.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Slightly improved the layout of shop rooms when many items are present\\n\\n\" +\n\t\t\t\t\"_-_ Updated a link in the game's credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.1:_\\n\" +\n\t\t\t\t\"_-_ Tengu being able to set himself on fire, oops =S\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Various minor textual errors\\n\" +\n\t\t\t\t\"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n\t\t\t\t\"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n\t\t\t\t\"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n\t\tchanges = new ChangeInfo(\"v2.3.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n\t\t\t\t\"_-_ Improved vibration on modern iOS devices\\n\" +\n\t\t\t\t\"_-_ Improved changing audio device behavior\\n\" +\n\t\t\t\t\"_-_ Misc. stability & compatibility improvements\\n\\n\" +\n\t\t\t\t\"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n\t\t\t\t\"_-_ Tengu's fire wall attack now ignites items\\n\\n\" +\n\t\t\t\t\"_-_ Improved music transitions in main menu when game was just won\\n\\n\" +\n\t\t\t\t\"_-_ Added support for controller vibration\\n\" +\n\t\t\t\t\"_-_ Added a vibration toggle in the settings\\n\\n\" +\n\t\t\t\t\"_-_ Updated translators and translator credits\\n\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported iOS version to 11, from 9\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.0:_\\n\" +\n\t\t\t\t\"Nothing! v2.3.0 is pretty stable. =)\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n\t\t\t\t\"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n\t\t\t\t\"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n\t\t\t\t\"_-_ Incorrect death messages when player is killed by wards\\n\" +\n\t\t\t\t\"_-_ Amoked allies not being affected by aggression debuff\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released January 18th, 2024\\n\" +\n\t\t\t\t\"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n\t\t\t\t\"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n\t\t\t\t\"More Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n\t\t\t\t\"_A second variant has been added to the caves quest!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n\t\t\t\t\"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n\t\t\t\t\"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n\t\t\t\t\"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n\t\t\t\t\"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n\t\t\t\t\"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n\t\t\t\t\"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n\t\t\t\t\"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n\t\t\t\t\"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n\t\t\t\t\"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n\t\t\t\t\"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n\t\t\t\t\"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Allies:_\\n\" +\n\t\t\t\t\"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n\t\t\t\t\"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n\t\t\t\t\"_-_ Spirit hawk now interrupts the hero when it expires\",\n\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n\t\t\t\t\"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n\t\t\t\t\"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n\t\t\t\t\"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n\t\t\t\t\"_-_ Added support for themed icons on Android 13+\\n\" +\n\t\t\t\t\"_-_ Removed support for saves prior to v1.4.3\\n\" +\n\t\t\t\t\"_-_ Added developer commentary for v1.2.0\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n\t\t\t\t\"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n\t\t\t\t\"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n\t\t\t\t\"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n\t\t\t\t\"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Quests:_\\n\" +\n\t\t\t\t\"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n\t\t\t\t\"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n\t\t\t\t\"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n\t\t\t\t\"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n\t\t\t\t\"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n\t\t\t\t\"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n\t\t\t\t\"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n\t\t\t\t\"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n\t\t\t\t\"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n\t\t\t\t\"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n\t\t\t\t\"_-_ Rare errors in DM-201 target selection\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Rotberry seed being deleted in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n\t\t\t\t\"_-_ Foresight effects not triggering after level transition\\n\" +\n\t\t\t\t\"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n\t\t\t\t\"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n\t\t\t\t\"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n\t\t\t\t\"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n\t\t\t\t\"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n\t\t\t\t\"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n\t\t\t\t\"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n\t\t\t\t\"_-_ Rare quickslot errors when bags which already contain items are collected\",\n\n\t\t\t\t\"_Hero & Allies:_\\n\" +\n\t\t\t\t\"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n\t\t\t\t\"_-_ Sneak ability working while Duelist is rooted\\n\" +\n\t\t\t\t\"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n\t\t\t\t\"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n\t\t\t\t\"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n\t\t\t\t\"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n\t\t\t\t\"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n\t\t\t\t\"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n\t\t\t\t\"_-_ Ally warp working on corrupted DM-201s\\n\" +\n\t\t\t\t\"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc.:_\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Tutorial becoming stuck in rare cases\\n\" +\n\t\t\t\t\"_-_ Beta updates setting not working as intended\\n\" +\n\t\t\t\t\"_-_ Music fading not working in rare cases\\n\" +\n\t\t\t\t\"_-_ Scrolling pane in journal window freezing in rare cases\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n\t\t\t\t\"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic static void add_v2_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v2.3.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Slightly improved the layout of shop rooms when many items are present\\n\\n\" +\n\t\t\t\t\"_-_ Updated a link in the game's credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.1:_\\n\" +\n\t\t\t\t\"_-_ Tengu being able to set himself on fire, oops =S\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Various minor textual errors\\n\" +\n\t\t\t\t\"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n\t\t\t\t\"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n\t\t\t\t\"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n\t\tchanges = new ChangeInfo(\"v2.3.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n\t\t\t\t\"_-_ Improved vibration on modern iOS devices\\n\" +\n\t\t\t\t\"_-_ Improved changing audio device behavior\\n\" +\n\t\t\t\t\"_-_ Misc. stability & compatibility improvements\\n\\n\" +\n\t\t\t\t\"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n\t\t\t\t\"_-_ Tengu's fire wall attack now ignites items\\n\\n\" +\n\t\t\t\t\"_-_ Improved music transitions in main menu when game was just won\\n\\n\" +\n\t\t\t\t\"_-_ Added support for controller vibration\\n\" +\n\t\t\t\t\"_-_ Added a vibration toggle in the settings\\n\\n\" +\n\t\t\t\t\"_-_ Updated translators and translator credits\\n\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported iOS version to 11, from 9\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.0:_\\n\" +\n\t\t\t\t\"Nothing! v2.3.0 is pretty stable. =)\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n\t\t\t\t\"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n\t\t\t\t\"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n\t\t\t\t\"_-_ Incorrect death messages when player is killed by wards\\n\" +\n\t\t\t\t\"_-_ Amoked allies not being affected by aggression debuff\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released January 18th, 2024\\n\" +\n\t\t\t\t\"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n\t\t\t\t\"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n\t\t\t\t\"More Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n\t\t\t\t\"_A second variant has been added to the caves quest!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n\t\t\t\t\"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n\t\t\t\t\"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n\t\t\t\t\"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n\t\t\t\t\"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n\t\t\t\t\"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n\t\t\t\t\"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n\t\t\t\t\"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n\t\t\t\t\"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n\t\t\t\t\"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n\t\t\t\t\"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n\t\t\t\t\"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Allies:_\\n\" +\n\t\t\t\t\"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n\t\t\t\t\"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n\t\t\t\t\"_-_ Spirit hawk now interrupts the hero when it expires\",\n\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n\t\t\t\t\"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n\t\t\t\t\"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n\t\t\t\t\"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n\t\t\t\t\"_-_ Added support for themed icons on Android 13+\\n\" +\n\t\t\t\t\"_-_ Removed support for saves prior to v1.4.3\\n\" +\n\t\t\t\t\"_-_ Added developer commentary for v1.2.0\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n\t\t\t\t\"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n\t\t\t\t\"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n\t\t\t\t\"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n\t\t\t\t\"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Quests:_\\n\" +\n\t\t\t\t\"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n\t\t\t\t\"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n\t\t\t\t\"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n\t\t\t\t\"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n\t\t\t\t\"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n\t\t\t\t\"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n\t\t\t\t\"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n\t\t\t\t\"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n\t\t\t\t\"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n\t\t\t\t\"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n\t\t\t\t\"_-_ Rare errors in DM-201 target selection\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Rotberry seed being deleted in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n\t\t\t\t\"_-_ Foresight effects not triggering after level transition\\n\" +\n\t\t\t\t\"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n\t\t\t\t\"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n\t\t\t\t\"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n\t\t\t\t\"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n\t\t\t\t\"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n\t\t\t\t\"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n\t\t\t\t\"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n\t\t\t\t\"_-_ Rare quickslot errors when bags which already contain items are collected\",\n\n\t\t\t\t\"_Hero & Allies:_\\n\" +\n\t\t\t\t\"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n\t\t\t\t\"_-_ Sneak ability working while Duelist is rooted\\n\" +\n\t\t\t\t\"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n\t\t\t\t\"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n\t\t\t\t\"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n\t\t\t\t\"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n\t\t\t\t\"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n\t\t\t\t\"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n\t\t\t\t\"_-_ Ally warp working on corrupted DM-201s\\n\" +\n\t\t\t\t\"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc.:_\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Tutorial becoming stuck in rare cases\\n\" +\n\t\t\t\t\"_-_ Beta updates setting not working as intended\\n\" +\n\t\t\t\t\"_-_ Music fading not working in rare cases\\n\" +\n\t\t\t\t\"_-_ Scrolling pane in journal window freezing in rare cases\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n\t\t\t\t\"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n}\n```\n\n### Refactored Code:\n```java\npublic static void add_v2_3_Changes(ArrayList<ChangeInfo> changeInfos) {\n    addChangeInfo(changeInfos, \"v2.3\", true, \"\");\n    addChangeInfo(changeInfos, \"v2.3.2\", false, null, \n        new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n            \"_-_ Slightly improved the layout of shop rooms when many items are present\\n\\n\" +\n            \"_-_ Updated a link in the game's credits\"),\n        new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n            \"Fixed the following bugs:\\n\" +\n            \"_Caused by v2.3.1:_\\n\" +\n            \"_-_ Tengu being able to set himself on fire, oops =S\\n\\n\" +\n            \"_Existed prior to v2.3.0:_\\n\" +\n            \"_-_ Various minor textual errors\\n\" +\n            \"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n            \"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n            \"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n    addChangeInfo(changeInfos, \"v2.3.1\", false, null, \n        new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n            \"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n            \"_-_ Improved vibration on modern iOS devices\\n\" +\n            \"_-_ Improved changing audio device behavior\\n\" +\n            \"_-_ Misc. stability & compatibility improvements\\n\\n\" +\n            \"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n            \"_-_ Tengu's fire wall attack now ignites items\\n\\n\" +\n            \"_-_ Improved music transitions in main menu when game was just won\\n\\n\" +\n            \"_-_ Added support for controller vibration\\n\" +\n            \"_-_ Added a vibration toggle in the settings\\n\\n\" +\n            \"_-_ Updated translators and translator credits\\n\\n\" +\n            \"_-_ Increased the minimum supported iOS version to 11, from 9\"),\n        new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n            \"Fixed the following bugs:\\n\" +\n            \"_Caused by v2.3.0:_\\n\" +\n            \"Nothing! v2.3.0 is pretty stable. =)\\n\\n\" +\n            \"_Existed prior to v2.3.0:_\\n\" +\n            \"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n            \"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n            \"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n            \"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n            \"_-_ Incorrect death messages when player is killed by wards\\n\" +\n            \"_-_ Amoked allies not being affected by aggression debuff\"));\n\n    addChangeInfo(changeInfos, Messages.get(ChangesScene.class, \"new\"), false, null, \n        new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n            \"_-_ Released January 18th, 2024\\n\" +\n            \"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n            \"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n            \"More Dev commentary will be added here in the future.\"),\n        new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n            \"_A second variant has been added to the caves quest!_\\n\" +\n            \"\\n\" +\n            \"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n            \"\\n\" +\n            \"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"),\n        new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n            \"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n            \"\\n\" +\n            \"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n            \"\\n\" +\n            \"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n            \"\\n\" +\n            \"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"),\n        new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n            \"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n            \"\\n\" +\n            \"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n            \"\\n\" +\n            \"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n    addChangeInfo(changeInfos, Messages.get(ChangesScene.class, \"changes\"), false, null, \n        new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n            \"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n            \"\\n\" +\n            \"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n            \"\\n\" +\n            \"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n    addChangeInfo(changeInfos, Messages.get(ChangesScene.class, \"misc\"), false, null, \n        new ChangeButton(Icons.get(Icons.PREFS), \"Highlights\",\n            \"_Highlights:_\\n\" +\n            \"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n            \"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n            \"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n            \"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n            \"\\n\" +\n            \"_Enemies:_\\n\" +\n            \"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n            \"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n            \"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n            \"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n            \"_Items:_\\n\" +\n            \"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n            \"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n            \"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n            \"\\n\" +\n            \"_Allies:_\\n\" +\n            \"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n            \"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n            \"_-_ Spirit hawk now interrupts the hero when it expires\",\n            \"_Misc:_\\n\" +\n            \"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n            \"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n            \"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n            \"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n            \"_-_ Added support for themed icons on Android 13+\\n\" +\n            \"_-_ Removed support for saves prior to v1.4.3\\n\" +\n            \"_-_ Added developer commentary for v1.2.0\"));\n\n    addChangeInfo(changeInfos, Messages.get(ChangesScene.class, \"bugfixes\"), false, null, \n        new ChangeButton(Icons.get(Icons.BUFFS), \"Fixed Bugs\",\n            \"Fixed the following bugs:\\n\" +\n            \"_Highlights:_\\n\" +\n            \"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n            \"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n            \"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n            \"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n            \"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n            \"\\n\" +\n            \"_Quests:_\\n\" +\n            \"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n            \"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n            \"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n            \"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n            \"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n            \"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n            \"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n            \"_Enemies:_\\n\" +\n            \"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n            \"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n            \"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n            \"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n            \"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n            \"_-_ Rare errors in DM-201 target selection\",\n            \"_Items:_\\n\" +\n            \"_-_ Rotberry seed being deleted in rare cases\\n\" +\n            \"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n            \"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n            \"_-_ Foresight effects not triggering after level transition\\n\" +\n            \"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n            \"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n            \"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n            \"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n            \"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n            \"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n            \"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n            \"_-_ Rare quickslot errors when bags which already contain items are collected\",\n            \"_Hero & Allies:_\\n\" +\n            \"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n            \"_-_ Sneak ability working while Duelist is rooted\\n\" +\n            \"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n            \"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n            \"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n            \"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n            \"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n            \"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n            \"_-_ Ally warp working on corrupted DM-201s\\n\" +\n            \"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n            \"\\n\" +\n            \"_Misc.:_\\n\" +\n            \"_-_ Various rare crash and freeze bugs\\n\" +\n            \"_-_ Various minor visual and textual errors\\n\" +\n            \"_-_ Tutorial becoming stuck in rare cases\\n\" +\n            \"_-_ Beta updates setting not working as intended\\n\" +\n            \"_-_ Music fading not working in rare cases\\n\" +\n            \"_-_ Scrolling pane in journal window freezing in rare cases\"));\n\n    addChangeInfo(changeInfos, Messages.get(ChangesScene.class, \"buffs\"), false, null, \n        new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n            \"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n            \"\\n\" +\n            \"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n            \"\\n\" +\n            \"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n}\n\nprivate static void addChangeInfo(ArrayList<ChangeInfo> changeInfos, String version, boolean isNew, String description, ChangeButton... buttons) {\n    ChangeInfo changes = new ChangeInfo(version, isNew, description);\n    changes.hardlight(Window.TITLE_COLOR);\n    changeInfos.add(changes);\n    for (ChangeButton button : buttons) {\n        changes.addButton(button);\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Method**: Created a helper method `addChangeInfo` to reduce code duplication when adding `ChangeInfo` objects and their buttons.\n2. **Improved Readability**: The refactored code is more concise and easier to read, as it reduces the number of lines and organizes the button additions in a loop.\n3. **Consistent Formatting**: The formatting of the code is more consistent, making it easier to follow the logic.",
        "sourceCodeAfterRefactoring": "public static void add_v2_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released January 18th, 2024\\n\" +\n\t\t\t\t\"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n\t\t\t\t\"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n\t\t\t\t\"More Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n\t\t\t\t\"_A second variant has been added to the caves quest!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n\t\t\t\t\"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n\t\t\t\t\"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n\t\t\t\t\"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n\t\t\t\t\"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n\t\t\t\t\"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n\t\t\t\t\"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n\t\t\t\t\"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n\t\t\t\t\"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n\t\t\t\t\"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n\t\t\t\t\"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n\t\t\t\t\"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Allies:_\\n\" +\n\t\t\t\t\"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n\t\t\t\t\"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n\t\t\t\t\"_-_ Spirit hawk now interrupts the hero when it expires\",\n\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n\t\t\t\t\"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n\t\t\t\t\"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n\t\t\t\t\"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n\t\t\t\t\"_-_ Added support for themed icons on Android 13+\\n\" +\n\t\t\t\t\"_-_ Removed support for saves prior to v1.4.3\\n\" +\n\t\t\t\t\"_-_ Added developer commentary for v1.2.0\",\n\n\t\t\t\t\"_v2.3.1_\\n\" +\n\t\t\t\t\"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n\t\t\t\t\"_-_ Improved vibration on modern iOS devices\\n\" +\n\t\t\t\t\"_-_ Improved changing audio device behavior\\n\" +\n\t\t\t\t\"_-_ Misc. stability & compatibility improvements\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n\t\t\t\t\"_-_ Tengu's fire wall attack now ignites items\\n\" +\n\t\t\t\t\"_-_ Improved music transitions in main menu when game was just won\\n\" +\n\t\t\t\t\"_-_ Added support for controller vibration\\n\" +\n\t\t\t\t\"_-_ Added a vibration toggle in the settings\\n\" +\n\t\t\t\t\"_-_ Updated translators and translator credits\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported iOS version to 11, from 9\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_v2.3.2_\\n\" +\n\t\t\t\t\"_-_ Slightly improved the layout of shop rooms when many items are present\\n\" +\n\t\t\t\t\"_-_ Updated a link in the game's credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n\t\t\t\t\"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n\t\t\t\t\"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n\t\t\t\t\"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n\t\t\t\t\"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Quests:_\\n\" +\n\t\t\t\t\"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n\t\t\t\t\"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n\t\t\t\t\"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n\t\t\t\t\"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n\t\t\t\t\"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n\t\t\t\t\"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n\t\t\t\t\"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n\t\t\t\t\"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n\t\t\t\t\"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n\t\t\t\t\"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n\t\t\t\t\"_-_ Rare errors in DM-201 target selection\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Rotberry seed being deleted in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n\t\t\t\t\"_-_ Foresight effects not triggering after level transition\\n\" +\n\t\t\t\t\"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n\t\t\t\t\"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n\t\t\t\t\"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n\t\t\t\t\"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n\t\t\t\t\"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n\t\t\t\t\"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n\t\t\t\t\"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n\t\t\t\t\"_-_ Rare quickslot errors when bags which already contain items are collected\",\n\n\t\t\t\t\"_Hero & Allies:_\\n\" +\n\t\t\t\t\"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n\t\t\t\t\"_-_ Sneak ability working while Duelist is rooted\\n\" +\n\t\t\t\t\"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n\t\t\t\t\"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n\t\t\t\t\"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n\t\t\t\t\"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n\t\t\t\t\"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n\t\t\t\t\"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n\t\t\t\t\"_-_ Ally warp working on corrupted DM-201s\\n\" +\n\t\t\t\t\"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc.:_\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Tutorial becoming stuck in rare cases\\n\" +\n\t\t\t\t\"_-_ Beta updates setting not working as intended\\n\" +\n\t\t\t\t\"_-_ Music fading not working in rare cases\\n\" +\n\t\t\t\t\"_-_ Scrolling pane in journal window freezing in rare cases\",\n\n\t\t\t\t\"_v2.3.1:_\\n\" +\n\t\t\t\t\"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n\t\t\t\t\"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n\t\t\t\t\"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n\t\t\t\t\"_-_ Incorrect death messages when player is killed by wards\\n\" +\n\t\t\t\t\"_-_ Amoked allies not being affected by aggression debuff\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_v2.3.2:_\\n\" +\n\t\t\t\t\"_-_ Various minor textual errors\\n\" +\n\t\t\t\t\"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n\t\t\t\t\"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n\t\t\t\t\"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n\t\t\t\t\"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v2_4_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.4.0-ALPHA\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Alpha To-Do\",\n\t\t\t\t\"v2.4.0 isn't yet content complete, so there's a bit more I plan to add before beta/release:\\n\\n\" +\n\t\t\t\t\"_-_ I want to add a few more Trinkets, ideally so there are 10-12 in total for release.\\n\" +\n\t\t\t\t\"_-_ I'd like to make further alchemy UI improvements, mainly it'd be nice to include the guidebook on the main screen for desktop users.\\n\" +\n\t\t\t\t\"_-_ I plan on making a few supporter feature improvements, primarily better epitaphs and maybe custom notes. This might get delayed to a future patch/update though.\\n\" +\n\t\t\t\t\"_-_ I'll make further Hero tweaks in response to feedback as needed.\\n\" +\n\t\t\t\t\"_-_ And, of course, there'll be various misc tweaks and fixes as needed.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RAT_SKULL), \"Trinkets!\",\n\t\t\t\t\"_A new category of item has been added: Trinkets!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Trinkets are a new item type produced and upgraded via alchemical energy, and are more about tweaking gameplay variables than giving direct power or utility.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Look out for a trinket catalyst in the early stages of the game, which you can use at the first alchemy pot to produce one of three trinket options. There are _8 trinkets in total_ currently.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.STAIRS), \"New Rooms\",\n\t\t\t\t\"_New standard rooms have been added to the various regions of the game!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This includes one totally new room per region, and two new variants of entrance/exit rooms per region. Rooms that are mostly empty rectangles are now much less common, and there's a bunch of variety for which rooms can have entrance/exit stairs in them.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Entrance rooms are now also capable of merging with other rooms in a dungeon floor, but there are some guarantees so that enemies won't ever be near you right after descending to a new floor.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.PUMPKIN_PIE), \"More Holiday Items\",\n\t\t\t\t\"_I've added more holiday items for the rest of 2024!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Expect to see some new temporary holiday overrides for cornish pasties for:\\n\" +\n\t\t\t\t\"_-_ Pride in late June\\n\" +\n\t\t\t\t\"_-_ Shattered's Birthday in early August\\n\" +\n\t\t\t\t\"_-_ Pixel Dungeon's Birthday in early December\\n\" +\n\t\t\t\t\"_-_ New Years in late December and early January\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This is in addition to the usual pumpkin pie around Halloween and candy cane around the Winter Holidays.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"...I may have also added a tiny little surprise for Rat King's birthday, but that won't appear until 2025.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(HeroSprite.avatar(HeroClass.DUELIST, 6), \"Duelist Weapon Abilities\",\n\t\t\t\t\"I'm making some overarching changes to the Duelist's weapon abilities, to make them stronger and feel more impactful:\\n\" +\n\t\t\t\t\"_-_ Weapon ability charge speed down by 33%\\n\" +\n\t\t\t\t\"_-_ Weapon abilities buffed across the board\\n\" +\n\t\t\t\t\"_-_ All weapon abilities now scale with weapon level in some way\\n\" +\n\t\t\t\t\"_-_ Weapon abilities now directly state their damage ranges\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"There are also some changes to the Champion subclass to go along with this:\\n\" +\n\t\t\t\t\"_-_ Champion's two weapons now share a charge count, but Champion gets boosted max charges and charge speed.\\n\" +\n\t\t\t\t\"_-_ Champion's secondary charge talent has been replaced with a new talent that encourages varied ability use.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.ENERGY), \"Alchemy Changes\",\n\t\t\t\t\"I've made a bunch of changes to the alchemy system to streamline things and complement the addition of trinkets:\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Catalysts have been removed entirely, recipes now simply cost more energy instead of requiring one.\\n\" +\n\t\t\t\t\"_-_ Lots of recipes have received adjustments to their overall energy cost or output quantities.\\n\" +\n\t\t\t\t\"_-_ High value potions/scrolls now grant a little more energy if they are energized.\\n\" +\n\t\t\t\t\"_-_ Alchemy pots now always spawn on the 3rd or 4th floor in each region.\\n\" +\n\t\t\t\t\"_-_ Various UI improvements have been made to the alchemy screen.\",\n\t\t\t\t\n\t\t\t\t\"Various specific alchemy items have also received more notable changes:\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Added Unstable Brew,_ which gives a random potion effect that's likely to be useful.\\n\" +\n\t\t\t\t\"_- Aqua Blast_ is now a brew, otherwise unchanged.\\n\" +\n\t\t\t\t\"_- Featherfall_ is now an elixir, otherwise unchanged.\\n\" +\n\t\t\t\t\"_- Elixir of Icy Touch_ now applies 3 chill each hit, up from 2.\\n\" +\n\t\t\t\t\"_- Elixir of Toxic Essence_ now spreads gas quicker and grants lingering gas immunity for 5 turns.\\n\" +\n\t\t\t\t\"_- Added Unstable Spell,_ which gives a random scroll effect that's likely to be useful.\\n\" +\n\t\t\t\t\"_- Alchemize_ has a new recipe, it is now much cheaper to make.\\n\" +\n\t\t\t\t\"_- Summon Elemental_ now retains its empowerment, rather than having it last only 1 use.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.TALENT), \"T1 talent changes\",\n\t\t\t\t\"I've made some changes meant to improve some of the least popular T1 talents:\\n\" +\n\t\t\t\t\"_- Cached Rations_ now awards a smaller number of unique 'supply rations'. These rations grant a little healing and cloak charge.\\n\" +\n\t\t\t\t\"_- Test Subject and Tested Hypothesis_ have been replaced with two new talents that grant small combat bonuses.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Plus one change to an unnecessarily complex T1 talent:\\n\" +\n\t\t\t\t\"_- Hearty Meal_ has been simplified, now just has one threshold at 30% HP\"));\n\n\t\t\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Potion and Scroll talents can now trigger from elixirs, brews, and spells\\n\" +\n\t\t\t\t\"_-_ Ankh resurrection window now warns if two items aren't selected\\n\" +\n\t\t\t\t\"_-_ Trying to attack an enemy that has charmed you now shows a warning\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Heroes:_\\n\" +\n\t\t\t\t\"_-_ Gladiator and Monk now include brief ability descriptions in their subclass descriptions\\n\" +\n\t\t\t\t\"_-_ Ability descriptions for Gladiator and Monk now change if their abilities are empowered\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Thrown weapons now state when they break in the game log\\n\" +\n\t\t\t\t\"_-_ Tipped darts now last forever when reaching 100 uses, like other thrown weapons\\n\" +\n\t\t\t\t\"_-_ Dried rose now includes the ghost's strength in its description\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Updated various code dependencies\\n\" +\n\t\t\t\t\"_-_ Slight optimizations to memory use\\n\" +\n\t\t\t\t\"_-_ Improved the error message on Android when native code is missing\\n\" +\n\t\t\t\t\"_-_ Removed the power saver setting on Android 4.4+ devices, if the user hadn't already enabled it.\\n\" +\n\t\t\t\t\"(Power saver was always meant for very old Android devices. It gives no real benefit for more modern ones.)\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Ruins rooms in the last region using incorrect wall shapes since v2.2.0\\n\" +\n\t\t\t\t\"_-_ Rare cases where some victory badges would not save if game was immediately closed\\n\" +\n\t\t\t\t\"_-_ Rare cases where game actors could continue to process for a moment when hero falls into a chasm\\n\" +\n\t\t\t\t\"_-_ Various cases where characters would not play death animations if they died while paralyzed\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Newborn elemental boss rarely firing its attack through walls\\n\" +\n\t\t\t\t\"_-_ Rare cases where the final boss could command minions to attack themselves\\n\" +\n\t\t\t\t\"_-_ Gnoll geomancer and sappers potentially dropping boulders next to entrance\\n\" +\n\t\t\t\t\"_-_ Gnoll sappers granting armor to corrupted gnoll guards\\n\" +\n\t\t\t\t\"_-_ Necromancer skeletons not following necromancer's aggro in some cases\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Thieve's Armband not working on hiding mimics\\n\" +\n\t\t\t\t\"_-_ Chilling enchantment reducing chill duration in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where lucky enchantment wouldn't trigger\\n\" +\n\t\t\t\t\"_-_ Runestones affecting terrain when thrown at a character\\n\" +\n\t\t\t\t\"_-_ Thrown weapons sticking to downed ghouls in some cases\\n\" +\n\t\t\t\t\"_-_ Camouflage glyph not working if hero uses ethereal chains to move into grass\\n\" +\n\t\t\t\t\"_-_ Sandals of nature incorrectly interacting with artifact charging\\n\" +\n\t\t\t\t\"_-_ Several artifacts being unable to gain more than 1 (or 1%) charge per turn\\n\" +\n\t\t\t\t\"_-_ Brimstone glyph not benefiting from glyph power boosts past +50%\\n\" +\n\t\t\t\t\"_-_ Errors when leaving/entering blacksmith's area while a boomerang was circling back\\n\" +\n\t\t\t\t\"_-_ Transfusion not benefiting from wand damage bonuses\\n\" +\n\t\t\t\t\"_-_ Dwarf King's crown automatically IDing armor\\n\" +\n\t\t\t\t\"_-_ Armband allowing more than one steal in specific cases\\n\" +\n\t\t\t\t\"_-_ Swiftness glyph ignoring nearby enemies in specific cases\",\n\n\t\t\t\t\"_Heroes:_\\n\" +\n\t\t\t\t\"_-_ Duelist's swift equip not working during time freeze\\n\" +\n\t\t\t\t\"_-_ Monk's flurry of blows not using projecting enchantment when empowered\\n\" +\n\t\t\t\t\"_-_ Various battlemage on-hit effects not showing as magical damage\\n\" +\n\t\t\t\t\"_-_ Empowered strike talent not working with blastwave\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Specific cases where unbreakable traps could spawn in halls in the caves\\n\" +\n\t\t\t\t\"_-_ Music not properly pausing in background on desktop in some cases\\n\" +\n\t\t\t\t\"_-_ Various rare errors when game launches in fullscreen\\n\" +\n\t\t\t\t\"_-_ 'taste vengeance' badge not being earnable in a run after unlocking it\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new Image(new GhostSprite()), \"Ghost and Blacksmith Enchantments\",\n\t\t\t\t\"I've given a slight boost to the rewards of the Ghost quest and Blacksmith's smith reward, aimed at making enchantments/glyphs more likely. this should make these rewards a bit more interesting more often.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Ghost reward enchant rate up to 20% from 10%\\n\" +\n\t\t\t\t\"_-_ Blacksmith smith reward enchant rate up to 30% from 0%\"));\n\n\t}",
        "uniqueId": "2763cf42ca71fce0e4e942721d9db6509306daf3_77_277_79_247_249_434",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nAfter Refactoring:\nprotected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t\n\t\tfLogo= new Logo();\n\n\t\t\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}\n\nExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}\nExample 2:\n Before Refactoring:\nprotected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}\n\nAfter Refactoring:\nprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\nExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\nExample 3:\n Before Refactoring:\nTestTreeCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"ok.gif\");\n\t    \tfOkIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"failure.gif\");\n\t    \tfFailureIcon= new ImageIcon(url);\n\t\t}\n\nAfter Refactoring:\nTestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}\n\nExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} \n\t\t\treturn new ImageIcon(url);\n\t\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "2a56271091b97a830ba128cd609928601f16eab7",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a56271091b97a830ba128cd609928601f16eab7",
        "sourceCodeBeforeRefactoring": "public int drRoll() {\n\t\tint dr = 0;\n\n\t\tdr += Random.NormalIntRange( 0 , Barkskin.currentLevel(this) );\n\n\t\treturn dr;\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic int drRoll() {\n    int dr = 0;\n\n    dr += Random.NormalIntRange(0, Barkskin.currentLevel(this));\n\n    return dr;\n}\n```\n\n### Refactored Code:\n```java\npublic int drRoll() {\n    return calculateDamageReduction();\n}\n\nprivate int calculateDamageReduction() {\n    return Random.NormalIntRange(0, Barkskin.currentLevel(this));\n}\n```\n\n### Explanation:\n- The `drRoll` method has been refactored to improve readability by extracting the logic for calculating the damage reduction into a separate method called `calculateDamageReduction`. This makes the `drRoll` method cleaner and more focused on its purpose, which is to roll for damage reduction.",
        "sourceCodeAfterRefactoring": "public int drRoll() {\n\t\tint dr = 0;\n\n\t\tdr += combatRoll( 0 , Barkskin.currentLevel(this) );\n\n\t\treturn dr;\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static int combatRoll(int min, int max ){\n\t\treturn Random.NormalIntRange( min, max );\n\t}",
        "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_605_611_595_597_611_617",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n\tpublic TestRunner(PrintStream writer) {\n\t\tif (writer == null)\n\t\t\tthrow new IllegalArgumentException(\"Writer can't be null\");\n\t\tfPrinter= new ResultPrinter(writer);\n\t}\n\nAfter Refactoring:\n\n\tpublic TestRunner(PrintStream writer) {\n\t\tthis(new ResultPrinter(writer));\n\t}\n\nExtractedCodeFragments:\n/**\n\t * Constructs a TestRunner using the given ResultPrinter all the output\n\t */\n\tpublic TestRunner(ResultPrinter printer) {\n\t\tfPrinter= printer;\n\t}\nExample 2:\n Before Refactoring:\npublic void step(int value, boolean successful) {\n\t\tsetValue(value);\n\t\tif (!fError && !successful) {\n\t\t\tfError= true;\n\t\t\tsetForeground(getStatusColor());\n\t\t}\n\t}\n\nAfter Refactoring:\npublic void step(int value, boolean successful) {\n\t\tsetValue(value);\n\t\tif (!fError && !successful) {\n\t\t\tfError= true;\n\t\t\tupdateBarColor();\n\t\t}\n\t\t}\n\nExtractedCodeFragments:\nprotected void updateBarColor() {\n\t\tsetForeground(getStatusColor());\n\t}\nExample 3:\n Before Refactoring:\npublic void runTest() {\n\t\t\n\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}\n\nAfter Refactoring:\npublic void runTest() {\n\t\trunBeforesThenTestThenAfters(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\trunTestMethod();\n\t\t\t}\n\t\t});\n\t}\n\nExtractedCodeFragments:\npublic void runBeforesThenTestThenAfters(Runnable test) {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\ttest.run();\n\t\t} catch (FailedBefore e) {\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"test should never throw an exception to this level\");\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\t\t\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "2a56271091b97a830ba128cd609928601f16eab7",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a56271091b97a830ba128cd609928601f16eab7",
        "sourceCodeBeforeRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\tch.damage(dmg, link);\n\t\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\t\tlink.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 1.67f;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\n\t\tif (buff(Sickle.HarvestBleedTracker.class) != null){\n\t\t\tif (isImmune(Bleeding.class)){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.titleCase(Messages.get(this, \"immune\")));\n\t\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\tif (b == null){\n\t\t\t\tb = new Bleeding();\n\t\t\t}\n\t\t\tb.announced = false;\n\t\t\tb.set(dmg*buff(Sickle.HarvestBleedTracker.class).bleedFactor, Sickle.HarvestBleedTracker.class);\n\t\t\tb.attachTo(this);\n\t\t\tsprite.showStatus(CharSprite.WARNING, Messages.titleCase(b.name()) + \" \" + (int)b.level());\n\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP > 0 && shielded > 0 && shielding() == 0){\n\t\t\tif (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)){\n\t\t\t\tBuff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n\t\t\t}\n\t\t}\n\n\t\tif (HP > 0 && buff(Grim.GrimTracker.class) != null){\n\n\t\t\tfloat finalChance = buff(Grim.GrimTracker.class).maxChance;\n\t\t\tfinalChance *= (float)Math.pow( ((HT - HP) / (float)HT), 2);\n\n\t\t\tif (Random.Float() < finalChance) {\n\t\t\t\tint extraDmg = Math.round(HP*resist(Grim.class));\n\t\t\t\tdmg += extraDmg;\n\t\t\t\tHP -= extraDmg;\n\n\t\t\t\tsprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\tif (!isAlive() && buff(Grim.GrimTracker.class).qualifiesForBadge){\n\t\t\t\t\tBadges.validateGrimWeapon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\t\n\t\t\tint                                                         icon = FloatingText.PHYS_DMG;\n\t\t\tif (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass()))     icon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\tif (AntiMagic.RESISTS.contains(src.getClass()))             icon = FloatingText.MAGIC_DMG;\n\t\t\tif (src instanceof Pickaxe)                                 icon = FloatingText.PICK_DMG;\n\n\t\t\t\n\t\t\tif (src == Dungeon.hero\n\t\t\t\t\t&& Dungeon.hero.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t&& !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n\t\t\t\t\t&& Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon){\n\t\t\t\ticon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\t}\n\n\t\t\tif (src instanceof Hunger)                                  icon = FloatingText.HUNGER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Chill || src instanceof Frost)        icon = FloatingText.FROST;\n\t\t\tif (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Electricity)                             icon = FloatingText.SHOCKING;\n\t\t\tif (src instanceof Bleeding)                                icon = FloatingText.BLEEDING;\n\t\t\tif (src instanceof ToxicGas)                                icon = FloatingText.TOXIC;\n\t\t\tif (src instanceof Corrosion)                               icon = FloatingText.CORROSION;\n\t\t\tif (src instanceof Poison)                                  icon = FloatingText.POISON;\n\t\t\tif (src instanceof Ooze)                                    icon = FloatingText.OOZE;\n\t\t\tif (src instanceof Viscosity.DeferedDamage)                 icon = FloatingText.DEFERRED;\n\t\t\tif (src instanceof Corruption)                              icon = FloatingText.CORRUPTION;\n\t\t\tif (src instanceof AscensionChallenge)                      icon = FloatingText.AMULET;\n\n\t\t\tsprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic void damage(int dmg, Object src) {\n    if (!isAlive() || dmg < 0) {\n        return;\n    }\n\n    if (isInvulnerable(src.getClass())) {\n        sprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n        return;\n    }\n\n    for (ChampionEnemy buff : buffs(ChampionEnemy.class)) {\n        dmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n    }\n\n    if (!(src instanceof LifeLink) && buff(LifeLink.class) != null) {\n        HashSet<LifeLink> links = buffs(LifeLink.class);\n        for (LifeLink link : links.toArray(new LifeLink[0])) {\n            if (Actor.findById(link.object) == null) {\n                links.remove(link);\n                link.detach();\n            }\n        }\n        dmg = (int) Math.ceil(dmg / (float) (links.size() + 1));\n        for (LifeLink link : links) {\n            Char ch = (Char) Actor.findById(link.object);\n            if (ch != null) {\n                ch.damage(dmg, link);\n                if (!ch.isAlive()) {\n                    link.detach();\n                }\n            }\n        }\n    }\n\n    recoverBuffs(src);\n\n    int shielded = dmg;\n\n    if (!(src instanceof Hunger)) {\n        for (ShieldBuff s : buffs(ShieldBuff.class)) {\n            dmg = s.absorbDamage(dmg);\n            if (dmg == 0) break;\n        }\n    }\n    shielded -= dmg;\n    HP -= dmg;\n\n    if (HP > 0 && shielded > 0 && shielding() == 0) {\n        if (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)) {\n            Buff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n        }\n    }\n\n    if (HP > 0 && buff(Grim.GrimTracker.class) != null) {\n        applyGrimDamage(dmg);\n    }\n\n    if (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY) {\n        handleKineticDamage(src);\n    }\n\n    if (sprite != null) {\n        showDamageStatus(dmg, shielded, src);\n    }\n\n    if (HP < 0) HP = 0;\n\n    if (!isAlive()) {\n        die(src);\n    } else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null) {\n        DeathMark.processFearTheReaper(this);\n    }\n}\n\nprivate void recoverBuffs(Object src) {\n    Terror t = buff(Terror.class);\n    if (t != null) {\n        t.recover();\n    }\n    Dread d = buff(Dread.class);\n    if (d != null) {\n        d.recover();\n    }\n    Charm c = buff(Charm.class);\n    if (c != null) {\n        c.recover(src);\n    }\n    if (this.buff(Frost.class) != null) {\n        Buff.detach(this, Frost.class);\n    }\n    if (this.buff(MagicalSleep.class) != null) {\n        Buff.detach(this, MagicalSleep.class);\n    }\n    if (this.buff(Doom.class) != null && !isImmune(Doom.class)) {\n        dmg *= 1.67f;\n    }\n    if (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null) {\n        dmg *= 1.25f;\n    }\n\n    Class<?> srcClass = src.getClass();\n    if (isImmune(srcClass)) {\n        dmg = 0;\n    } else {\n        dmg = Math.round(dmg * resist(srcClass));\n    }\n\n    if (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null) {\n        dmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n        if (dmg < 0) dmg = 0;\n    }\n\n    if (buff(Sickle.HarvestBleedTracker.class) != null) {\n        handleBleeding(src, dmg);\n    }\n\n    if (buff(Paralysis.class) != null) {\n        buff(Paralysis.class).processDamage(dmg);\n    }\n}\n\nprivate void handleBleeding(Object src, int dmg) {\n    if (isImmune(Bleeding.class)) {\n        sprite.showStatus(CharSprite.POSITIVE, Messages.titleCase(Messages.get(this, \"immune\")));\n        buff(Sickle.HarvestBleedTracker.class).detach();\n        return;\n    }\n\n    Bleeding b = buff(Bleeding.class);\n    if (b == null) {\n        b = new Bleeding();\n    }\n    b.announced = false;\n    b.set(dmg * buff(Sickle.HarvestBleedTracker.class).bleedFactor, Sickle.HarvestBleedTracker.class);\n    b.attachTo(this);\n    sprite.showStatus(CharSprite.WARNING, Messages.titleCase(b.name()) + \" \" + (int) b.level());\n    buff(Sickle.HarvestBleedTracker.class).detach();\n}\n\nprivate void applyGrimDamage(int dmg) {\n    float finalChance = buff(Grim.GrimTracker.class).maxChance;\n    finalChance *= (float) Math.pow(((HT - HP) / (float) HT), 2);\n\n    if (Random.Float() < finalChance) {\n        int extraDmg = Math.round(HP * resist(Grim.class));\n        dmg += extraDmg;\n        HP -= extraDmg;\n\n        sprite.emitter().burst(ShadowParticle.UP, 5);\n        if (!isAlive() && buff(Grim.GrimTracker.class).qualifiesForBadge) {\n            Badges.validateGrimWeapon();\n        }\n    }\n}\n\nprivate void handleKineticDamage(Object src) {\n    if (((Char) src).buff(Kinetic.KineticTracker.class) != null) {\n        int dmgToAdd = -HP;\n        dmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n        dmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n        if (dmgToAdd > 0) {\n            Buff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n        }\n        ((Char) src).buff(Kinetic.KineticTracker.class).detach();\n    }\n}\n\nprivate void showDamageStatus(int dmg, int shielded, Object src) {\n    int icon = FloatingText.PHYS_DMG;\n    if (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass())) icon = FloatingText.PHYS_DMG_NO_BLOCK;\n    if (AntiMagic.RESISTS.contains(src.getClass())) icon = FloatingText.MAGIC_DMG;\n    if (src instanceof Pickaxe) icon = FloatingText.PICK_DMG;\n\n    if (src == Dungeon.hero\n            && Dungeon.hero.subClass == HeroSubClass.SNIPER\n            && !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n            && Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon) {\n        icon = FloatingText.PHYS_DMG_NO_BLOCK;\n    }\n\n    if (src instanceof Hunger) icon = FloatingText.HUNGER;\n    if (src instanceof Burning) icon = FloatingText.BURNING;\n    if (src instanceof Chill || src instanceof Frost) icon = FloatingText.FROST;\n    if (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n    if (src instanceof Burning) icon = FloatingText.BURNING;\n    if (src instanceof Electricity) icon = FloatingText.SHOCKING;\n    if (src instanceof Bleeding) icon = FloatingText.BLEEDING;\n    if (src instanceof ToxicGas) icon = FloatingText.TOXIC;\n    if (src instanceof Corrosion) icon = FloatingText.CORROSION;\n    if (src instanceof Poison) icon = FloatingText.POISON;\n    if (src instanceof Ooze) icon = FloatingText.OOZE;\n    if (src instanceof Viscosity.DeferedDamage) icon = FloatingText.DEFERRED;\n    if (src instanceof Corruption) icon = FloatingText.CORRUPTION;\n    if (src instanceof AscensionChallenge) icon = FloatingText.AMULET;\n\n    sprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n}\n```\n\n### Refactored Code:\n```java\npublic void damage(int dmg, Object src) {\n    if (!isAlive() || dmg < 0) {\n        return;\n    }\n\n    if (isInvulnerable(src.getClass())) {\n        sprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n        return;\n    }\n\n    dmg = applyChampionEnemyBuffs(dmg);\n    dmg = handleLifeLink(src, dmg);\n\n    recoverBuffs(src);\n\n    int shielded = applyShielding(src, dmg);\n    HP -= dmg;\n\n    handlePostDamageEffects(shielded, src);\n\n    if (sprite != null) {\n        showDamageStatus(dmg, shielded, src);\n    }\n\n    if (HP < 0) HP = 0;\n\n    if (!isAlive()) {\n        die(src);\n    } else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null) {\n        DeathMark.processFearTheReaper(this);\n    }\n}\n\nprivate int applyChampionEnemyBuffs(int dmg) {\n    for (ChampionEnemy buff : buffs(ChampionEnemy.class)) {\n        dmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n    }\n    return dmg;\n}\n\nprivate int handleLifeLink(Object src, int dmg) {\n    if (!(src instanceof LifeLink) && buff(LifeLink.class) != null) {\n        HashSet<LifeLink> links = buffs(LifeLink.class);\n        removeInvalidLinks(links);\n        dmg = (int) Math.ceil(dmg / (float) (links.size() + 1));\n        applyLifeLinkDamage(links, dmg);\n    }\n    return dmg;\n}\n\nprivate void removeInvalidLinks(HashSet<LifeLink> links) {\n    for (LifeLink link : links.toArray(new LifeLink[0])) {\n        if (Actor.findById(link.object) == null) {\n            links.remove(link);\n            link.detach();\n        }\n    }\n}\n\nprivate void applyLifeLinkDamage(HashSet<LifeLink> links, int dmg) {\n    for (LifeLink link : links) {\n        Char ch = (Char) Actor.findById(link.object);\n        if (ch != null) {\n            ch.damage(dmg, link);\n            if (!ch.isAlive()) {\n                link.detach();\n            }\n        }\n    }\n}\n\nprivate void recoverBuffs(Object src) {\n    recoverBuff(Terror.class);\n    recoverBuff(Dread.class);\n    recoverBuff(Charm.class, src);\n    detachBuffs(Frost.class, MagicalSleep.class);\n    applyDoomDamage();\n    applyDeathMarkDamage(src);\n}\n\nprivate void recoverBuff(Class<? extends Buff> buffClass) {\n    Buff buff = buff(buffClass);\n    if (buff != null) {\n        buff.recover();\n    }\n}\n\nprivate void recoverBuff(Class<? extends Buff> buffClass, Object src) {\n    Buff buff = buff(buffClass);\n    if (buff != null) {\n        buff.recover(src);\n    }\n}\n\nprivate void detachBuffs(Class<? extends Buff>... buffClasses) {\n    for (Class<? extends Buff> buffClass : buffClasses) {\n        if (this.buff(buffClass) != null) {\n            Buff.detach(this, buffClass);\n        }\n    }\n}\n\nprivate void applyDoomDamage() {\n    if (this.buff(Doom.class) != null && !isImmune(Doom.class)) {\n        dmg *= 1.67f;\n    }\n}\n\nprivate void applyDeathMarkDamage(Object src) {\n    if (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null) {\n        dmg *= 1.25f;\n    }\n\n    Class<?> srcClass = src.getClass();\n    if (isImmune(srcClass)) {\n        dmg = 0;\n    } else {\n        dmg = Math.round(dmg * resist(srcClass));\n    }\n\n    if (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null) {\n        dmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n        if (dmg < 0) dmg = 0;\n    }\n}\n\nprivate int applyShielding(Object src, int dmg) {\n    int shielded = dmg;\n    if (!(src instanceof Hunger)) {\n        for (ShieldBuff s : buffs(ShieldBuff.class)) {\n            dmg = s.absorbDamage(dmg);\n            if (dmg == 0) break;\n        }\n    }\n    shielded -= dmg;\n    return shielded;\n}\n\nprivate void handlePostDamageEffects(int shielded, Object src) {\n    if (HP > 0 && shielded > 0 && shielding() == 0) {\n        if (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)) {\n            Buff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n        }\n    }\n\n    if (HP > 0 && buff(Grim.GrimTracker.class) != null) {\n        applyGrimDamage(dmg);\n    }\n\n    if (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY) {\n        handleKineticDamage(src);\n    }\n\n    if (HP < 0) HP = 0;\n}\n\nprivate void showDamageStatus(int dmg, int shielded, Object src) {\n    int icon = determineDamageIcon(src);\n    sprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n}\n\nprivate int determineDamageIcon(Object src) {\n    int icon = FloatingText.PHYS_DMG;\n    if (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass())) icon = FloatingText.PHYS_DMG_NO_BLOCK;\n    if (AntiMagic.RESISTS.contains(src.getClass())) icon = FloatingText.MAGIC_DMG;\n    if (src instanceof Pickaxe) icon = FloatingText.PICK_DMG;\n\n    if (src == Dungeon.hero\n            && Dungeon.hero.subClass == HeroSubClass.SNIPER\n            && !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n            && Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon) {\n        icon = FloatingText.PHYS_DMG_NO_BLOCK;\n    }\n\n    if (src instanceof Hunger) icon = FloatingText.HUNGER;\n    if (src instanceof Burning) icon = FloatingText.BURNING;\n    if (src instanceof Chill || src instanceof Frost) icon = FloatingText.FROST;\n    if (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n    if (src instanceof Burning) icon = FloatingText.BURNING;\n    if (src instanceof Electricity) icon = FloatingText.SHOCKING;\n    if (src instanceof Bleeding) icon = FloatingText.BLEEDING;\n    if (src instanceof ToxicGas) icon = FloatingText.TOXIC;\n    if (src instanceof Corrosion) icon = FloatingText.CORROSION;\n    if (src instanceof Poison) icon = FloatingText.POISON;\n    if (src instanceof Ooze) icon = FloatingText.OOZE;\n    if (src instanceof Viscosity.DeferedDamage) icon = FloatingText.DEFERRED;\n    if (src instanceof Corruption) icon = FloatingText.CORRUPTION;\n    if (src instanceof AscensionChallenge) icon = FloatingText.AMULET;\n\n    return icon;\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: The code was broken down into smaller, more manageable methods to improve readability and maintainability.\n2. **Reduced Complexity**: The logic for handling buffs, damage calculations, and showing status was encapsulated in dedicated methods.\n3. **Improved Clarity**: The naming of methods and variables was enhanced to better convey their purpose, making the code easier to understand at a glance.",
        "sourceCodeAfterRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\tch.damage(dmg, link);\n\t\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\t\tlink.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 1.67f;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= combatRoll(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\n\t\tif (buff(Sickle.HarvestBleedTracker.class) != null){\n\t\t\tif (isImmune(Bleeding.class)){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.titleCase(Messages.get(this, \"immune\")));\n\t\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\tif (b == null){\n\t\t\t\tb = new Bleeding();\n\t\t\t}\n\t\t\tb.announced = false;\n\t\t\tb.set(dmg*buff(Sickle.HarvestBleedTracker.class).bleedFactor, Sickle.HarvestBleedTracker.class);\n\t\t\tb.attachTo(this);\n\t\t\tsprite.showStatus(CharSprite.WARNING, Messages.titleCase(b.name()) + \" \" + (int)b.level());\n\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP > 0 && shielded > 0 && shielding() == 0){\n\t\t\tif (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)){\n\t\t\t\tBuff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n\t\t\t}\n\t\t}\n\n\t\tif (HP > 0 && buff(Grim.GrimTracker.class) != null){\n\n\t\t\tfloat finalChance = buff(Grim.GrimTracker.class).maxChance;\n\t\t\tfinalChance *= (float)Math.pow( ((HT - HP) / (float)HT), 2);\n\n\t\t\tif (Random.Float() < finalChance) {\n\t\t\t\tint extraDmg = Math.round(HP*resist(Grim.class));\n\t\t\t\tdmg += extraDmg;\n\t\t\t\tHP -= extraDmg;\n\n\t\t\t\tsprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\tif (!isAlive() && buff(Grim.GrimTracker.class).qualifiesForBadge){\n\t\t\t\t\tBadges.validateGrimWeapon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\t\n\t\t\tint                                                         icon = FloatingText.PHYS_DMG;\n\t\t\tif (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass()))     icon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\tif (AntiMagic.RESISTS.contains(src.getClass()))             icon = FloatingText.MAGIC_DMG;\n\t\t\tif (src instanceof Pickaxe)                                 icon = FloatingText.PICK_DMG;\n\n\t\t\t\n\t\t\tif (src == Dungeon.hero\n\t\t\t\t\t&& Dungeon.hero.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t&& !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n\t\t\t\t\t&& Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon){\n\t\t\t\ticon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\t}\n\n\t\t\tif (src instanceof Hunger)                                  icon = FloatingText.HUNGER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Chill || src instanceof Frost)        icon = FloatingText.FROST;\n\t\t\tif (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Electricity)                             icon = FloatingText.SHOCKING;\n\t\t\tif (src instanceof Bleeding)                                icon = FloatingText.BLEEDING;\n\t\t\tif (src instanceof ToxicGas)                                icon = FloatingText.TOXIC;\n\t\t\tif (src instanceof Corrosion)                               icon = FloatingText.CORROSION;\n\t\t\tif (src instanceof Poison)                                  icon = FloatingText.POISON;\n\t\t\tif (src instanceof Ooze)                                    icon = FloatingText.OOZE;\n\t\t\tif (src instanceof Viscosity.DeferedDamage)                 icon = FloatingText.DEFERRED;\n\t\t\tif (src instanceof Corruption)                              icon = FloatingText.CORRUPTION;\n\t\t\tif (src instanceof AscensionChallenge)                      icon = FloatingText.AMULET;\n\n\t\t\tsprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\npublic static int combatRoll(int min, int max ){\n\t\treturn Random.NormalIntRange( min, max );\n\t}",
        "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_669_851_595_597_675_857",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}\n\nAfter Refactoring:\nprotected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}\n\nExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}\nExample 2:\n Before Refactoring:\n\n\tpublic Result runMain(JUnitSystem system, String... args) {\n\t\tsystem.out().println(\"JUnit version \" + Version.id());\n\t\tList<Class<?>> classes= new ArrayList<Class<?>>();\n\t\tList<Failure> missingClasses= new ArrayList<Failure>();\n\t\tfor (String each : args)\n\t\t\ttry {\n\t\t\t\tclasses.add(Class.forName(each));\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tsystem.out().println(\"Could not find class: \" + each);\n\t\t\t\tDescription description= Description.createSuiteDescription(each);\n\t\t\t\tFailure failure= new Failure(description, e);\n\t\t\t\tmissingClasses.add(failure);\n\t\t\t}\n\t\tRunListener listener= new TextListener(system);\n\t\taddListener(listener);\n\t\tResult result= run(classes.toArray(new Class[0]));\n\t\tfor (Failure each : missingClasses)\n\t\t\tresult.getFailures().add(each);\n\t\treturn result;\n\t}\n\nAfter Refactoring:\n\n\tpublic Result runMain(JUnitSystem system, String... args) {\n\t\tsystem.out().println(\"JUnit version \" + Version.id());\n\t\tList<Class<?>> classes= new ArrayList<Class<?>>();\n\t\tList<Failure> missingClasses= new ArrayList<Failure>();\n\t\tfor (String each : args)\n\t\t\ttry {\n\t\t\t\tclasses.add(Class.forName(each));\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tsystem.out().println(\"Could not find class: \" + each);\n\t\t\t\tDescription description= Description.createSuiteDescription(each);\n\t\t\t\tFailure failure= new Failure(description, e);\n\t\t\t\tmissingClasses.add(failure);\n\t\t\t}\n\t\tRunListener listener= new TextListener(system);\n\t\taddListener(listener);\n\t\t\n\t\tResult result= run(new Executioner(), classes.toArray(new Class[0]));\n\t\tfor (Failure each : missingClasses)\n\t\t\tresult.getFailures().add(each);\n\t\treturn result;\n\t}\n\nExtractedCodeFragments:\n/**\n\t * Run all the tests in <code>classes</code>.\n\t * @param asdfasdf TODO\n\t * @param classes the classes containing tests\n\t * @return a {@link Result} describing the details of the test run and the failed tests.\n\t */\n\tpublic Result run(Executioner asdfasdf, Class<?>... classes) {\n\t\treturn run(Request.classes(asdfasdf, classes));\n\t}\nExample 3:\n Before Refactoring:\n\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}\n\nAfter Refactoring:\n\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tvalidatePublicVoid(isStatic, errors);\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}\n\nExtractedCodeFragments:\npublic void validatePublicVoid(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t}"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "2a56271091b97a830ba128cd609928601f16eab7",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a56271091b97a830ba128cd609928601f16eab7",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean act() {\n\t\t\n\t\tif (target.isAlive() && !target.isImmune(getClass())) {\n\t\t\t\n\t\t\tint damage = Random.NormalIntRange( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\tBuff.detach( target, Chill.class);\n\n\t\t\tif (target instanceof Hero && target.buff(TimekeepersHourglass.timeStasis.class) == null) {\n\t\t\t\t\n\t\t\t\tHero hero = (Hero)target;\n\n\t\t\t\thero.damage( damage, this );\n\t\t\t\tburnIncrement++;\n\n\t\t\t\t\n\t\t\t\tif (Random.Int(3) < (burnIncrement - 3)){\n\t\t\t\t\tburnIncrement = 0;\n\n\t\t\t\t\tArrayList<Item> burnable = new ArrayList<>();\n\t\t\t\t\t\n\t\t\t\t\tif (!hero.belongings.lostInventory()) {\n\t\t\t\t\t\tfor (Item i : hero.belongings.backpack.items) {\n\t\t\t\t\t\t\tif (!i.unique && (i instanceof Scroll || i instanceof MysteryMeat || i instanceof FrozenCarpaccio)) {\n\t\t\t\t\t\t\t\tburnable.add(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!burnable.isEmpty()){\n\t\t\t\t\t\tItem toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n\t\t\t\t\t\tGLog.w( Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())) );\n\t\t\t\t\t\tif (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio){\n\t\t\t\t\t\t\tChargrilledMeat steak = new ChargrilledMeat();\n\t\t\t\t\t\t\tif (!steak.collect( hero.belongings.backpack )) {\n\t\t\t\t\t\t\t\tDungeon.level.drop( steak, hero.pos ).sprite.drop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHeap.burnFX( hero.pos );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\ttarget.damage( damage, this );\n\t\t\t}\n\n\t\t\tif (target instanceof Thief && ((Thief) target).item != null) {\n\n\t\t\t\tItem item = ((Thief) target).item;\n\n\t\t\t\tif (!item.unique && item instanceof Scroll) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = null;\n\t\t\t\t} else if (item instanceof MysteryMeat) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = new ChargrilledMeat();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tif (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n\t\t\tGameScene.add( Blob.seed( target.pos, 4, Fire.class ) );\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\tleft -= TICK;\n\t\t\n\t\tif (left <= 0 ||\n\t\t\t(Dungeon.level.water[target.pos] && !target.flying)) {\n\t\t\t\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\n\tpublic boolean act() {\n\t\t\n\t\tif (target.isAlive() && !target.isImmune(getClass())) {\n\t\t\t\n\t\t\tint damage = Random.NormalIntRange( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\tBuff.detach( target, Chill.class);\n\n\t\t\tif (target instanceof Hero && target.buff(TimekeepersHourglass.timeStasis.class) == null) {\n\t\t\t\t\n\t\t\t\tHero hero = (Hero)target;\n\n\t\t\t\thero.damage( damage, this );\n\t\t\t\tburnIncrement++;\n\n\t\t\t\t\n\t\t\t\tif (Random.Int(3) < (burnIncrement - 3)){\n\t\t\t\t\tburnIncrement = 0;\n\n\t\t\t\t\tArrayList<Item> burnable = new ArrayList<>();\n\t\t\t\t\t\n\t\t\t\t\tif (!hero.belongings.lostInventory()) {\n\t\t\t\t\t\tfor (Item i : hero.belongings.backpack.items) {\n\t\t\t\t\t\t\tif (!i.unique && (i instanceof Scroll || i instanceof MysteryMeat || i instanceof FrozenCarpaccio)) {\n\t\t\t\t\t\t\t\tburnable.add(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!burnable.isEmpty()){\n\t\t\t\t\t\tItem toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n\t\t\t\t\t\tGLog.w( Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())) );\n\t\t\t\t\t\tif (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio){\n\t\t\t\t\t\t\tChargrilledMeat steak = new ChargrilledMeat();\n\t\t\t\t\t\t\tif (!steak.collect( hero.belongings.backpack )) {\n\t\t\t\t\t\t\t\tDungeon.level.drop( steak, hero.pos ).sprite.drop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHeap.burnFX( hero.pos );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\ttarget.damage( damage, this );\n\t\t\t}\n\n\t\t\tif (target instanceof Thief && ((Thief) target).item != null) {\n\n\t\t\t\tItem item = ((Thief) target).item;\n\n\t\t\t\tif (!item.unique && item instanceof Scroll) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = null;\n\t\t\t\t} else if (item instanceof MysteryMeat) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = new ChargrilledMeat();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tif (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n\t\t\tGameScene.add( Blob.seed( target.pos, 4, Fire.class ) );\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\tleft -= TICK;\n\t\t\n\t\tif (left <= 0 ||\n\t\t\t(Dungeon.level.water[target.pos] && !target.flying)) {\n\t\t\t\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n```\n\n### Refactored Code:\n```java\n@Override\npublic boolean act() {\n    if (!target.isAlive() || target.isImmune(getClass())) {\n        detach();\n        return true;\n    }\n\n    int damage = Random.NormalIntRange(1, 3 + Dungeon.scalingDepth() / 4);\n    Buff.detach(target, Chill.class);\n\n    if (target instanceof Hero) {\n        handleHeroAction((Hero) target, damage);\n    } else {\n        target.damage(damage, this);\n    }\n\n    if (target instanceof Thief) {\n        handleThiefAction((Thief) target);\n    }\n\n    handleFlammable();\n\n    spend(TICK);\n    left -= TICK;\n\n    if (left <= 0 || (Dungeon.level.water[target.pos] && !target.flying)) {\n        detach();\n    }\n\n    return true;\n}\n\nprivate void handleHeroAction(Hero hero, int damage) {\n    if (hero.buff(TimekeepersHourglass.timeStasis.class) == null) {\n        hero.damage(damage, this);\n        burnIncrement++;\n\n        if (Random.Int(3) < (burnIncrement - 3)) {\n            burnIncrement = 0;\n            burnItems(hero);\n        }\n    }\n}\n\nprivate void burnItems(Hero hero) {\n    ArrayList<Item> burnable = new ArrayList<>();\n    if (!hero.belongings.lostInventory()) {\n        for (Item item : hero.belongings.backpack.items) {\n            if (!item.unique && (item instanceof Scroll || item instanceof MysteryMeat || item instanceof FrozenCarpaccio)) {\n                burnable.add(item);\n            }\n        }\n    }\n\n    if (!burnable.isEmpty()) {\n        Item toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n        GLog.w(Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())));\n        if (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio) {\n            ChargrilledMeat steak = new ChargrilledMeat();\n            if (!steak.collect(hero.belongings.backpack)) {\n                Dungeon.level.drop(steak, hero.pos).sprite.drop();\n            }\n        }\n        Heap.burnFX(hero.pos);\n    }\n}\n\nprivate void handleThiefAction(Thief thief) {\n    Item item = thief.item;\n    if (item != null) {\n        if (!item.unique && item instanceof Scroll) {\n            target.sprite.emitter().burst(ElmoParticle.FACTORY, 6);\n            thief.item = null;\n        } else if (item instanceof MysteryMeat) {\n            target.sprite.emitter().burst(ElmoParticle.FACTORY, 6);\n            thief.item = new ChargrilledMeat();\n        }\n    }\n}\n\nprivate void handleFlammable() {\n    if (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n        GameScene.add(Blob.seed(target.pos, 4, Fire.class));\n    }\n}\n```\n\n### Summary of Changes:\n1. **Early Exit**: Added an early exit for the case where the target is not alive or is immune, reducing nesting.\n2. **Extracted Methods**: Created separate methods (`handleHeroAction`, `burnItems`, `handleThiefAction`, and `handleFlammable`) to encapsulate specific behaviors, improving readability and maintainability.\n3. **Reduced Code Duplication**: The logic for handling the hero and thief actions is now encapsulated in their respective methods, reducing duplication and improving clarity.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean act() {\n\t\t\n\t\tif (target.isAlive() && !target.isImmune(getClass())) {\n\t\t\t\n\t\t\tint damage = Char.combatRoll( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\tBuff.detach( target, Chill.class);\n\n\t\t\tif (target instanceof Hero && target.buff(TimekeepersHourglass.timeStasis.class) == null) {\n\t\t\t\t\n\t\t\t\tHero hero = (Hero)target;\n\n\t\t\t\thero.damage( damage, this );\n\t\t\t\tburnIncrement++;\n\n\t\t\t\t\n\t\t\t\tif (Random.Int(3) < (burnIncrement - 3)){\n\t\t\t\t\tburnIncrement = 0;\n\n\t\t\t\t\tArrayList<Item> burnable = new ArrayList<>();\n\t\t\t\t\t\n\t\t\t\t\tif (!hero.belongings.lostInventory()) {\n\t\t\t\t\t\tfor (Item i : hero.belongings.backpack.items) {\n\t\t\t\t\t\t\tif (!i.unique && (i instanceof Scroll || i instanceof MysteryMeat || i instanceof FrozenCarpaccio)) {\n\t\t\t\t\t\t\t\tburnable.add(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!burnable.isEmpty()){\n\t\t\t\t\t\tItem toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n\t\t\t\t\t\tGLog.w( Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())) );\n\t\t\t\t\t\tif (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio){\n\t\t\t\t\t\t\tChargrilledMeat steak = new ChargrilledMeat();\n\t\t\t\t\t\t\tif (!steak.collect( hero.belongings.backpack )) {\n\t\t\t\t\t\t\t\tDungeon.level.drop( steak, hero.pos ).sprite.drop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHeap.burnFX( hero.pos );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\ttarget.damage( damage, this );\n\t\t\t}\n\n\t\t\tif (target instanceof Thief && ((Thief) target).item != null) {\n\n\t\t\t\tItem item = ((Thief) target).item;\n\n\t\t\t\tif (!item.unique && item instanceof Scroll) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = null;\n\t\t\t\t} else if (item instanceof MysteryMeat) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = new ChargrilledMeat();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tif (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n\t\t\tGameScene.add( Blob.seed( target.pos, 4, Fire.class ) );\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\tleft -= TICK;\n\t\t\n\t\tif (left <= 0 ||\n\t\t\t(Dungeon.level.water[target.pos] && !target.flying)) {\n\t\t\t\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n",
        "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_89_168_595_597_89_168",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\nprivate List<Runner> runners(Class<?> klass, Class<?>[] annotatedClasses)\n\t\t\t\tthrows InitializationError {\n\t\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\t\taddParent(klass);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\t\t\tif (childRunner != null)\n\t\t\t\t\t\trunners.add(childRunner);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tremoveParent(klass);\n\t\t\t}\n\t\t\treturn runners;\n\t\t}\n\nAfter Refactoring:\nprivate List<Runner> runners(Class<?> parent, Class<?>[] children)\n\t\t\t\tthrows InitializationError {\n\t\t\taddParent(parent);\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn runners(children);\n\t\t\t} finally {\n\t\t\t\tremoveParent(parent);\n\t\t\t}\n\t\t}\n\nExtractedCodeFragments:\nprivate List<Runner> runners(Class<?>[] children) {\n\t\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : children) {\n\t\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\t\tif (childRunner != null)\n\t\t\t\t\trunners.add(childRunner);\n\t\t\t}\n\t\t\treturn runners;\n\t\t}\nExample 3:\n Before Refactoring:\n@Override\n    public void evaluate() throws Throwable {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        try {\n            next.evaluate();\n        } catch (Throwable e) {\n            errors.add(e);\n        } finally {\n            for (FrameworkMethod each : afters) {\n                try {\n                    each.invokeExplosively(target);\n                } catch (Throwable e) {\n                    errors.add(e);\n                }\n            }\n        }\n        MultipleFailureException.assertEmpty(errors);\n    }\n\nAfter Refactoring:\n@Override\n    public void evaluate() throws Throwable {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        try {\n            next.evaluate();\n        } catch (Throwable e) {\n            errors.add(e);\n        } finally {\n            for (FrameworkMethod each : afters) {\n                try {\n                    invokeMethod(each);\n                } catch (Throwable e) {\n                    errors.add(e);\n                }\n            }\n        }\n        MultipleFailureException.assertEmpty(errors);\n    }\n\nExtractedCodeFragments:\n/**\n     * @since 4.13\n     */\n    protected void invokeMethod(FrameworkMethod method) throws Throwable {\n        method.invokeExplosively(target);\n    }"
    },
    {
        "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
        "sha1": "2a56271091b97a830ba128cd609928601f16eab7",
        "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a56271091b97a830ba128cd609928601f16eab7",
        "sourceCodeBeforeRefactoring": "public int armorBonus(){\n\t\tif (pos == target.pos && target instanceof Hero){\n\t\t\treturn Random.NormalIntRange(0, 2* ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n\t\t} else {\n\t\t\tdetach();\n\t\t\treturn 0;\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\npublic int armorBonus(){\n\t\tif (pos == target.pos && target instanceof Hero){\n\t\t\treturn Random.NormalIntRange(0, 2* ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n\t\t} else {\n\t\t\tdetach();\n\t\t\treturn 0;\n\t\t}\n\t}\n```\n\n### Refactored Code:\n```java\npublic int armorBonus() {\n    if (isTargetHeroAtSamePosition()) {\n        return calculateArmorBonus();\n    } else {\n        detach();\n        return 0;\n    }\n}\n\nprivate boolean isTargetHeroAtSamePosition() {\n    return pos == target.pos && target instanceof Hero;\n}\n\nprivate int calculateArmorBonus() {\n    return Random.NormalIntRange(0, 2 * ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: The logic for checking if the target is a hero at the same position and the calculation of the armor bonus were extracted into separate methods (`isTargetHeroAtSamePosition` and `calculateArmorBonus`). This improves readability by giving meaningful names to the checks and calculations.\n2. **Improved Readability**: The main method `armorBonus` is now cleaner and easier to understand at a glance, as it clearly outlines the flow of logic without getting bogged down in details.",
        "sourceCodeAfterRefactoring": "public int armorBonus(){\n\t\tif (pos == target.pos && target instanceof Hero){\n\t\t\treturn Char.combatRoll(0, 2* ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n\t\t} else {\n\t\t\tdetach();\n\t\t\treturn 0;\n\t\t}\n\t}",
        "diffSourceCode": "ExtractedCodeFragments:\n",
        "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_58_595_597_51_58",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\n\nAfter Refactoring:\nprivate void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}\n\nExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}\nExample 2:\n Before Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); \n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            \n            \n            \n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t\n    \t\t\n    \t} \n    \t\n    \t\n    \t\n    \t\n    \t\n    \t\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nAfter Refactoring:\n\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        \n        \n        \n        \n        \n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }\n\nExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }\nExample 3:\n Before Refactoring:\nprivate void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if (returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) {\n                try {\n                    addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }\n\nAfter Refactoring:\nprivate void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if ((returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) ||\n                    Iterable.class.isAssignableFrom(returnType)) {\n                try {\n                    addDataPointsValues(returnType, sig, dataPointsMethod.getName(), list, \n                            dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate void addDataPointsValues(Class<?> type, ParameterSignature sig, String name, \n            List<PotentialAssignment> list, Object value) {\n        if (type.isArray()) {\n            addArrayValues(sig, name, list, value);\n        }\n        else if (Iterable.class.isAssignableFrom(type)) {\n            addIterableValues(sig, name, list, (Iterable<?>) value);\n        }\n    }"
    }
]
[
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\n}\n@Test\npublic void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n}\n@Test\npublic void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n}\n@Test\npublic void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testExcludeInnerClassObject() {\n    assertThat(isExcluded(innerClass)).isTrue();\n}\n\n@Test\npublic void testExcludeInnerClassField() throws Exception {\n    assertThat(isExcluded(\"innerClass\")).isTrue();\n}\n\n@Test\npublic void testIncludeStaticNestedClassObject() {\n    assertThat(isExcluded(staticNestedClass)).isFalse();\n}\n\n@Test\npublic void testIncludeStaticNestedClassField() throws Exception {\n    assertThat(isExcluded(\"staticNestedClass\")).isFalse();\n}\n\nprivate boolean isExcluded(Object obj) {\n    return excluder.excludeClass(obj.getClass(), true);\n}\n\nprivate boolean isExcluded(String fieldName) throws Exception {\n    Field f = getClass().getField(fieldName);\n    return excluder.excludeField(f, true);\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Common Logic**: The logic to check if a class or field is excluded has been extracted into a private method `isExcluded(Object obj)` for classes and `isExcluded(String fieldName)` for fields. This reduces code duplication and improves readability.\n2. **Simplified Assertions**: The assertions in the test methods are now cleaner and more straightforward, focusing on the outcome rather than the setup details.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertExcludesClass(clazz);\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertIncludesClass(clazz);\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertIncludesField(f);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertExcludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_39_40_43_55_59",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nprivate String getFieldName(Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\n\nAfter Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\nprivate String getFieldName(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }\n\nExtractedCodeFragments:\nstatic boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nExtractedCodeFragments:\nstatic String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\nExample 2:\n Before Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses && isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\nAfter Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n      return excludeClassChecks(clazz) ||\n              excludeClassInStrategy(clazz, serialize);\n  }\n\nExtractedCodeFragments:\nprivate boolean excludeClassChecks(Class<?> clazz) {\n      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n          return true;\n      }\n\n      if (!serializeInnerClasses && isInnerClass(clazz)) {\n          return true;\n      }\n\n      if (isAnonymousOrLocal(clazz)) {\n          return true;\n      }\n\n      return false;\n  }\nExample 3:\n Before Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\n\nAfter Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\n\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    \n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\n}\n\n@Test\npublic void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n}\n\n@Test\npublic void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testSameVersion() throws Exception {\n    assertExclusionForVersion(VERSION, false, true);\n}\n\n@Test\npublic void testNewerVersion() throws Exception {\n    assertExclusionForVersion(VERSION + 5, false, true);\n}\n\n@Test\npublic void testOlderVersion() throws Exception {\n    assertExclusionForVersion(VERSION - 5, true, false);\n}\n\nprivate void assertExclusionForVersion(int version, boolean expectedUntilExclusion, boolean expectedBothExclusion) throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(version);\n    \n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isEqualTo(expectedUntilExclusion);\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isEqualTo(expectedUntilExclusion);\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isEqualTo(expectedBothExclusion);\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isEqualTo(expectedBothExclusion);\n}\n```\n\n### Explanation of Refactoring:\n- The repeated code in the test methods was extracted into a private method `assertExclusionForVersion`, which takes the version and expected results as parameters. This reduces redundancy and improves readability.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    \n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassBoth.class);\n    assertIncludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertExcludesClass(excluder, MockClassSince.class);\n    assertExcludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassUntil.class);\n    assertIncludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertIncludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_47_36_39_56_68",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nprivate String getFieldName(Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\n\nAfter Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\nprivate String getFieldName(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }\n\nExtractedCodeFragments:\nstatic boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nExtractedCodeFragments:\nstatic String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\nExample 2:\n Before Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\n\nAfter Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\n\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExample 3:\n Before Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses && isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\nAfter Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n      return excludeClassChecks(clazz) ||\n              excludeClassInStrategy(clazz, serialize);\n  }\n\nExtractedCodeFragments:\nprivate boolean excludeClassChecks(Class<?> clazz) {\n      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n          return true;\n      }\n\n      if (!serializeInnerClasses && isInnerClass(clazz)) {\n          return true;\n      }\n\n      if (isAnonymousOrLocal(clazz)) {\n          return true;\n      }\n\n      return false;\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testNeverSkipClasses() {\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\n}\n\n@Test\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n}\n\n@Test\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n}\n\n@Test\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n}\n\n@Test\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testNeverSkipClasses() {\n    assertClassIsNotExcluded(MockObject.class);\n}\n\n@Test\npublic void testSkipNonAnnotatedFields() throws Exception {\n    assertFieldIsExcluded(\"hiddenField\");\n}\n\n@Test\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    assertFieldIsExcluded(\"explicitlyHiddenField\");\n}\n\n@Test\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    assertFieldIsNotExcluded(\"exposedField\");\n}\n\n@Test\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    assertFieldIsNotExcluded(\"explicitlyExposedField\");\n}\n\nprivate void assertClassIsNotExcluded(Class<?> clazz) {\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n    assertThat(excluder.excludeClass(clazz, false)).isFalse();\n}\n\nprivate void assertFieldIsExcluded(String fieldName) throws Exception {\n    Field f = createFieldAttributes(fieldName);\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n}\n\nprivate void assertFieldIsNotExcluded(String fieldName) throws Exception {\n    Field f = createFieldAttributes(fieldName);\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: Created helper methods `assertClassIsNotExcluded`, `assertFieldIsExcluded`, and `assertFieldIsNotExcluded` to reduce code duplication and improve readability.\n2. **Descriptive Method Names**: The new method names clearly describe their purpose, making the test cases easier to understand at a glance.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertIncludesClass(MockObject.class);\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertIncludesField(f);\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertIncludesField(f);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_34_38_34_37_49_52",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\n\nAfter Refactoring:\npublic void testSkipNonAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\n\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExample 2:\n Before Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nprivate String getFieldName(Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\n\nAfter Refactoring:\npublic boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\nprivate String getFieldName(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }\n\nExtractedCodeFragments:\nstatic boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nExtractedCodeFragments:\nstatic String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }\nExample 3:\n Before Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses && isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\nAfter Refactoring:\npublic boolean excludeClass(Class<?> clazz, boolean serialize) {\n      return excludeClassChecks(clazz) ||\n              excludeClassInStrategy(clazz, serialize);\n  }\n\nExtractedCodeFragments:\nprivate boolean excludeClassChecks(Class<?> clazz) {\n      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n          return true;\n      }\n\n      if (!serializeInnerClasses && isInnerClass(clazz)) {\n          return true;\n      }\n\n      if (isAnonymousOrLocal(clazz)) {\n          return true;\n      }\n\n      return false;\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "08174e201980698a89f5f5996e10617d89ff09e1",
        "url": "https://github.com/google/gson/commit/08174e201980698a89f5f5996e10617d89ff09e1",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testNonFiniteFloats() throws IOException {\n    testNonFiniteFloatValues(false);\n}\n\n@Test\npublic void testNonFiniteFloatsWhenStrict() throws IOException {\n    testNonFiniteFloatValues(true);\n}\n\n@Test\npublic void testNonFiniteDoubles() throws IOException {\n    testNonFiniteDoubleValues(false);\n}\n\n@Test\npublic void testNonFiniteDoublesWhenStrict() throws IOException {\n    testNonFiniteDoubleValues(true);\n}\n\n@Test\npublic void testNonFiniteNumbers() throws IOException {\n    testNonFiniteNumberValues(false);\n}\n\n@Test\npublic void testNonFiniteNumbersWhenStrict() throws IOException {\n    testNonFiniteNumberValues(true);\n}\n\nprivate void testNonFiniteFloatValues(boolean strict) throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    if (strict) {\n        jsonWriter.setStrictness(Strictness.STRICT);\n    }\n    jsonWriter.beginArray();\n\n    assertNonFiniteValueThrows(jsonWriter, Float.NaN);\n    assertNonFiniteValueThrows(jsonWriter, Float.NEGATIVE_INFINITY);\n    assertNonFiniteValueThrows(jsonWriter, Float.POSITIVE_INFINITY);\n}\n\nprivate void testNonFiniteDoubleValues(boolean strict) throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    if (strict) {\n        jsonWriter.setStrictness(Strictness.STRICT);\n    }\n    jsonWriter.beginArray();\n\n    assertNonFiniteValueThrows(jsonWriter, Double.NaN);\n    assertNonFiniteValueThrows(jsonWriter, Double.NEGATIVE_INFINITY);\n    assertNonFiniteValueThrows(jsonWriter, Double.POSITIVE_INFINITY);\n}\n\nprivate void testNonFiniteNumberValues(boolean strict) throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    if (strict) {\n        jsonWriter.setStrictness(Strictness.STRICT);\n    }\n    jsonWriter.beginArray();\n\n    assertNonFiniteValueThrows(jsonWriter, Double.valueOf(Double.NaN));\n    assertNonFiniteValueThrows(jsonWriter, Double.valueOf(Double.NEGATIVE_INFINITY));\n    assertNonFiniteValueThrows(jsonWriter, Double.valueOf(Double.POSITIVE_INFINITY));\n    assertNonFiniteValueThrows(jsonWriter, new LazilyParsedNumber(\"Infinity\"));\n}\n\nprivate void assertNonFiniteValueThrows(JsonWriter jsonWriter, Object value) {\n    IllegalArgumentException expected = assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(value));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was \" + value);\n}\n```",
        "sourceCodeAfterRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
        "uniqueId": "08174e201980698a89f5f5996e10617d89ff09e1_289_312_289_309_311_316",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    \n    Class<?> internalClass = Collections.emptyList().getClass();\n    try {\n      gson.fromJson(\"[]\", internalClass);\n      fail(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().startsWith(\"Failed making constructor 'java.util.Collections$EmptyList()' accessible;\"\n          + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n    }\n  }\n\nAfter Refactoring:\n\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    \n    Class<?> internalClass = Collections.emptyList().getClass();\n    JsonIOException exception = assertInaccessibleException(\"[]\", internalClass);\n    \n    assertThat(exception).hasMessageThat().startsWith(\"Failed making constructor '\");\n    assertThat(exception).hasMessageThat().contains(\"' accessible; either increase its visibility or\"\n        + \" write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n  }\n\nExtractedCodeFragments:\nprivate static JsonIOException assertInaccessibleException(String json, Class<?> toDeserialize) {\n    Gson gson = new Gson();\n    try {\n      gson.fromJson(json, toDeserialize);\n      throw new AssertionError(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().endsWith(\"\\nSee https://github.com/google/gson/blob/master/Troubleshooting.md#reflection-inaccessible\");\n      // Return exception for further assertions\n      return expected;\n    }\n  }\nExample 2:\n Before Refactoring:\n\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = new JsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = new JsonReader(json);\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n\nAfter Refactoring:\n\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = newJsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n\nExtractedCodeFragments:\n/**\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   */\n  public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader = new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }\nExtractedCodeFragments:\n/**\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   */\n  public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader = new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }\nExample 3:\n Before Refactoring:\npublic void testFailWithPosition() throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }\n\nAfter Refactoring:\npublic void testFailWithPosition() throws IOException {\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\\n\\n\\n0,}]\");\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n  }\n\nExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }\nExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "66847264765180c849f945ca13704aa0eae79c58",
        "url": "https://github.com/google/gson/commit/66847264765180c849f945ca13704aa0eae79c58",
        "sourceCodeBeforeRefactoring": "\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n  }",
        "refactoredCode": "### Original Code:\n```java\n@CanIgnoreReturnValue\npublic GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n}\n```\n\n### Refactored Code:\n```java\n@CanIgnoreReturnValue\npublic GsonBuilder setDateFormat(int style) {\n    resetDatePattern();\n    this.dateStyle = style;\n    return this;\n}\n\nprivate void resetDatePattern() {\n    this.datePattern = null;\n}\n```\n\nIn this refactoring, I extracted the logic of resetting the `datePattern` into a separate method called `resetDatePattern()`. This improves readability by clearly indicating the purpose of that line of code and adheres to the Single Responsibility Principle.",
        "sourceCodeAfterRefactoring": "\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = checkDateFormatStyle(style);\n    this.datePattern = null;\n    return this;\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static int checkDateFormatStyle(int style) {\n    \n    if (style < 0 || style > 3) {\n      throw new IllegalArgumentException(\"Invalid style: \" + style);\n    }\n    return style;\n  }",
        "uniqueId": "66847264765180c849f945ca13704aa0eae79c58_614_633_616_622_624_644",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\nAfter Refactoring:\npublic DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\n\nExtractedCodeFragments:\npublic DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }\nExample 2:\n Before Refactoring:\npublic Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n        throws JsonParseException {\n      if (!(json instanceof JsonPrimitive)) {\n        throw new JsonParseException(\"The date should be a string value\");\n      }\n      synchronized (localFormat) {\n        try {\n          return localFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return enUsFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return iso8601Format.parse(json.getAsString());\n        } catch (ParseException e) {\n          throw new JsonSyntaxException(json.getAsString(), e);\n        }\n      }\n    }\n\nAfter Refactoring:\npublic Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n        throws JsonParseException {\n      if (!(json instanceof JsonPrimitive)) {\n        throw new JsonParseException(\"The date should be a string value\");\n      }\n      Date date = deserializeToDate(json);\n      if (typeOfT == Date.class) {\n        return date;\n      } else if (typeOfT == Timestamp.class) {\n        return new Timestamp(date.getTime());\n      } else if (typeOfT == java.sql.Date.class) {\n        return new java.sql.Date(date.getTime());\n      } else {\n        throw new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n      }\n    }\n\nExtractedCodeFragments:\nprivate Date deserializeToDate(JsonElement json) {\n      synchronized (localFormat) {\n        try {\n          return localFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return enUsFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return iso8601Format.parse(json.getAsString());\n        } catch (ParseException e) {\n          throw new JsonSyntaxException(json.getAsString(), e);\n        }\n      }\n    }\nExample 3:\n Before Refactoring:\npublic UtcDateTypeAdapter() {\n    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  }\n\nAfter Refactoring:\npublic UtcDateTypeAdapter() {\n    this(false);\n  }\n\nExtractedCodeFragments:\npublic UtcDateTypeAdapter(boolean jdk6Compatible) {\n    if (jdk6Compatible) {\n      this.iso8601Format = null;\n    } else {\n      // XXX is only supported by JDK 1.7+\n      this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n      this.iso8601Format.setTimeZone(UTC_TIME_ZONE);\n    }\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
        "url": "https://github.com/google/gson/commit/6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
        "sourceCodeBeforeRefactoring": "\n  private Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n  }",
        "refactoredCode": "### Original Code:\n```java\nprivate Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n}\n```\n\n### Refactored Code:\n```java\nprivate Object writeReplace() throws ObjectStreamException {\n    return convertToBigDecimal(value);\n}\n\nprivate BigDecimal convertToBigDecimal(Object value) {\n    return new BigDecimal(value);\n}\n```\n\n### Explanation:\nThe refactoring introduces a helper method `convertToBigDecimal` to encapsulate the conversion logic. This improves readability by clearly indicating the purpose of the conversion and allows for easier modifications in the future if the conversion logic needs to change.",
        "sourceCodeAfterRefactoring": "\n  private Object writeReplace() throws ObjectStreamException {\n    return asBigDecimal();\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate BigDecimal asBigDecimal() {\n    return NumberLimits.parseBigDecimal(value);\n  }",
        "uniqueId": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc_75_82_38_40_79_86",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n  @Override\n  public Number getAsNumber() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsNumber();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public String getAsString() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsString();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public double getAsDouble() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsDouble();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public BigDecimal getAsBigDecimal() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigDecimal();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public BigInteger getAsBigInteger() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigInteger();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public float getAsFloat() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsFloat();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public long getAsLong() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsLong();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public int getAsInt() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsInt();\n    }\n    throw new IllegalStateException();\n  }\n@Override\n  public byte getAsByte() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsByte();\n    }\n    throw new IllegalStateException();\n  }\n@Deprecated\n  @Override\n  public char getAsCharacter() {\n    if (elements.size() == 1) {\n      JsonElement element = elements.get(0);\n      return element.getAsCharacter();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public short getAsShort() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsShort();\n    }\n    throw new IllegalStateException();\n  }\n\n  @Override\n  public boolean getAsBoolean() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBoolean();\n    }\n    throw new IllegalStateException();\n  }\n\nAfter Refactoring:\n\n  @Override\n  public Number getAsNumber() {\n    return getAsSingleElement().getAsNumber();\n  }\n\n  @Override\n  public String getAsString() {\n    return getAsSingleElement().getAsString();\n  }\n\n  @Override\n  public double getAsDouble() {\n    return getAsSingleElement().getAsDouble();\n  }\n\n  @Override\n  public BigDecimal getAsBigDecimal() {\n    return getAsSingleElement().getAsBigDecimal();\n  }\n\n  @Override\n  public BigInteger getAsBigInteger() {\n    return getAsSingleElement().getAsBigInteger();\n  }\n\n  @Override\n  public float getAsFloat() {\n    return getAsSingleElement().getAsFloat();\n  }\n\n  @Override\n  public long getAsLong() {\n    return getAsSingleElement().getAsLong();\n  }\n\n  @Override\n  public int getAsInt() {\n    return getAsSingleElement().getAsInt();\n  }\n\n  @Override\n  public byte getAsByte() {\n    return getAsSingleElement().getAsByte();\n  }\n\n  @Deprecated\n  @Override\n  public char getAsCharacter() {\n    return getAsSingleElement().getAsCharacter();\n  }\n\n  @Override\n  public short getAsShort() {\n    return getAsSingleElement().getAsShort();\n  }\n\n  @Override\n  public boolean getAsBoolean() {\n    return getAsSingleElement().getAsBoolean();\n  }\n\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExample 2:\n Before Refactoring:\nfinal private JsonPrimitive JsonNumber() throws ParseException {\n  String intpart = null,\n         fracpart = null,\n         exppart = null;\n    intpart = JsonInt();\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case 30:\n      fracpart = JsonFrac();\n      break;\n    default:\n      jj_la1[8] = jj_gen;\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case E:\n      exppart = JsonExp();\n      break;\n    default:\n      jj_la1[9] = jj_gen;\n      ;\n    }\n    Number n;\n    if (exppart != null || fracpart != null) {\n      fracpart = (fracpart == null) ? \"\" : fracpart;\n      exppart = (exppart == null) ? \"\" : exppart;\n      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n    } else {\n      n = new java.math.BigInteger(intpart);\n    }\n    {if (true) return new JsonPrimitive(n);}\n    throw new Error(\"Missing return statement in function\");\n  }\n\nAfter Refactoring:\nfinal private JsonPrimitive JsonNumber() throws ParseException {\r\n  String intpart = null,\r\n         fracpart = null,\r\n         exppart = null;\r\n  JsonPrimitive value;\r\n    if (jj_2_1(2)) {\r\n      value = JsonSpecialNumbers();\r\n                                {if (true) return value;}\r\n    } else {\r\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n      case DIGITS:\r\n      case 31:\r\n        intpart = JsonInt();\r\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n        case 32:\r\n          fracpart = JsonFrac();\r\n          break;\r\n        default:\r\n          jj_la1[8] = jj_gen;\r\n          ;\r\n        }\r\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n        case E:\r\n          exppart = JsonExp();\r\n          break;\r\n        default:\r\n          jj_la1[9] = jj_gen;\r\n          ;\r\n        }\r\n    Number n;\r\n    if (exppart != null || fracpart != null) {\r\n      fracpart = (fracpart == null) ? \"\" : fracpart;\r\n      exppart = (exppart == null) ? \"\" : exppart;\r\n      n = new java.math.BigDecimal(intpart + fracpart + exppart);\r\n    } else {\r\n      n = new java.math.BigInteger(intpart);\r\n    }\r\n    {if (true) return new JsonPrimitive(n);}\r\n        break;\r\n      default:\r\n        jj_la1[10] = jj_gen;\r\n        jj_consume_token(-1);\r\n        throw new ParseException();\r\n      }\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n  }\n\nExtractedCodeFragments:\nfinal private JsonPrimitive JsonSpecialNumbers() throws ParseException {\r\n  boolean negative = false;\r\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n    case NAN:\r\n      jj_consume_token(NAN);\r\n           {if (true) return new JsonPrimitive(Double.NaN);}\r\n      break;\r\n    case INFINITY:\r\n    case 31:\r\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n      case 31:\r\n        jj_consume_token(31);\r\n         negative = true;\r\n        break;\r\n      default:\r\n        jj_la1[11] = jj_gen;\r\n        ;\r\n      }\r\n      jj_consume_token(INFINITY);\r\n                                        {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\r\n      break;\r\n    default:\r\n      jj_la1[12] = jj_gen;\r\n      jj_consume_token(-1);\r\n      throw new ParseException();\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n  }\nExample 3:\n Before Refactoring:\n\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    try {\n      if (src != null) {\n        JsonSerializationContext context = new JsonSerializationContextDefault(\n            createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n        JsonElement jsonElement = context.serialize(src, typeOfSrc);\n\n        if (generateNonExecutableJson) {\n          writer.append(JSON_NON_EXECUTABLE_PREFIX);\n        }\n        \n        formatter.format(jsonElement, writer, serializeNulls);\n      } else {\n        if (serializeNulls) {\n          writeOutNullString(writer);\n        }\n      }\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }\n\nAfter Refactoring:\n\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    try {\n      if (generateNonExecutableJson) {\n        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n      }\n      JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n      formatter.format(jsonElement, writer, serializeNulls);\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }\n\nExtractedCodeFragments:\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the \n   * specified object is a generic type. For non-generic objects, use {@link #toJson(Object)} \n   * instead. If you want to write out the object to a {@link Appendable}, \n   * use {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   */\n  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    if (src == null) {\n      return JsonNull.createJsonNull();\n    }\n    JsonSerializationContext context = new JsonSerializationContextDefault(\n        createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n    return context.serialize(src, typeOfSrc);\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "e7cf5c458374e5fc69dbdce6de5cb2c881521135",
        "url": "https://github.com/google/gson/commit/e7cf5c458374e5fc69dbdce6de5cb2c881521135",
        "sourceCodeBeforeRefactoring": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      \n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        \n        \n        Method accessor = null;\n        if (isRecord) {\n          \n          \n          \n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            \n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            \n            \n            \n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        \n        \n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, accessor, name,\n              TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n              + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n              + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n              + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }",
        "refactoredCode": "### Original Code:\n```java\nprivate Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        \n        Method accessor = null;\n        if (isRecord) {\n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, accessor, name,\n              TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n              + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n              + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n              + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n}\n```\n\n### Refactored Code:\n```java\nprivate Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n        return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n        Field[] fields = raw.getDeclaredFields();\n        handleReflectionAccessFilter(originalRaw, raw, fields);\n\n        for (Field field : fields) {\n            boolean serialize = includeField(field, true);\n            boolean deserialize = includeField(field, false);\n            if (!serialize && !deserialize) {\n                continue;\n            }\n\n            Method accessor = null;\n            if (isRecord) {\n                accessor = handleRecordField(raw, field, blockInaccessible, deserialize);\n                if (accessor == null) {\n                    deserialize = false;\n                }\n            }\n\n            if (!blockInaccessible && accessor == null) {\n                ReflectionHelper.makeAccessible(field);\n            }\n            processField(context, type, result, originalRaw, field, accessor, serialize, deserialize, blockInaccessible);\n        }\n        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw = type.getRawType();\n    }\n    return result;\n}\n\nprivate void handleReflectionAccessFilter(Class<?> originalRaw, Class<?> raw, Field[] fields) {\n    if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n            throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n                + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n                + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n    }\n}\n\nprivate Method handleRecordField(Class<?> raw, Field field, boolean blockInaccessible, boolean deserialize) {\n    if (Modifier.isStatic(field.getModifiers())) {\n        return null;\n    } else {\n        Method accessor = ReflectionHelper.getAccessor(raw, field);\n        if (!blockInaccessible) {\n            ReflectionHelper.makeAccessible(accessor);\n        }\n        validateSerializedName(accessor, field);\n        return accessor;\n    }\n}\n\nprivate void validateSerializedName(Method accessor, Field field) {\n    if (accessor.getAnnotation(SerializedName.class) != null && field.getAnnotation(SerializedName.class) == null) {\n        String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n    }\n}\n\nprivate void processField(Gson context, TypeToken<?> type, Map<String, BoundField> result, Class<?> originalRaw,\n                          Field field, Method accessor, boolean serialize, boolean deserialize, boolean blockInaccessible) {\n    Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n    List<String> fieldNames = getFieldNames(field);\n    BoundField previous = null;\n    for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n        String name = fieldNames.get(i);\n        if (i != 0) serialize = false; \n        BoundField boundField = createBoundField(context, field, accessor, name,\n            TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n        BoundField replaced = result.put(name, boundField);\n        if (previous == null) previous = replaced;\n    }\n    if (previous != null) {\n        throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n            + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n            + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n            + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: Created helper methods (`handleReflectionAccessFilter`, `handleRecordField`, `validateSerializedName`, and `processField`) to encapsulate specific logic, improving readability and maintainability.\n2. **Reduced Complexity**: Each method now has a single responsibility, making the main method `getBoundFields` easier to follow.\n3. **Improved Naming**: Method names were chosen to clearly indicate their purpose, enhancing code clarity.",
        "sourceCodeAfterRefactoring": "private FieldsData getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\n    if (raw.isInterface()) {\n      return FieldsData.EMPTY;\n    }\n\n    Map<String, BoundField> deserializedFields = new LinkedHashMap<>();\n    \n    Map<String, BoundField> serializedFields = new LinkedHashMap<>();\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      \n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        \n        \n        Method accessor = null;\n        if (isRecord) {\n          \n          \n          \n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            \n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            \n            \n            \n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        \n        \n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        String serializedName = fieldNames.get(0);\n        BoundField boundField = createBoundField(context, field, accessor, serializedName,\n            TypeToken.get(fieldType), serialize, blockInaccessible);\n\n        if (deserialize) {\n          for (String name : fieldNames) {\n            BoundField replaced = deserializedFields.put(name, boundField);\n\n            if (replaced != null) {\n              throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\n            }\n          }\n        }\n\n        if (serialize) {\n          BoundField replaced = serializedFields.put(serializedName, boundField);\n          if (replaced != null) {\n            throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\n          }\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static IllegalArgumentException createDuplicateFieldException(Class<?> declaringType, String duplicateName, Field field1, Field field2) {\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName()\n        + \" declares multiple JSON fields named '\" + duplicateName + \"'; conflict is caused\"\n        + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2)\n        + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n  }",
        "uniqueId": "e7cf5c458374e5fc69dbdce6de5cb2c881521135_236_318_247_252_254_344",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n  @Override\n  public void makeAccessible(AccessibleObject ao) {\n    if (theUnsafe != null && overrideField != null) {\n      long overrideOffset = theUnsafe.objectFieldOffset(overrideField);\n      theUnsafe.putBoolean(ao, overrideOffset, true);\n    }\n  }\n\nAfter Refactoring:\n\n  @Override\n  public void makeAccessible(AccessibleObject ao) {\n    boolean success = makeAccessibleWithUnsafe(ao);\n    if (!success) {\n      try {\n        \n        ao.setAccessible(true);\n      } catch (SecurityException e) {\n        throw new JsonIOException(\"Gson couldn't modify fields for \" + ao\n          + \"\\nand sun.misc.Unsafe not found.\\nEither write a custom type adapter,\"\n          + \" or make fields accessible, or include sun.misc.Unsafe.\", e);\n      }\n    }\n  }\n\nExtractedCodeFragments:\nboolean makeAccessibleWithUnsafe(AccessibleObject ao) {\n    if (theUnsafe != null && overrideField != null) {\n      try {\n        Method method = unsafeClass.getMethod(\"objectFieldOffset\", Field.class);\n        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);\n        Method putBooleanMethod = unsafeClass.getMethod(\"putBoolean\",  Object.class, long.class, boolean.class);\n        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);\n        return true;\n      } catch (Exception ignored) { // do nothing\n      }\n    }\n    return false;\n  }\nExample 2:\n Before Refactoring:\n\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    \n    Class<?> internalClass = Collections.emptyList().getClass();\n    try {\n      gson.fromJson(\"[]\", internalClass);\n      fail(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().startsWith(\"Failed making constructor 'java.util.Collections$EmptyList()' accessible;\"\n          + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n    }\n  }\n\nAfter Refactoring:\n\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    \n    Class<?> internalClass = Collections.emptyList().getClass();\n    JsonIOException exception = assertInaccessibleException(\"[]\", internalClass);\n    \n    assertThat(exception).hasMessageThat().startsWith(\"Failed making constructor '\");\n    assertThat(exception).hasMessageThat().contains(\"' accessible; either increase its visibility or\"\n        + \" write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n  }\n\nExtractedCodeFragments:\nprivate static JsonIOException assertInaccessibleException(String json, Class<?> toDeserialize) {\n    Gson gson = new Gson();\n    try {\n      gson.fromJson(json, toDeserialize);\n      throw new AssertionError(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().endsWith(\"\\nSee https://github.com/google/gson/blob/master/Troubleshooting.md#reflection-inaccessible\");\n      // Return exception for further assertions\n      return expected;\n    }\n  }\nExample 3:\n Before Refactoring:\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken);\n      return object;\n    } catch (EOFException e) {\n      \n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      \n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n\nAfter Refactoring:\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken.getRawType());\n      return object;\n    } catch (EOFException e) {\n      \n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      \n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n\nExtractedCodeFragments:\nprivate <T> void invokeInterceptorIfNeeded(T object, Type type) {\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(type);\n    Class<? super T> clazz = typeToken.getRawType();\n    invokeInterceptorIfNeeded(object, clazz);\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
        "url": "https://github.com/google/gson/commit/7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\") \n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
        "refactoredCode": "### Original Code:\n```java\n@SuppressWarnings(\"unchecked\") \n@Override\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n        return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}\n\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n        typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n        typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n        JsonSerializer<?> serializer = instance instanceof JsonSerializer\n            ? (JsonSerializer<?>) instance\n            : null;\n        JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n            ? (JsonDeserializer<?>) instance\n            : null;\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n        typeAdapter = tempAdapter;\n\n        nullSafe = false;\n    } else {\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n            + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n            + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n            + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n        typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n}\n```\n\n### Refactored Code:\n```java\n@SuppressWarnings(\"unchecked\") \n@Override\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n        return null;\n    }\n    return (TypeAdapter<T>) createTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}\n\nprivate TypeAdapter<?> createTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n    boolean nullSafe = annotation.nullSafe();\n    TypeAdapter<?> typeAdapter = getTypeAdapterFromInstance(instance, gson, type);\n\n    if (typeAdapter != null && nullSafe) {\n        typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n}\n\nprivate TypeAdapter<?> getTypeAdapterFromInstance(Object instance, Gson gson, TypeToken<?> type) {\n    if (instance instanceof TypeAdapter) {\n        return (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n        return ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n        return createTreeTypeAdapter(instance, gson, type);\n    } else {\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n            + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n            + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n            + \" JsonSerializer or JsonDeserializer.\");\n    }\n}\n\nprivate TypeAdapter<?> createTreeTypeAdapter(Object instance, Gson gson, TypeToken<?> type) {\n    JsonSerializer<?> serializer = instance instanceof JsonSerializer ? (JsonSerializer<?>) instance : null;\n    JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer ? (JsonDeserializer<?>) instance : null;\n    return new TreeTypeAdapter(serializer, deserializer, gson, type, null, false);\n}\n```\n\n### Summary of Changes:\n1. **Extracted Method**: The logic for creating a `TypeAdapter` from an instance has been extracted into a separate method `getTypeAdapterFromInstance` for better readability.\n2. **Extracted Tree Type Adapter Creation**: The creation of the `TreeTypeAdapter` has been moved to its own method `createTreeTypeAdapter` to reduce complexity in the main method.\n3. **Improved Readability**: The refactored code is more modular, making it easier to understand and maintain.",
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\") \n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = getAnnotation(rawType);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation, boolean isClassAnnotation) {\n    Object instance = createAdapter(constructorConstructor, annotation.value());\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      TypeAdapterFactory factory = (TypeAdapterFactory) instance;\n\n      if (isClassAnnotation) {\n        factory = putFactoryAndGetCurrent(type.getRawType(), factory);\n      }\n\n      typeAdapter = factory.create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      \n      \n      TypeAdapterFactory skipPast;\n      if (isClassAnnotation) {\n        skipPast = TREE_TYPE_CLASS_DUMMY_FACTORY;\n      } else {\n        skipPast = TREE_TYPE_FIELD_DUMMY_FACTORY;\n      }\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate JsonAdapter getAnnotation(Class<?> rawType) {\n    return rawType.getAnnotation(JsonAdapter.class);\n  }\nExtractedCodeFragments:\nprivate static Object createAdapter(ConstructorConstructor constructorConstructor, Class<?> adapterClass) {\n    \n    \n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\n  }",
        "uniqueId": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956_41_50_73_75_77_86",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> clazz = targetType.getRawType();\n    JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n    if (annotation == null) return null;\n    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n    ObjectConstructor<? extends TypeAdapter<?>> constructor = constructorConstructor.get(TypeToken.get(adapterClass));\n    TypeAdapter adapter = constructor.construct();\n    return adapter;\n  }\n\nAfter Refactoring:\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> clazz = targetType.getRawType();\n    JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n    if (annotation == null) return null;\n    TypeAdapter adapter = getAnnotationTypeAdapter(constructorConstructor, annotation);\n    return adapter;\n  }\n\nExtractedCodeFragments:\nstatic TypeAdapter<?> getAnnotationTypeAdapter(\n      ConstructorConstructor constructorConstructor, JsonAdapter annotation) {\n    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n    ObjectConstructor<? extends TypeAdapter<?>> constructor =\n        constructorConstructor.get(TypeToken.get(adapterClass));\n    return constructor.construct();\n  }\nExample 2:\n Before Refactoring:\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken);\n      return object;\n    } catch (EOFException e) {\n      \n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      \n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n\nAfter Refactoring:\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken.getRawType());\n      return object;\n    } catch (EOFException e) {\n      \n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      \n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n\nExtractedCodeFragments:\nprivate <T> void invokeInterceptorIfNeeded(T object, Type type) {\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(type);\n    Class<? super T> clazz = typeToken.getRawType();\n    invokeInterceptorIfNeeded(object, clazz);\n  }\nExample 3:\n Before Refactoring:\n\n  public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    @SuppressWarnings(\"unchecked\")\n    T target = (T) fromJson(reader, typeOfT);\n    return target;\n  }\n\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = newJsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    @SuppressWarnings(\"unchecked\")\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      @SuppressWarnings(\"unchecked\")\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      \n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      \n      throw new JsonSyntaxException(e);\n    } catch (AssertionError e) {\n      AssertionError error = new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage());\n      error.initCause(e);\n      throw error;\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n\n  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return (T) fromJson(new JsonTreeReader(json), typeOfT);\n  }\n\nAfter Refactoring:\n\n  public <T> T fromJson(String json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    return fromJson(reader, typeOfT);\n  }\n\n  public <T> T fromJson(String json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    return fromJson(reader, typeOfT);\n  }\n\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    T object = fromJson(json, TypeToken.get(classOfT));\n    return Primitives.wrap(classOfT).cast(object);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    return (T) fromJson(json, TypeToken.get(typeOfT));\n  }\n\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n\n  public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return fromJson(new JsonTreeReader(json), typeOfT);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    return (T) fromJson(json, TypeToken.get(typeOfT));\n  }\n\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * Reads the next JSON value from {@code reader} and converts it to an object\n   * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\n   * This method is useful if the specified object is a generic type. For non-generic objects,\n   * {@link #fromJson(JsonReader, Type)} can be called, or {@link TypeToken#get(Class)} can\n   * be used to create the type token.\n   *\n   * <p>Unlike the other {@code fromJson} methods, no exception is thrown if the JSON data has\n   * multiple top-level JSON elements, or if there is trailing data.\n   *\n   * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},\n   * regardless of the lenient mode setting of the provided reader. The lenient mode setting\n   * of the reader is restored once this method returns.\n   *\n   * @param <T> the type of the desired object\n   * @param reader the reader whose next JSON value should be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the JsonReader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonReader, Type)\n   */\n  public <T> T fromJson(JsonReader reader, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeAdapter<T> typeAdapter = getAdapter(typeOfT);\n      T object = typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } catch (AssertionError e) {\n      AssertionError error = new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage());\n      error.initCause(e);\n      throw error;\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonElement, Class)\n   */\n  public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return fromJson(new JsonTreeReader(json), typeOfT);\n  }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "b3dce2dc17086c72bd1f8ccf508874849f9631bb",
        "url": "https://github.com/google/gson/commit/b3dce2dc17086c72bd1f8ccf508874849f9631bb",
        "sourceCodeBeforeRefactoring": "\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }",
        "refactoredCode": "### Original Code:\n```java\npublic final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n}\n```\n\n### Refactored Code:\n```java\npublic final void setLenientMode(boolean isLenient) {\n    this.lenient = isLenient;\n}\n```\n\nIn the refactored code, I changed the method parameter name from `lenient` to `isLenient` to improve clarity, indicating that it is a boolean flag. The method name was also modified to `setLenientMode` to better reflect its purpose.",
        "sourceCodeAfterRefactoring": "\n  @Deprecated\n  @SuppressWarnings(\"InlineMeSuggester\") \n  public final void setLenient(boolean lenient) {\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\n\n  public final void setStrictness(Strictness strictness) {\n    this.strictness = Objects.requireNonNull(strictness);\n  }",
        "uniqueId": "b3dce2dc17086c72bd1f8ccf508874849f9631bb_270_282_298_320_271_287",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic void testFailWithPosition() throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }\n\nAfter Refactoring:\npublic void testFailWithPosition() throws IOException {\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\\n\\n\\n0,}]\");\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n  }\n\nExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }\nExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }\nExample 2:\n Before Refactoring:\nprivate void breakLineIfNeeded() throws IOException {\n      if (getLine().length() > printMargin - rightMargin) {\n        finishLine();\n      }\n    }\n\nAfter Refactoring:\nprivate void breakLineIfNeeded() throws IOException {\n      breakLineIfThisToNextExceedsLimit(0);\n    }\n\nExtractedCodeFragments:\nprivate void breakLineIfThisToNextExceedsLimit(int nextLength) throws IOException {\n        if (getLine().length() + nextLength > printMargin - rightMargin) {\n          finishLine();\n        }\n      }\nExample 3:\n Before Refactoring:\nprivate void assertAvlBuilder(int size, String expected) {\n    char[] values = \"abcdefghijklmnopqrstuvwxyzABCDE\".toCharArray();\n    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();\n    avlBuilder.reset(size);\n    for (int i = 0; i < size; i++) {\n      avlBuilder.add(node(Character.toString(values[i])));\n    }\n    assertEquals(expected, toString(avlBuilder.root()));\n  }\npublic void testDoubleCapacity() {\n    @SuppressWarnings(\"unchecked\") \n    Node<String, String>[] oldTable = new Node[1];\n    oldTable[0] = node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\")));\n\n    Node<String, String>[] newTable = LinkedTreeMap.doubleCapacity(oldTable);\n    assertEquals(\"(b d f)\", toString(newTable[0])); \n    assertEquals(\"(a c (. e g))\", toString(newTable[1])); \n  }\n\nAfter Refactoring:\nprivate void assertAvlBuilder(int size, String expected) {\n    char[] values = \"abcdefghijklmnopqrstuvwxyzABCDE\".toCharArray();\n    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();\n    avlBuilder.reset(size);\n    for (int i = 0; i < size; i++) {\n      avlBuilder.add(node(Character.toString(values[i])));\n    }\n    assertTree(expected, avlBuilder.root());\n  }\npublic void testDoubleCapacity() {\n    @SuppressWarnings(\"unchecked\") \n    Node<String, String>[] oldTable = new Node[1];\n    oldTable[0] = node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\")));\n\n    Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);\n    assertTree(\"(b d f)\", newTable[0]); \n    assertTree(\"(a c (. e g))\", newTable[1]); \n\n    for (Node<?, ?> node : newTable) {\n      if (node != null) {\n        assertConsistent(node);\n      }\n    }\n  }\n\nExtractedCodeFragments:\nprivate void assertTree(String expected, Node<?, ?> root) {\n    assertEquals(expected, toString(root));\n    assertConsistent(root);\n  }\nExtractedCodeFragments:\nprivate void assertTree(String expected, Node<?, ?> root) {\n    assertEquals(expected, toString(root));\n    assertConsistent(root);\n  }"
    }
]
[
    {
        "url": "https://github.com/wordpress-mobile/WordPress-Android.git",
        "branch": "master",
        "commitId": "4bfe164cc8b4556b98df18098b162e0a84038b32",
        "sourceCodeBeforeRefactoring": "@Override\n    protected void onResume() {\n        super.onResume();\n\n        // Start listening to Simperium Note bucket\n        if (SimperiumUtils.getNotesBucket() != null) {\n            SimperiumUtils.getNotesBucket().addListener(this);\n        }\n        checkNoteBadge();\n\n        // We need to track the current item on the screen when this activity is resumed.\n        // Ex: Notifications -> notifications detail -> back to notifications\n        int position = (mViewPager.getCurrentItem());\n        switch (position) {\n            case WPMainTabAdapter.TAB_MY_SITE:\n                ActivityId.trackLastActivity(ActivityId.MY_SITE);\n                break;\n            case WPMainTabAdapter.TAB_READER:\n                ActivityId.trackLastActivity(ActivityId.READER);\n                break;\n            case WPMainTabAdapter.TAB_ME:\n                ActivityId.trackLastActivity(ActivityId.ME);\n                break;\n            case WPMainTabAdapter.TAB_NOTIFS:\n                ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n                break;\n            default:\n                break;\n        }\n    }",
        "refactoredCode": "### Original Code:\n```java\n@Override\nprotected void onResume() {\n    super.onResume();\n\n    // Start listening to Simperium Note bucket\n    if (SimperiumUtils.getNotesBucket() != null) {\n        SimperiumUtils.getNotesBucket().addListener(this);\n    }\n    checkNoteBadge();\n\n    // We need to track the current item on the screen when this activity is resumed.\n    // Ex: Notifications -> notifications detail -> back to notifications\n    int position = (mViewPager.getCurrentItem());\n    switch (position) {\n        case WPMainTabAdapter.TAB_MY_SITE:\n            ActivityId.trackLastActivity(ActivityId.MY_SITE);\n            break;\n        case WPMainTabAdapter.TAB_READER:\n            ActivityId.trackLastActivity(ActivityId.READER);\n            break;\n        case WPMainTabAdapter.TAB_ME:\n            ActivityId.trackLastActivity(ActivityId.ME);\n            break;\n        case WPMainTabAdapter.TAB_NOTIFS:\n            ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n            break;\n        default:\n            break;\n    }\n}\n```\n\n### Refactored Code:\n```java\n@Override\nprotected void onResume() {\n    super.onResume();\n    startListeningToNotesBucket();\n    checkNoteBadge();\n    trackCurrentActivity();\n}\n\nprivate void startListeningToNotesBucket() {\n    if (SimperiumUtils.getNotesBucket() != null) {\n        SimperiumUtils.getNotesBucket().addListener(this);\n    }\n}\n\nprivate void trackCurrentActivity() {\n    int position = mViewPager.getCurrentItem();\n    switch (position) {\n        case WPMainTabAdapter.TAB_MY_SITE:\n            ActivityId.trackLastActivity(ActivityId.MY_SITE);\n            break;\n        case WPMainTabAdapter.TAB_READER:\n            ActivityId.trackLastActivity(ActivityId.READER);\n            break;\n        case WPMainTabAdapter.TAB_ME:\n            ActivityId.trackLastActivity(ActivityId.ME);\n            break;\n        case WPMainTabAdapter.TAB_NOTIFS:\n            ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n            break;\n        default:\n            break;\n    }\n}\n```\n\n### Explanation of Refactoring:\n1. **Method Extraction**: The original `onResume` method was broken down into three smaller methods:\n   - `startListeningToNotesBucket()`: Handles the logic for starting to listen to the Simperium Note bucket.\n   - `checkNoteBadge()`: This method remains unchanged and is called directly.\n   - `trackCurrentActivity()`: Contains the logic for tracking the current activity based on the position of the `ViewPager`.\n\n2. **Single Responsibility**: Each extracted method now has a single responsibility, making the code easier to read and maintain.\n\n3. **Functionality Unchanged**: The refactored code maintains the same functionality as the original code, ensuring that the behavior of the `onResume` method remains consistent.",
        "sourceCodeAfterRefactoring": "@Override\n    protected void onResume() {\n        super.onResume();\n\n        // Start listening to Simperium Note bucket\n        if (SimperiumUtils.getNotesBucket() != null) {\n            SimperiumUtils.getNotesBucket().addListener(this);\n        }\n        checkNoteBadge();\n\n        // We need to track the current item on the screen when this activity is resumed.\n        // Ex: Notifications -> notifications detail -> back to notifications\n       trackLastVisibleTab(mViewPager.getCurrentItem());\n    }\nprivate void trackLastVisibleTab(int position) {\n        switch (position) {\n            case WPMainTabAdapter.TAB_MY_SITE:\n                ActivityId.trackLastActivity(ActivityId.MY_SITE);\n                break;\n            case WPMainTabAdapter.TAB_READER:\n                ActivityId.trackLastActivity(ActivityId.READER);\n                break;\n            case WPMainTabAdapter.TAB_ME:\n                ActivityId.trackLastActivity(ActivityId.ME);\n                break;\n            case WPMainTabAdapter.TAB_NOTIFS:\n                ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n                break;\n            default:\n                break;\n        }\n    }",
        "diffSourceCode": "-  247:     @Override\n-  248:     protected void onResume() {\n-  249:         super.onResume();\n-  250: \n-  251:         // Start listening to Simperium Note bucket\n-  252:         if (SimperiumUtils.getNotesBucket() != null) {\n-  253:             SimperiumUtils.getNotesBucket().addListener(this);\n-  254:         }\n-  255:         checkNoteBadge();\n-  256: \n-  257:         // We need to track the current item on the screen when this activity is resumed.\n-  258:         // Ex: Notifications -> notifications detail -> back to notifications\n-  259:         int position = (mViewPager.getCurrentItem());\n-  260:         switch (position) {\n-  261:             case WPMainTabAdapter.TAB_MY_SITE:\n-  262:                 ActivityId.trackLastActivity(ActivityId.MY_SITE);\n-  263:                 break;\n-  264:             case WPMainTabAdapter.TAB_READER:\n-  265:                 ActivityId.trackLastActivity(ActivityId.READER);\n-  266:                 break;\n-  267:             case WPMainTabAdapter.TAB_ME:\n-  268:                 ActivityId.trackLastActivity(ActivityId.ME);\n-  269:                 break;\n-  270:             case WPMainTabAdapter.TAB_NOTIFS:\n-  271:                 ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n-  272:                 break;\n-  273:             default:\n-  274:                 break;\n-  275:         }\n-  276:     }\n-  277: \n-  278:     /*\n-  279:      * re-create the fragment adapter so all its fragments are also re-created - used when\n-  280:      * user signs in/out so the fragments reflect the active account\n+  247: \n+  248:     @Override\n+  249:     protected void onResume() {\n+  250:         super.onResume();\n+  251: \n+  252:         // Start listening to Simperium Note bucket\n+  253:         if (SimperiumUtils.getNotesBucket() != null) {\n+  254:             SimperiumUtils.getNotesBucket().addListener(this);\n+  255:         }\n+  256:         checkNoteBadge();\n+  257: \n+  258:         // We need to track the current item on the screen when this activity is resumed.\n+  259:         // Ex: Notifications -> notifications detail -> back to notifications\n+  260:        trackLastVisibleTab(mViewPager.getCurrentItem());\n+  261:     }\n+  262: \n+  263:     private void trackLastVisibleTab(int position) {\n+  264:         switch (position) {\n+  265:             case WPMainTabAdapter.TAB_MY_SITE:\n+  266:                 ActivityId.trackLastActivity(ActivityId.MY_SITE);\n+  267:                 break;\n+  268:             case WPMainTabAdapter.TAB_READER:\n+  269:                 ActivityId.trackLastActivity(ActivityId.READER);\n+  270:                 break;\n+  271:             case WPMainTabAdapter.TAB_ME:\n+  272:                 ActivityId.trackLastActivity(ActivityId.ME);\n+  273:                 break;\n+  274:             case WPMainTabAdapter.TAB_NOTIFS:\n+  275:                 ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n+  276:                 break;\n+  277:             default:\n+  278:                 break;\n+  279:         }\n+  280:     }\n",
        "uniqueId": "4bfe164cc8b4556b98df18098b162e0a84038b32_247_276_263_280_248_261",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param editValue the protection type\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n     */\n    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n                                        String password, HashAlgorithm hashAlgo) {\n    \t\n        safeGetDocumentProtection().setEnforcement(true);    \t\n        safeGetDocumentProtection().setEdit(editValue);\n        \n        // Word 2010 doesn't enforce TRACKED_CHANGES,\n        // unless <w:trackRevisions/> is also set!\n        if (editValue==STDocProtect.TRACKED_CHANGES) {\n        \tif (this.jaxbElement.getTrackRevisions()==null) {\n        \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n        \t}\n        }\n\n        if (password == null) {\n        \t// unset\n            safeGetDocumentProtection().setCryptProviderType(null);\n            safeGetDocumentProtection().setCryptAlgorithmClass(null);\n            safeGetDocumentProtection().setCryptAlgorithmType(null);\n            safeGetDocumentProtection().setCryptAlgorithmSid(null);\n            safeGetDocumentProtection().setSalt(null);\n            safeGetDocumentProtection().setCryptSpinCount(null);\n            safeGetDocumentProtection().setHash(null);\n            \n            return;\n            \n        } else {\n            final STCryptProv providerType;\n            final int sid;\n            switch (hashAlgo) {\n                case md2:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 1;\n                    break;\n                case md4:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 2;\n                    break;\n                case md5:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 3;\n                    break;\n                case sha1:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 4;\n                    break;\n                case sha256:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 12;\n                    break;\n                case sha384:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 13;\n                    break;\n                case sha512:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 14;\n                    break;\n                default:\n                    throw new EncryptedDocumentException\n                            (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n            }\n\n\n            SecureRandom random = new SecureRandom();\n            byte salt[] = random.generateSeed(16);\n\n            // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n            // iteration's result as the input for the next iteration).\n            int spinCount = 100000;\n\n            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n\n            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n            // Implementation Notes List:\n            // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n            //     be converted to Unicode hex string representation\n            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n\n            safeGetDocumentProtection().setSalt(salt);\n            safeGetDocumentProtection().setHash(hash);\n            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n            safeGetDocumentProtection().setCryptProviderType(providerType);\n            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n        }\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param editValue the protection type\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n\t * @since 3.3.0\n     */\n    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n                                        String password, HashAlgorithm hashAlgo) {\n    \t\n        safeGetDocumentProtection().setEnforcement(true);    \t\n        safeGetDocumentProtection().setEdit(editValue);\n        \n        // Word 2010 doesn't enforce TRACKED_CHANGES,\n        // unless <w:trackRevisions/> is also set!\n        if (editValue==STDocProtect.TRACKED_CHANGES) {\n        \tif (this.jaxbElement.getTrackRevisions()==null) {\n        \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n        \t}\n        }\n\n        setProtectionPassword(password, hashAlgo);\n    }\n/**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n\t * @since 3.3.0\n     */\n    private void setProtectionPassword(String password, HashAlgorithm hashAlgo) {\n\n        if (password == null) {\n        \t// unset\n            safeGetDocumentProtection().setCryptProviderType(null);\n            safeGetDocumentProtection().setCryptAlgorithmClass(null);\n            safeGetDocumentProtection().setCryptAlgorithmType(null);\n            safeGetDocumentProtection().setCryptAlgorithmSid(null);\n            safeGetDocumentProtection().setSalt(null);\n            safeGetDocumentProtection().setCryptSpinCount(null);\n            safeGetDocumentProtection().setHash(null);\n            \n            return;\n            \n        } else {\n            final STCryptProv providerType;\n            final int sid;\n            switch (hashAlgo) {\n                case md2:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 1;\n                    break;\n                case md4:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 2;\n                    break;\n                case md5:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 3;\n                    break;\n                case sha1:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 4;\n                    break;\n                case sha256:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 12;\n                    break;\n                case sha384:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 13;\n                    break;\n                case sha512:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 14;\n                    break;\n                default:\n                    throw new EncryptedDocumentException\n                            (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n            }\n\n\n            SecureRandom random = new SecureRandom();\n            byte salt[] = random.generateSeed(16);\n\n            // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n            // iteration's result as the input for the next iteration).\n            int spinCount = 100000;\n\n            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n\n            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n            // Implementation Notes List:\n            // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n            //     be converted to Unicode hex string representation\n            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n\n            safeGetDocumentProtection().setSalt(salt);\n            safeGetDocumentProtection().setHash(hash);\n            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n            safeGetDocumentProtection().setCryptProviderType(providerType);\n            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n        }\n    }\n DiffSourceCode:\n-  238:     /**\n-  239:      * Enforces the protection with the option specified by passed editValue, password, and \n-  240:      * HashAlgorithm for the password.\n-  241: \n-  242:      *\n-  243:      * @param editValue the protection type\n-  244:      * @param password  the plaintext password, if null no password will be applied\n-  245:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n-  246:      *                  if null, it will default default to sha1\n-  247:      */\n-  248:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n-  249:                                         String password, HashAlgorithm hashAlgo) {\n-  250:     \t\n-  251:         safeGetDocumentProtection().setEnforcement(true);    \t\n-  252:         safeGetDocumentProtection().setEdit(editValue);\n-  253:         \n-  254:         // Word 2010 doesn't enforce TRACKED_CHANGES,\n-  255:         // unless <w:trackRevisions/> is also set!\n-  256:         if (editValue==STDocProtect.TRACKED_CHANGES) {\n-  257:         \tif (this.jaxbElement.getTrackRevisions()==null) {\n-  258:         \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n-  259:         \t}\n-  260:         }\n-  261: \n-  262:         if (password == null) {\n-  263:         \t// unset\n-  264:             safeGetDocumentProtection().setCryptProviderType(null);\n-  265:             safeGetDocumentProtection().setCryptAlgorithmClass(null);\n-  266:             safeGetDocumentProtection().setCryptAlgorithmType(null);\n-  267:             safeGetDocumentProtection().setCryptAlgorithmSid(null);\n-  268:             safeGetDocumentProtection().setSalt(null);\n-  269:             safeGetDocumentProtection().setCryptSpinCount(null);\n-  270:             safeGetDocumentProtection().setHash(null);\n-  271:             \n-  272:             return;\n-  273:             \n-  274:         } else {\n-  275:             final STCryptProv providerType;\n-  276:             final int sid;\n-  277:             switch (hashAlgo) {\n-  278:                 case md2:\n-  279:                     providerType = STCryptProv.RSA_FULL;\n-  280:                     sid = 1;\n-  281:                     break;\n-  282:                 case md4:\n-  283:                     providerType = STCryptProv.RSA_FULL;\n-  284:                     sid = 2;\n-  285:                     break;\n-  286:                 case md5:\n-  287:                     providerType = STCryptProv.RSA_FULL;\n-  288:                     sid = 3;\n-  289:                     break;\n-  290:                 case sha1:\n-  291:                     providerType = STCryptProv.RSA_FULL;\n-  292:                     sid = 4;\n-  293:                     break;\n-  294:                 case sha256:\n-  295:                     providerType = STCryptProv.RSA_AES;\n-  296:                     sid = 12;\n-  297:                     break;\n-  298:                 case sha384:\n-  299:                     providerType = STCryptProv.RSA_AES;\n-  300:                     sid = 13;\n-  301:                     break;\n-  302:                 case sha512:\n-  303:                     providerType = STCryptProv.RSA_AES;\n-  304:                     sid = 14;\n-  305:                     break;\n-  306:                 default:\n-  307:                     throw new EncryptedDocumentException\n-  308:                             (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n-  309:             }\n-  310: \n-  311: \n-  312:             SecureRandom random = new SecureRandom();\n-  313:             byte salt[] = random.generateSeed(16);\n-  314: \n-  315:             // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n-  316:             // iteration's result as the input for the next iteration).\n-  317:             int spinCount = 100000;\n-  318: \n-  319:             if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n-  320: \n-  321:             String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n-  322:             // Implementation Notes List:\n-  323:             // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n-  324:             //     be converted to Unicode hex string representation\n-  325:             byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n+  238:      * Verifies the documentProtection tag inside settings.xml file \n+  239:      * if the protection is enforced (w:enforcement=\"1\") \n+  240:      * and if the kind of protection equals to passed (STDocProtect.Enum editValue) \n+  241:      *\n+  242:      * @return true if documentProtection is enforced with option readOnly\n+  243: \t * @since 3.3.0\n+  244:      */\n+  245:     public boolean isEnforcedWith(STDocProtect editValue) {\n+  246:         CTDocProtect ctDocProtect = this.jaxbElement.getDocumentProtection();\n+  247: \n+  248:         if (ctDocProtect == null) {\n+  249:             return false;\n+  250:         }\n+  251: \n+  252:         return ctDocProtect.isEnforcement() && ctDocProtect.getEdit().equals(editValue);\n+  253:     }\n+  254:     \n+  255: \n+  256:     /**\n+  257:      * Enforces the protection with the option specified by passed editValue.<br/>\n+  258:      * <br/>\n+  259:      * In the documentProtection tag inside settings.xml file <br/>\n+  260:      * it sets the value of enforcement to \"1\" (w:enforcement=\"1\") <br/>\n+  261:      * and the value of edit to the passed editValue (w:edit=\"[passed editValue]\")<br/>\n+  262:      * <br/>\n+  263:      * sample snippet from settings.xml\n+  264:      * <pre>\n+  265:      *     &lt;w:settings  ... &gt;\n+  266:      *         &lt;w:documentProtection w:edit=&quot;[passed editValue]&quot; w:enforcement=&quot;1&quot;/&gt;\n+  267:      * </pre>\n+  268: \t * @since 3.3.0\n+  269:      */\n+  270:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue) {\n+  271:     \t\n+  272:     \tsetEnforcementEditValue(editValue, null, null);\n+  273:     }\n+  274: \n+  275:     /**\n+  276:      * Enforces the protection with the option specified by passed editValue and password,\n+  277:      * using rsaFull (sha1) (like Word 2010).\n+  278:      * \n+  279:      * WARNING: this functionality may give a false sense of security, since it only affects\n+  280:      * the behaviour of Word's user interface. A mischevious user could still edit the document\n+  281:      * in some other program, and subsequent users would *not* be warned it has been tampered with. \n+  282:      *\n+  283:      * @param editValue the protection type\n+  284:      * @param password  the plaintext password, if null no password will be applied\n+  285:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  286:      *                  if null, it will default default to sha1\n+  287: \t * @since 3.3.0\n+  288:      */\n+  289:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n+  290:                                         String password) {\n+  291: \n+  292:     \tsetEnforcementEditValue(editValue, password, HashAlgorithm.sha1);\n+  293:     }\n+  294: \n+  295:     /**\n+  296:      * Enforces the protection with the option specified by passed editValue, password, and \n+  297:      * HashAlgorithm for the password.\n+  298: \n+  299:      *\n+  300:      * @param editValue the protection type\n+  301:      * @param password  the plaintext password, if null no password will be applied\n+  302:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  303:      *                  if null, it will default default to sha1\n+  304: \t * @since 3.3.0\n+  305:      */\n+  306:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n+  307:                                         String password, HashAlgorithm hashAlgo) {\n+  308:     \t\n+  309:         safeGetDocumentProtection().setEnforcement(true);    \t\n+  310:         safeGetDocumentProtection().setEdit(editValue);\n+  311:         \n+  312:         // Word 2010 doesn't enforce TRACKED_CHANGES,\n+  313:         // unless <w:trackRevisions/> is also set!\n+  314:         if (editValue==STDocProtect.TRACKED_CHANGES) {\n+  315:         \tif (this.jaxbElement.getTrackRevisions()==null) {\n+  316:         \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n+  317:         \t}\n+  318:         }\n+  319: \n+  320:         setProtectionPassword(password, hashAlgo);\n+  321:     }\n+  322:     \n+  323:     /**\n+  324:      * Enforces the protection with the option specified by passed editValue, password, and \n+  325:      * HashAlgorithm for the password.\n   326: \n-  327:             safeGetDocumentProtection().setSalt(salt);\n-  328:             safeGetDocumentProtection().setHash(hash);\n-  329:             safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n-  330:             safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n-  331:             safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n-  332:             safeGetDocumentProtection().setCryptProviderType(providerType);\n-  333:             safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n-  334:         }\n-  335:     }\n-  336: \n-  337:     /**\n-  338:      * Validates the existing password\n-  339:      *\n-  340:      * @param password\n-  341:      * @return true, only if password was set and equals, false otherwise\n-  342:      */\n-  343:     public boolean validateProtectionPassword(String password) {\n-  344:         BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();\n-  345:         byte hash[] = safeGetDocumentProtection().getHash();\n-  346:         byte salt[] = safeGetDocumentProtection().getSalt();\n-  347:         BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();\n-  348: \n-  349:         if (sid == null || hash == null || salt == null || spinCount == null) return false;\n-  350: \n-  351:         HashAlgorithm hashAlgo;\n-  352:         switch (sid.intValue()) {\n-  353:             case 1:\n-  354:                 hashAlgo = HashAlgorithm.md2;\n-  355:                 break;\n-  356:             case 2:\n-  357:                 hashAlgo = HashAlgorithm.md4;\n-  358:                 break;\n-  359:             case 3:\n-  360:                 hashAlgo = HashAlgorithm.md5;\n-  361:                 break;\n-  362:             case 4:\n-  363:                 hashAlgo = HashAlgorithm.sha1;\n-  364:                 break;\n-  365:             case 12:\n-  366:                 hashAlgo = HashAlgorithm.sha256;\n-  367:                 break;\n-  368:             case 13:\n-  369:                 hashAlgo = HashAlgorithm.sha384;\n-  370:                 break;\n-  371:             case 14:\n-  372:                 hashAlgo = HashAlgorithm.sha512;\n-  373:                 break;\n-  374:             default:\n-  375:                 return false;\n-  376:         }\n-  377: \n-  378:         String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n-  379:         // Implementation Notes List:\n-  380:         // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n-  381:         //     be converted to Unicode hex string representation\n-  382:         byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);\n+  327:      *\n+  328:      * @param password  the plaintext password, if null no password will be applied\n+  329:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  330:      *                  if null, it will default default to sha1\n+  331: \t * @since 3.3.0\n+  332:      */\n+  333:     private void setProtectionPassword(String password, HashAlgorithm hashAlgo) {\n+  334: \n+  335:         if (password == null) {\n+  336:         \t// unset\n+  337:             safeGetDocumentProtection().setCryptProviderType(null);\n+  338:             safeGetDocumentProtection().setCryptAlgorithmClass(null);\n+  339:             safeGetDocumentProtection().setCryptAlgorithmType(null);\n+  340:             safeGetDocumentProtection().setCryptAlgorithmSid(null);\n+  341:             safeGetDocumentProtection().setSalt(null);\n+  342:             safeGetDocumentProtection().setCryptSpinCount(null);\n+  343:             safeGetDocumentProtection().setHash(null);\n+  344:             \n+  345:             return;\n+  346:             \n+  347:         } else {\n+  348:             final STCryptProv providerType;\n+  349:             final int sid;\n+  350:             switch (hashAlgo) {\n+  351:                 case md2:\n+  352:                     providerType = STCryptProv.RSA_FULL;\n+  353:                     sid = 1;\n+  354:                     break;\n+  355:                 case md4:\n+  356:                     providerType = STCryptProv.RSA_FULL;\n+  357:                     sid = 2;\n+  358:                     break;\n+  359:                 case md5:\n+  360:                     providerType = STCryptProv.RSA_FULL;\n+  361:                     sid = 3;\n+  362:                     break;\n+  363:                 case sha1:\n+  364:                     providerType = STCryptProv.RSA_FULL;\n+  365:                     sid = 4;\n+  366:                     break;\n+  367:                 case sha256:\n+  368:                     providerType = STCryptProv.RSA_AES;\n+  369:                     sid = 12;\n+  370:                     break;\n+  371:                 case sha384:\n+  372:                     providerType = STCryptProv.RSA_AES;\n+  373:                     sid = 13;\n+  374:                     break;\n+  375:                 case sha512:\n+  376:                     providerType = STCryptProv.RSA_AES;\n+  377:                     sid = 14;\n+  378:                     break;\n+  379:                 default:\n+  380:                     throw new EncryptedDocumentException\n+  381:                             (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n+  382:             }\n   383: \n-  384:         return Arrays.equals(hash, hash2);\n-  385:     }\n-  386: \n-  387:     /**\n-  388:      * Removes protection enforcement.<br/>\n-  389:      * In the documentProtection tag inside settings.xml file <br/>\n-  390:      * it sets the value of enforcement to \"0\" (w:enforcement=\"0\") <br/>\n-  391:      */\n-  392:     public void removeEnforcement() {\n-  393: //        safeGetDocumentProtection().setEnforcement(STOnOff.X_0);\n-  394:         safeGetDocumentProtection().setEnforcement(false);    \t\n-  395:     }\t\n-  396:     \n-  397:     private CTDocProtect safeGetDocumentProtection() {\n-  398:     \t\n-  399:     \tif (this.getJaxbElement()==null) {\n-  400:     \t\tthis.jaxbElement=new CTSettings();\n-  401:     \t}\n-  402:     \t\n-  403:         CTDocProtect documentProtection = this.jaxbElement.getDocumentProtection();\n-  404:         if (documentProtection == null) {\n-  405:             documentProtection = Context.getWmlObjectFactory().createCTDocProtect();\n-  406:             this.jaxbElement.setDocumentProtection(documentProtection);\n+  384: \n+  385:             SecureRandom random = new SecureRandom();\n+  386:             byte salt[] = random.generateSeed(16);\n+  387: \n+  388:             // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n+  389:             // iteration's result as the input for the next iteration).\n+  390:             int spinCount = 100000;\n+  391: \n+  392:             if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n+  393: \n+  394:             String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n+  395:             // Implementation Notes List:\n+  396:             // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n+  397:             //     be converted to Unicode hex string representation\n+  398:             byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n+  399: \n+  400:             safeGetDocumentProtection().setSalt(salt);\n+  401:             safeGetDocumentProtection().setHash(hash);\n+  402:             safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n+  403:             safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n+  404:             safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n+  405:             safeGetDocumentProtection().setCryptProviderType(providerType);\n+  406:             safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n   407:         }\n-  408:         return this.jaxbElement.getDocumentProtection();\n+  408:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n     * checks if Tor is enabled and if it is, that Orbot is installed and runnign. Generates appropriate dialogs.\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param proxyPrefs\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n        Handler ignoreTorHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                // every message received by this handler will mean  the middle button was pressed\n                middleButtonRunnable.run();\n            }\n        };\n\n        if (!proxyPrefs.torEnabled) {\n            return true;\n        }\n\n        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n\n            OrbotHelper.getInstallDialogFragmentWithThirdButton(\n                    new Messenger(ignoreTorHandler),\n                    middleButton\n            ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n\n            return false;\n        } else if (!OrbotHelper.isOrbotRunning()) {\n\n            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n                    middleButton)\n                    .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n\n            return false;\n        } else {\n            return true;\n        }\n    }\n SourceCodeAfterRefactoring:\n/**\n     * checks if Tor is enabled and if it is, that Orbot is installed and running. Generates appropriate dialogs.\n     * Convenience function for isOrbotinRequiredState(int, Runnable, FragmentActivity) by checking for tor being\n     * enabled internally\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param proxyPrefs\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n\n        if (!proxyPrefs.torEnabled) {\n            return true;\n        } else {\n            return isOrbotInRequiredState(middleButton, middleButtonRunnable, fragmentActivity);\n        }\n\n    }\n/**\n     * checks if Orbot is installed and running. Generates appropriate dialogs.\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 FragmentActivity fragmentActivity) {\n        Handler ignoreTorHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                // every message received by this handler will mean  the middle button was pressed\n                middleButtonRunnable.run();\n            }\n        };\n\n        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n\n            OrbotHelper.getInstallDialogFragmentWithThirdButton(\n                    new Messenger(ignoreTorHandler),\n                    middleButton\n            ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n\n            return false;\n        } else if (!OrbotHelper.isOrbotRunning()) {\n\n            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n                    middleButton)\n                    .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n\n            return false;\n        } else {\n            return true;\n        }\n    }\n DiffSourceCode:\n   137:     /**\n-  138:      * checks if Tor is enabled and if it is, that Orbot is installed and runnign. Generates appropriate dialogs.\n-  139:      *\n-  140:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n-  141:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n-  142:      * @param proxyPrefs\n-  143:      * @param fragmentActivity\n-  144:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n-  145:      */\n-  146:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n-  147:                                                  Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n-  148:         Handler ignoreTorHandler = new Handler() {\n-  149:             @Override\n-  150:             public void handleMessage(Message msg) {\n-  151:                 // every message received by this handler will mean  the middle button was pressed\n-  152:                 middleButtonRunnable.run();\n-  153:             }\n-  154:         };\n-  155: \n-  156:         if (!proxyPrefs.torEnabled) {\n-  157:             return true;\n-  158:         }\n-  159: \n-  160:         if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n-  161: \n-  162:             OrbotHelper.getInstallDialogFragmentWithThirdButton(\n-  163:                     new Messenger(ignoreTorHandler),\n-  164:                     middleButton\n-  165:             ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n-  166: \n-  167:             return false;\n-  168:         } else if (!OrbotHelper.isOrbotRunning()) {\n-  169: \n-  170:             OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n-  171:                     middleButton)\n-  172:                     .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n-  173: \n-  174:             return false;\n-  175:         } else {\n-  176:             return true;\n-  177:         }\n-  178:     }\n-  179: \n-  180:     // TODO: PHILIP return an Intent to required dialog activity\n-  181:     public static Intent getRequiredIntent(Context context) {\n-  182:         if (!isOrbotInstalled(context)) {\n+  138:      * checks if Tor is enabled and if it is, that Orbot is installed and running. Generates appropriate dialogs.\n+  139:      * Convenience function for isOrbotinRequiredState(int, Runnable, FragmentActivity) by checking for tor being\n+  140:      * enabled internally\n+  141:      *\n+  142:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n+  143:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n+  144:      * @param proxyPrefs\n+  145:      * @param fragmentActivity\n+  146:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n+  147:      */\n+  148:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n+  149:                                                  Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n+  150: \n+  151:         if (!proxyPrefs.torEnabled) {\n+  152:             return true;\n+  153:         } else {\n+  154:             return isOrbotInRequiredState(middleButton, middleButtonRunnable, fragmentActivity);\n+  155:         }\n+  156: \n+  157:     }\n+  158: \n+  159:     /**\n+  160:      * checks if Orbot is installed and running. Generates appropriate dialogs.\n+  161:      *\n+  162:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n+  163:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n+  164:      * @param fragmentActivity\n+  165:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n+  166:      */\n+  167:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n+  168:                                                  FragmentActivity fragmentActivity) {\n+  169:         Handler ignoreTorHandler = new Handler() {\n+  170:             @Override\n+  171:             public void handleMessage(Message msg) {\n+  172:                 // every message received by this handler will mean  the middle button was pressed\n+  173:                 middleButtonRunnable.run();\n+  174:             }\n+  175:         };\n+  176: \n+  177:         if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n+  178: \n+  179:             OrbotHelper.getInstallDialogFragmentWithThirdButton(\n+  180:                     new Messenger(ignoreTorHandler),\n+  181:                     middleButton\n+  182:             ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n   183: \n-  184:         }\n-  185:         if (!isOrbotRunning()) {\n+  184:             return false;\n+  185:         } else if (!OrbotHelper.isOrbotRunning()) {\n   186: \n-  187:         }\n-  188:         return null;\n-  189:     }\n-  190: }\n+  187:             OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n+  188:                     middleButton)\n+  189:                     .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n+  190: \n+  191:             return false;\n+  192:         } else {\n+  193:             return true;\n+  194:         }\n+  195:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public void generateCodec(ExecutableElement methodElement, Lang lang) {\n        final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n\n        final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n        final int response = methodElementAnnotation.response();\n        final int[] events = methodElementAnnotation.event();\n        final boolean retryable = methodElementAnnotation.retryable();\n\n        ExecutableElement responseElement = responseMap.get(response);\n\n        List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n        if (events != null) {\n            for (Integer eventType : events) {\n                final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n                if (eventResponse != null) {\n                    eventElementList.add(eventResponse);\n                }\n            }\n        }\n\n        CodecModel codecModel = new CodecModel(parent, methodElement,\n                responseElement, eventElementList, retryable, lang);\n\n        final String content;\n        switch (lang) {\n            case JAVA:\n                content = generateFromTemplate(codecTemplate, codecModel);\n                saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n                break;\n            case CSHARP:\n//                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n//                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n//                break;\n            case CPP:\n                //TODO\n                //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n                //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n        }\n    }\n SourceCodeAfterRefactoring:\npublic void generateCodec(ExecutableElement methodElement, Lang lang) {\n        CodecModel codecModel = createCodecModel(methodElement,lang);\n        final String content;\n        switch (lang) {\n            case JAVA:\n                content = generateFromTemplate(codecTemplate, codecModel);\n                saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n                break;\n            case CSHARP:\n                //TODO\n                //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n                //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n                //                break;\n            case CPP:\n                //TODO\n                //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n                //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n        }\n    }\nprivate CodecModel createCodecModel(ExecutableElement methodElement, Lang lang) {\n        final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n\n        final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n        final int response = methodElementAnnotation.response();\n        final int[] events = methodElementAnnotation.event();\n        final boolean retryable = methodElementAnnotation.retryable();\n\n        ExecutableElement responseElement = responseMap.get(response);\n\n        List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n        if (events != null) {\n            for (Integer eventType : events) {\n                final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n                if (eventResponse != null) {\n                    eventElementList.add(eventResponse);\n                }\n            }\n        }\n\n        return new CodecModel(parent, methodElement, responseElement, eventElementList, retryable, lang);\n    }\n DiffSourceCode:\n-  150:     public void generateCodec(ExecutableElement methodElement, Lang lang) {\n-  151:         final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n-  152: \n-  153:         final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n-  154:         final int response = methodElementAnnotation.response();\n-  155:         final int[] events = methodElementAnnotation.event();\n-  156:         final boolean retryable = methodElementAnnotation.retryable();\n-  157: \n-  158:         ExecutableElement responseElement = responseMap.get(response);\n-  159: \n-  160:         List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n-  161:         if (events != null) {\n-  162:             for (Integer eventType : events) {\n-  163:                 final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n-  164:                 if (eventResponse != null) {\n-  165:                     eventElementList.add(eventResponse);\n-  166:                 }\n+  150:                 continue;\n+  151:             }\n+  152:             ExecutableElement methodElement = (ExecutableElement) enclosedElement;\n+  153: \n+  154:             short masterId = classElement.getAnnotation(GenerateCodec.class).id();\n+  155: \n+  156:             final Request request = methodElement.getAnnotation(Request.class);\n+  157:             if (request != null) {\n+  158:                 String id = CodeGenerationUtils.mergeIds(masterId, request.id());\n+  159:                 requestMap.put(id, methodElement);\n+  160:                 continue;\n+  161:             }\n+  162: \n+  163:             final Response response = methodElement.getAnnotation(Response.class);\n+  164:             if (response != null) {\n+  165:                 responseMap.put(response.value(), methodElement);\n+  166:                 continue;\n   167:             }\n-  168:         }\n-  169: \n-  170:         CodecModel codecModel = new CodecModel(parent, methodElement,\n-  171:                 responseElement, eventElementList, retryable, lang);\n-  172: \n-  173:         final String content;\n-  174:         switch (lang) {\n-  175:             case JAVA:\n-  176:                 content = generateFromTemplate(codecTemplate, codecModel);\n-  177:                 saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n-  178:                 break;\n-  179:             case CSHARP:\n-  180: //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n-  181: //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n-  182: //                break;\n-  183:             case CPP:\n-  184:                 //TODO\n-  185:                 //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n-  186:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n-  187:                 break;\n-  188:             default:\n-  189:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n-  190:         }\n-  191:     }\n-  192: \n-  193:     private void generateMessageTypeEnum(TypeElement classElement, Lang lang) {\n-  194:         MessageTypeEnumModel clazz = new MessageTypeEnumModel(classElement, lang);\n-  195:         if (clazz.isEmpty()) {\n-  196:             return;\n-  197:         }\n-  199:         switch (lang) {\n-  200:             case JAVA:\n-  201:                 content = generateFromTemplate(messageTypeTemplate, clazz);\n-  202:                 saveClass(clazz.getPackageName(), clazz.getClassName(), content);\n-  203:                 break;\n-  204:             case CSHARP:\n-  205:                 content = generateFromTemplate(messageTypeTemplateCSharp, clazz);\n-  206:                 saveFile(clazz.getClassName() + \".cs\", clazz.getPackageName(), content);\n-  207:                 break;\n-  208:             case CPP:\n-  209:                 //TODO\n-  210:                 //content = generateFromTemplate(messageTypeTemplateCpp, clazz);\n-  211:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n-  212:                 break;\n-  213:             default:\n-  214:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n-  215: \n-  216:         }\n-  217:     }\n+  168: \n+  169:             final EventResponse eventResponse = methodElement.getAnnotation(EventResponse.class);\n+  170:             if (eventResponse != null) {\n+  171:                 eventResponseMap.put(eventResponse.value(), methodElement);\n+  172:             }\n+  173:         }\n+  174:     }\n+  175: \n+  176:     public void generateCodec(ExecutableElement methodElement, Lang lang) {\n+  177:         CodecModel codecModel = createCodecModel(methodElement,lang);\n+  178:         final String content;\n+  179:         switch (lang) {\n+  180:             case JAVA:\n+  181:                 content = generateFromTemplate(codecTemplate, codecModel);\n+  182:                 saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n+  183:                 break;\n+  184:             case CSHARP:\n+  185:                 //TODO\n+  186:                 //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n+  187:                 //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n+  188:                 //                break;\n+  189:             case CPP:\n+  190:                 //TODO\n+  191:                 //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n+  192:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n+  193:                 break;\n+  194:             default:\n+  195:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n+  196:         }\n+  197:     }\n+  199:     private CodecModel createCodecModel(ExecutableElement methodElement, Lang lang) {\n+  200:         final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n+  201: \n+  202:         final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n+  203:         final int response = methodElementAnnotation.response();\n+  204:         final int[] events = methodElementAnnotation.event();\n+  205:         final boolean retryable = methodElementAnnotation.retryable();\n+  206: \n+  207:         ExecutableElement responseElement = responseMap.get(response);\n+  208: \n+  209:         List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n+  210:         if (events != null) {\n+  211:             for (Integer eventType : events) {\n+  212:                 final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n+  213:                 if (eventResponse != null) {\n+  214:                     eventElementList.add(eventResponse);\n+  215:                 }\n+  216:             }\n+  217:         }\n   218: \n-  219:     private void saveClass(String packageName, String className, String content) {\n-  220:         JavaFileObject file;\n+  219:         return new CodecModel(parent, methodElement, responseElement, eventElementList, retryable, lang);\n+  220:     }\n\n",
        "contextDescription": "PackageName: org.wordpress.android.ui.main\nClassName: org.wordpress.android.ui.main.WPMainActivity\nMethodName: org.wordpress.android.ui.main.WPMainActivity#onResume\n ClassSignature: public class WPMainActivity extends Activity\n    implements ViewPager.OnPageChangeListener,\n        SlidingTabLayout.SingleTabClickListener,\n        MediaAddFragment.MediaAddFragmentCallback,\n        Bucket.Listener<Note> \nInvokedMethod: methodSignature: org.wordpress.android.ui.main.WPMainActivity#onResume\n methodBody: protected void onResume() {\nsuper.onResume();\nif(SimperiumUtils.getNotesBucket() != null){SimperiumUtils.getNotesBucket().addListener(this);\n}checkNoteBadge();\nint position=(mViewPager.getCurrentItem());\nswitch(position)case WPMainTabAdapter.TAB_MY_SITE:ActivityId.trackLastActivity(ActivityId.MY_SITE);\nbreak;\ncase WPMainTabAdapter.TAB_READER:ActivityId.trackLastActivity(ActivityId.READER);\nbreak;\ncase WPMainTabAdapter.TAB_ME:ActivityId.trackLastActivity(ActivityId.ME);\nbreak;\ncase WPMainTabAdapter.TAB_NOTIFS:ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\nbreak;\ndefault:break;\n}\nmethodSignature: org.wordpress.android.ui.main.MySiteFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nif(ServiceUtils.isServiceRunning(getActivity(),StatsService.class)){getActivity().stopService(new Intent(getActivity(),StatsService.class));\n}}\nmethodSignature: org.wordpress.android.ui.notifications.NotificationsListFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nrefreshNotes();\nif(mBucket != null){mBucket.addListener(this);\n}NotificationManager notificationManager=(NotificationManager)getActivity().getSystemService(GCMIntentService.NOTIFICATION_SERVICE);\nnotificationManager.cancel(GCMIntentService.PUSH_NOTIFICATION_ID);\nif(SimperiumUtils.isUserAuthorized()){SimperiumUtils.startBuckets();\nAppLog.i(AppLog.T.NOTIFS,\"Starting Simperium buckets\");\n}}\nmethodSignature: org.wordpress.android.ui.main.WPMainActivity#checkNoteBadge\n methodBody: private void checkNoteBadge() {\nif(mIsCheckingNoteBadge){AppLog.v(AppLog.T.MAIN,\"main activity > already checking note badge\");\nreturn;\n}if(isViewingNotificationsTab()){if(mTabs.isBadged(WPMainTabAdapter.TAB_NOTIFS)){mTabs.setBadge(WPMainTabAdapter.TAB_NOTIFS,false);\n}return;\n}mIsCheckingNoteBadge=true;\nnew Thread(){\n  @Override public void run(){\n    final boolean hasUnreadNotes=SimperiumUtils.hasUnreadNotes();\n    boolean isBadged=mTabs.isBadged(WPMainTabAdapter.TAB_NOTIFS);\n    if (hasUnreadNotes != isBadged) {\n      runOnUiThread(new Runnable(){\n        @Override public void run(){\n          mTabs.setBadge(WPMainTabAdapter.TAB_NOTIFS,hasUnreadNotes);\n          mIsCheckingNoteBadge=false;\n        }\n      }\n);\n    }\n else {\n      mIsCheckingNoteBadge=false;\n    }\n  }\n}\n.start();\n}\nmethodSignature: org.wordpress.android.ui.reader.ReaderPostListFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nif(mWasPaused){AppLog.d(T.READER,\"reader post list > resumed from paused state\");\nmWasPaused=false;\nrefreshPosts();\nrefreshTags();\nif(!isUpdating() && getPostListType() == ReaderPostListType.TAG_FOLLOWED && ReaderTagTable.shouldAutoUpdateTag(mCurrentTag)){AppLog.i(T.READER,\"reader post list > auto-updating current tag after resume\");\nupdatePostsWithTag(getCurrentTag(),UpdateAction.REQUEST_NEWER);\n}}}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n@Override\n    protected void onResume() {\n        super.onResume();\n\n        // Start listening to Simperium Note bucket\n        if (SimperiumUtils.getNotesBucket() != null) {\n            SimperiumUtils.getNotesBucket().addListener(this);\n        }\n        checkNoteBadge();\n\n        // We need to track the current item on the screen when this activity is resumed.\n        // Ex: Notifications -> notifications detail -> back to notifications\n        int position = (mViewPager.getCurrentItem());\n        switch (position) {\n            case WPMainTabAdapter.TAB_MY_SITE:\n                ActivityId.trackLastActivity(ActivityId.MY_SITE);\n                break;\n            case WPMainTabAdapter.TAB_READER:\n                ActivityId.trackLastActivity(ActivityId.READER);\n                break;\n            case WPMainTabAdapter.TAB_ME:\n                ActivityId.trackLastActivity(ActivityId.ME);\n                break;\n            case WPMainTabAdapter.TAB_NOTIFS:\n                ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\n                break;\n            default:\n                break;\n        }\n    }\n\nThe context of the source code is as follows:\nPackageName: org.wordpress.android.ui.main\nClassName: org.wordpress.android.ui.main.WPMainActivity\nMethodName: org.wordpress.android.ui.main.WPMainActivity#onResume\n ClassSignature: public class WPMainActivity extends Activity\n    implements ViewPager.OnPageChangeListener,\n        SlidingTabLayout.SingleTabClickListener,\n        MediaAddFragment.MediaAddFragmentCallback,\n        Bucket.Listener<Note> \nInvokedMethod: methodSignature: org.wordpress.android.ui.main.WPMainActivity#onResume\n methodBody: protected void onResume() {\nsuper.onResume();\nif(SimperiumUtils.getNotesBucket() != null){SimperiumUtils.getNotesBucket().addListener(this);\n}checkNoteBadge();\nint position=(mViewPager.getCurrentItem());\nswitch(position)case WPMainTabAdapter.TAB_MY_SITE:ActivityId.trackLastActivity(ActivityId.MY_SITE);\nbreak;\ncase WPMainTabAdapter.TAB_READER:ActivityId.trackLastActivity(ActivityId.READER);\nbreak;\ncase WPMainTabAdapter.TAB_ME:ActivityId.trackLastActivity(ActivityId.ME);\nbreak;\ncase WPMainTabAdapter.TAB_NOTIFS:ActivityId.trackLastActivity(ActivityId.NOTIFICATIONS);\nbreak;\ndefault:break;\n}\nmethodSignature: org.wordpress.android.ui.main.MySiteFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nif(ServiceUtils.isServiceRunning(getActivity(),StatsService.class)){getActivity().stopService(new Intent(getActivity(),StatsService.class));\n}}\nmethodSignature: org.wordpress.android.ui.notifications.NotificationsListFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nrefreshNotes();\nif(mBucket != null){mBucket.addListener(this);\n}NotificationManager notificationManager=(NotificationManager)getActivity().getSystemService(GCMIntentService.NOTIFICATION_SERVICE);\nnotificationManager.cancel(GCMIntentService.PUSH_NOTIFICATION_ID);\nif(SimperiumUtils.isUserAuthorized()){SimperiumUtils.startBuckets();\nAppLog.i(AppLog.T.NOTIFS,\"Starting Simperium buckets\");\n}}\nmethodSignature: org.wordpress.android.ui.main.WPMainActivity#checkNoteBadge\n methodBody: private void checkNoteBadge() {\nif(mIsCheckingNoteBadge){AppLog.v(AppLog.T.MAIN,\"main activity > already checking note badge\");\nreturn;\n}if(isViewingNotificationsTab()){if(mTabs.isBadged(WPMainTabAdapter.TAB_NOTIFS)){mTabs.setBadge(WPMainTabAdapter.TAB_NOTIFS,false);\n}return;\n}mIsCheckingNoteBadge=true;\nnew Thread(){\n  @Override public void run(){\n    final boolean hasUnreadNotes=SimperiumUtils.hasUnreadNotes();\n    boolean isBadged=mTabs.isBadged(WPMainTabAdapter.TAB_NOTIFS);\n    if (hasUnreadNotes != isBadged) {\n      runOnUiThread(new Runnable(){\n        @Override public void run(){\n          mTabs.setBadge(WPMainTabAdapter.TAB_NOTIFS,hasUnreadNotes);\n          mIsCheckingNoteBadge=false;\n        }\n      }\n);\n    }\n else {\n      mIsCheckingNoteBadge=false;\n    }\n  }\n}\n.start();\n}\nmethodSignature: org.wordpress.android.ui.reader.ReaderPostListFragment#onResume\n methodBody: public void onResume() {\nsuper.onResume();\nif(mWasPaused){AppLog.d(T.READER,\"reader post list > resumed from paused state\");\nmWasPaused=false;\nrefreshPosts();\nrefreshTags();\nif(!isUpdating() && getPostListType() == ReaderPostListType.TAG_FOLLOWED && ReaderTagTable.shouldAutoUpdateTag(mCurrentTag)){AppLog.i(T.READER,\"reader post list > auto-updating current tag after resume\");\nupdatePostsWithTag(getCurrentTag(),UpdateAction.REQUEST_NEWER);\n}}}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param editValue the protection type\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n     */\n    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n                                        String password, HashAlgorithm hashAlgo) {\n    \t\n        safeGetDocumentProtection().setEnforcement(true);    \t\n        safeGetDocumentProtection().setEdit(editValue);\n        \n        // Word 2010 doesn't enforce TRACKED_CHANGES,\n        // unless <w:trackRevisions/> is also set!\n        if (editValue==STDocProtect.TRACKED_CHANGES) {\n        \tif (this.jaxbElement.getTrackRevisions()==null) {\n        \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n        \t}\n        }\n\n        if (password == null) {\n        \t// unset\n            safeGetDocumentProtection().setCryptProviderType(null);\n            safeGetDocumentProtection().setCryptAlgorithmClass(null);\n            safeGetDocumentProtection().setCryptAlgorithmType(null);\n            safeGetDocumentProtection().setCryptAlgorithmSid(null);\n            safeGetDocumentProtection().setSalt(null);\n            safeGetDocumentProtection().setCryptSpinCount(null);\n            safeGetDocumentProtection().setHash(null);\n            \n            return;\n            \n        } else {\n            final STCryptProv providerType;\n            final int sid;\n            switch (hashAlgo) {\n                case md2:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 1;\n                    break;\n                case md4:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 2;\n                    break;\n                case md5:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 3;\n                    break;\n                case sha1:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 4;\n                    break;\n                case sha256:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 12;\n                    break;\n                case sha384:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 13;\n                    break;\n                case sha512:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 14;\n                    break;\n                default:\n                    throw new EncryptedDocumentException\n                            (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n            }\n\n\n            SecureRandom random = new SecureRandom();\n            byte salt[] = random.generateSeed(16);\n\n            // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n            // iteration's result as the input for the next iteration).\n            int spinCount = 100000;\n\n            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n\n            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n            // Implementation Notes List:\n            // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n            //     be converted to Unicode hex string representation\n            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n\n            safeGetDocumentProtection().setSalt(salt);\n            safeGetDocumentProtection().setHash(hash);\n            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n            safeGetDocumentProtection().setCryptProviderType(providerType);\n            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n        }\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param editValue the protection type\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n\t * @since 3.3.0\n     */\n    public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n                                        String password, HashAlgorithm hashAlgo) {\n    \t\n        safeGetDocumentProtection().setEnforcement(true);    \t\n        safeGetDocumentProtection().setEdit(editValue);\n        \n        // Word 2010 doesn't enforce TRACKED_CHANGES,\n        // unless <w:trackRevisions/> is also set!\n        if (editValue==STDocProtect.TRACKED_CHANGES) {\n        \tif (this.jaxbElement.getTrackRevisions()==null) {\n        \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n        \t}\n        }\n\n        setProtectionPassword(password, hashAlgo);\n    }\n/**\n     * Enforces the protection with the option specified by passed editValue, password, and \n     * HashAlgorithm for the password.\n\n     *\n     * @param password  the plaintext password, if null no password will be applied\n     * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n     *                  if null, it will default default to sha1\n\t * @since 3.3.0\n     */\n    private void setProtectionPassword(String password, HashAlgorithm hashAlgo) {\n\n        if (password == null) {\n        \t// unset\n            safeGetDocumentProtection().setCryptProviderType(null);\n            safeGetDocumentProtection().setCryptAlgorithmClass(null);\n            safeGetDocumentProtection().setCryptAlgorithmType(null);\n            safeGetDocumentProtection().setCryptAlgorithmSid(null);\n            safeGetDocumentProtection().setSalt(null);\n            safeGetDocumentProtection().setCryptSpinCount(null);\n            safeGetDocumentProtection().setHash(null);\n            \n            return;\n            \n        } else {\n            final STCryptProv providerType;\n            final int sid;\n            switch (hashAlgo) {\n                case md2:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 1;\n                    break;\n                case md4:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 2;\n                    break;\n                case md5:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 3;\n                    break;\n                case sha1:\n                    providerType = STCryptProv.RSA_FULL;\n                    sid = 4;\n                    break;\n                case sha256:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 12;\n                    break;\n                case sha384:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 13;\n                    break;\n                case sha512:\n                    providerType = STCryptProv.RSA_AES;\n                    sid = 14;\n                    break;\n                default:\n                    throw new EncryptedDocumentException\n                            (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n            }\n\n\n            SecureRandom random = new SecureRandom();\n            byte salt[] = random.generateSeed(16);\n\n            // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n            // iteration's result as the input for the next iteration).\n            int spinCount = 100000;\n\n            if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n\n            String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n            // Implementation Notes List:\n            // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n            //     be converted to Unicode hex string representation\n            byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n\n            safeGetDocumentProtection().setSalt(salt);\n            safeGetDocumentProtection().setHash(hash);\n            safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n            safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n            safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n            safeGetDocumentProtection().setCryptProviderType(providerType);\n            safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n        }\n    }\n DiffSourceCode:\n-  238:     /**\n-  239:      * Enforces the protection with the option specified by passed editValue, password, and \n-  240:      * HashAlgorithm for the password.\n-  241: \n-  242:      *\n-  243:      * @param editValue the protection type\n-  244:      * @param password  the plaintext password, if null no password will be applied\n-  245:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n-  246:      *                  if null, it will default default to sha1\n-  247:      */\n-  248:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n-  249:                                         String password, HashAlgorithm hashAlgo) {\n-  250:     \t\n-  251:         safeGetDocumentProtection().setEnforcement(true);    \t\n-  252:         safeGetDocumentProtection().setEdit(editValue);\n-  253:         \n-  254:         // Word 2010 doesn't enforce TRACKED_CHANGES,\n-  255:         // unless <w:trackRevisions/> is also set!\n-  256:         if (editValue==STDocProtect.TRACKED_CHANGES) {\n-  257:         \tif (this.jaxbElement.getTrackRevisions()==null) {\n-  258:         \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n-  259:         \t}\n-  260:         }\n-  261: \n-  262:         if (password == null) {\n-  263:         \t// unset\n-  264:             safeGetDocumentProtection().setCryptProviderType(null);\n-  265:             safeGetDocumentProtection().setCryptAlgorithmClass(null);\n-  266:             safeGetDocumentProtection().setCryptAlgorithmType(null);\n-  267:             safeGetDocumentProtection().setCryptAlgorithmSid(null);\n-  268:             safeGetDocumentProtection().setSalt(null);\n-  269:             safeGetDocumentProtection().setCryptSpinCount(null);\n-  270:             safeGetDocumentProtection().setHash(null);\n-  271:             \n-  272:             return;\n-  273:             \n-  274:         } else {\n-  275:             final STCryptProv providerType;\n-  276:             final int sid;\n-  277:             switch (hashAlgo) {\n-  278:                 case md2:\n-  279:                     providerType = STCryptProv.RSA_FULL;\n-  280:                     sid = 1;\n-  281:                     break;\n-  282:                 case md4:\n-  283:                     providerType = STCryptProv.RSA_FULL;\n-  284:                     sid = 2;\n-  285:                     break;\n-  286:                 case md5:\n-  287:                     providerType = STCryptProv.RSA_FULL;\n-  288:                     sid = 3;\n-  289:                     break;\n-  290:                 case sha1:\n-  291:                     providerType = STCryptProv.RSA_FULL;\n-  292:                     sid = 4;\n-  293:                     break;\n-  294:                 case sha256:\n-  295:                     providerType = STCryptProv.RSA_AES;\n-  296:                     sid = 12;\n-  297:                     break;\n-  298:                 case sha384:\n-  299:                     providerType = STCryptProv.RSA_AES;\n-  300:                     sid = 13;\n-  301:                     break;\n-  302:                 case sha512:\n-  303:                     providerType = STCryptProv.RSA_AES;\n-  304:                     sid = 14;\n-  305:                     break;\n-  306:                 default:\n-  307:                     throw new EncryptedDocumentException\n-  308:                             (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n-  309:             }\n-  310: \n-  311: \n-  312:             SecureRandom random = new SecureRandom();\n-  313:             byte salt[] = random.generateSeed(16);\n-  314: \n-  315:             // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n-  316:             // iteration's result as the input for the next iteration).\n-  317:             int spinCount = 100000;\n-  318: \n-  319:             if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n-  320: \n-  321:             String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n-  322:             // Implementation Notes List:\n-  323:             // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n-  324:             //     be converted to Unicode hex string representation\n-  325:             byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n+  238:      * Verifies the documentProtection tag inside settings.xml file \n+  239:      * if the protection is enforced (w:enforcement=\"1\") \n+  240:      * and if the kind of protection equals to passed (STDocProtect.Enum editValue) \n+  241:      *\n+  242:      * @return true if documentProtection is enforced with option readOnly\n+  243: \t * @since 3.3.0\n+  244:      */\n+  245:     public boolean isEnforcedWith(STDocProtect editValue) {\n+  246:         CTDocProtect ctDocProtect = this.jaxbElement.getDocumentProtection();\n+  247: \n+  248:         if (ctDocProtect == null) {\n+  249:             return false;\n+  250:         }\n+  251: \n+  252:         return ctDocProtect.isEnforcement() && ctDocProtect.getEdit().equals(editValue);\n+  253:     }\n+  254:     \n+  255: \n+  256:     /**\n+  257:      * Enforces the protection with the option specified by passed editValue.<br/>\n+  258:      * <br/>\n+  259:      * In the documentProtection tag inside settings.xml file <br/>\n+  260:      * it sets the value of enforcement to \"1\" (w:enforcement=\"1\") <br/>\n+  261:      * and the value of edit to the passed editValue (w:edit=\"[passed editValue]\")<br/>\n+  262:      * <br/>\n+  263:      * sample snippet from settings.xml\n+  264:      * <pre>\n+  265:      *     &lt;w:settings  ... &gt;\n+  266:      *         &lt;w:documentProtection w:edit=&quot;[passed editValue]&quot; w:enforcement=&quot;1&quot;/&gt;\n+  267:      * </pre>\n+  268: \t * @since 3.3.0\n+  269:      */\n+  270:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue) {\n+  271:     \t\n+  272:     \tsetEnforcementEditValue(editValue, null, null);\n+  273:     }\n+  274: \n+  275:     /**\n+  276:      * Enforces the protection with the option specified by passed editValue and password,\n+  277:      * using rsaFull (sha1) (like Word 2010).\n+  278:      * \n+  279:      * WARNING: this functionality may give a false sense of security, since it only affects\n+  280:      * the behaviour of Word's user interface. A mischevious user could still edit the document\n+  281:      * in some other program, and subsequent users would *not* be warned it has been tampered with. \n+  282:      *\n+  283:      * @param editValue the protection type\n+  284:      * @param password  the plaintext password, if null no password will be applied\n+  285:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  286:      *                  if null, it will default default to sha1\n+  287: \t * @since 3.3.0\n+  288:      */\n+  289:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n+  290:                                         String password) {\n+  291: \n+  292:     \tsetEnforcementEditValue(editValue, password, HashAlgorithm.sha1);\n+  293:     }\n+  294: \n+  295:     /**\n+  296:      * Enforces the protection with the option specified by passed editValue, password, and \n+  297:      * HashAlgorithm for the password.\n+  298: \n+  299:      *\n+  300:      * @param editValue the protection type\n+  301:      * @param password  the plaintext password, if null no password will be applied\n+  302:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  303:      *                  if null, it will default default to sha1\n+  304: \t * @since 3.3.0\n+  305:      */\n+  306:     public void setEnforcementEditValue(org.docx4j.wml.STDocProtect editValue,\n+  307:                                         String password, HashAlgorithm hashAlgo) {\n+  308:     \t\n+  309:         safeGetDocumentProtection().setEnforcement(true);    \t\n+  310:         safeGetDocumentProtection().setEdit(editValue);\n+  311:         \n+  312:         // Word 2010 doesn't enforce TRACKED_CHANGES,\n+  313:         // unless <w:trackRevisions/> is also set!\n+  314:         if (editValue==STDocProtect.TRACKED_CHANGES) {\n+  315:         \tif (this.jaxbElement.getTrackRevisions()==null) {\n+  316:         \t\tthis.jaxbElement.setTrackRevisions(new BooleanDefaultTrue());\n+  317:         \t}\n+  318:         }\n+  319: \n+  320:         setProtectionPassword(password, hashAlgo);\n+  321:     }\n+  322:     \n+  323:     /**\n+  324:      * Enforces the protection with the option specified by passed editValue, password, and \n+  325:      * HashAlgorithm for the password.\n   326: \n-  327:             safeGetDocumentProtection().setSalt(salt);\n-  328:             safeGetDocumentProtection().setHash(hash);\n-  329:             safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n-  330:             safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n-  331:             safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n-  332:             safeGetDocumentProtection().setCryptProviderType(providerType);\n-  333:             safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n-  334:         }\n-  335:     }\n-  336: \n-  337:     /**\n-  338:      * Validates the existing password\n-  339:      *\n-  340:      * @param password\n-  341:      * @return true, only if password was set and equals, false otherwise\n-  342:      */\n-  343:     public boolean validateProtectionPassword(String password) {\n-  344:         BigInteger sid = safeGetDocumentProtection().getCryptAlgorithmSid();\n-  345:         byte hash[] = safeGetDocumentProtection().getHash();\n-  346:         byte salt[] = safeGetDocumentProtection().getSalt();\n-  347:         BigInteger spinCount = safeGetDocumentProtection().getCryptSpinCount();\n-  348: \n-  349:         if (sid == null || hash == null || salt == null || spinCount == null) return false;\n-  350: \n-  351:         HashAlgorithm hashAlgo;\n-  352:         switch (sid.intValue()) {\n-  353:             case 1:\n-  354:                 hashAlgo = HashAlgorithm.md2;\n-  355:                 break;\n-  356:             case 2:\n-  357:                 hashAlgo = HashAlgorithm.md4;\n-  358:                 break;\n-  359:             case 3:\n-  360:                 hashAlgo = HashAlgorithm.md5;\n-  361:                 break;\n-  362:             case 4:\n-  363:                 hashAlgo = HashAlgorithm.sha1;\n-  364:                 break;\n-  365:             case 12:\n-  366:                 hashAlgo = HashAlgorithm.sha256;\n-  367:                 break;\n-  368:             case 13:\n-  369:                 hashAlgo = HashAlgorithm.sha384;\n-  370:                 break;\n-  371:             case 14:\n-  372:                 hashAlgo = HashAlgorithm.sha512;\n-  373:                 break;\n-  374:             default:\n-  375:                 return false;\n-  376:         }\n-  377: \n-  378:         String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n-  379:         // Implementation Notes List:\n-  380:         // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n-  381:         //     be converted to Unicode hex string representation\n-  382:         byte hash2[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount.intValue(), false);\n+  327:      *\n+  328:      * @param password  the plaintext password, if null no password will be applied\n+  329:      * @param hashAlgo  the hash algorithm - only md2, m5, sha1, sha256, sha384 and sha512 are supported.\n+  330:      *                  if null, it will default default to sha1\n+  331: \t * @since 3.3.0\n+  332:      */\n+  333:     private void setProtectionPassword(String password, HashAlgorithm hashAlgo) {\n+  334: \n+  335:         if (password == null) {\n+  336:         \t// unset\n+  337:             safeGetDocumentProtection().setCryptProviderType(null);\n+  338:             safeGetDocumentProtection().setCryptAlgorithmClass(null);\n+  339:             safeGetDocumentProtection().setCryptAlgorithmType(null);\n+  340:             safeGetDocumentProtection().setCryptAlgorithmSid(null);\n+  341:             safeGetDocumentProtection().setSalt(null);\n+  342:             safeGetDocumentProtection().setCryptSpinCount(null);\n+  343:             safeGetDocumentProtection().setHash(null);\n+  344:             \n+  345:             return;\n+  346:             \n+  347:         } else {\n+  348:             final STCryptProv providerType;\n+  349:             final int sid;\n+  350:             switch (hashAlgo) {\n+  351:                 case md2:\n+  352:                     providerType = STCryptProv.RSA_FULL;\n+  353:                     sid = 1;\n+  354:                     break;\n+  355:                 case md4:\n+  356:                     providerType = STCryptProv.RSA_FULL;\n+  357:                     sid = 2;\n+  358:                     break;\n+  359:                 case md5:\n+  360:                     providerType = STCryptProv.RSA_FULL;\n+  361:                     sid = 3;\n+  362:                     break;\n+  363:                 case sha1:\n+  364:                     providerType = STCryptProv.RSA_FULL;\n+  365:                     sid = 4;\n+  366:                     break;\n+  367:                 case sha256:\n+  368:                     providerType = STCryptProv.RSA_AES;\n+  369:                     sid = 12;\n+  370:                     break;\n+  371:                 case sha384:\n+  372:                     providerType = STCryptProv.RSA_AES;\n+  373:                     sid = 13;\n+  374:                     break;\n+  375:                 case sha512:\n+  376:                     providerType = STCryptProv.RSA_AES;\n+  377:                     sid = 14;\n+  378:                     break;\n+  379:                 default:\n+  380:                     throw new EncryptedDocumentException\n+  381:                             (\"Hash algorithm '\" + hashAlgo + \"' is not supported for document write protection.\");\n+  382:             }\n   383: \n-  384:         return Arrays.equals(hash, hash2);\n-  385:     }\n-  386: \n-  387:     /**\n-  388:      * Removes protection enforcement.<br/>\n-  389:      * In the documentProtection tag inside settings.xml file <br/>\n-  390:      * it sets the value of enforcement to \"0\" (w:enforcement=\"0\") <br/>\n-  391:      */\n-  392:     public void removeEnforcement() {\n-  393: //        safeGetDocumentProtection().setEnforcement(STOnOff.X_0);\n-  394:         safeGetDocumentProtection().setEnforcement(false);    \t\n-  395:     }\t\n-  396:     \n-  397:     private CTDocProtect safeGetDocumentProtection() {\n-  398:     \t\n-  399:     \tif (this.getJaxbElement()==null) {\n-  400:     \t\tthis.jaxbElement=new CTSettings();\n-  401:     \t}\n-  402:     \t\n-  403:         CTDocProtect documentProtection = this.jaxbElement.getDocumentProtection();\n-  404:         if (documentProtection == null) {\n-  405:             documentProtection = Context.getWmlObjectFactory().createCTDocProtect();\n-  406:             this.jaxbElement.setDocumentProtection(documentProtection);\n+  384: \n+  385:             SecureRandom random = new SecureRandom();\n+  386:             byte salt[] = random.generateSeed(16);\n+  387: \n+  388:             // Iterations specifies the number of times the hashing function shall be iteratively run (using each\n+  389:             // iteration's result as the input for the next iteration).\n+  390:             int spinCount = 100000;\n+  391: \n+  392:             if (hashAlgo == null) hashAlgo = HashAlgorithm.sha1;\n+  393: \n+  394:             String legacyHash = CryptoFunctions.xorHashPasswordReversed(password);\n+  395:             // Implementation Notes List:\n+  396:             // --> In this third stage, the reversed byte order legacy hash from the second stage shall\n+  397:             //     be converted to Unicode hex string representation\n+  398:             byte hash[] = CryptoFunctions.hashPassword(legacyHash, hashAlgo, salt, spinCount, false);\n+  399: \n+  400:             safeGetDocumentProtection().setSalt(salt);\n+  401:             safeGetDocumentProtection().setHash(hash);\n+  402:             safeGetDocumentProtection().setCryptSpinCount(BigInteger.valueOf(spinCount));\n+  403:             safeGetDocumentProtection().setCryptAlgorithmType(STAlgType.TYPE_ANY);\n+  404:             safeGetDocumentProtection().setCryptAlgorithmClass(STAlgClass.HASH);\n+  405:             safeGetDocumentProtection().setCryptProviderType(providerType);\n+  406:             safeGetDocumentProtection().setCryptAlgorithmSid(BigInteger.valueOf(sid));\n   407:         }\n-  408:         return this.jaxbElement.getDocumentProtection();\n+  408:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n     * checks if Tor is enabled and if it is, that Orbot is installed and runnign. Generates appropriate dialogs.\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param proxyPrefs\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n        Handler ignoreTorHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                // every message received by this handler will mean  the middle button was pressed\n                middleButtonRunnable.run();\n            }\n        };\n\n        if (!proxyPrefs.torEnabled) {\n            return true;\n        }\n\n        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n\n            OrbotHelper.getInstallDialogFragmentWithThirdButton(\n                    new Messenger(ignoreTorHandler),\n                    middleButton\n            ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n\n            return false;\n        } else if (!OrbotHelper.isOrbotRunning()) {\n\n            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n                    middleButton)\n                    .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n\n            return false;\n        } else {\n            return true;\n        }\n    }\n SourceCodeAfterRefactoring:\n/**\n     * checks if Tor is enabled and if it is, that Orbot is installed and running. Generates appropriate dialogs.\n     * Convenience function for isOrbotinRequiredState(int, Runnable, FragmentActivity) by checking for tor being\n     * enabled internally\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param proxyPrefs\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n\n        if (!proxyPrefs.torEnabled) {\n            return true;\n        } else {\n            return isOrbotInRequiredState(middleButton, middleButtonRunnable, fragmentActivity);\n        }\n\n    }\n/**\n     * checks if Orbot is installed and running. Generates appropriate dialogs.\n     *\n     * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n     * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n     * @param fragmentActivity\n     * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n     */\n    public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n                                                 FragmentActivity fragmentActivity) {\n        Handler ignoreTorHandler = new Handler() {\n            @Override\n            public void handleMessage(Message msg) {\n                // every message received by this handler will mean  the middle button was pressed\n                middleButtonRunnable.run();\n            }\n        };\n\n        if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n\n            OrbotHelper.getInstallDialogFragmentWithThirdButton(\n                    new Messenger(ignoreTorHandler),\n                    middleButton\n            ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n\n            return false;\n        } else if (!OrbotHelper.isOrbotRunning()) {\n\n            OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n                    middleButton)\n                    .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n\n            return false;\n        } else {\n            return true;\n        }\n    }\n DiffSourceCode:\n   137:     /**\n-  138:      * checks if Tor is enabled and if it is, that Orbot is installed and runnign. Generates appropriate dialogs.\n-  139:      *\n-  140:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n-  141:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n-  142:      * @param proxyPrefs\n-  143:      * @param fragmentActivity\n-  144:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n-  145:      */\n-  146:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n-  147:                                                  Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n-  148:         Handler ignoreTorHandler = new Handler() {\n-  149:             @Override\n-  150:             public void handleMessage(Message msg) {\n-  151:                 // every message received by this handler will mean  the middle button was pressed\n-  152:                 middleButtonRunnable.run();\n-  153:             }\n-  154:         };\n-  155: \n-  156:         if (!proxyPrefs.torEnabled) {\n-  157:             return true;\n-  158:         }\n-  159: \n-  160:         if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n-  161: \n-  162:             OrbotHelper.getInstallDialogFragmentWithThirdButton(\n-  163:                     new Messenger(ignoreTorHandler),\n-  164:                     middleButton\n-  165:             ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n-  166: \n-  167:             return false;\n-  168:         } else if (!OrbotHelper.isOrbotRunning()) {\n-  169: \n-  170:             OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n-  171:                     middleButton)\n-  172:                     .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n-  173: \n-  174:             return false;\n-  175:         } else {\n-  176:             return true;\n-  177:         }\n-  178:     }\n-  179: \n-  180:     // TODO: PHILIP return an Intent to required dialog activity\n-  181:     public static Intent getRequiredIntent(Context context) {\n-  182:         if (!isOrbotInstalled(context)) {\n+  138:      * checks if Tor is enabled and if it is, that Orbot is installed and running. Generates appropriate dialogs.\n+  139:      * Convenience function for isOrbotinRequiredState(int, Runnable, FragmentActivity) by checking for tor being\n+  140:      * enabled internally\n+  141:      *\n+  142:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n+  143:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n+  144:      * @param proxyPrefs\n+  145:      * @param fragmentActivity\n+  146:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n+  147:      */\n+  148:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n+  149:                                                  Preferences.ProxyPrefs proxyPrefs, FragmentActivity fragmentActivity) {\n+  150: \n+  151:         if (!proxyPrefs.torEnabled) {\n+  152:             return true;\n+  153:         } else {\n+  154:             return isOrbotInRequiredState(middleButton, middleButtonRunnable, fragmentActivity);\n+  155:         }\n+  156: \n+  157:     }\n+  158: \n+  159:     /**\n+  160:      * checks if Orbot is installed and running. Generates appropriate dialogs.\n+  161:      *\n+  162:      * @param middleButton         resourceId of string to display as the middle button of install and enable dialogs\n+  163:      * @param middleButtonRunnable runnable to be executed if the user clicks on the middle button\n+  164:      * @param fragmentActivity\n+  165:      * @return true if Tor is not enabled or Tor is enabled and Orbot is installed and running, else false\n+  166:      */\n+  167:     public static boolean isOrbotInRequiredState(int middleButton, final Runnable middleButtonRunnable,\n+  168:                                                  FragmentActivity fragmentActivity) {\n+  169:         Handler ignoreTorHandler = new Handler() {\n+  170:             @Override\n+  171:             public void handleMessage(Message msg) {\n+  172:                 // every message received by this handler will mean  the middle button was pressed\n+  173:                 middleButtonRunnable.run();\n+  174:             }\n+  175:         };\n+  176: \n+  177:         if (!OrbotHelper.isOrbotInstalled(fragmentActivity)) {\n+  178: \n+  179:             OrbotHelper.getInstallDialogFragmentWithThirdButton(\n+  180:                     new Messenger(ignoreTorHandler),\n+  181:                     middleButton\n+  182:             ).show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotInstallDialog\");\n   183: \n-  184:         }\n-  185:         if (!isOrbotRunning()) {\n+  184:             return false;\n+  185:         } else if (!OrbotHelper.isOrbotRunning()) {\n   186: \n-  187:         }\n-  188:         return null;\n-  189:     }\n-  190: }\n+  187:             OrbotHelper.getOrbotStartDialogFragment(new Messenger(ignoreTorHandler),\n+  188:                     middleButton)\n+  189:                     .show(fragmentActivity.getSupportFragmentManager(), \"OrbotHelperOrbotStartDialog\");\n+  190: \n+  191:             return false;\n+  192:         } else {\n+  193:             return true;\n+  194:         }\n+  195:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public void generateCodec(ExecutableElement methodElement, Lang lang) {\n        final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n\n        final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n        final int response = methodElementAnnotation.response();\n        final int[] events = methodElementAnnotation.event();\n        final boolean retryable = methodElementAnnotation.retryable();\n\n        ExecutableElement responseElement = responseMap.get(response);\n\n        List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n        if (events != null) {\n            for (Integer eventType : events) {\n                final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n                if (eventResponse != null) {\n                    eventElementList.add(eventResponse);\n                }\n            }\n        }\n\n        CodecModel codecModel = new CodecModel(parent, methodElement,\n                responseElement, eventElementList, retryable, lang);\n\n        final String content;\n        switch (lang) {\n            case JAVA:\n                content = generateFromTemplate(codecTemplate, codecModel);\n                saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n                break;\n            case CSHARP:\n//                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n//                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n//                break;\n            case CPP:\n                //TODO\n                //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n                //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n        }\n    }\n SourceCodeAfterRefactoring:\npublic void generateCodec(ExecutableElement methodElement, Lang lang) {\n        CodecModel codecModel = createCodecModel(methodElement,lang);\n        final String content;\n        switch (lang) {\n            case JAVA:\n                content = generateFromTemplate(codecTemplate, codecModel);\n                saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n                break;\n            case CSHARP:\n                //TODO\n                //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n                //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n                //                break;\n            case CPP:\n                //TODO\n                //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n                //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n        }\n    }\nprivate CodecModel createCodecModel(ExecutableElement methodElement, Lang lang) {\n        final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n\n        final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n        final int response = methodElementAnnotation.response();\n        final int[] events = methodElementAnnotation.event();\n        final boolean retryable = methodElementAnnotation.retryable();\n\n        ExecutableElement responseElement = responseMap.get(response);\n\n        List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n        if (events != null) {\n            for (Integer eventType : events) {\n                final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n                if (eventResponse != null) {\n                    eventElementList.add(eventResponse);\n                }\n            }\n        }\n\n        return new CodecModel(parent, methodElement, responseElement, eventElementList, retryable, lang);\n    }\n DiffSourceCode:\n-  150:     public void generateCodec(ExecutableElement methodElement, Lang lang) {\n-  151:         final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n-  152: \n-  153:         final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n-  154:         final int response = methodElementAnnotation.response();\n-  155:         final int[] events = methodElementAnnotation.event();\n-  156:         final boolean retryable = methodElementAnnotation.retryable();\n-  157: \n-  158:         ExecutableElement responseElement = responseMap.get(response);\n-  159: \n-  160:         List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n-  161:         if (events != null) {\n-  162:             for (Integer eventType : events) {\n-  163:                 final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n-  164:                 if (eventResponse != null) {\n-  165:                     eventElementList.add(eventResponse);\n-  166:                 }\n+  150:                 continue;\n+  151:             }\n+  152:             ExecutableElement methodElement = (ExecutableElement) enclosedElement;\n+  153: \n+  154:             short masterId = classElement.getAnnotation(GenerateCodec.class).id();\n+  155: \n+  156:             final Request request = methodElement.getAnnotation(Request.class);\n+  157:             if (request != null) {\n+  158:                 String id = CodeGenerationUtils.mergeIds(masterId, request.id());\n+  159:                 requestMap.put(id, methodElement);\n+  160:                 continue;\n+  161:             }\n+  162: \n+  163:             final Response response = methodElement.getAnnotation(Response.class);\n+  164:             if (response != null) {\n+  165:                 responseMap.put(response.value(), methodElement);\n+  166:                 continue;\n   167:             }\n-  168:         }\n-  169: \n-  170:         CodecModel codecModel = new CodecModel(parent, methodElement,\n-  171:                 responseElement, eventElementList, retryable, lang);\n-  172: \n-  173:         final String content;\n-  174:         switch (lang) {\n-  175:             case JAVA:\n-  176:                 content = generateFromTemplate(codecTemplate, codecModel);\n-  177:                 saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n-  178:                 break;\n-  179:             case CSHARP:\n-  180: //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n-  181: //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n-  182: //                break;\n-  183:             case CPP:\n-  184:                 //TODO\n-  185:                 //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n-  186:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n-  187:                 break;\n-  188:             default:\n-  189:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n-  190:         }\n-  191:     }\n-  192: \n-  193:     private void generateMessageTypeEnum(TypeElement classElement, Lang lang) {\n-  194:         MessageTypeEnumModel clazz = new MessageTypeEnumModel(classElement, lang);\n-  195:         if (clazz.isEmpty()) {\n-  196:             return;\n-  197:         }\n-  199:         switch (lang) {\n-  200:             case JAVA:\n-  201:                 content = generateFromTemplate(messageTypeTemplate, clazz);\n-  202:                 saveClass(clazz.getPackageName(), clazz.getClassName(), content);\n-  203:                 break;\n-  204:             case CSHARP:\n-  205:                 content = generateFromTemplate(messageTypeTemplateCSharp, clazz);\n-  206:                 saveFile(clazz.getClassName() + \".cs\", clazz.getPackageName(), content);\n-  207:                 break;\n-  208:             case CPP:\n-  209:                 //TODO\n-  210:                 //content = generateFromTemplate(messageTypeTemplateCpp, clazz);\n-  211:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n-  212:                 break;\n-  213:             default:\n-  214:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n-  215: \n-  216:         }\n-  217:     }\n+  168: \n+  169:             final EventResponse eventResponse = methodElement.getAnnotation(EventResponse.class);\n+  170:             if (eventResponse != null) {\n+  171:                 eventResponseMap.put(eventResponse.value(), methodElement);\n+  172:             }\n+  173:         }\n+  174:     }\n+  175: \n+  176:     public void generateCodec(ExecutableElement methodElement, Lang lang) {\n+  177:         CodecModel codecModel = createCodecModel(methodElement,lang);\n+  178:         final String content;\n+  179:         switch (lang) {\n+  180:             case JAVA:\n+  181:                 content = generateFromTemplate(codecTemplate, codecModel);\n+  182:                 saveClass(codecModel.getPackageName(), codecModel.getClassName(), content);\n+  183:                 break;\n+  184:             case CSHARP:\n+  185:                 //TODO\n+  186:                 //                content = generateFromTemplate(codecTemplateCSharp, codecModel);\n+  187:                 //                saveFile(codecModel.getClassName() + \".cs\", codecModel.getPackageName(), content);\n+  188:                 //                break;\n+  189:             case CPP:\n+  190:                 //TODO\n+  191:                 //content = generateFromTemplate(parameterTemplateCSharp, clazz);\n+  192:                 //saveFile(classElement, clazz.getPackageName(), clazz.getClassName(), content);\n+  193:                 break;\n+  194:             default:\n+  195:                 throw new UnsupportedOperationException(\"Unsupported language: \" + lang);\n+  196:         }\n+  197:     }\n+  199:     private CodecModel createCodecModel(ExecutableElement methodElement, Lang lang) {\n+  200:         final TypeElement parent = (TypeElement) methodElement.getEnclosingElement();\n+  201: \n+  202:         final Request methodElementAnnotation = methodElement.getAnnotation(Request.class);\n+  203:         final int response = methodElementAnnotation.response();\n+  204:         final int[] events = methodElementAnnotation.event();\n+  205:         final boolean retryable = methodElementAnnotation.retryable();\n+  206: \n+  207:         ExecutableElement responseElement = responseMap.get(response);\n+  208: \n+  209:         List<ExecutableElement> eventElementList = new ArrayList<ExecutableElement>();\n+  210:         if (events != null) {\n+  211:             for (Integer eventType : events) {\n+  212:                 final ExecutableElement eventResponse = eventResponseMap.get(eventType);\n+  213:                 if (eventResponse != null) {\n+  214:                     eventElementList.add(eventResponse);\n+  215:                 }\n+  216:             }\n+  217:         }\n   218: \n-  219:     private void saveClass(String packageName, String className, String content) {\n-  220:         JavaFileObject file;\n+  219:         return new CodecModel(parent, methodElement, responseElement, eventElementList, retryable, lang);\n+  220:     }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/wordpress-mobile/WordPress-Android.git",
        "branch": "master",
        "commitId": "3b95d10985776fb7b710089ff71074fd2bf860ee",
        "sourceCodeBeforeRefactoring": "@Override\n        protected SiteList doInBackground(Void... params) {\n            List<Map<String, Object>> blogs;\n            String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n\n            if (mShowHiddenSites) {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs and all wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(null, extraFields);\n                } else {\n                    // only wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n                }\n            } else {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs plus visible wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n                } else {\n                    // only visible wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n                }\n            }\n\n            SiteList sites = new SiteList(blogs);\n\n            // sort by blog/host\n            Collections.sort(sites, new Comparator<SiteRecord>() {\n                public int compare(SiteRecord site1, SiteRecord site2) {\n                    return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n                }\n            });\n\n            return sites;\n        }",
        "refactoredCode": "### Original Code:\n```java\n@Override\nprotected SiteList doInBackground(Void... params) {\n    List<Map<String, Object>> blogs;\n    String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n\n    if (mShowHiddenSites) {\n        if (mShowSelfHostedSites) {\n            // all self-hosted blogs and all wp.com blogs\n            blogs = WordPress.wpDB.getBlogsBy(null, extraFields);\n        } else {\n            // only wp.com blogs\n            blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n        }\n    } else {\n        if (mShowSelfHostedSites) {\n            // all self-hosted blogs plus visible wp.com blogs\n            blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n        } else {\n            // only visible wp.com blogs\n            blogs = WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n        }\n    }\n\n    SiteList sites = new SiteList(blogs);\n\n    // sort by blog/host\n    Collections.sort(sites, new Comparator<SiteRecord>() {\n        public int compare(SiteRecord site1, SiteRecord site2) {\n            return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n        }\n    });\n\n    return sites;\n}\n```\n\n### Refactored Code:\n```java\n@Override\nprotected SiteList doInBackground(Void... params) {\n    List<Map<String, Object>> blogs = fetchBlogs();\n    SiteList sites = new SiteList(blogs);\n    sortSites(sites);\n    return sites;\n}\n\nprivate List<Map<String, Object>> fetchBlogs() {\n    String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n    if (mShowHiddenSites) {\n        return mShowSelfHostedSites ? \n            WordPress.wpDB.getBlogsBy(null, extraFields) : \n            WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n    } else {\n        return mShowSelfHostedSites ? \n            WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1)\", extraFields) : \n            WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n    }\n}\n\nprivate void sortSites(SiteList sites) {\n    Collections.sort(sites, new Comparator<SiteRecord>() {\n        public int compare(SiteRecord site1, SiteRecord site2) {\n            return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n        }\n    });\n}\n```\n\n### Explanation:\n1. **Method Extraction**: The original method `doInBackground` was broken down into two smaller methods: `fetchBlogs` and `sortSites`. \n   - `fetchBlogs` handles the logic for retrieving the blogs based on the visibility flags.\n   - `sortSites` is responsible for sorting the `SiteList`.\n\n2. **Single Responsibility**: Each extracted method has a clear, single responsibility, improving readability and maintainability.\n\n3. **Functionality Unchanged**: The refactored code maintains the same functionality as the original code, ensuring that the behavior remains consistent.",
        "sourceCodeAfterRefactoring": "@Override\n        protected SiteList doInBackground(Void... params) {\n            List<Map<String, Object>> blogs;\n\n            if (mIsInSearchMode) {\n                blogs = WordPress.wpDB.getAllBlogs();\n            } else {\n                blogs = getBlogsForCurrentView();\n            }\n\n            SiteList sites = new SiteList(blogs);\n\n            // sort by blog/host\n            Collections.sort(sites, new Comparator<SiteRecord>() {\n                public int compare(SiteRecord site1, SiteRecord site2) {\n                    return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n                }\n            });\n\n            return sites;\n        }\nprivate List<Map<String, Object>> getBlogsForCurrentView() {\n            String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n\n            if (mShowHiddenSites) {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs and all wp.com blogs\n                    return WordPress.wpDB.getBlogsBy(null, extraFields);\n                } else {\n                    // only wp.com blogs\n                    return WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n                }\n            } else {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs plus visible wp.com blogs\n                    return WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n                } else {\n                    // only visible wp.com blogs\n                    return WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n                }\n            }\n        }",
        "diffSourceCode": "-  328:         @Override\n-  329:         protected SiteList doInBackground(Void... params) {\n-  330:             List<Map<String, Object>> blogs;\n-  331:             String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n+  328:         } else {\n+  329:             return filteredSitesByText(sites);\n+  330:         }\n+  331:     }\n   332: \n-  333:             if (mShowHiddenSites) {\n-  334:                 if (mShowSelfHostedSites) {\n-  335:                     // all self-hosted blogs and all wp.com blogs\n-  336:                     blogs = WordPress.wpDB.getBlogsBy(null, extraFields);\n-  337:                 } else {\n-  338:                     // only wp.com blogs\n-  339:                     blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n-  340:                 }\n-  341:             } else {\n-  342:                 if (mShowSelfHostedSites) {\n-  343:                     // all self-hosted blogs plus visible wp.com blogs\n-  344:                     blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n-  345:                 } else {\n-  346:                     // only visible wp.com blogs\n-  347:                     blogs = WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n-  348:                 }\n-  349:             }\n-  350: \n-  351:             SiteList sites = new SiteList(blogs);\n-  352: \n-  353:             // sort by blog/host\n-  354:             Collections.sort(sites, new Comparator<SiteRecord>() {\n-  355:                 public int compare(SiteRecord site1, SiteRecord site2) {\n-  356:                     return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n-  357:                 }\n-  358:             });\n+  333:     private SiteList filteredSitesByText(SiteList sites) {\n+  334:         SiteList filteredSiteList = new SiteList();\n+  335: \n+  336:         for (int i = 0; i < sites.size(); i++) {\n+  337:             SiteRecord record = sites.get(i);\n+  338:             String siteNameLowerCase = record.blogName.toLowerCase();\n+  339:             String hostNameLowerCase = record.hostName.toLowerCase();\n+  340: \n+  341:             if (siteNameLowerCase.contains(mLastSearch.toLowerCase()) || hostNameLowerCase.contains(mLastSearch.toLowerCase())) {\n+  342:                 filteredSiteList.add(record);\n+  343:             }\n+  344:         }\n+  345: \n+  346:         return filteredSiteList;\n+  347:     }\n+  348: \n+  349:     /*\n+  350:      * AsyncTask which loads sites from database and populates the adapter\n+  351:      */\n+  352:     private boolean mIsTaskRunning;\n+  353:     private class LoadSitesTask extends AsyncTask<Void, Void, SiteList> {\n+  354:         @Override\n+  355:         protected void onPreExecute() {\n+  356:             super.onPreExecute();\n+  357:             mIsTaskRunning = true;\n+  358:         }\n   359: \n-  360:             return sites;\n-  361:         }\n-  366:                 mSites = sites;\n-  367:                 notifyDataSetChanged();\n-  368:             }\n-  369:             mIsTaskRunning = false;\n-  370:         }\n-  371:     }\n-  372: \n-  373:     /**\n-  374:      * SiteRecord is a simplified version of the full account (blog) record\n-  375:      */\n-  376:     static class SiteRecord {\n-  377:         final int localId;\n-  378:         final String blogId;\n-  379:         final String blogName;\n-  380:         final String hostName;\n-  381:         final String url;\n-  382:         final String blavatarUrl;\n-  383:         final boolean isDotCom;\n-  384:         boolean isHidden;\n-  385: \n-  386:         SiteRecord(Map<String, Object> account) {\n-  398:             if (TextUtils.isEmpty(blogName)) {\n-  399:                 return hostName;\n-  400:             }\n-  401:             return blogName;\n-  402:         }\n-  403:     }\n-  404: \n-  405:     static class SiteList extends ArrayList<SiteRecord> {\n-  406:         SiteList() { }\n-  407:         SiteList(List<Map<String, Object>> accounts) {\n-  408:             if (accounts != null) {\n-  409:                 for (Map<String, Object> account : accounts) {\n-  410:                     add(new SiteRecord(account));\n-  411:                 }\n-  412:             }\n-  413:         }\n-  414: \n-  415:         boolean isSameList(SiteList sites) {\n-  416:             if (sites == null || sites.size() != this.size()) {\n-  417:                 return false;\n-  418:             }\n+  360:         @Override\n+  361:         protected void onCancelled() {\n+  366:         @Override\n+  367:         protected SiteList doInBackground(Void... params) {\n+  368:             List<Map<String, Object>> blogs;\n+  369: \n+  370:             if (mIsInSearchMode) {\n+  371:                 blogs = WordPress.wpDB.getAllBlogs();\n+  372:             } else {\n+  373:                 blogs = getBlogsForCurrentView();\n+  374:             }\n+  375: \n+  376:             SiteList sites = new SiteList(blogs);\n+  377: \n+  378:             // sort by blog/host\n+  379:             Collections.sort(sites, new Comparator<SiteRecord>() {\n+  380:                 public int compare(SiteRecord site1, SiteRecord site2) {\n+  381:                     return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n+  382:                 }\n+  383:             });\n+  384: \n+  385:             return sites;\n+  386:         }\n+  398:         private List<Map<String, Object>> getBlogsForCurrentView() {\n+  399:             String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n+  400: \n+  401:             if (mShowHiddenSites) {\n+  402:                 if (mShowSelfHostedSites) {\n+  403:                     // all self-hosted blogs and all wp.com blogs\n+  404:                     return WordPress.wpDB.getBlogsBy(null, extraFields);\n+  405:                 } else {\n+  406:                     // only wp.com blogs\n+  407:                     return WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n+  408:                 }\n+  409:             } else {\n+  410:                 if (mShowSelfHostedSites) {\n+  411:                     // all self-hosted blogs plus visible wp.com blogs\n+  412:                     return WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n+  413:                 } else {\n+  414:                     // only visible wp.com blogs\n+  415:                     return WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n+  416:                 }\n+  417:             }\n+  418:         }\n",
        "uniqueId": "3b95d10985776fb7b710089ff71074fd2bf860ee_328_361_398_418_366_386",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n public void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n\n    Collections.sort(rules, new CategoryComparator());\n\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    // JPanel\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n    treeModel.addTreeModelListener(new TreeModelListener() {\n\n      @Override\n      public void treeNodesChanged(TreeModelEvent e) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n        int index = e.getChildIndices()[0];\n        node = (DefaultMutableTreeNode) node.getChildAt(index);\n        if (node instanceof RuleNode) {\n          RuleNode o = (RuleNode) node;\n          if (o.getRule().isDefaultOff()) {\n            if (o.isEnabled()) {\n              config.getEnabledRuleIds().add(o.getRule().getId());\n            } else {\n              config.getEnabledRuleIds().remove(o.getRule().getId());\n            }\n          } else {\n            if (o.isEnabled()) {\n              config.getDisabledRuleIds().remove(o.getRule().getId());\n            } else {\n              config.getDisabledRuleIds().add(o.getRule().getId());\n            }\n          }\n        }\n        if (node instanceof CategoryNode) {\n          CategoryNode o = (CategoryNode) node;\n          if (o.isEnabled()) {\n            config.getDisabledCategoryNames().remove(o.getCategory().getName());\n          } else {\n            config.getDisabledCategoryNames().add(o.getCategory().getName());\n          }\n        }\n      }\n\n      @Override\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeStructureChanged(TreeModelEvent e) {\n      }\n    });\n    configTree = new JTree(treeModel);\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(\n      ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n\n    MouseAdapter ma = new MouseAdapter() {\n      private void handlePopupEvent(MouseEvent e) {\n        final JTree tree = (JTree) e.getSource();\n\n        TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n        if (path == null) {\n          return;\n        }\n\n        DefaultMutableTreeNode node\n                = (DefaultMutableTreeNode) path.getLastPathComponent();\n\n        TreePath[] paths = tree.getSelectionPaths();\n\n        boolean isSelected = false;\n        if (paths != null) {\n          for (TreePath selectionPath : paths) {\n            if (selectionPath.equals(path)) {\n              isSelected = true;\n            }\n          }\n        }\n        if (!isSelected) {\n          tree.setSelectionPath(path);\n        }\n        if (node.isLeaf()) {\n          JPopupMenu popup = new JPopupMenu();\n          final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n          aboutRuleMenuItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {\n              RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n              Rule rule = node.getRule();\n              Language lang = config.getLanguage();\n              if(lang == null) {\n                lang = Languages.getLanguageForLocale(Locale.getDefault());\n              }\n              Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n                      rule.getDescription(), rule, messages,\n                      lang.getShortNameWithCountryAndVariant());\n            }\n          });\n          popup.add(aboutRuleMenuItem);\n          popup.show(tree, e.getX(), e.getY());\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n    };\n    configTree.addMouseListener(ma);\n    final JPanel treeButtonPanel = new JPanel();\n    cons = new GridBagConstraints();\n    cons.gridx = 0;\n    cons.gridy = 0;\n    final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n    treeButtonPanel.add(expandAllButton, cons);\n    expandAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n          TreeNode n = (TreeNode) cat.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.expandPath(child);\n        }\n      }\n    });\n\n    cons.gridx = 1;\n    cons.gridy = 0;\n    final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n    treeButtonPanel.add(collapseAllButton, cons);\n    collapseAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n          TreeNode n = (TreeNode) categ.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.collapsePath(child);\n        }\n      }\n    });\n\n    final JPanel motherTonguePanel = new JPanel();\n    motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n    motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n    if (config.getMotherTongue() != null) {\n      motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n    }\n    motherTongueBox.addItemListener(new ItemListener() {\n\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        if (e.getStateChange() == ItemEvent.SELECTED) {\n          Language motherTongue;\n          if (motherTongueBox.getSelectedItem() instanceof String) {\n            motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n          } else {\n            motherTongue = (Language) motherTongueBox.getSelectedItem();\n          }\n          config.setMotherTongue(motherTongue);\n        }\n      }\n    });\n    motherTonguePanel.add(motherTongueBox, cons);\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setSelected(config.getRunServer());\n      portPanel.add(serverCheckbox, cons);\n      serverCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n          serverPortField.setEnabled(serverCheckbox.isSelected());\n          serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n        }\n      });\n      serverCheckbox.addItemListener(new ItemListener() {\n\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setRunServer(serverCheckbox.isSelected());\n        }\n      });\n\n      serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n      serverPortField.setEnabled(serverCheckbox.isSelected());\n      serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n      serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n      cons.gridx = 1;\n      portPanel.add(serverPortField, cons);\n      serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n          try {\n            int serverPort = Integer.parseInt(serverPortField.getText());\n            if (serverPort > -1 && serverPort < MAX_PORT) {\n              serverPortField.setForeground(null);\n              config.setServerPort(serverPort);\n            } else {\n              serverPortField.setForeground(Color.RED);\n            }\n          } catch (NumberFormatException ex) {\n            serverPortField.setForeground(Color.RED);\n          }\n        }\n      });\n\n      cons.gridx = 0;\n      cons.gridy = 10;      \n      serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n          .getString(\"useGUIConfig\")));\n      serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n      serverSettingsCheckbox.setEnabled(config.getRunServer());\n      serverSettingsCheckbox.addItemListener(new ItemListener() {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n        }\n      });\n      portPanel.add(serverSettingsCheckbox, cons);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(treeButtonPanel, cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(motherTonguePanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\n SourceCodeAfterRefactoring:\npublic void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    Collections.sort(rules, new CategoryComparator());\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    configTree = new JTree(getTreeModel(rootNode));\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n    configTree.addMouseListener(getMouseAdapter());\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      createNonOfficeElements(cons, portPanel);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(getTreeButtonPanel(), cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(getMotherTonguePanel(cons), cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\nprivate void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n    serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setSelected(config.getRunServer());\n    portPanel.add(serverCheckbox, cons);\n    serverCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n        serverPortField.setEnabled(serverCheckbox.isSelected());\n        serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n      }\n    });\n    serverCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setRunServer(serverCheckbox.isSelected());\n      }\n    });\n\n    serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n    serverPortField.setEnabled(serverCheckbox.isSelected());\n    serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n    serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n    cons.gridx = 1;\n    portPanel.add(serverPortField, cons);\n    serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void changedUpdate(DocumentEvent e) {\n        try {\n          int serverPort = Integer.parseInt(serverPortField.getText());\n          if (serverPort > -1 && serverPort < MAX_PORT) {\n            serverPortField.setForeground(null);\n            config.setServerPort(serverPort);\n          } else {\n            serverPortField.setForeground(Color.RED);\n          }\n        } catch (NumberFormatException ex) {\n          serverPortField.setForeground(Color.RED);\n        }\n      }\n    });\n\n    cons.gridx = 0;\n    cons.gridy = 10;\n    serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n    serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n    serverSettingsCheckbox.setEnabled(config.getRunServer());\n    serverSettingsCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n      }\n    });\n    portPanel.add(serverSettingsCheckbox, cons);\n  }\n DiffSourceCode:\n-  117:   public void show(List<Rule> rules) {\n-  118:     if (original != null) {\n-  119:       config.restoreState(original);\n-  120:     }\n-  121:     dialog = new JDialog(owner, true);\n-  122:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n-  123: \n-  124:     Collections.sort(rules, new CategoryComparator());\n-  125: \n-  126:     // close dialog when user presses Escape key:\n-  127:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n-  128:     final ActionListener actionListener = new ActionListener() {\n-  129:       @Override\n-  130:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n-  131:         dialog.setVisible(false);\n-  132:       }\n-  133:     };\n-  134:     final JRootPane rootPane = dialog.getRootPane();\n-  135:     rootPane.registerKeyboardAction(actionListener, stroke,\n-  136:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n-  137: \n-  138:     // JPanel\n-  139:     final JPanel checkBoxPanel = new JPanel();\n-  140:     checkBoxPanel.setLayout(new GridBagLayout());\n-  141:     GridBagConstraints cons = new GridBagConstraints();\n-  142:     cons.anchor = GridBagConstraints.NORTHWEST;\n-  143:     cons.gridx = 0;\n-  144:     cons.weightx = 1.0;\n-  145:     cons.weighty = 1.0;\n-  146:     cons.fill = GridBagConstraints.BOTH;\n-  147:     DefaultMutableTreeNode rootNode = createTree(rules);\n-  148:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n-  149:     treeModel.addTreeModelListener(new TreeModelListener() {\n-  150: \n-  151:       @Override\n-  152:       public void treeNodesChanged(TreeModelEvent e) {\n-  153:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n-  154:         int index = e.getChildIndices()[0];\n-  155:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n-  156:         if (node instanceof RuleNode) {\n-  157:           RuleNode o = (RuleNode) node;\n-  158:           if (o.getRule().isDefaultOff()) {\n-  159:             if (o.isEnabled()) {\n-  160:               config.getEnabledRuleIds().add(o.getRule().getId());\n-  161:             } else {\n-  162:               config.getEnabledRuleIds().remove(o.getRule().getId());\n-  163:             }\n-  164:           } else {\n-  165:             if (o.isEnabled()) {\n-  166:               config.getDisabledRuleIds().remove(o.getRule().getId());\n-  167:             } else {\n-  168:               config.getDisabledRuleIds().add(o.getRule().getId());\n-  169:             }\n-  170:           }\n-  171:         }\n-  172:         if (node instanceof CategoryNode) {\n-  173:           CategoryNode o = (CategoryNode) node;\n-  174:           if (o.isEnabled()) {\n-  175:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n-  176:           } else {\n-  177:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n-  178:           }\n-  179:         }\n-  180:       }\n-  181: \n-  182:       @Override\n-  183:       public void treeNodesInserted(TreeModelEvent e) {\n-  184:       }\n-  185: \n-  186:       @Override\n-  187:       public void treeNodesRemoved(TreeModelEvent e) {\n-  188:       }\n-  189: \n-  190:       @Override\n-  191:       public void treeStructureChanged(TreeModelEvent e) {\n-  192:       }\n-  193:     });\n-  194:     configTree = new JTree(treeModel);\n-  195: \n-  196:     Language lang = config.getLanguage();\n-  197:     if (lang == null) {\n-  198:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  199:     }\n-  200:     configTree.applyComponentOrientation(\n-  201:       ComponentOrientation.getOrientation(lang.getLocale()));\n-  202: \n-  203:     configTree.setRootVisible(false);\n-  204:     configTree.setEditable(false);\n-  205:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n-  206:     TreeListener.install(configTree);\n-  207:     checkBoxPanel.add(configTree, cons);\n-  208: \n-  209:     MouseAdapter ma = new MouseAdapter() {\n-  210:       private void handlePopupEvent(MouseEvent e) {\n-  211:         final JTree tree = (JTree) e.getSource();\n-  212: \n-  213:         TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n-  214:         if (path == null) {\n-  215:           return;\n-  216:         }\n-  217: \n-  218:         DefaultMutableTreeNode node\n-  219:                 = (DefaultMutableTreeNode) path.getLastPathComponent();\n-  220: \n-  221:         TreePath[] paths = tree.getSelectionPaths();\n-  222: \n-  223:         boolean isSelected = false;\n-  224:         if (paths != null) {\n-  225:           for (TreePath selectionPath : paths) {\n-  226:             if (selectionPath.equals(path)) {\n-  227:               isSelected = true;\n-  228:             }\n-  229:           }\n-  230:         }\n-  231:         if (!isSelected) {\n-  232:           tree.setSelectionPath(path);\n-  233:         }\n-  234:         if (node.isLeaf()) {\n-  235:           JPopupMenu popup = new JPopupMenu();\n-  236:           final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n-  237:           aboutRuleMenuItem.addActionListener(new ActionListener() {\n-  238:             @Override\n-  239:             public void actionPerformed(ActionEvent actionEvent) {\n-  240:               RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n-  241:               Rule rule = node.getRule();\n-  242:               Language lang = config.getLanguage();\n-  243:               if(lang == null) {\n-  244:                 lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  245:               }\n-  246:               Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n-  247:                       rule.getDescription(), rule, messages,\n-  248:                       lang.getShortNameWithCountryAndVariant());\n-  249:             }\n-  250:           });\n-  251:           popup.add(aboutRuleMenuItem);\n-  252:           popup.show(tree, e.getX(), e.getY());\n-  253:         }\n-  254:       }\n-  255: \n-  256:       @Override\n-  257:       public void mousePressed(MouseEvent e) {\n-  258:         if (e.isPopupTrigger()) {\n-  259:           handlePopupEvent(e);\n-  260:         }\n-  261:       }\n-  262: \n-  263:       @Override\n-  264:       public void mouseReleased(MouseEvent e) {\n-  265:         if (e.isPopupTrigger()) {\n-  266:           handlePopupEvent(e);\n-  267:         }\n-  268:       }\n-  269:     };\n-  270:     configTree.addMouseListener(ma);\n-  271:     final JPanel treeButtonPanel = new JPanel();\n-  272:     cons = new GridBagConstraints();\n-  273:     cons.gridx = 0;\n-  274:     cons.gridy = 0;\n-  275:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n-  276:     treeButtonPanel.add(expandAllButton, cons);\n-  277:     expandAllButton.addActionListener(new ActionListener() {\n-  278: \n-  279:       @Override\n-  280:       public void actionPerformed(ActionEvent e) {\n-  281:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  282:         TreePath parent = new TreePath(root);\n-  283:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n-  284:           TreeNode n = (TreeNode) cat.nextElement();\n-  285:           TreePath child = parent.pathByAddingChild(n);\n-  286:           configTree.expandPath(child);\n-  287:         }\n-  288:       }\n-  289:     });\n-  290: \n-  291:     cons.gridx = 1;\n-  292:     cons.gridy = 0;\n-  293:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n-  294:     treeButtonPanel.add(collapseAllButton, cons);\n-  295:     collapseAllButton.addActionListener(new ActionListener() {\n-  296: \n-  297:       @Override\n-  298:       public void actionPerformed(ActionEvent e) {\n-  299:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  300:         TreePath parent = new TreePath(root);\n-  301:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n-  302:           TreeNode n = (TreeNode) categ.nextElement();\n-  303:           TreePath child = parent.pathByAddingChild(n);\n-  304:           configTree.collapsePath(child);\n-  305:         }\n-  306:       }\n-  307:     });\n-  308: \n-  309:     final JPanel motherTonguePanel = new JPanel();\n-  310:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n-  311:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n-  312:     if (config.getMotherTongue() != null) {\n-  313:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n-  314:     }\n-  315:     motherTongueBox.addItemListener(new ItemListener() {\n-  316: \n-  317:       @Override\n-  318:       public void itemStateChanged(ItemEvent e) {\n-  319:         if (e.getStateChange() == ItemEvent.SELECTED) {\n-  320:           Language motherTongue;\n-  321:           if (motherTongueBox.getSelectedItem() instanceof String) {\n-  322:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  117: \n+  118:   public void show(List<Rule> rules) {\n+  119:     if (original != null) {\n+  120:       config.restoreState(original);\n+  121:     }\n+  122:     dialog = new JDialog(owner, true);\n+  123:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n+  124:     // close dialog when user presses Escape key:\n+  125:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n+  126:     final ActionListener actionListener = new ActionListener() {\n+  127:       @Override\n+  128:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n+  129:         dialog.setVisible(false);\n+  130:       }\n+  131:     };\n+  132:     final JRootPane rootPane = dialog.getRootPane();\n+  133:     rootPane.registerKeyboardAction(actionListener, stroke,\n+  134:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n+  135: \n+  136:     final JPanel checkBoxPanel = new JPanel();\n+  137:     checkBoxPanel.setLayout(new GridBagLayout());\n+  138:     GridBagConstraints cons = new GridBagConstraints();\n+  139:     cons.anchor = GridBagConstraints.NORTHWEST;\n+  140:     cons.gridx = 0;\n+  141:     cons.weightx = 1.0;\n+  142:     cons.weighty = 1.0;\n+  143:     cons.fill = GridBagConstraints.BOTH;\n+  144:     Collections.sort(rules, new CategoryComparator());\n+  145:     DefaultMutableTreeNode rootNode = createTree(rules);\n+  146:     configTree = new JTree(getTreeModel(rootNode));\n+  147: \n+  148:     Language lang = config.getLanguage();\n+  149:     if (lang == null) {\n+  150:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  151:     }\n+  152:     configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n+  153: \n+  154:     configTree.setRootVisible(false);\n+  155:     configTree.setEditable(false);\n+  156:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n+  157:     TreeListener.install(configTree);\n+  158:     checkBoxPanel.add(configTree, cons);\n+  159:     configTree.addMouseListener(getMouseAdapter());\n+  160:     \n+  161:     final JPanel portPanel = new JPanel();\n+  162:     portPanel.setLayout(new GridBagLayout());\n+  163:     cons = new GridBagConstraints();\n+  164:     cons.insets = new Insets(0, 4, 0, 0);\n+  165:     cons.gridx = 0;\n+  166:     cons.gridy = 0;\n+  167:     cons.anchor = GridBagConstraints.WEST;\n+  168:     cons.fill = GridBagConstraints.NONE;\n+  169:     cons.weightx = 0.0f;\n+  170:     if (!insideOffice) {\n+  171:       createNonOfficeElements(cons, portPanel);\n+  172:     }\n+  173: \n+  174:     final JPanel buttonPanel = new JPanel();\n+  175:     buttonPanel.setLayout(new GridBagLayout());\n+  176:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n+  177:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n+  178:     okButton.addActionListener(this);\n+  179:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n+  180:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n+  181:     cancelButton.addActionListener(this);\n+  182:     cons = new GridBagConstraints();\n+  183:     cons.insets = new Insets(0, 4, 0, 0);\n+  184:     buttonPanel.add(okButton, cons);\n+  185:     buttonPanel.add(cancelButton, cons);\n+  186: \n+  187:     final Container contentPane = dialog.getContentPane();\n+  188:     contentPane.setLayout(new GridBagLayout());\n+  189:     cons = new GridBagConstraints();\n+  190:     cons.insets = new Insets(4, 4, 4, 4);\n+  191:     cons.gridx = 0;\n+  192:     cons.gridy = 0;\n+  193:     cons.weightx = 10.0f;\n+  194:     cons.weighty = 10.0f;\n+  195:     cons.fill = GridBagConstraints.BOTH;\n+  196:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n+  197: \n+  198:     cons.gridx = 0;\n+  199:     cons.gridy++;\n+  200:     cons.fill = GridBagConstraints.NONE;\n+  201:     cons.anchor = GridBagConstraints.LINE_END;\n+  202:     contentPane.add(getTreeButtonPanel(), cons);\n+  203:     \n+  204:     cons.gridy++;\n+  205:     cons.anchor = GridBagConstraints.WEST;\n+  206:     contentPane.add(getMotherTonguePanel(cons), cons);\n+  207: \n+  208:     cons.gridy++;\n+  209:     cons.anchor = GridBagConstraints.WEST;\n+  210:     contentPane.add(portPanel, cons);\n+  211: \n+  212:     cons.gridy++;\n+  213:     cons.anchor = GridBagConstraints.EAST;\n+  214:     contentPane.add(buttonPanel, cons);\n+  215: \n+  216:     dialog.pack();\n+  217:     dialog.setSize(500, 500);\n+  218:     // center on screen:\n+  219:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+  220:     final Dimension frameSize = dialog.getSize();\n+  221:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n+  222:         screenSize.height / 2 - frameSize.height / 2);\n+  223:     dialog.setLocationByPlatform(true);\n+  224:     dialog.setVisible(true);\n+  225:   }\n+  226: \n+  227:   private void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n+  228:     serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n+  229:     serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n+  230:     serverCheckbox.setSelected(config.getRunServer());\n+  231:     portPanel.add(serverCheckbox, cons);\n+  232:     serverCheckbox.addActionListener(new ActionListener() {\n+  233:       @Override\n+  234:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n+  235:         serverPortField.setEnabled(serverCheckbox.isSelected());\n+  236:         serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n+  237:       }\n+  238:     });\n+  239:     serverCheckbox.addItemListener(new ItemListener() {\n+  240:       @Override\n+  241:       public void itemStateChanged(ItemEvent e) {\n+  242:         config.setRunServer(serverCheckbox.isSelected());\n+  243:       }\n+  244:     });\n+  245: \n+  246:     serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n+  247:     serverPortField.setEnabled(serverCheckbox.isSelected());\n+  248:     serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n+  249:     serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n+  250:     cons.gridx = 1;\n+  251:     portPanel.add(serverPortField, cons);\n+  252:     serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n+  253: \n+  254:       @Override\n+  255:       public void insertUpdate(DocumentEvent e) {\n+  256:         changedUpdate(e);\n+  257:       }\n+  258: \n+  259:       @Override\n+  260:       public void removeUpdate(DocumentEvent e) {\n+  261:         changedUpdate(e);\n+  262:       }\n+  263: \n+  264:       @Override\n+  265:       public void changedUpdate(DocumentEvent e) {\n+  266:         try {\n+  267:           int serverPort = Integer.parseInt(serverPortField.getText());\n+  268:           if (serverPort > -1 && serverPort < MAX_PORT) {\n+  269:             serverPortField.setForeground(null);\n+  270:             config.setServerPort(serverPort);\n+  271:           } else {\n+  272:             serverPortField.setForeground(Color.RED);\n+  273:           }\n+  274:         } catch (NumberFormatException ex) {\n+  275:           serverPortField.setForeground(Color.RED);\n+  276:         }\n+  277:       }\n+  278:     });\n+  279: \n+  280:     cons.gridx = 0;\n+  281:     cons.gridy = 10;\n+  282:     serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n+  283:     serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n+  284:     serverSettingsCheckbox.setEnabled(config.getRunServer());\n+  285:     serverSettingsCheckbox.addItemListener(new ItemListener() {\n+  286:       @Override\n+  287:       public void itemStateChanged(ItemEvent e) {\n+  288:         config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n+  289:       }\n+  290:     });\n+  291:     portPanel.add(serverSettingsCheckbox, cons);\n+  292:   }\n+  293: \n+  294:   @NotNull\n+  295:   private DefaultTreeModel getTreeModel(DefaultMutableTreeNode rootNode) {\n+  296:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n+  297:     treeModel.addTreeModelListener(new TreeModelListener() {\n+  298:       @Override\n+  299:       public void treeNodesChanged(TreeModelEvent e) {\n+  300:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n+  301:         int index = e.getChildIndices()[0];\n+  302:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n+  303:         if (node instanceof RuleNode) {\n+  304:           RuleNode o = (RuleNode) node;\n+  305:           if (o.getRule().isDefaultOff()) {\n+  306:             if (o.isEnabled()) {\n+  307:               config.getEnabledRuleIds().add(o.getRule().getId());\n+  308:             } else {\n+  309:               config.getEnabledRuleIds().remove(o.getRule().getId());\n+  310:             }\n+  311:           } else {\n+  312:             if (o.isEnabled()) {\n+  313:               config.getDisabledRuleIds().remove(o.getRule().getId());\n+  314:             } else {\n+  315:               config.getDisabledRuleIds().add(o.getRule().getId());\n+  316:             }\n+  317:           }\n+  318:         }\n+  319:         if (node instanceof CategoryNode) {\n+  320:           CategoryNode o = (CategoryNode) node;\n+  321:           if (o.isEnabled()) {\n+  322:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n   323:           } else {\n-  324:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  324:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n   325:           }\n-  326:           config.setMotherTongue(motherTongue);\n-  327:         }\n-  328:       }\n-  329:     });\n-  330:     motherTonguePanel.add(motherTongueBox, cons);\n-  331:     \n-  332:     final JPanel portPanel = new JPanel();\n-  333:     portPanel.setLayout(new GridBagLayout());\n-  334:     cons = new GridBagConstraints();\n-  335:     cons.insets = new Insets(0, 4, 0, 0);\n-  336:     cons.gridx = 0;\n-  337:     cons.gridy = 0;\n-  338:     cons.anchor = GridBagConstraints.WEST;\n-  339:     cons.fill = GridBagConstraints.NONE;\n-  340:     cons.weightx = 0.0f;\n-  341:     if (!insideOffice) {\n-  342:       serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n-  343:       serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n-  344:       serverCheckbox.setSelected(config.getRunServer());\n-  345:       portPanel.add(serverCheckbox, cons);\n-  346:       serverCheckbox.addActionListener(new ActionListener() {\n-  347:         @Override\n-  348:         public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n-  349:           serverPortField.setEnabled(serverCheckbox.isSelected());\n-  350:           serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n-  351:         }\n-  352:       });\n-  353:       serverCheckbox.addItemListener(new ItemListener() {\n-  354: \n-  355:         @Override\n-  356:         public void itemStateChanged(ItemEvent e) {\n-  357:           config.setRunServer(serverCheckbox.isSelected());\n-  358:         }\n-  359:       });\n-  360: \n-  361:       serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n-  362:       serverPortField.setEnabled(serverCheckbox.isSelected());\n-  363:       serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n-  364:       serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n-  365:       cons.gridx = 1;\n-  366:       portPanel.add(serverPortField, cons);\n-  367:       serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n-  368: \n-  369:         @Override\n-  370:         public void insertUpdate(DocumentEvent e) {\n-  371:           changedUpdate(e);\n-  372:         }\n-  373: \n-  374:         @Override\n-  375:         public void removeUpdate(DocumentEvent e) {\n-  376:           changedUpdate(e);\n-  377:         }\n-  378: \n-  379:         @Override\n-  380:         public void changedUpdate(DocumentEvent e) {\n-  381:           try {\n-  382:             int serverPort = Integer.parseInt(serverPortField.getText());\n-  383:             if (serverPort > -1 && serverPort < MAX_PORT) {\n-  384:               serverPortField.setForeground(null);\n-  385:               config.setServerPort(serverPort);\n-  386:             } else {\n-  387:               serverPortField.setForeground(Color.RED);\n-  388:             }\n-  389:           } catch (NumberFormatException ex) {\n-  390:             serverPortField.setForeground(Color.RED);\n-  391:           }\n-  392:         }\n-  393:       });\n-  394: \n-  395:       cons.gridx = 0;\n-  396:       cons.gridy = 10;      \n-  397:       serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n-  398:           .getString(\"useGUIConfig\")));\n-  399:       serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n-  400:       serverSettingsCheckbox.setEnabled(config.getRunServer());\n-  401:       serverSettingsCheckbox.addItemListener(new ItemListener() {\n-  402:         @Override\n-  403:         public void itemStateChanged(ItemEvent e) {\n-  404:           config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n-  405:         }\n-  406:       });\n-  407:       portPanel.add(serverSettingsCheckbox, cons);\n-  408:     }\n+  326:         }\n+  327:       }\n+  328:       @Override\n+  329:       public void treeNodesInserted(TreeModelEvent e) {}\n+  330:       @Override\n+  331:       public void treeNodesRemoved(TreeModelEvent e) {}\n+  332:       @Override\n+  333:       public void treeStructureChanged(TreeModelEvent e) {}\n+  334:     });\n+  335:     return treeModel;\n+  336:   }\n+  337: \n+  338:   @NotNull\n+  339:   private MouseAdapter getMouseAdapter() {\n+  340:     return new MouseAdapter() {\n+  341:         private void handlePopupEvent(MouseEvent e) {\n+  342:           final JTree tree = (JTree) e.getSource();\n+  343:           TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n+  344:           if (path == null) {\n+  345:             return;\n+  346:           }\n+  347:           DefaultMutableTreeNode node\n+  348:                   = (DefaultMutableTreeNode) path.getLastPathComponent();\n+  349:           TreePath[] paths = tree.getSelectionPaths();\n+  350:           boolean isSelected = false;\n+  351:           if (paths != null) {\n+  352:             for (TreePath selectionPath : paths) {\n+  353:               if (selectionPath.equals(path)) {\n+  354:                 isSelected = true;\n+  355:               }\n+  356:             }\n+  357:           }\n+  358:           if (!isSelected) {\n+  359:             tree.setSelectionPath(path);\n+  360:           }\n+  361:           if (node.isLeaf()) {\n+  362:             JPopupMenu popup = new JPopupMenu();\n+  363:             final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n+  364:             aboutRuleMenuItem.addActionListener(new ActionListener() {\n+  365:               @Override\n+  366:               public void actionPerformed(ActionEvent actionEvent) {\n+  367:                 RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n+  368:                 Rule rule = node.getRule();\n+  369:                 Language lang = config.getLanguage();\n+  370:                 if(lang == null) {\n+  371:                   lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  372:                 }\n+  373:                 Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n+  374:                         rule.getDescription(), rule, messages,\n+  375:                         lang.getShortNameWithCountryAndVariant());\n+  376:               }\n+  377:             });\n+  378:             popup.add(aboutRuleMenuItem);\n+  379:             popup.show(tree, e.getX(), e.getY());\n+  380:           }\n+  381:         }\n+  382:   \n+  383:         @Override\n+  384:         public void mousePressed(MouseEvent e) {\n+  385:           if (e.isPopupTrigger()) {\n+  386:             handlePopupEvent(e);\n+  387:           }\n+  388:         }\n+  389:   \n+  390:         @Override\n+  391:         public void mouseReleased(MouseEvent e) {\n+  392:           if (e.isPopupTrigger()) {\n+  393:             handlePopupEvent(e);\n+  394:           }\n+  395:         }\n+  396:       };\n+  397:   }\n+  398: \n+  399:   @NotNull\n+  400:   private JPanel getTreeButtonPanel() {\n+  401:     GridBagConstraints cons;\n+  402:     final JPanel treeButtonPanel = new JPanel();\n+  403:     cons = new GridBagConstraints();\n+  404:     cons.gridx = 0;\n+  405:     cons.gridy = 0;\n+  406:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n+  407:     treeButtonPanel.add(expandAllButton, cons);\n+  408:     expandAllButton.addActionListener(new ActionListener() {\n   409: \n-  410:     final JPanel buttonPanel = new JPanel();\n-  411:     buttonPanel.setLayout(new GridBagLayout());\n-  412:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n-  413:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n-  414:     okButton.addActionListener(this);\n-  415:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n-  416:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n-  417:     cancelButton.addActionListener(this);\n-  418:     cons = new GridBagConstraints();\n-  419:     cons.insets = new Insets(0, 4, 0, 0);\n-  420:     buttonPanel.add(okButton, cons);\n-  421:     buttonPanel.add(cancelButton, cons);\n-  422: \n-  423:     final Container contentPane = dialog.getContentPane();\n-  424:     contentPane.setLayout(new GridBagLayout());\n-  425:     cons = new GridBagConstraints();\n-  426:     cons.insets = new Insets(4, 4, 4, 4);\n-  427:     cons.gridx = 0;\n-  428:     cons.gridy = 0;\n-  429:     cons.weightx = 10.0f;\n-  430:     cons.weighty = 10.0f;\n-  431:     cons.fill = GridBagConstraints.BOTH;\n-  432:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n-  433: \n-  434:     cons.gridx = 0;\n-  435:     cons.gridy++;\n-  436:     cons.fill = GridBagConstraints.NONE;\n-  437:     cons.anchor = GridBagConstraints.LINE_END;\n-  438:     contentPane.add(treeButtonPanel, cons);\n-  439:     \n-  440:     cons.gridy++;\n-  441:     cons.anchor = GridBagConstraints.WEST;\n-  442:     contentPane.add(motherTonguePanel, cons);\n-  443: \n-  444:     cons.gridy++;\n-  445:     cons.anchor = GridBagConstraints.WEST;\n-  446:     contentPane.add(portPanel, cons);\n-  447: \n-  448:     cons.gridy++;\n-  449:     cons.anchor = GridBagConstraints.EAST;\n-  450:     contentPane.add(buttonPanel, cons);\n+  410:       @Override\n+  411:       public void actionPerformed(ActionEvent e) {\n+  412:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  413:         TreePath parent = new TreePath(root);\n+  414:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n+  415:           TreeNode n = (TreeNode) cat.nextElement();\n+  416:           TreePath child = parent.pathByAddingChild(n);\n+  417:           configTree.expandPath(child);\n+  418:         }\n+  419:       }\n+  420:     });\n+  421: \n+  422:     cons.gridx = 1;\n+  423:     cons.gridy = 0;\n+  424:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n+  425:     treeButtonPanel.add(collapseAllButton, cons);\n+  426:     collapseAllButton.addActionListener(new ActionListener() {\n+  427: \n+  428:       @Override\n+  429:       public void actionPerformed(ActionEvent e) {\n+  430:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  431:         TreePath parent = new TreePath(root);\n+  432:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n+  433:           TreeNode n = (TreeNode) categ.nextElement();\n+  434:           TreePath child = parent.pathByAddingChild(n);\n+  435:           configTree.collapsePath(child);\n+  436:         }\n+  437:       }\n+  438:     });\n+  439:     return treeButtonPanel;\n+  440:   }\n+  441: \n+  442:   @NotNull\n+  443:   private JPanel getMotherTonguePanel(GridBagConstraints cons) {\n+  444:     final JPanel motherTonguePanel = new JPanel();\n+  445:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n+  446:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n+  447:     if (config.getMotherTongue() != null) {\n+  448:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n+  449:     }\n+  450:     motherTongueBox.addItemListener(new ItemListener() {\n   451: \n-  452:     dialog.pack();\n-  453:     dialog.setSize(500, 500);\n-  454:     // center on screen:\n-  455:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-  456:     final Dimension frameSize = dialog.getSize();\n-  457:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n-  458:         screenSize.height / 2 - frameSize.height / 2);\n-  459:     dialog.setLocationByPlatform(true);\n-  460:     dialog.setVisible(true);\n-  461:   }\n+  452:       @Override\n+  453:       public void itemStateChanged(ItemEvent e) {\n+  454:         if (e.getStateChange() == ItemEvent.SELECTED) {\n+  455:           Language motherTongue;\n+  456:           if (motherTongueBox.getSelectedItem() instanceof String) {\n+  457:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  458:           } else {\n+  459:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  460:           }\n+  461:           config.setMotherTongue(motherTongue);\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n   * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n   * filtering based on three possible arguments:\n   *\n   *  -e (emulator-only) - only emulators are passing the filter\n   *  -d (device-only) - only real devices are passing the filter\n   *  -s (serial) - only device/emulator with specific serial number are passing the filter\n   *\n   *  If more than one device matches the filter this function will fail unless multi-install\n   *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n   *  devices will be used to install the apk if needed.\n   */\n  @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n    List<IDevice> devices;\n\n    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n\n      // Initialize adb connection.\n      AndroidDebugBridge adb = createAdb(context);\n      if (adb == null) {\n        console.printBuildFailure(\"Failed to create adb connection.\");\n        return false;\n      }\n\n      // Build list of matching devices.\n      devices = filterDevices(adb.getDevices());\n      if (devices == null) {\n        if (restartAdbOnFailure) {\n          console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n          adb.restart();\n          devices = filterDevices(adb.getDevices());\n        }\n\n        if (devices == null) {\n            return false;\n        }\n      }\n    }\n\n    int adbThreadCount = options.getAdbThreadCount();\n    if (adbThreadCount <= 0) {\n      adbThreadCount = devices.size();\n    }\n\n    // Start executions on all matching devices.\n    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n    ListeningExecutorService executorService =\n        listeningDecorator(\n            newMultiThreadExecutor(\n                new CommandThreadFactory(getClass().getSimpleName()),\n                adbThreadCount));\n\n    for (final IDevice device : devices) {\n      futures.add(executorService.submit(adbCallable.forDevice(device)));\n    }\n\n    // Wait for all executions to complete or fail.\n    List<Boolean> results = null;\n    try {\n      results = Futures.allAsList(futures).get();\n    } catch (ExecutionException ex) {\n      console.printBuildFailure(\"Failed: \" + adbCallable);\n      ex.printStackTrace(console.getStdErr());\n      return false;\n    } catch (InterruptedException e) {\n      try {\n        Futures.allAsList(futures).cancel(true);\n      } catch (CancellationException ignored) {\n        // Rethrow original InterruptedException instead.\n      }\n      Thread.currentThread().interrupt();\n      throw e;\n    } finally {\n      MoreExecutors.shutdownOrThrow(\n          executorService,\n          10,\n          TimeUnit.MINUTES,\n          new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n    }\n\n    int successCount = 0;\n    for (Boolean result : results) {\n      if (result) {\n        successCount++;\n      }\n    }\n    int failureCount = results.size() - successCount;\n\n    // Report results.\n    if (successCount > 0) {\n      console.printSuccess(\n          String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n    }\n    if (failureCount > 0) {\n      console.printBuildFailure(\n          String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n    }\n\n    return failureCount == 0;\n  }\n SourceCodeAfterRefactoring:\n/**\n   * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n   * filtering based on three possible arguments:\n   *\n   *  -e (emulator-only) - only emulators are passing the filter\n   *  -d (device-only) - only real devices are passing the filter\n   *  -s (serial) - only device/emulator with specific serial number are passing the filter\n   *\n   *  If more than one device matches the filter this function will fail unless multi-install\n   *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n   *  devices will be used to install the apk if needed.\n   */\n  @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n    List<IDevice> devices;\n\n    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n      devices = getDevices();\n      if (devices == null) {\n        return false;\n      }\n    }\n\n    int adbThreadCount = options.getAdbThreadCount();\n    if (adbThreadCount <= 0) {\n      adbThreadCount = devices.size();\n    }\n\n    // Start executions on all matching devices.\n    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n    ListeningExecutorService executorService =\n        listeningDecorator(\n            newMultiThreadExecutor(\n                new CommandThreadFactory(getClass().getSimpleName()),\n                adbThreadCount));\n\n    for (final IDevice device : devices) {\n      futures.add(executorService.submit(adbCallable.forDevice(device)));\n    }\n\n    // Wait for all executions to complete or fail.\n    List<Boolean> results = null;\n    try {\n      results = Futures.allAsList(futures).get();\n    } catch (ExecutionException ex) {\n      console.printBuildFailure(\"Failed: \" + adbCallable);\n      ex.printStackTrace(console.getStdErr());\n      return false;\n    } catch (InterruptedException e) {\n      try {\n        Futures.allAsList(futures).cancel(true);\n      } catch (CancellationException ignored) {\n        // Rethrow original InterruptedException instead.\n      }\n      Thread.currentThread().interrupt();\n      throw e;\n    } finally {\n      MoreExecutors.shutdownOrThrow(\n          executorService,\n          10,\n          TimeUnit.MINUTES,\n          new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n    }\n\n    int successCount = 0;\n    for (Boolean result : results) {\n      if (result) {\n        successCount++;\n      }\n    }\n    int failureCount = results.size() - successCount;\n\n    // Report results.\n    if (successCount > 0) {\n      console.printSuccess(\n          String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n    }\n    if (failureCount > 0) {\n      console.printBuildFailure(\n          String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n    }\n\n    return failureCount == 0;\n  }\n@Nullable\n  public List<IDevice> getDevices() throws InterruptedException {\n    // Initialize adb connection.\n    AndroidDebugBridge adb = createAdb(context);\n    if (adb == null) {\n      console.printBuildFailure(\"Failed to create adb connection.\");\n      return null;\n    }\n\n    // Build list of matching devices.\n    List<IDevice> devices = filterDevices(adb.getDevices());\n    if (devices == null && restartAdbOnFailure) {\n      console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n      adb.restart();\n      devices = filterDevices(adb.getDevices());\n    }\n    return devices;\n  }\n DiffSourceCode:\n-  235:   /**\n-  236:    * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n-  237:    * filtering based on three possible arguments:\n-  238:    *\n-  239:    *  -e (emulator-only) - only emulators are passing the filter\n-  240:    *  -d (device-only) - only real devices are passing the filter\n-  241:    *  -s (serial) - only device/emulator with specific serial number are passing the filter\n-  242:    *\n-  243:    *  If more than one device matches the filter this function will fail unless multi-install\n-  244:    *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n-  245:    *  devices will be used to install the apk if needed.\n-  246:    */\n-  247:   @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n-  248:   public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n-  249:     List<IDevice> devices;\n-  250: \n-  251:     try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n-  252: \n-  253:       // Initialize adb connection.\n-  254:       AndroidDebugBridge adb = createAdb(context);\n-  255:       if (adb == null) {\n-  256:         console.printBuildFailure(\"Failed to create adb connection.\");\n-  257:         return false;\n-  258:       }\n-  259: \n-  260:       // Build list of matching devices.\n-  261:       devices = filterDevices(adb.getDevices());\n-  262:       if (devices == null) {\n-  263:         if (restartAdbOnFailure) {\n-  264:           console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n-  265:           adb.restart();\n-  266:           devices = filterDevices(adb.getDevices());\n-  267:         }\n-  268: \n-  269:         if (devices == null) {\n-  270:             return false;\n-  271:         }\n-  272:       }\n-  273:     }\n-  274: \n-  275:     int adbThreadCount = options.getAdbThreadCount();\n-  276:     if (adbThreadCount <= 0) {\n-  277:       adbThreadCount = devices.size();\n-  278:     }\n-  279: \n-  280:     // Start executions on all matching devices.\n-  281:     List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n-  282:     ListeningExecutorService executorService =\n-  283:         listeningDecorator(\n-  284:             newMultiThreadExecutor(\n-  285:                 new CommandThreadFactory(getClass().getSimpleName()),\n-  286:                 adbThreadCount));\n-  287: \n-  288:     for (final IDevice device : devices) {\n-  289:       futures.add(executorService.submit(adbCallable.forDevice(device)));\n-  290:     }\n-  291: \n-  292:     // Wait for all executions to complete or fail.\n-  293:     List<Boolean> results = null;\n-  294:     try {\n-  295:       results = Futures.allAsList(futures).get();\n-  296:     } catch (ExecutionException ex) {\n-  297:       console.printBuildFailure(\"Failed: \" + adbCallable);\n-  298:       ex.printStackTrace(console.getStdErr());\n-  299:       return false;\n-  300:     } catch (InterruptedException e) {\n-  301:       try {\n-  302:         Futures.allAsList(futures).cancel(true);\n-  303:       } catch (CancellationException ignored) {\n-  304:         // Rethrow original InterruptedException instead.\n-  305:       }\n-  306:       Thread.currentThread().interrupt();\n-  307:       throw e;\n-  308:     } finally {\n-  309:       MoreExecutors.shutdownOrThrow(\n-  310:           executorService,\n-  311:           10,\n-  312:           TimeUnit.MINUTES,\n-  313:           new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n-  314:     }\n-  315: \n-  316:     int successCount = 0;\n-  317:     for (Boolean result : results) {\n-  318:       if (result) {\n-  319:         successCount++;\n-  320:       }\n-  321:     }\n-  322:     int failureCount = results.size() - successCount;\n-  323: \n-  324:     // Report results.\n-  325:     if (successCount > 0) {\n-  326:       console.printSuccess(\n-  327:           String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n-  328:     }\n-  329:     if (failureCount > 0) {\n-  330:       console.printBuildFailure(\n-  331:           String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n-  332:     }\n-  333: \n-  334:     return failureCount == 0;\n-  335:   }\n-  336: \n-  337:   /**\n+  235:   @Nullable\n+  236:   public List<IDevice> getDevices() throws InterruptedException {\n+  237:     // Initialize adb connection.\n+  238:     AndroidDebugBridge adb = createAdb(context);\n+  239:     if (adb == null) {\n+  240:       console.printBuildFailure(\"Failed to create adb connection.\");\n+  241:       return null;\n+  242:     }\n+  243: \n+  244:     // Build list of matching devices.\n+  245:     List<IDevice> devices = filterDevices(adb.getDevices());\n+  246:     if (devices == null && restartAdbOnFailure) {\n+  247:       console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n+  248:       adb.restart();\n+  249:       devices = filterDevices(adb.getDevices());\n+  250:     }\n+  251:     return devices;\n+  252:   }\n+  253: \n+  254:   /**\n+  255:    * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n+  256:    * filtering based on three possible arguments:\n+  257:    *\n+  258:    *  -e (emulator-only) - only emulators are passing the filter\n+  259:    *  -d (device-only) - only real devices are passing the filter\n+  260:    *  -s (serial) - only device/emulator with specific serial number are passing the filter\n+  261:    *\n+  262:    *  If more than one device matches the filter this function will fail unless multi-install\n+  263:    *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n+  264:    *  devices will be used to install the apk if needed.\n+  265:    */\n+  266:   @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n+  267:   public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n+  268:     List<IDevice> devices;\n+  269: \n+  270:     try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n+  271:       devices = getDevices();\n+  272:       if (devices == null) {\n+  273:         return false;\n+  274:       }\n+  275:     }\n+  276: \n+  277:     int adbThreadCount = options.getAdbThreadCount();\n+  278:     if (adbThreadCount <= 0) {\n+  279:       adbThreadCount = devices.size();\n+  280:     }\n+  281: \n+  282:     // Start executions on all matching devices.\n+  283:     List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n+  284:     ListeningExecutorService executorService =\n+  285:         listeningDecorator(\n+  286:             newMultiThreadExecutor(\n+  287:                 new CommandThreadFactory(getClass().getSimpleName()),\n+  288:                 adbThreadCount));\n+  289: \n+  290:     for (final IDevice device : devices) {\n+  291:       futures.add(executorService.submit(adbCallable.forDevice(device)));\n+  292:     }\n+  293: \n+  294:     // Wait for all executions to complete or fail.\n+  295:     List<Boolean> results = null;\n+  296:     try {\n+  297:       results = Futures.allAsList(futures).get();\n+  298:     } catch (ExecutionException ex) {\n+  299:       console.printBuildFailure(\"Failed: \" + adbCallable);\n+  300:       ex.printStackTrace(console.getStdErr());\n+  301:       return false;\n+  302:     } catch (InterruptedException e) {\n+  303:       try {\n+  304:         Futures.allAsList(futures).cancel(true);\n+  305:       } catch (CancellationException ignored) {\n+  306:         // Rethrow original InterruptedException instead.\n+  307:       }\n+  308:       Thread.currentThread().interrupt();\n+  309:       throw e;\n+  310:     } finally {\n+  311:       MoreExecutors.shutdownOrThrow(\n+  312:           executorService,\n+  313:           10,\n+  314:           TimeUnit.MINUTES,\n+  315:           new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n+  316:     }\n+  317: \n+  318:     int successCount = 0;\n+  319:     for (Boolean result : results) {\n+  320:       if (result) {\n+  321:         successCount++;\n+  322:       }\n+  323:     }\n+  324:     int failureCount = results.size() - successCount;\n+  325: \n+  326:     // Report results.\n+  327:     if (successCount > 0) {\n+  328:       console.printSuccess(\n+  329:           String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n+  330:     }\n+  331:     if (failureCount > 0) {\n+  332:       console.printBuildFailure(\n+  333:           String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n+  334:     }\n+  335: \n+  336:     return failureCount == 0;\n+  337:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n        Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n        Source source = new Source(Origin.LOCAL, \"write0\");\n        SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(0).getEurekaServerRegistry();\n\n        final Set<String> expectedInstances = new HashSet<>();\n        for (int i = 0; i < count; i++) {\n            InstanceInfo next = instanceIt.next();\n            eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n            expectedInstances.add(next.getId());\n        }\n\n        final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n\n        eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n                    @Override\n                    public void call(ChangeNotification<InstanceInfo> notification) {\n                        if (notification.getKind() == Kind.Add) {\n                            String id = notification.getData().getId();\n                            if (expectedInstances.remove(id)) {\n                                latch.countDown();\n                            }\n                        }\n                    }\n                });\n\n        assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n    }\n SourceCodeAfterRefactoring:\npublic void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n        fillUpRegistryOfServer(0, count, instanceTemplate);\n    }\npublic void fillUpRegistryOfServer(int serverIdx, int count, InstanceInfo instanceTemplate) throws Exception {\n        Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n        Source source = new Source(Origin.LOCAL, \"write\" + serverIdx);\n        SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(serverIdx).getEurekaServerRegistry();\n\n        final Set<String> expectedInstances = new HashSet<>();\n        for (int i = 0; i < count; i++) {\n            InstanceInfo next = instanceIt.next();\n            eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n            expectedInstances.add(next.getId());\n        }\n\n        final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n\n        eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n                    @Override\n                    public void call(ChangeNotification<InstanceInfo> notification) {\n                        if (notification.getKind() == Kind.Add) {\n                            String id = notification.getData().getId();\n                            if (expectedInstances.remove(id)) {\n                                latch.countDown();\n                            }\n                        }\n                    }\n                });\n\n        assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n    }\n DiffSourceCode:\n-   38:     public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n-   39:         Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n-   40:         Source source = new Source(Origin.LOCAL, \"write0\");\n-   41:         SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(0).getEurekaServerRegistry();\n-   42: \n-   43:         final Set<String> expectedInstances = new HashSet<>();\n-   44:         for (int i = 0; i < count; i++) {\n-   45:             InstanceInfo next = instanceIt.next();\n-   46:             eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n-   47:             expectedInstances.add(next.getId());\n-   48:         }\n-   49: \n-   50:         final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n-   51: \n-   52:         eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n-   53:                 .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n-   54:                     @Override\n-   55:                     public void call(ChangeNotification<InstanceInfo> notification) {\n-   56:                         if (notification.getKind() == Kind.Add) {\n-   57:                             String id = notification.getData().getId();\n-   58:                             if (expectedInstances.remove(id)) {\n-   59:                                 latch.countDown();\n-   60:                             }\n-   61:                         }\n-   62:                     }\n-   63:                 });\n-   64: \n-   65:         assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n-   66:     }\n-   67: }\n+   38:     public EurekaDeploymentClients(EurekaDeployment eurekaDeployment) {\n+   39:         this.eurekaDeployment = eurekaDeployment;\n+   40:     }\n+   41: \n+   42:     public void fillUpRegistryOfServer(int serverIdx, int count, InstanceInfo instanceTemplate) throws Exception {\n+   43:         Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n+   44:         Source source = new Source(Origin.LOCAL, \"write\" + serverIdx);\n+   45:         SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(serverIdx).getEurekaServerRegistry();\n+   46: \n+   47:         final Set<String> expectedInstances = new HashSet<>();\n+   48:         for (int i = 0; i < count; i++) {\n+   49:             InstanceInfo next = instanceIt.next();\n+   50:             eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n+   51:             expectedInstances.add(next.getId());\n+   52:         }\n+   53: \n+   54:         final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n+   55: \n+   56:         eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n+   57:                 .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n+   58:                     @Override\n+   59:                     public void call(ChangeNotification<InstanceInfo> notification) {\n+   60:                         if (notification.getKind() == Kind.Add) {\n+   61:                             String id = notification.getData().getId();\n+   62:                             if (expectedInstances.remove(id)) {\n+   63:                                 latch.countDown();\n+   64:                             }\n+   65:                         }\n+   66:                     }\n+   67:                 });\n+   68: \n+   69:         assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n+   70:     }\n+   72:     public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n+   73:         fillUpRegistryOfServer(0, count, instanceTemplate);\n+   74:     }\n\n",
        "contextDescription": "PackageName: org.wordpress.android.ui.main.SitePickerAdapter\nClassName: org.wordpress.android.ui.main.SitePickerAdapter.LoadSitesTask\nMethodName: org.wordpress.android.ui.main.SitePickerAdapter.LoadSitesTask#doInBackground\n ClassSignature: private class LoadSitesTask extends AsyncTask<Void, Void, SiteList> \nInvokedMethod: methodSignature: org.wordpress.android.ui.main.SitePickerAdapter.SiteRecord#getBlogNameOrHostName\n methodBody: String getBlogNameOrHostName() {\nif(TextUtils.isEmpty(blogName)){return hostName;\n}return blogName;\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n@Override\n        protected SiteList doInBackground(Void... params) {\n            List<Map<String, Object>> blogs;\n            String[] extraFields = {\"isHidden\", \"dotcomFlag\"};\n\n            if (mShowHiddenSites) {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs and all wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(null, extraFields);\n                } else {\n                    // only wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=1\", extraFields);\n                }\n            } else {\n                if (mShowSelfHostedSites) {\n                    // all self-hosted blogs plus visible wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"dotcomFlag=0 OR (isHidden=0 AND dotcomFlag=1) \", extraFields);\n                } else {\n                    // only visible wp.com blogs\n                    blogs = WordPress.wpDB.getBlogsBy(\"isHidden=0 AND dotcomFlag=1\", extraFields);\n                }\n            }\n\n            SiteList sites = new SiteList(blogs);\n\n            // sort by blog/host\n            Collections.sort(sites, new Comparator<SiteRecord>() {\n                public int compare(SiteRecord site1, SiteRecord site2) {\n                    return site1.getBlogNameOrHostName().compareToIgnoreCase(site2.getBlogNameOrHostName());\n                }\n            });\n\n            return sites;\n        }\n\nThe context of the source code is as follows:\nPackageName: org.wordpress.android.ui.main.SitePickerAdapter\nClassName: org.wordpress.android.ui.main.SitePickerAdapter.LoadSitesTask\nMethodName: org.wordpress.android.ui.main.SitePickerAdapter.LoadSitesTask#doInBackground\n ClassSignature: private class LoadSitesTask extends AsyncTask<Void, Void, SiteList> \nInvokedMethod: methodSignature: org.wordpress.android.ui.main.SitePickerAdapter.SiteRecord#getBlogNameOrHostName\n methodBody: String getBlogNameOrHostName() {\nif(TextUtils.isEmpty(blogName)){return hostName;\n}return blogName;\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n public void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n\n    Collections.sort(rules, new CategoryComparator());\n\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    // JPanel\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n    treeModel.addTreeModelListener(new TreeModelListener() {\n\n      @Override\n      public void treeNodesChanged(TreeModelEvent e) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n        int index = e.getChildIndices()[0];\n        node = (DefaultMutableTreeNode) node.getChildAt(index);\n        if (node instanceof RuleNode) {\n          RuleNode o = (RuleNode) node;\n          if (o.getRule().isDefaultOff()) {\n            if (o.isEnabled()) {\n              config.getEnabledRuleIds().add(o.getRule().getId());\n            } else {\n              config.getEnabledRuleIds().remove(o.getRule().getId());\n            }\n          } else {\n            if (o.isEnabled()) {\n              config.getDisabledRuleIds().remove(o.getRule().getId());\n            } else {\n              config.getDisabledRuleIds().add(o.getRule().getId());\n            }\n          }\n        }\n        if (node instanceof CategoryNode) {\n          CategoryNode o = (CategoryNode) node;\n          if (o.isEnabled()) {\n            config.getDisabledCategoryNames().remove(o.getCategory().getName());\n          } else {\n            config.getDisabledCategoryNames().add(o.getCategory().getName());\n          }\n        }\n      }\n\n      @Override\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeStructureChanged(TreeModelEvent e) {\n      }\n    });\n    configTree = new JTree(treeModel);\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(\n      ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n\n    MouseAdapter ma = new MouseAdapter() {\n      private void handlePopupEvent(MouseEvent e) {\n        final JTree tree = (JTree) e.getSource();\n\n        TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n        if (path == null) {\n          return;\n        }\n\n        DefaultMutableTreeNode node\n                = (DefaultMutableTreeNode) path.getLastPathComponent();\n\n        TreePath[] paths = tree.getSelectionPaths();\n\n        boolean isSelected = false;\n        if (paths != null) {\n          for (TreePath selectionPath : paths) {\n            if (selectionPath.equals(path)) {\n              isSelected = true;\n            }\n          }\n        }\n        if (!isSelected) {\n          tree.setSelectionPath(path);\n        }\n        if (node.isLeaf()) {\n          JPopupMenu popup = new JPopupMenu();\n          final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n          aboutRuleMenuItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {\n              RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n              Rule rule = node.getRule();\n              Language lang = config.getLanguage();\n              if(lang == null) {\n                lang = Languages.getLanguageForLocale(Locale.getDefault());\n              }\n              Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n                      rule.getDescription(), rule, messages,\n                      lang.getShortNameWithCountryAndVariant());\n            }\n          });\n          popup.add(aboutRuleMenuItem);\n          popup.show(tree, e.getX(), e.getY());\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n    };\n    configTree.addMouseListener(ma);\n    final JPanel treeButtonPanel = new JPanel();\n    cons = new GridBagConstraints();\n    cons.gridx = 0;\n    cons.gridy = 0;\n    final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n    treeButtonPanel.add(expandAllButton, cons);\n    expandAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n          TreeNode n = (TreeNode) cat.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.expandPath(child);\n        }\n      }\n    });\n\n    cons.gridx = 1;\n    cons.gridy = 0;\n    final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n    treeButtonPanel.add(collapseAllButton, cons);\n    collapseAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n          TreeNode n = (TreeNode) categ.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.collapsePath(child);\n        }\n      }\n    });\n\n    final JPanel motherTonguePanel = new JPanel();\n    motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n    motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n    if (config.getMotherTongue() != null) {\n      motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n    }\n    motherTongueBox.addItemListener(new ItemListener() {\n\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        if (e.getStateChange() == ItemEvent.SELECTED) {\n          Language motherTongue;\n          if (motherTongueBox.getSelectedItem() instanceof String) {\n            motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n          } else {\n            motherTongue = (Language) motherTongueBox.getSelectedItem();\n          }\n          config.setMotherTongue(motherTongue);\n        }\n      }\n    });\n    motherTonguePanel.add(motherTongueBox, cons);\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setSelected(config.getRunServer());\n      portPanel.add(serverCheckbox, cons);\n      serverCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n          serverPortField.setEnabled(serverCheckbox.isSelected());\n          serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n        }\n      });\n      serverCheckbox.addItemListener(new ItemListener() {\n\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setRunServer(serverCheckbox.isSelected());\n        }\n      });\n\n      serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n      serverPortField.setEnabled(serverCheckbox.isSelected());\n      serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n      serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n      cons.gridx = 1;\n      portPanel.add(serverPortField, cons);\n      serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n          try {\n            int serverPort = Integer.parseInt(serverPortField.getText());\n            if (serverPort > -1 && serverPort < MAX_PORT) {\n              serverPortField.setForeground(null);\n              config.setServerPort(serverPort);\n            } else {\n              serverPortField.setForeground(Color.RED);\n            }\n          } catch (NumberFormatException ex) {\n            serverPortField.setForeground(Color.RED);\n          }\n        }\n      });\n\n      cons.gridx = 0;\n      cons.gridy = 10;      \n      serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n          .getString(\"useGUIConfig\")));\n      serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n      serverSettingsCheckbox.setEnabled(config.getRunServer());\n      serverSettingsCheckbox.addItemListener(new ItemListener() {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n        }\n      });\n      portPanel.add(serverSettingsCheckbox, cons);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(treeButtonPanel, cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(motherTonguePanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\n SourceCodeAfterRefactoring:\npublic void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    Collections.sort(rules, new CategoryComparator());\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    configTree = new JTree(getTreeModel(rootNode));\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n    configTree.addMouseListener(getMouseAdapter());\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      createNonOfficeElements(cons, portPanel);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(getTreeButtonPanel(), cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(getMotherTonguePanel(cons), cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\nprivate void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n    serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setSelected(config.getRunServer());\n    portPanel.add(serverCheckbox, cons);\n    serverCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n        serverPortField.setEnabled(serverCheckbox.isSelected());\n        serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n      }\n    });\n    serverCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setRunServer(serverCheckbox.isSelected());\n      }\n    });\n\n    serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n    serverPortField.setEnabled(serverCheckbox.isSelected());\n    serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n    serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n    cons.gridx = 1;\n    portPanel.add(serverPortField, cons);\n    serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void changedUpdate(DocumentEvent e) {\n        try {\n          int serverPort = Integer.parseInt(serverPortField.getText());\n          if (serverPort > -1 && serverPort < MAX_PORT) {\n            serverPortField.setForeground(null);\n            config.setServerPort(serverPort);\n          } else {\n            serverPortField.setForeground(Color.RED);\n          }\n        } catch (NumberFormatException ex) {\n          serverPortField.setForeground(Color.RED);\n        }\n      }\n    });\n\n    cons.gridx = 0;\n    cons.gridy = 10;\n    serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n    serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n    serverSettingsCheckbox.setEnabled(config.getRunServer());\n    serverSettingsCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n      }\n    });\n    portPanel.add(serverSettingsCheckbox, cons);\n  }\n DiffSourceCode:\n-  117:   public void show(List<Rule> rules) {\n-  118:     if (original != null) {\n-  119:       config.restoreState(original);\n-  120:     }\n-  121:     dialog = new JDialog(owner, true);\n-  122:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n-  123: \n-  124:     Collections.sort(rules, new CategoryComparator());\n-  125: \n-  126:     // close dialog when user presses Escape key:\n-  127:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n-  128:     final ActionListener actionListener = new ActionListener() {\n-  129:       @Override\n-  130:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n-  131:         dialog.setVisible(false);\n-  132:       }\n-  133:     };\n-  134:     final JRootPane rootPane = dialog.getRootPane();\n-  135:     rootPane.registerKeyboardAction(actionListener, stroke,\n-  136:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n-  137: \n-  138:     // JPanel\n-  139:     final JPanel checkBoxPanel = new JPanel();\n-  140:     checkBoxPanel.setLayout(new GridBagLayout());\n-  141:     GridBagConstraints cons = new GridBagConstraints();\n-  142:     cons.anchor = GridBagConstraints.NORTHWEST;\n-  143:     cons.gridx = 0;\n-  144:     cons.weightx = 1.0;\n-  145:     cons.weighty = 1.0;\n-  146:     cons.fill = GridBagConstraints.BOTH;\n-  147:     DefaultMutableTreeNode rootNode = createTree(rules);\n-  148:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n-  149:     treeModel.addTreeModelListener(new TreeModelListener() {\n-  150: \n-  151:       @Override\n-  152:       public void treeNodesChanged(TreeModelEvent e) {\n-  153:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n-  154:         int index = e.getChildIndices()[0];\n-  155:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n-  156:         if (node instanceof RuleNode) {\n-  157:           RuleNode o = (RuleNode) node;\n-  158:           if (o.getRule().isDefaultOff()) {\n-  159:             if (o.isEnabled()) {\n-  160:               config.getEnabledRuleIds().add(o.getRule().getId());\n-  161:             } else {\n-  162:               config.getEnabledRuleIds().remove(o.getRule().getId());\n-  163:             }\n-  164:           } else {\n-  165:             if (o.isEnabled()) {\n-  166:               config.getDisabledRuleIds().remove(o.getRule().getId());\n-  167:             } else {\n-  168:               config.getDisabledRuleIds().add(o.getRule().getId());\n-  169:             }\n-  170:           }\n-  171:         }\n-  172:         if (node instanceof CategoryNode) {\n-  173:           CategoryNode o = (CategoryNode) node;\n-  174:           if (o.isEnabled()) {\n-  175:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n-  176:           } else {\n-  177:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n-  178:           }\n-  179:         }\n-  180:       }\n-  181: \n-  182:       @Override\n-  183:       public void treeNodesInserted(TreeModelEvent e) {\n-  184:       }\n-  185: \n-  186:       @Override\n-  187:       public void treeNodesRemoved(TreeModelEvent e) {\n-  188:       }\n-  189: \n-  190:       @Override\n-  191:       public void treeStructureChanged(TreeModelEvent e) {\n-  192:       }\n-  193:     });\n-  194:     configTree = new JTree(treeModel);\n-  195: \n-  196:     Language lang = config.getLanguage();\n-  197:     if (lang == null) {\n-  198:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  199:     }\n-  200:     configTree.applyComponentOrientation(\n-  201:       ComponentOrientation.getOrientation(lang.getLocale()));\n-  202: \n-  203:     configTree.setRootVisible(false);\n-  204:     configTree.setEditable(false);\n-  205:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n-  206:     TreeListener.install(configTree);\n-  207:     checkBoxPanel.add(configTree, cons);\n-  208: \n-  209:     MouseAdapter ma = new MouseAdapter() {\n-  210:       private void handlePopupEvent(MouseEvent e) {\n-  211:         final JTree tree = (JTree) e.getSource();\n-  212: \n-  213:         TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n-  214:         if (path == null) {\n-  215:           return;\n-  216:         }\n-  217: \n-  218:         DefaultMutableTreeNode node\n-  219:                 = (DefaultMutableTreeNode) path.getLastPathComponent();\n-  220: \n-  221:         TreePath[] paths = tree.getSelectionPaths();\n-  222: \n-  223:         boolean isSelected = false;\n-  224:         if (paths != null) {\n-  225:           for (TreePath selectionPath : paths) {\n-  226:             if (selectionPath.equals(path)) {\n-  227:               isSelected = true;\n-  228:             }\n-  229:           }\n-  230:         }\n-  231:         if (!isSelected) {\n-  232:           tree.setSelectionPath(path);\n-  233:         }\n-  234:         if (node.isLeaf()) {\n-  235:           JPopupMenu popup = new JPopupMenu();\n-  236:           final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n-  237:           aboutRuleMenuItem.addActionListener(new ActionListener() {\n-  238:             @Override\n-  239:             public void actionPerformed(ActionEvent actionEvent) {\n-  240:               RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n-  241:               Rule rule = node.getRule();\n-  242:               Language lang = config.getLanguage();\n-  243:               if(lang == null) {\n-  244:                 lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  245:               }\n-  246:               Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n-  247:                       rule.getDescription(), rule, messages,\n-  248:                       lang.getShortNameWithCountryAndVariant());\n-  249:             }\n-  250:           });\n-  251:           popup.add(aboutRuleMenuItem);\n-  252:           popup.show(tree, e.getX(), e.getY());\n-  253:         }\n-  254:       }\n-  255: \n-  256:       @Override\n-  257:       public void mousePressed(MouseEvent e) {\n-  258:         if (e.isPopupTrigger()) {\n-  259:           handlePopupEvent(e);\n-  260:         }\n-  261:       }\n-  262: \n-  263:       @Override\n-  264:       public void mouseReleased(MouseEvent e) {\n-  265:         if (e.isPopupTrigger()) {\n-  266:           handlePopupEvent(e);\n-  267:         }\n-  268:       }\n-  269:     };\n-  270:     configTree.addMouseListener(ma);\n-  271:     final JPanel treeButtonPanel = new JPanel();\n-  272:     cons = new GridBagConstraints();\n-  273:     cons.gridx = 0;\n-  274:     cons.gridy = 0;\n-  275:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n-  276:     treeButtonPanel.add(expandAllButton, cons);\n-  277:     expandAllButton.addActionListener(new ActionListener() {\n-  278: \n-  279:       @Override\n-  280:       public void actionPerformed(ActionEvent e) {\n-  281:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  282:         TreePath parent = new TreePath(root);\n-  283:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n-  284:           TreeNode n = (TreeNode) cat.nextElement();\n-  285:           TreePath child = parent.pathByAddingChild(n);\n-  286:           configTree.expandPath(child);\n-  287:         }\n-  288:       }\n-  289:     });\n-  290: \n-  291:     cons.gridx = 1;\n-  292:     cons.gridy = 0;\n-  293:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n-  294:     treeButtonPanel.add(collapseAllButton, cons);\n-  295:     collapseAllButton.addActionListener(new ActionListener() {\n-  296: \n-  297:       @Override\n-  298:       public void actionPerformed(ActionEvent e) {\n-  299:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  300:         TreePath parent = new TreePath(root);\n-  301:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n-  302:           TreeNode n = (TreeNode) categ.nextElement();\n-  303:           TreePath child = parent.pathByAddingChild(n);\n-  304:           configTree.collapsePath(child);\n-  305:         }\n-  306:       }\n-  307:     });\n-  308: \n-  309:     final JPanel motherTonguePanel = new JPanel();\n-  310:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n-  311:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n-  312:     if (config.getMotherTongue() != null) {\n-  313:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n-  314:     }\n-  315:     motherTongueBox.addItemListener(new ItemListener() {\n-  316: \n-  317:       @Override\n-  318:       public void itemStateChanged(ItemEvent e) {\n-  319:         if (e.getStateChange() == ItemEvent.SELECTED) {\n-  320:           Language motherTongue;\n-  321:           if (motherTongueBox.getSelectedItem() instanceof String) {\n-  322:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  117: \n+  118:   public void show(List<Rule> rules) {\n+  119:     if (original != null) {\n+  120:       config.restoreState(original);\n+  121:     }\n+  122:     dialog = new JDialog(owner, true);\n+  123:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n+  124:     // close dialog when user presses Escape key:\n+  125:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n+  126:     final ActionListener actionListener = new ActionListener() {\n+  127:       @Override\n+  128:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n+  129:         dialog.setVisible(false);\n+  130:       }\n+  131:     };\n+  132:     final JRootPane rootPane = dialog.getRootPane();\n+  133:     rootPane.registerKeyboardAction(actionListener, stroke,\n+  134:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n+  135: \n+  136:     final JPanel checkBoxPanel = new JPanel();\n+  137:     checkBoxPanel.setLayout(new GridBagLayout());\n+  138:     GridBagConstraints cons = new GridBagConstraints();\n+  139:     cons.anchor = GridBagConstraints.NORTHWEST;\n+  140:     cons.gridx = 0;\n+  141:     cons.weightx = 1.0;\n+  142:     cons.weighty = 1.0;\n+  143:     cons.fill = GridBagConstraints.BOTH;\n+  144:     Collections.sort(rules, new CategoryComparator());\n+  145:     DefaultMutableTreeNode rootNode = createTree(rules);\n+  146:     configTree = new JTree(getTreeModel(rootNode));\n+  147: \n+  148:     Language lang = config.getLanguage();\n+  149:     if (lang == null) {\n+  150:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  151:     }\n+  152:     configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n+  153: \n+  154:     configTree.setRootVisible(false);\n+  155:     configTree.setEditable(false);\n+  156:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n+  157:     TreeListener.install(configTree);\n+  158:     checkBoxPanel.add(configTree, cons);\n+  159:     configTree.addMouseListener(getMouseAdapter());\n+  160:     \n+  161:     final JPanel portPanel = new JPanel();\n+  162:     portPanel.setLayout(new GridBagLayout());\n+  163:     cons = new GridBagConstraints();\n+  164:     cons.insets = new Insets(0, 4, 0, 0);\n+  165:     cons.gridx = 0;\n+  166:     cons.gridy = 0;\n+  167:     cons.anchor = GridBagConstraints.WEST;\n+  168:     cons.fill = GridBagConstraints.NONE;\n+  169:     cons.weightx = 0.0f;\n+  170:     if (!insideOffice) {\n+  171:       createNonOfficeElements(cons, portPanel);\n+  172:     }\n+  173: \n+  174:     final JPanel buttonPanel = new JPanel();\n+  175:     buttonPanel.setLayout(new GridBagLayout());\n+  176:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n+  177:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n+  178:     okButton.addActionListener(this);\n+  179:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n+  180:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n+  181:     cancelButton.addActionListener(this);\n+  182:     cons = new GridBagConstraints();\n+  183:     cons.insets = new Insets(0, 4, 0, 0);\n+  184:     buttonPanel.add(okButton, cons);\n+  185:     buttonPanel.add(cancelButton, cons);\n+  186: \n+  187:     final Container contentPane = dialog.getContentPane();\n+  188:     contentPane.setLayout(new GridBagLayout());\n+  189:     cons = new GridBagConstraints();\n+  190:     cons.insets = new Insets(4, 4, 4, 4);\n+  191:     cons.gridx = 0;\n+  192:     cons.gridy = 0;\n+  193:     cons.weightx = 10.0f;\n+  194:     cons.weighty = 10.0f;\n+  195:     cons.fill = GridBagConstraints.BOTH;\n+  196:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n+  197: \n+  198:     cons.gridx = 0;\n+  199:     cons.gridy++;\n+  200:     cons.fill = GridBagConstraints.NONE;\n+  201:     cons.anchor = GridBagConstraints.LINE_END;\n+  202:     contentPane.add(getTreeButtonPanel(), cons);\n+  203:     \n+  204:     cons.gridy++;\n+  205:     cons.anchor = GridBagConstraints.WEST;\n+  206:     contentPane.add(getMotherTonguePanel(cons), cons);\n+  207: \n+  208:     cons.gridy++;\n+  209:     cons.anchor = GridBagConstraints.WEST;\n+  210:     contentPane.add(portPanel, cons);\n+  211: \n+  212:     cons.gridy++;\n+  213:     cons.anchor = GridBagConstraints.EAST;\n+  214:     contentPane.add(buttonPanel, cons);\n+  215: \n+  216:     dialog.pack();\n+  217:     dialog.setSize(500, 500);\n+  218:     // center on screen:\n+  219:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+  220:     final Dimension frameSize = dialog.getSize();\n+  221:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n+  222:         screenSize.height / 2 - frameSize.height / 2);\n+  223:     dialog.setLocationByPlatform(true);\n+  224:     dialog.setVisible(true);\n+  225:   }\n+  226: \n+  227:   private void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n+  228:     serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n+  229:     serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n+  230:     serverCheckbox.setSelected(config.getRunServer());\n+  231:     portPanel.add(serverCheckbox, cons);\n+  232:     serverCheckbox.addActionListener(new ActionListener() {\n+  233:       @Override\n+  234:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n+  235:         serverPortField.setEnabled(serverCheckbox.isSelected());\n+  236:         serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n+  237:       }\n+  238:     });\n+  239:     serverCheckbox.addItemListener(new ItemListener() {\n+  240:       @Override\n+  241:       public void itemStateChanged(ItemEvent e) {\n+  242:         config.setRunServer(serverCheckbox.isSelected());\n+  243:       }\n+  244:     });\n+  245: \n+  246:     serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n+  247:     serverPortField.setEnabled(serverCheckbox.isSelected());\n+  248:     serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n+  249:     serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n+  250:     cons.gridx = 1;\n+  251:     portPanel.add(serverPortField, cons);\n+  252:     serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n+  253: \n+  254:       @Override\n+  255:       public void insertUpdate(DocumentEvent e) {\n+  256:         changedUpdate(e);\n+  257:       }\n+  258: \n+  259:       @Override\n+  260:       public void removeUpdate(DocumentEvent e) {\n+  261:         changedUpdate(e);\n+  262:       }\n+  263: \n+  264:       @Override\n+  265:       public void changedUpdate(DocumentEvent e) {\n+  266:         try {\n+  267:           int serverPort = Integer.parseInt(serverPortField.getText());\n+  268:           if (serverPort > -1 && serverPort < MAX_PORT) {\n+  269:             serverPortField.setForeground(null);\n+  270:             config.setServerPort(serverPort);\n+  271:           } else {\n+  272:             serverPortField.setForeground(Color.RED);\n+  273:           }\n+  274:         } catch (NumberFormatException ex) {\n+  275:           serverPortField.setForeground(Color.RED);\n+  276:         }\n+  277:       }\n+  278:     });\n+  279: \n+  280:     cons.gridx = 0;\n+  281:     cons.gridy = 10;\n+  282:     serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n+  283:     serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n+  284:     serverSettingsCheckbox.setEnabled(config.getRunServer());\n+  285:     serverSettingsCheckbox.addItemListener(new ItemListener() {\n+  286:       @Override\n+  287:       public void itemStateChanged(ItemEvent e) {\n+  288:         config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n+  289:       }\n+  290:     });\n+  291:     portPanel.add(serverSettingsCheckbox, cons);\n+  292:   }\n+  293: \n+  294:   @NotNull\n+  295:   private DefaultTreeModel getTreeModel(DefaultMutableTreeNode rootNode) {\n+  296:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n+  297:     treeModel.addTreeModelListener(new TreeModelListener() {\n+  298:       @Override\n+  299:       public void treeNodesChanged(TreeModelEvent e) {\n+  300:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n+  301:         int index = e.getChildIndices()[0];\n+  302:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n+  303:         if (node instanceof RuleNode) {\n+  304:           RuleNode o = (RuleNode) node;\n+  305:           if (o.getRule().isDefaultOff()) {\n+  306:             if (o.isEnabled()) {\n+  307:               config.getEnabledRuleIds().add(o.getRule().getId());\n+  308:             } else {\n+  309:               config.getEnabledRuleIds().remove(o.getRule().getId());\n+  310:             }\n+  311:           } else {\n+  312:             if (o.isEnabled()) {\n+  313:               config.getDisabledRuleIds().remove(o.getRule().getId());\n+  314:             } else {\n+  315:               config.getDisabledRuleIds().add(o.getRule().getId());\n+  316:             }\n+  317:           }\n+  318:         }\n+  319:         if (node instanceof CategoryNode) {\n+  320:           CategoryNode o = (CategoryNode) node;\n+  321:           if (o.isEnabled()) {\n+  322:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n   323:           } else {\n-  324:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  324:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n   325:           }\n-  326:           config.setMotherTongue(motherTongue);\n-  327:         }\n-  328:       }\n-  329:     });\n-  330:     motherTonguePanel.add(motherTongueBox, cons);\n-  331:     \n-  332:     final JPanel portPanel = new JPanel();\n-  333:     portPanel.setLayout(new GridBagLayout());\n-  334:     cons = new GridBagConstraints();\n-  335:     cons.insets = new Insets(0, 4, 0, 0);\n-  336:     cons.gridx = 0;\n-  337:     cons.gridy = 0;\n-  338:     cons.anchor = GridBagConstraints.WEST;\n-  339:     cons.fill = GridBagConstraints.NONE;\n-  340:     cons.weightx = 0.0f;\n-  341:     if (!insideOffice) {\n-  342:       serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n-  343:       serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n-  344:       serverCheckbox.setSelected(config.getRunServer());\n-  345:       portPanel.add(serverCheckbox, cons);\n-  346:       serverCheckbox.addActionListener(new ActionListener() {\n-  347:         @Override\n-  348:         public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n-  349:           serverPortField.setEnabled(serverCheckbox.isSelected());\n-  350:           serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n-  351:         }\n-  352:       });\n-  353:       serverCheckbox.addItemListener(new ItemListener() {\n-  354: \n-  355:         @Override\n-  356:         public void itemStateChanged(ItemEvent e) {\n-  357:           config.setRunServer(serverCheckbox.isSelected());\n-  358:         }\n-  359:       });\n-  360: \n-  361:       serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n-  362:       serverPortField.setEnabled(serverCheckbox.isSelected());\n-  363:       serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n-  364:       serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n-  365:       cons.gridx = 1;\n-  366:       portPanel.add(serverPortField, cons);\n-  367:       serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n-  368: \n-  369:         @Override\n-  370:         public void insertUpdate(DocumentEvent e) {\n-  371:           changedUpdate(e);\n-  372:         }\n-  373: \n-  374:         @Override\n-  375:         public void removeUpdate(DocumentEvent e) {\n-  376:           changedUpdate(e);\n-  377:         }\n-  378: \n-  379:         @Override\n-  380:         public void changedUpdate(DocumentEvent e) {\n-  381:           try {\n-  382:             int serverPort = Integer.parseInt(serverPortField.getText());\n-  383:             if (serverPort > -1 && serverPort < MAX_PORT) {\n-  384:               serverPortField.setForeground(null);\n-  385:               config.setServerPort(serverPort);\n-  386:             } else {\n-  387:               serverPortField.setForeground(Color.RED);\n-  388:             }\n-  389:           } catch (NumberFormatException ex) {\n-  390:             serverPortField.setForeground(Color.RED);\n-  391:           }\n-  392:         }\n-  393:       });\n-  394: \n-  395:       cons.gridx = 0;\n-  396:       cons.gridy = 10;      \n-  397:       serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n-  398:           .getString(\"useGUIConfig\")));\n-  399:       serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n-  400:       serverSettingsCheckbox.setEnabled(config.getRunServer());\n-  401:       serverSettingsCheckbox.addItemListener(new ItemListener() {\n-  402:         @Override\n-  403:         public void itemStateChanged(ItemEvent e) {\n-  404:           config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n-  405:         }\n-  406:       });\n-  407:       portPanel.add(serverSettingsCheckbox, cons);\n-  408:     }\n+  326:         }\n+  327:       }\n+  328:       @Override\n+  329:       public void treeNodesInserted(TreeModelEvent e) {}\n+  330:       @Override\n+  331:       public void treeNodesRemoved(TreeModelEvent e) {}\n+  332:       @Override\n+  333:       public void treeStructureChanged(TreeModelEvent e) {}\n+  334:     });\n+  335:     return treeModel;\n+  336:   }\n+  337: \n+  338:   @NotNull\n+  339:   private MouseAdapter getMouseAdapter() {\n+  340:     return new MouseAdapter() {\n+  341:         private void handlePopupEvent(MouseEvent e) {\n+  342:           final JTree tree = (JTree) e.getSource();\n+  343:           TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n+  344:           if (path == null) {\n+  345:             return;\n+  346:           }\n+  347:           DefaultMutableTreeNode node\n+  348:                   = (DefaultMutableTreeNode) path.getLastPathComponent();\n+  349:           TreePath[] paths = tree.getSelectionPaths();\n+  350:           boolean isSelected = false;\n+  351:           if (paths != null) {\n+  352:             for (TreePath selectionPath : paths) {\n+  353:               if (selectionPath.equals(path)) {\n+  354:                 isSelected = true;\n+  355:               }\n+  356:             }\n+  357:           }\n+  358:           if (!isSelected) {\n+  359:             tree.setSelectionPath(path);\n+  360:           }\n+  361:           if (node.isLeaf()) {\n+  362:             JPopupMenu popup = new JPopupMenu();\n+  363:             final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n+  364:             aboutRuleMenuItem.addActionListener(new ActionListener() {\n+  365:               @Override\n+  366:               public void actionPerformed(ActionEvent actionEvent) {\n+  367:                 RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n+  368:                 Rule rule = node.getRule();\n+  369:                 Language lang = config.getLanguage();\n+  370:                 if(lang == null) {\n+  371:                   lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  372:                 }\n+  373:                 Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n+  374:                         rule.getDescription(), rule, messages,\n+  375:                         lang.getShortNameWithCountryAndVariant());\n+  376:               }\n+  377:             });\n+  378:             popup.add(aboutRuleMenuItem);\n+  379:             popup.show(tree, e.getX(), e.getY());\n+  380:           }\n+  381:         }\n+  382:   \n+  383:         @Override\n+  384:         public void mousePressed(MouseEvent e) {\n+  385:           if (e.isPopupTrigger()) {\n+  386:             handlePopupEvent(e);\n+  387:           }\n+  388:         }\n+  389:   \n+  390:         @Override\n+  391:         public void mouseReleased(MouseEvent e) {\n+  392:           if (e.isPopupTrigger()) {\n+  393:             handlePopupEvent(e);\n+  394:           }\n+  395:         }\n+  396:       };\n+  397:   }\n+  398: \n+  399:   @NotNull\n+  400:   private JPanel getTreeButtonPanel() {\n+  401:     GridBagConstraints cons;\n+  402:     final JPanel treeButtonPanel = new JPanel();\n+  403:     cons = new GridBagConstraints();\n+  404:     cons.gridx = 0;\n+  405:     cons.gridy = 0;\n+  406:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n+  407:     treeButtonPanel.add(expandAllButton, cons);\n+  408:     expandAllButton.addActionListener(new ActionListener() {\n   409: \n-  410:     final JPanel buttonPanel = new JPanel();\n-  411:     buttonPanel.setLayout(new GridBagLayout());\n-  412:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n-  413:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n-  414:     okButton.addActionListener(this);\n-  415:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n-  416:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n-  417:     cancelButton.addActionListener(this);\n-  418:     cons = new GridBagConstraints();\n-  419:     cons.insets = new Insets(0, 4, 0, 0);\n-  420:     buttonPanel.add(okButton, cons);\n-  421:     buttonPanel.add(cancelButton, cons);\n-  422: \n-  423:     final Container contentPane = dialog.getContentPane();\n-  424:     contentPane.setLayout(new GridBagLayout());\n-  425:     cons = new GridBagConstraints();\n-  426:     cons.insets = new Insets(4, 4, 4, 4);\n-  427:     cons.gridx = 0;\n-  428:     cons.gridy = 0;\n-  429:     cons.weightx = 10.0f;\n-  430:     cons.weighty = 10.0f;\n-  431:     cons.fill = GridBagConstraints.BOTH;\n-  432:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n-  433: \n-  434:     cons.gridx = 0;\n-  435:     cons.gridy++;\n-  436:     cons.fill = GridBagConstraints.NONE;\n-  437:     cons.anchor = GridBagConstraints.LINE_END;\n-  438:     contentPane.add(treeButtonPanel, cons);\n-  439:     \n-  440:     cons.gridy++;\n-  441:     cons.anchor = GridBagConstraints.WEST;\n-  442:     contentPane.add(motherTonguePanel, cons);\n-  443: \n-  444:     cons.gridy++;\n-  445:     cons.anchor = GridBagConstraints.WEST;\n-  446:     contentPane.add(portPanel, cons);\n-  447: \n-  448:     cons.gridy++;\n-  449:     cons.anchor = GridBagConstraints.EAST;\n-  450:     contentPane.add(buttonPanel, cons);\n+  410:       @Override\n+  411:       public void actionPerformed(ActionEvent e) {\n+  412:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  413:         TreePath parent = new TreePath(root);\n+  414:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n+  415:           TreeNode n = (TreeNode) cat.nextElement();\n+  416:           TreePath child = parent.pathByAddingChild(n);\n+  417:           configTree.expandPath(child);\n+  418:         }\n+  419:       }\n+  420:     });\n+  421: \n+  422:     cons.gridx = 1;\n+  423:     cons.gridy = 0;\n+  424:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n+  425:     treeButtonPanel.add(collapseAllButton, cons);\n+  426:     collapseAllButton.addActionListener(new ActionListener() {\n+  427: \n+  428:       @Override\n+  429:       public void actionPerformed(ActionEvent e) {\n+  430:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  431:         TreePath parent = new TreePath(root);\n+  432:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n+  433:           TreeNode n = (TreeNode) categ.nextElement();\n+  434:           TreePath child = parent.pathByAddingChild(n);\n+  435:           configTree.collapsePath(child);\n+  436:         }\n+  437:       }\n+  438:     });\n+  439:     return treeButtonPanel;\n+  440:   }\n+  441: \n+  442:   @NotNull\n+  443:   private JPanel getMotherTonguePanel(GridBagConstraints cons) {\n+  444:     final JPanel motherTonguePanel = new JPanel();\n+  445:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n+  446:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n+  447:     if (config.getMotherTongue() != null) {\n+  448:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n+  449:     }\n+  450:     motherTongueBox.addItemListener(new ItemListener() {\n   451: \n-  452:     dialog.pack();\n-  453:     dialog.setSize(500, 500);\n-  454:     // center on screen:\n-  455:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-  456:     final Dimension frameSize = dialog.getSize();\n-  457:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n-  458:         screenSize.height / 2 - frameSize.height / 2);\n-  459:     dialog.setLocationByPlatform(true);\n-  460:     dialog.setVisible(true);\n-  461:   }\n+  452:       @Override\n+  453:       public void itemStateChanged(ItemEvent e) {\n+  454:         if (e.getStateChange() == ItemEvent.SELECTED) {\n+  455:           Language motherTongue;\n+  456:           if (motherTongueBox.getSelectedItem() instanceof String) {\n+  457:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  458:           } else {\n+  459:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  460:           }\n+  461:           config.setMotherTongue(motherTongue);\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n   * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n   * filtering based on three possible arguments:\n   *\n   *  -e (emulator-only) - only emulators are passing the filter\n   *  -d (device-only) - only real devices are passing the filter\n   *  -s (serial) - only device/emulator with specific serial number are passing the filter\n   *\n   *  If more than one device matches the filter this function will fail unless multi-install\n   *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n   *  devices will be used to install the apk if needed.\n   */\n  @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n    List<IDevice> devices;\n\n    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n\n      // Initialize adb connection.\n      AndroidDebugBridge adb = createAdb(context);\n      if (adb == null) {\n        console.printBuildFailure(\"Failed to create adb connection.\");\n        return false;\n      }\n\n      // Build list of matching devices.\n      devices = filterDevices(adb.getDevices());\n      if (devices == null) {\n        if (restartAdbOnFailure) {\n          console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n          adb.restart();\n          devices = filterDevices(adb.getDevices());\n        }\n\n        if (devices == null) {\n            return false;\n        }\n      }\n    }\n\n    int adbThreadCount = options.getAdbThreadCount();\n    if (adbThreadCount <= 0) {\n      adbThreadCount = devices.size();\n    }\n\n    // Start executions on all matching devices.\n    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n    ListeningExecutorService executorService =\n        listeningDecorator(\n            newMultiThreadExecutor(\n                new CommandThreadFactory(getClass().getSimpleName()),\n                adbThreadCount));\n\n    for (final IDevice device : devices) {\n      futures.add(executorService.submit(adbCallable.forDevice(device)));\n    }\n\n    // Wait for all executions to complete or fail.\n    List<Boolean> results = null;\n    try {\n      results = Futures.allAsList(futures).get();\n    } catch (ExecutionException ex) {\n      console.printBuildFailure(\"Failed: \" + adbCallable);\n      ex.printStackTrace(console.getStdErr());\n      return false;\n    } catch (InterruptedException e) {\n      try {\n        Futures.allAsList(futures).cancel(true);\n      } catch (CancellationException ignored) {\n        // Rethrow original InterruptedException instead.\n      }\n      Thread.currentThread().interrupt();\n      throw e;\n    } finally {\n      MoreExecutors.shutdownOrThrow(\n          executorService,\n          10,\n          TimeUnit.MINUTES,\n          new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n    }\n\n    int successCount = 0;\n    for (Boolean result : results) {\n      if (result) {\n        successCount++;\n      }\n    }\n    int failureCount = results.size() - successCount;\n\n    // Report results.\n    if (successCount > 0) {\n      console.printSuccess(\n          String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n    }\n    if (failureCount > 0) {\n      console.printBuildFailure(\n          String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n    }\n\n    return failureCount == 0;\n  }\n SourceCodeAfterRefactoring:\n/**\n   * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n   * filtering based on three possible arguments:\n   *\n   *  -e (emulator-only) - only emulators are passing the filter\n   *  -d (device-only) - only real devices are passing the filter\n   *  -s (serial) - only device/emulator with specific serial number are passing the filter\n   *\n   *  If more than one device matches the filter this function will fail unless multi-install\n   *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n   *  devices will be used to install the apk if needed.\n   */\n  @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n  public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n    List<IDevice> devices;\n\n    try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n      devices = getDevices();\n      if (devices == null) {\n        return false;\n      }\n    }\n\n    int adbThreadCount = options.getAdbThreadCount();\n    if (adbThreadCount <= 0) {\n      adbThreadCount = devices.size();\n    }\n\n    // Start executions on all matching devices.\n    List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n    ListeningExecutorService executorService =\n        listeningDecorator(\n            newMultiThreadExecutor(\n                new CommandThreadFactory(getClass().getSimpleName()),\n                adbThreadCount));\n\n    for (final IDevice device : devices) {\n      futures.add(executorService.submit(adbCallable.forDevice(device)));\n    }\n\n    // Wait for all executions to complete or fail.\n    List<Boolean> results = null;\n    try {\n      results = Futures.allAsList(futures).get();\n    } catch (ExecutionException ex) {\n      console.printBuildFailure(\"Failed: \" + adbCallable);\n      ex.printStackTrace(console.getStdErr());\n      return false;\n    } catch (InterruptedException e) {\n      try {\n        Futures.allAsList(futures).cancel(true);\n      } catch (CancellationException ignored) {\n        // Rethrow original InterruptedException instead.\n      }\n      Thread.currentThread().interrupt();\n      throw e;\n    } finally {\n      MoreExecutors.shutdownOrThrow(\n          executorService,\n          10,\n          TimeUnit.MINUTES,\n          new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n    }\n\n    int successCount = 0;\n    for (Boolean result : results) {\n      if (result) {\n        successCount++;\n      }\n    }\n    int failureCount = results.size() - successCount;\n\n    // Report results.\n    if (successCount > 0) {\n      console.printSuccess(\n          String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n    }\n    if (failureCount > 0) {\n      console.printBuildFailure(\n          String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n    }\n\n    return failureCount == 0;\n  }\n@Nullable\n  public List<IDevice> getDevices() throws InterruptedException {\n    // Initialize adb connection.\n    AndroidDebugBridge adb = createAdb(context);\n    if (adb == null) {\n      console.printBuildFailure(\"Failed to create adb connection.\");\n      return null;\n    }\n\n    // Build list of matching devices.\n    List<IDevice> devices = filterDevices(adb.getDevices());\n    if (devices == null && restartAdbOnFailure) {\n      console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n      adb.restart();\n      devices = filterDevices(adb.getDevices());\n    }\n    return devices;\n  }\n DiffSourceCode:\n-  235:   /**\n-  236:    * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n-  237:    * filtering based on three possible arguments:\n-  238:    *\n-  239:    *  -e (emulator-only) - only emulators are passing the filter\n-  240:    *  -d (device-only) - only real devices are passing the filter\n-  241:    *  -s (serial) - only device/emulator with specific serial number are passing the filter\n-  242:    *\n-  243:    *  If more than one device matches the filter this function will fail unless multi-install\n-  244:    *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n-  245:    *  devices will be used to install the apk if needed.\n-  246:    */\n-  247:   @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n-  248:   public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n-  249:     List<IDevice> devices;\n-  250: \n-  251:     try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n-  252: \n-  253:       // Initialize adb connection.\n-  254:       AndroidDebugBridge adb = createAdb(context);\n-  255:       if (adb == null) {\n-  256:         console.printBuildFailure(\"Failed to create adb connection.\");\n-  257:         return false;\n-  258:       }\n-  259: \n-  260:       // Build list of matching devices.\n-  261:       devices = filterDevices(adb.getDevices());\n-  262:       if (devices == null) {\n-  263:         if (restartAdbOnFailure) {\n-  264:           console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n-  265:           adb.restart();\n-  266:           devices = filterDevices(adb.getDevices());\n-  267:         }\n-  268: \n-  269:         if (devices == null) {\n-  270:             return false;\n-  271:         }\n-  272:       }\n-  273:     }\n-  274: \n-  275:     int adbThreadCount = options.getAdbThreadCount();\n-  276:     if (adbThreadCount <= 0) {\n-  277:       adbThreadCount = devices.size();\n-  278:     }\n-  279: \n-  280:     // Start executions on all matching devices.\n-  281:     List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n-  282:     ListeningExecutorService executorService =\n-  283:         listeningDecorator(\n-  284:             newMultiThreadExecutor(\n-  285:                 new CommandThreadFactory(getClass().getSimpleName()),\n-  286:                 adbThreadCount));\n-  287: \n-  288:     for (final IDevice device : devices) {\n-  289:       futures.add(executorService.submit(adbCallable.forDevice(device)));\n-  290:     }\n-  291: \n-  292:     // Wait for all executions to complete or fail.\n-  293:     List<Boolean> results = null;\n-  294:     try {\n-  295:       results = Futures.allAsList(futures).get();\n-  296:     } catch (ExecutionException ex) {\n-  297:       console.printBuildFailure(\"Failed: \" + adbCallable);\n-  298:       ex.printStackTrace(console.getStdErr());\n-  299:       return false;\n-  300:     } catch (InterruptedException e) {\n-  301:       try {\n-  302:         Futures.allAsList(futures).cancel(true);\n-  303:       } catch (CancellationException ignored) {\n-  304:         // Rethrow original InterruptedException instead.\n-  305:       }\n-  306:       Thread.currentThread().interrupt();\n-  307:       throw e;\n-  308:     } finally {\n-  309:       MoreExecutors.shutdownOrThrow(\n-  310:           executorService,\n-  311:           10,\n-  312:           TimeUnit.MINUTES,\n-  313:           new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n-  314:     }\n-  315: \n-  316:     int successCount = 0;\n-  317:     for (Boolean result : results) {\n-  318:       if (result) {\n-  319:         successCount++;\n-  320:       }\n-  321:     }\n-  322:     int failureCount = results.size() - successCount;\n-  323: \n-  324:     // Report results.\n-  325:     if (successCount > 0) {\n-  326:       console.printSuccess(\n-  327:           String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n-  328:     }\n-  329:     if (failureCount > 0) {\n-  330:       console.printBuildFailure(\n-  331:           String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n-  332:     }\n-  333: \n-  334:     return failureCount == 0;\n-  335:   }\n-  336: \n-  337:   /**\n+  235:   @Nullable\n+  236:   public List<IDevice> getDevices() throws InterruptedException {\n+  237:     // Initialize adb connection.\n+  238:     AndroidDebugBridge adb = createAdb(context);\n+  239:     if (adb == null) {\n+  240:       console.printBuildFailure(\"Failed to create adb connection.\");\n+  241:       return null;\n+  242:     }\n+  243: \n+  244:     // Build list of matching devices.\n+  245:     List<IDevice> devices = filterDevices(adb.getDevices());\n+  246:     if (devices == null && restartAdbOnFailure) {\n+  247:       console.printErrorText(\"No devices found with adb, restarting adb-server.\");\n+  248:       adb.restart();\n+  249:       devices = filterDevices(adb.getDevices());\n+  250:     }\n+  251:     return devices;\n+  252:   }\n+  253: \n+  254:   /**\n+  255:    * Execute an {@link AdbCallable} for all matching devices. This functions performs device\n+  256:    * filtering based on three possible arguments:\n+  257:    *\n+  258:    *  -e (emulator-only) - only emulators are passing the filter\n+  259:    *  -d (device-only) - only real devices are passing the filter\n+  260:    *  -s (serial) - only device/emulator with specific serial number are passing the filter\n+  261:    *\n+  262:    *  If more than one device matches the filter this function will fail unless multi-install\n+  263:    *  mode is enabled (-x). This flag is used as a marker that user understands that multiple\n+  264:    *  devices will be used to install the apk if needed.\n+  265:    */\n+  266:   @SuppressWarnings(\"PMD.EmptyCatchBlock\")\n+  267:   public boolean adbCall(AdbCallable adbCallable) throws InterruptedException {\n+  268:     List<IDevice> devices;\n+  269: \n+  270:     try (TraceEventLogger ignored = TraceEventLogger.start(buckEventBus, \"set_up_adb_call\")) {\n+  271:       devices = getDevices();\n+  272:       if (devices == null) {\n+  273:         return false;\n+  274:       }\n+  275:     }\n+  276: \n+  277:     int adbThreadCount = options.getAdbThreadCount();\n+  278:     if (adbThreadCount <= 0) {\n+  279:       adbThreadCount = devices.size();\n+  280:     }\n+  281: \n+  282:     // Start executions on all matching devices.\n+  283:     List<ListenableFuture<Boolean>> futures = Lists.newArrayList();\n+  284:     ListeningExecutorService executorService =\n+  285:         listeningDecorator(\n+  286:             newMultiThreadExecutor(\n+  287:                 new CommandThreadFactory(getClass().getSimpleName()),\n+  288:                 adbThreadCount));\n+  289: \n+  290:     for (final IDevice device : devices) {\n+  291:       futures.add(executorService.submit(adbCallable.forDevice(device)));\n+  292:     }\n+  293: \n+  294:     // Wait for all executions to complete or fail.\n+  295:     List<Boolean> results = null;\n+  296:     try {\n+  297:       results = Futures.allAsList(futures).get();\n+  298:     } catch (ExecutionException ex) {\n+  299:       console.printBuildFailure(\"Failed: \" + adbCallable);\n+  300:       ex.printStackTrace(console.getStdErr());\n+  301:       return false;\n+  302:     } catch (InterruptedException e) {\n+  303:       try {\n+  304:         Futures.allAsList(futures).cancel(true);\n+  305:       } catch (CancellationException ignored) {\n+  306:         // Rethrow original InterruptedException instead.\n+  307:       }\n+  308:       Thread.currentThread().interrupt();\n+  309:       throw e;\n+  310:     } finally {\n+  311:       MoreExecutors.shutdownOrThrow(\n+  312:           executorService,\n+  313:           10,\n+  314:           TimeUnit.MINUTES,\n+  315:           new InterruptionFailedException(\"Failed to shutdown ExecutorService.\"));\n+  316:     }\n+  317: \n+  318:     int successCount = 0;\n+  319:     for (Boolean result : results) {\n+  320:       if (result) {\n+  321:         successCount++;\n+  322:       }\n+  323:     }\n+  324:     int failureCount = results.size() - successCount;\n+  325: \n+  326:     // Report results.\n+  327:     if (successCount > 0) {\n+  328:       console.printSuccess(\n+  329:           String.format(\"Successfully ran %s on %d device(s)\", adbCallable, successCount));\n+  330:     }\n+  331:     if (failureCount > 0) {\n+  332:       console.printBuildFailure(\n+  333:           String.format(\"Failed to %s on %d device(s).\", adbCallable, failureCount));\n+  334:     }\n+  335: \n+  336:     return failureCount == 0;\n+  337:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n        Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n        Source source = new Source(Origin.LOCAL, \"write0\");\n        SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(0).getEurekaServerRegistry();\n\n        final Set<String> expectedInstances = new HashSet<>();\n        for (int i = 0; i < count; i++) {\n            InstanceInfo next = instanceIt.next();\n            eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n            expectedInstances.add(next.getId());\n        }\n\n        final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n\n        eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n                    @Override\n                    public void call(ChangeNotification<InstanceInfo> notification) {\n                        if (notification.getKind() == Kind.Add) {\n                            String id = notification.getData().getId();\n                            if (expectedInstances.remove(id)) {\n                                latch.countDown();\n                            }\n                        }\n                    }\n                });\n\n        assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n    }\n SourceCodeAfterRefactoring:\npublic void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n        fillUpRegistryOfServer(0, count, instanceTemplate);\n    }\npublic void fillUpRegistryOfServer(int serverIdx, int count, InstanceInfo instanceTemplate) throws Exception {\n        Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n        Source source = new Source(Origin.LOCAL, \"write\" + serverIdx);\n        SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(serverIdx).getEurekaServerRegistry();\n\n        final Set<String> expectedInstances = new HashSet<>();\n        for (int i = 0; i < count; i++) {\n            InstanceInfo next = instanceIt.next();\n            eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n            expectedInstances.add(next.getId());\n        }\n\n        final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n\n        eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n                .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n                    @Override\n                    public void call(ChangeNotification<InstanceInfo> notification) {\n                        if (notification.getKind() == Kind.Add) {\n                            String id = notification.getData().getId();\n                            if (expectedInstances.remove(id)) {\n                                latch.countDown();\n                            }\n                        }\n                    }\n                });\n\n        assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n    }\n DiffSourceCode:\n-   38:     public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n-   39:         Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n-   40:         Source source = new Source(Origin.LOCAL, \"write0\");\n-   41:         SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(0).getEurekaServerRegistry();\n-   42: \n-   43:         final Set<String> expectedInstances = new HashSet<>();\n-   44:         for (int i = 0; i < count; i++) {\n-   45:             InstanceInfo next = instanceIt.next();\n-   46:             eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n-   47:             expectedInstances.add(next.getId());\n-   48:         }\n-   49: \n-   50:         final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n-   51: \n-   52:         eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n-   53:                 .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n-   54:                     @Override\n-   55:                     public void call(ChangeNotification<InstanceInfo> notification) {\n-   56:                         if (notification.getKind() == Kind.Add) {\n-   57:                             String id = notification.getData().getId();\n-   58:                             if (expectedInstances.remove(id)) {\n-   59:                                 latch.countDown();\n-   60:                             }\n-   61:                         }\n-   62:                     }\n-   63:                 });\n-   64: \n-   65:         assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n-   66:     }\n-   67: }\n+   38:     public EurekaDeploymentClients(EurekaDeployment eurekaDeployment) {\n+   39:         this.eurekaDeployment = eurekaDeployment;\n+   40:     }\n+   41: \n+   42:     public void fillUpRegistryOfServer(int serverIdx, int count, InstanceInfo instanceTemplate) throws Exception {\n+   43:         Iterator<InstanceInfo> instanceIt = collectionOf(instanceTemplate.getApp(), instanceTemplate);\n+   44:         Source source = new Source(Origin.LOCAL, \"write\" + serverIdx);\n+   45:         SourcedEurekaRegistry<InstanceInfo> eurekaServerRegistry = eurekaDeployment.getWriteCluster().getServer(serverIdx).getEurekaServerRegistry();\n+   46: \n+   47:         final Set<String> expectedInstances = new HashSet<>();\n+   48:         for (int i = 0; i < count; i++) {\n+   49:             InstanceInfo next = instanceIt.next();\n+   50:             eurekaServerRegistry.register(next, source).subscribe(new NoOpSubscriber<Boolean>());\n+   51:             expectedInstances.add(next.getId());\n+   52:         }\n+   53: \n+   54:         final CountDownLatch latch = new CountDownLatch(expectedInstances.size());\n+   55: \n+   56:         eurekaServerRegistry.forInterest(Interests.forApplications(instanceTemplate.getApp()))\n+   57:                 .subscribe(new Action1<ChangeNotification<InstanceInfo>>() {\n+   58:                     @Override\n+   59:                     public void call(ChangeNotification<InstanceInfo> notification) {\n+   60:                         if (notification.getKind() == Kind.Add) {\n+   61:                             String id = notification.getData().getId();\n+   62:                             if (expectedInstances.remove(id)) {\n+   63:                                 latch.countDown();\n+   64:                             }\n+   65:                         }\n+   66:                     }\n+   67:                 });\n+   68: \n+   69:         assertTrue(\"Registry not ready in time\", latch.await(30, TimeUnit.SECONDS));\n+   70:     }\n+   72:     public void fillUpRegistry(int count, InstanceInfo instanceTemplate) throws Exception {\n+   73:         fillUpRegistryOfServer(0, count, instanceTemplate);\n+   74:     }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/wordpress-mobile/WordPress-Android.git",
        "branch": "master",
        "commitId": "f8d5cf01f123a1d0a65857aa2db0571fe9cd1911",
        "sourceCodeBeforeRefactoring": "public String getIconImageURL(int size) {\n        String blavatarUrl = GravatarUtils.blavatarFromUrl(this.getUrl(), size);\n        if (iconURL == null) {\n            return blavatarUrl;\n        }\n        if (isPhotonURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"w=%d&h=%d\", size, size));\n        }\n        if (isBlavatarURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"s=%d\", size));\n        }\n        return blavatarUrl;\n    }",
        "refactoredCode": "### Original Code:\n```java\npublic String getIconImageURL(int size) {\n        String blavatarUrl = GravatarUtils.blavatarFromUrl(this.getUrl(), size);\n        if (iconURL == null) {\n            return blavatarUrl;\n        }\n        if (isPhotonURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"w=%d&h=%d\", size, size));\n        }\n        if (isBlavatarURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"s=%d\", size));\n        }\n        return blavatarUrl;\n    }\n```\n\n### Refactored Code:\n```java\npublic String getIconImageURL(int size) {\n        String blavatarUrl = GravatarUtils.blavatarFromUrl(this.getUrl(), size);\n        if (iconURL == null) {\n            return blavatarUrl;\n        }\n        return getIconUrlWithSize(size, blavatarUrl);\n    }\n\nprivate String getIconUrlWithSize(int size, String blavatarUrl) {\n        if (isPhotonURL(iconURL)) {\n            return formatPhotonUrl(size);\n        }\n        if (isBlavatarURL(iconURL)) {\n            return formatBlavatarUrl(size);\n        }\n        return blavatarUrl;\n    }\n\nprivate String formatPhotonUrl(int size) {\n        return UrlUtils.removeQuery(iconURL).concat(String.format(\"w=%d&h=%d\", size, size));\n    }\n\nprivate String formatBlavatarUrl(int size) {\n        return UrlUtils.removeQuery(iconURL).concat(String.format(\"s=%d\", size));\n    }\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: The original method was broken down into smaller methods:\n   - `getIconUrlWithSize(int size, String blavatarUrl)`: This method determines which URL formatting to apply based on the type of `iconURL`.\n   - `formatPhotonUrl(int size)`: This method formats the URL for Photon.\n   - `formatBlavatarUrl(int size)`: This method formats the URL for Blavatar.\n\n2. **Single Responsibility**: Each new method has a single responsibility, making the code easier to read and maintain.\n\n3. **Functionality Unchanged**: The refactored code maintains the same functionality as the original code, ensuring that the output remains consistent.",
        "sourceCodeAfterRefactoring": "public String getIconImageURL(int size) {\n        if (iconURL == null && isJetpackPowered()) {\n            Blog jetpackBlog = WordPress.wpDB.getBlogForDotComBlogId(this.api_blogid);\n            if (jetpackBlog == null) {\n                return null;\n            }\n            return getIconImageURL(size, jetpackBlog.iconURL, jetpackBlog.getUrl());\n        }\n        return getIconImageURL(size, this.iconURL, this.getUrl());\n    }\nprivate static String getIconImageURL(int size, String iconUrl, String blogUrl) {\n        String blavatarUrl = GravatarUtils.blavatarFromUrl(blogUrl, size);\n        if (iconUrl == null) {\n            return blavatarUrl;\n        }\n        if (isPhotonURL(iconUrl)) {\n            return UrlUtils.removeQuery(iconUrl).concat(String.format(\"w=%d&h=%d\", size, size));\n        }\n        if (isBlavatarURL(iconUrl)) {\n            return UrlUtils.removeQuery(iconUrl).concat(String.format(\"s=%d\", size));\n        }\n        return blavatarUrl;\n    }",
        "diffSourceCode": "   476:     public String getIconImageURL(int size) {\n-  477:         String blavatarUrl = GravatarUtils.blavatarFromUrl(this.getUrl(), size);\n-  478:         if (iconURL == null) {\n-  479:             return blavatarUrl;\n-  480:         }\n-  481:         if (isPhotonURL(iconURL)) {\n-  482:             return UrlUtils.removeQuery(iconURL).concat(String.format(\"w=%d&h=%d\", size, size));\n+  477:         if (iconURL == null && isJetpackPowered()) {\n+  478:             Blog jetpackBlog = WordPress.wpDB.getBlogForDotComBlogId(this.api_blogid);\n+  479:             if (jetpackBlog == null) {\n+  480:                 return null;\n+  481:             }\n+  482:             return getIconImageURL(size, jetpackBlog.iconURL, jetpackBlog.getUrl());\n   483:         }\n-  484:         if (isBlavatarURL(iconURL)) {\n-  485:             return UrlUtils.removeQuery(iconURL).concat(String.format(\"s=%d\", size));\n-  486:         }\n-  487:         return blavatarUrl;\n-  488:     }\n-  489: \n-  490:     // Possible matches are \"i0.wp.com\", \"i1.wp.com\" & \"i2.wp.com\" -> https://developer.wordpress.com/docs/photon/\n-  491:     public boolean isPhotonURL(String url) {\n-  492:         return url.contains(\".wp.com\");\n-  493:     }\n-  494: \n-  495:     public boolean isBlavatarURL(String url) {\n-  496:         return url.contains(\"gravatar.com/blavatar\");\n-  497:     }\n-  498: }\n+  484:         return getIconImageURL(size, this.iconURL, this.getUrl());\n+  485:     }\n+  486: \n+  487:     private static String getIconImageURL(int size, String iconUrl, String blogUrl) {\n+  488:         String blavatarUrl = GravatarUtils.blavatarFromUrl(blogUrl, size);\n+  489:         if (iconUrl == null) {\n+  490:             return blavatarUrl;\n+  491:         }\n+  492:         if (isPhotonURL(iconUrl)) {\n+  493:             return UrlUtils.removeQuery(iconUrl).concat(String.format(\"w=%d&h=%d\", size, size));\n+  494:         }\n+  495:         if (isBlavatarURL(iconUrl)) {\n+  496:             return UrlUtils.removeQuery(iconUrl).concat(String.format(\"s=%d\", size));\n+  497:         }\n+  498:         return blavatarUrl;\n+  499:     }\n",
        "uniqueId": "f8d5cf01f123a1d0a65857aa2db0571fe9cd1911_476_488_487_499_476_485",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic byte[] fetch(Feed feed) {\n\t\tString url = feed.getLink() != null ? feed.getLink() : feed.getUrl();\n\n\t\tif (url == null) {\n\t\t\tlog.debug(\"url is null\");\n\t\t\treturn null;\n\t\t}\n\n\t\tint doubleSlash = url.indexOf(\"//\");\n\t\tif (doubleSlash == -1) {\n\t\t\tdoubleSlash = 0;\n\t\t} else {\n\t\t\tdoubleSlash += 2;\n\t\t}\n\t\tint firstSlash = url.indexOf('/', doubleSlash);\n\t\tif (firstSlash != -1) {\n\t\t\turl = url.substring(0, firstSlash);\n\t\t}\n\n\t\tbyte[] icon = getIconAtRoot(url);\n\n\t\tif (icon == null) {\n\t\t\ticon = getIconInPage(url);\n\t\t}\n\n\t\treturn icon;\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic byte[] fetch(Feed feed) {\n\t\tbyte[] icon = fetch(feed.getLink());\n\t\tif (icon == null) {\n\t\t\ticon = fetch(feed.getUrl());\n\t\t}\n\t\treturn icon;\n\t}\nprivate byte[] fetch(String url) {\n\t\tif (url == null) {\n\t\t\tlog.debug(\"url is null\");\n\t\t\treturn null;\n\t\t}\n\n\t\tint doubleSlash = url.indexOf(\"//\");\n\t\tif (doubleSlash == -1) {\n\t\t\tdoubleSlash = 0;\n\t\t} else {\n\t\t\tdoubleSlash += 2;\n\t\t}\n\t\tint firstSlash = url.indexOf('/', doubleSlash);\n\t\tif (firstSlash != -1) {\n\t\t\turl = url.substring(0, firstSlash);\n\t\t}\n\n\t\tbyte[] icon = getIconAtRoot(url);\n\n\t\tif (icon == null) {\n\t\t\ticon = getIconInPage(url);\n\t\t}\n\n\t\treturn icon;\n\t}\n DiffSourceCode:\n    30: \t@Override\n    31: \tpublic byte[] fetch(Feed feed) {\n-   32: \t\tString url = feed.getLink() != null ? feed.getLink() : feed.getUrl();\n-   33: \n-   34: \t\tif (url == null) {\n-   35: \t\t\tlog.debug(\"url is null\");\n-   36: \t\t\treturn null;\n-   37: \t\t}\n+   32: \t\tbyte[] icon = fetch(feed.getLink());\n+   33: \t\tif (icon == null) {\n+   34: \t\t\ticon = fetch(feed.getUrl());\n+   35: \t\t}\n+   36: \t\treturn icon;\n+   37: \t}\n    38: \n-   39: \t\tint doubleSlash = url.indexOf(\"//\");\n-   40: \t\tif (doubleSlash == -1) {\n-   41: \t\t\tdoubleSlash = 0;\n-   42: \t\t} else {\n-   43: \t\t\tdoubleSlash += 2;\n-   44: \t\t}\n-   45: \t\tint firstSlash = url.indexOf('/', doubleSlash);\n-   46: \t\tif (firstSlash != -1) {\n-   47: \t\t\turl = url.substring(0, firstSlash);\n-   48: \t\t}\n-   49: \n-   50: \t\tbyte[] icon = getIconAtRoot(url);\n-   51: \n-   52: \t\tif (icon == null) {\n-   53: \t\t\ticon = getIconInPage(url);\n+   39: \tprivate byte[] fetch(String url) {\n+   40: \t\tif (url == null) {\n+   41: \t\t\tlog.debug(\"url is null\");\n+   42: \t\t\treturn null;\n+   43: \t\t}\n+   44: \n+   45: \t\tint doubleSlash = url.indexOf(\"//\");\n+   46: \t\tif (doubleSlash == -1) {\n+   47: \t\t\tdoubleSlash = 0;\n+   48: \t\t} else {\n+   49: \t\t\tdoubleSlash += 2;\n+   50: \t\t}\n+   51: \t\tint firstSlash = url.indexOf('/', doubleSlash);\n+   52: \t\tif (firstSlash != -1) {\n+   53: \t\t\turl = url.substring(0, firstSlash);\n    54: \t\t}\n    55: \n-   56: \t\treturn icon;\n-   57: \t}\n-   58: \n-   59: \tprivate byte[] getIconAtRoot(String url) {\n-   60: \t\tbyte[] bytes = null;\n-   61: \t\tString contentType = null;\n-   62: \n-   63: \t\ttry {\n+   56: \t\tbyte[] icon = getIconAtRoot(url);\n+   57: \n+   58: \t\tif (icon == null) {\n+   59: \t\t\ticon = getIconInPage(url);\n+   60: \t\t}\n+   61: \n+   62: \t\treturn icon;\n+   63: \t}\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n     * @since Available in iOS 4.0 and later.\n     */\n    public String getTypeIdentifierHint() {\n        if (data.containsKey(TypeIdentifierHintKey())) {\n            CFString val = data.get(TypeIdentifierHintKey(), CFString.class);\n            return val.toString();\n        }\n        return null;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifier) {\n        data.put(TypeIdentifierHintKey(), new CFString(typeIdentifier));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCache() {\n        if (data.containsKey(ShouldCacheKey())) {\n            CFBoolean val = data.get(ShouldCacheKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCache(boolean cache) {\n        data.put(ShouldCacheKey(), CFBoolean.valueOf(cache));\n        return this;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public boolean shouldCacheImmediately() {\n        if (data.containsKey(ShouldCacheImmediatelyKey())) {\n            CFBoolean val = data.get(ShouldCacheImmediatelyKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public CGImageSourceOptions setShouldCacheImmediately(boolean cache) {\n        data.put(ShouldCacheImmediatelyKey(), CFBoolean.valueOf(cache));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldAllowFloat() {\n        if (data.containsKey(ShouldAllowFloatKey())) {\n            CFBoolean val = data.get(ShouldAllowFloatKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldAllowFloat(boolean allowFloat) {\n        data.put(ShouldAllowFloatKey(), CFBoolean.valueOf(allowFloat));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailFromImageIfAbsent() {\n        if (data.containsKey(CreateThumbnailFromImageIfAbsentKey())) {\n            CFBoolean val = data.get(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean createThumbnail) {\n        data.put(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.valueOf(createThumbnail));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public long getThumbnailMaxPixelSize() {\n        if (data.containsKey(ThumbnailMaxPixelSizeKey())) {\n            CFNumber val = data.get(ThumbnailMaxPixelSizeKey(), CFNumber.class);\n            return val.longValue();\n        }\n        return 0;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setThumbnailMaxPixelSize(long maxSize) {\n        data.put(ThumbnailMaxPixelSizeKey(), CFNumber.valueOf(maxSize));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailWithTransform() {\n        if (data.containsKey(CreateThumbnailWithTransformKey())) {\n            CFBoolean val = data.get(CreateThumbnailWithTransformKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean transform) {\n        data.put(CreateThumbnailWithTransformKey(), CFBoolean.valueOf(transform));\n        return this;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public String getTypeIdentifierHint() {\n        if (has(Keys.TypeIdentifierHint())) {\n            CFString val = get(Keys.TypeIdentifierHint(), CFString.class);\n            return val.toString();\n        }\n        return null;\n    }\npublic boolean has(CFString key) {\n        return data.containsKey(key);\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifierHint) {\n        set(Keys.TypeIdentifierHint(), new CFString(typeIdentifierHint));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCache() {\n        if (has(Keys.ShouldCache())) {\n            CFBoolean val = get(Keys.ShouldCache(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCache(boolean shouldCache) {\n        set(Keys.ShouldCache(), CFBoolean.valueOf(shouldCache));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public boolean shouldCacheImmediately() {\n        if (has(Keys.ShouldCacheImmediately())) {\n            CFBoolean val = get(Keys.ShouldCacheImmediately(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public CGImageSourceOptions setShouldCacheImmediately(boolean shouldCacheImmediately) {\n        set(Keys.ShouldCacheImmediately(), CFBoolean.valueOf(shouldCacheImmediately));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldAllowFloat() {\n        if (has(Keys.ShouldAllowFloat())) {\n            CFBoolean val = get(Keys.ShouldAllowFloat(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldAllowFloat(boolean shouldAllowFloat) {\n        set(Keys.ShouldAllowFloat(), CFBoolean.valueOf(shouldAllowFloat));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailFromImageIfAbsent() {\n        if (has(Keys.CreateThumbnailFromImageIfAbsent())) {\n            CFBoolean val = get(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean shouldCreateThumbnailFromImageIfAbsent) {\n        set(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.valueOf(shouldCreateThumbnailFromImageIfAbsent));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public long getThumbnailMaxPixelSize() {\n        if (has(Keys.ThumbnailMaxPixelSize())) {\n            CFNumber val = get(Keys.ThumbnailMaxPixelSize(), CFNumber.class);\n            return val.longValue();\n        }\n        return 0;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setThumbnailMaxPixelSize(long thumbnailMaxPixelSize) {\n        set(Keys.ThumbnailMaxPixelSize(), CFNumber.valueOf(thumbnailMaxPixelSize));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailWithTransform() {\n        if (has(Keys.CreateThumbnailWithTransform())) {\n            CFBoolean val = get(Keys.CreateThumbnailWithTransform(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean shouldCreateThumbnailWithTransform) {\n        set(Keys.CreateThumbnailWithTransform(), CFBoolean.valueOf(shouldCreateThumbnailWithTransform));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n DiffSourceCode:\n-   81:     /**\n-   82:      * @since Available in iOS 4.0 and later.\n-   83:      */\n-   84:     public String getTypeIdentifierHint() {\n-   85:         if (data.containsKey(TypeIdentifierHintKey())) {\n-   86:             CFString val = data.get(TypeIdentifierHintKey(), CFString.class);\n-   87:             return val.toString();\n-   88:         }\n-   89:         return null;\n-   90:     }\n-   91:     /**\n-   92:      * @since Available in iOS 4.0 and later.\n-   93:      */\n-   94:     public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifier) {\n-   95:         data.put(TypeIdentifierHintKey(), new CFString(typeIdentifier));\n-   96:         return this;\n-   97:     }\n-   98:     /**\n-   99:      * @since Available in iOS 4.0 and later.\n-  100:      */\n-  101:     public boolean shouldCache() {\n-  102:         if (data.containsKey(ShouldCacheKey())) {\n-  103:             CFBoolean val = data.get(ShouldCacheKey(), CFBoolean.class);\n-  104:             return val.booleanValue();\n-  105:         }\n-  106:         return false;\n-  107:     }\n-  108:     /**\n-  109:      * @since Available in iOS 4.0 and later.\n-  110:      */\n-  111:     public CGImageSourceOptions setShouldCache(boolean cache) {\n-  112:         data.put(ShouldCacheKey(), CFBoolean.valueOf(cache));\n-  113:         return this;\n-  114:     }\n-  115:     /**\n-  116:      * @since Available in iOS 7.0 and later.\n-  117:      */\n-  118:     public boolean shouldCacheImmediately() {\n-  119:         if (data.containsKey(ShouldCacheImmediatelyKey())) {\n-  120:             CFBoolean val = data.get(ShouldCacheImmediatelyKey(), CFBoolean.class);\n-  121:             return val.booleanValue();\n-  122:         }\n-  123:         return false;\n-  124:     }\n-  125:     /**\n-  126:      * @since Available in iOS 7.0 and later.\n-  127:      */\n-  128:     public CGImageSourceOptions setShouldCacheImmediately(boolean cache) {\n-  129:         data.put(ShouldCacheImmediatelyKey(), CFBoolean.valueOf(cache));\n-  130:         return this;\n-  131:     }\n-  132:     /**\n-  133:      * @since Available in iOS 4.0 and later.\n-  134:      */\n-  135:     public boolean shouldAllowFloat() {\n-  136:         if (data.containsKey(ShouldAllowFloatKey())) {\n-  137:             CFBoolean val = data.get(ShouldAllowFloatKey(), CFBoolean.class);\n-  138:             return val.booleanValue();\n-  139:         }\n-  140:         return false;\n-  141:     }\n-  142:     /**\n-  143:      * @since Available in iOS 4.0 and later.\n-  144:      */\n-  145:     public CGImageSourceOptions setShouldAllowFloat(boolean allowFloat) {\n-  146:         data.put(ShouldAllowFloatKey(), CFBoolean.valueOf(allowFloat));\n-  147:         return this;\n-  148:     }\n-  149:     /**\n-  150:      * @since Available in iOS 4.0 and later.\n-  151:      */\n-  152:     public boolean shouldCreateThumbnailFromImageIfAbsent() {\n-  153:         if (data.containsKey(CreateThumbnailFromImageIfAbsentKey())) {\n-  154:             CFBoolean val = data.get(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.class);\n-  155:             return val.booleanValue();\n-  156:         }\n-  157:         return false;\n-  158:     }\n-  159:     /**\n-  160:      * @since Available in iOS 4.0 and later.\n-  161:      */\n-  162:     public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean createThumbnail) {\n-  163:         data.put(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.valueOf(createThumbnail));\n-  164:         return this;\n-  165:     }\n-  166:     /**\n-  167:      * @since Available in iOS 4.0 and later.\n-  168:      */\n-  169:     public boolean shouldCreateThumbnailFromImageAlways() {\n-  170:         if (data.containsKey(CreateThumbnailFromImageAlwaysKey())) {\n-  171:             CFBoolean val = data.get(CreateThumbnailFromImageAlwaysKey(), CFBoolean.class);\n-  172:             return val.booleanValue();\n-  173:         }\n-  174:         return false;\n-  175:     }\n-  176:     /**\n-  177:      * @since Available in iOS 4.0 and later.\n-  178:      */\n-  179:     public CGImageSourceOptions setShouldCreateThumbnailFromImageAlways(boolean createThumbnail) {\n-  180:         data.put(CreateThumbnailFromImageAlwaysKey(), CFBoolean.valueOf(createThumbnail));\n-  181:         return this;\n-  182:     }\n-  183:     /**\n-  184:      * @since Available in iOS 4.0 and later.\n-  185:      */\n-  186:     public long getThumbnailMaxPixelSize() {\n-  187:         if (data.containsKey(ThumbnailMaxPixelSizeKey())) {\n-  188:             CFNumber val = data.get(ThumbnailMaxPixelSizeKey(), CFNumber.class);\n-  189:             return val.longValue();\n-  190:         }\n-  191:         return 0;\n-  192:     }\n-  193:     /**\n-  194:      * @since Available in iOS 4.0 and later.\n-  195:      */\n-  196:     public CGImageSourceOptions setThumbnailMaxPixelSize(long maxSize) {\n-  197:         data.put(ThumbnailMaxPixelSizeKey(), CFNumber.valueOf(maxSize));\n-  198:         return this;\n-  199:     }\n-  200:     /**\n-  201:      * @since Available in iOS 4.0 and later.\n-  202:      */\n-  203:     public boolean shouldCreateThumbnailWithTransform() {\n-  204:         if (data.containsKey(CreateThumbnailWithTransformKey())) {\n-  205:             CFBoolean val = data.get(CreateThumbnailWithTransformKey(), CFBoolean.class);\n-  206:             return val.booleanValue();\n-  207:         }\n-  208:         return false;\n-  209:     }\n-  210:     /**\n-  211:      * @since Available in iOS 4.0 and later.\n-  212:      */\n-  213:     public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean transform) {\n-  214:         data.put(CreateThumbnailWithTransformKey(), CFBoolean.valueOf(transform));\n-  215:         return this;\n-  216:     }\n-  217:     /*<methods>*/\n-  218:     /**\n-  219:      * @since Available in iOS 4.0 and later.\n-  220:      */\n-  221:     @GlobalValue(symbol=\"kCGImageSourceTypeIdentifierHint\", optional=true)\n-  222:     protected static native CFString TypeIdentifierHintKey();\n+   81:                 array.add(i.getDictionary());\n+   82:             }\n+   83:             return CFType.Marshaler.toNative(array, flags);\n+   84:         }\n+   85:     }\n+   86:     /*</marshalers>*/\n+   87: \n+   88:     /*<constructors>*/\n+   89:     CGImageSourceOptions(CFDictionary data) {\n+   90:         super(data);\n+   91:     }\n+   92:     public CGImageSourceOptions() {}\n+   93:     /*</constructors>*/\n+   94: \n+   95:     /*<methods>*/\n+   96:     public boolean has(CFString key) {\n+   97:         return data.containsKey(key);\n+   98:     }\n+   99:     public <T extends NativeObject> T get(CFString key, Class<T> type) {\n+  100:         if (has(key)) {\n+  101:             return data.get(key, type);\n+  102:         }\n+  103:         return null;\n+  104:     }\n+  105:     public CGImageSourceOptions set(CFString key, NativeObject value) {\n+  106:         data.put(key, value);\n+  107:         return this;\n+  108:     }\n+  109:     \n+  110: \n+  111:     /**\n+  112:      * @since Available in iOS 4.0 and later.\n+  113:      */\n+  114:     public String getTypeIdentifierHint() {\n+  115:         if (has(Keys.TypeIdentifierHint())) {\n+  116:             CFString val = get(Keys.TypeIdentifierHint(), CFString.class);\n+  117:             return val.toString();\n+  118:         }\n+  119:         return null;\n+  120:     }\n+  121:     /**\n+  122:      * @since Available in iOS 4.0 and later.\n+  123:      */\n+  124:     public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifierHint) {\n+  125:         set(Keys.TypeIdentifierHint(), new CFString(typeIdentifierHint));\n+  126:         return this;\n+  127:     }\n+  128:     /**\n+  129:      * @since Available in iOS 4.0 and later.\n+  130:      */\n+  131:     public boolean shouldCache() {\n+  132:         if (has(Keys.ShouldCache())) {\n+  133:             CFBoolean val = get(Keys.ShouldCache(), CFBoolean.class);\n+  134:             return val.booleanValue();\n+  135:         }\n+  136:         return false;\n+  137:     }\n+  138:     /**\n+  139:      * @since Available in iOS 4.0 and later.\n+  140:      */\n+  141:     public CGImageSourceOptions setShouldCache(boolean shouldCache) {\n+  142:         set(Keys.ShouldCache(), CFBoolean.valueOf(shouldCache));\n+  143:         return this;\n+  144:     }\n+  145:     /**\n+  146:      * @since Available in iOS 7.0 and later.\n+  147:      */\n+  148:     public boolean shouldCacheImmediately() {\n+  149:         if (has(Keys.ShouldCacheImmediately())) {\n+  150:             CFBoolean val = get(Keys.ShouldCacheImmediately(), CFBoolean.class);\n+  151:             return val.booleanValue();\n+  152:         }\n+  153:         return false;\n+  154:     }\n+  155:     /**\n+  156:      * @since Available in iOS 7.0 and later.\n+  157:      */\n+  158:     public CGImageSourceOptions setShouldCacheImmediately(boolean shouldCacheImmediately) {\n+  159:         set(Keys.ShouldCacheImmediately(), CFBoolean.valueOf(shouldCacheImmediately));\n+  160:         return this;\n+  161:     }\n+  162:     /**\n+  163:      * @since Available in iOS 4.0 and later.\n+  164:      */\n+  165:     public boolean shouldAllowFloat() {\n+  166:         if (has(Keys.ShouldAllowFloat())) {\n+  167:             CFBoolean val = get(Keys.ShouldAllowFloat(), CFBoolean.class);\n+  168:             return val.booleanValue();\n+  169:         }\n+  170:         return false;\n+  171:     }\n+  172:     /**\n+  173:      * @since Available in iOS 4.0 and later.\n+  174:      */\n+  175:     public CGImageSourceOptions setShouldAllowFloat(boolean shouldAllowFloat) {\n+  176:         set(Keys.ShouldAllowFloat(), CFBoolean.valueOf(shouldAllowFloat));\n+  177:         return this;\n+  178:     }\n+  179:     /**\n+  180:      * @since Available in iOS 4.0 and later.\n+  181:      */\n+  182:     public boolean shouldCreateThumbnailFromImageIfAbsent() {\n+  183:         if (has(Keys.CreateThumbnailFromImageIfAbsent())) {\n+  184:             CFBoolean val = get(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.class);\n+  185:             return val.booleanValue();\n+  186:         }\n+  187:         return false;\n+  188:     }\n+  189:     /**\n+  190:      * @since Available in iOS 4.0 and later.\n+  191:      */\n+  192:     public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean shouldCreateThumbnailFromImageIfAbsent) {\n+  193:         set(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.valueOf(shouldCreateThumbnailFromImageIfAbsent));\n+  194:         return this;\n+  195:     }\n+  196:     /**\n+  197:      * @since Available in iOS 4.0 and later.\n+  198:      */\n+  199:     public long getThumbnailMaxPixelSize() {\n+  200:         if (has(Keys.ThumbnailMaxPixelSize())) {\n+  201:             CFNumber val = get(Keys.ThumbnailMaxPixelSize(), CFNumber.class);\n+  202:             return val.longValue();\n+  203:         }\n+  204:         return 0;\n+  205:     }\n+  206:     /**\n+  207:      * @since Available in iOS 4.0 and later.\n+  208:      */\n+  209:     public CGImageSourceOptions setThumbnailMaxPixelSize(long thumbnailMaxPixelSize) {\n+  210:         set(Keys.ThumbnailMaxPixelSize(), CFNumber.valueOf(thumbnailMaxPixelSize));\n+  211:         return this;\n+  212:     }\n+  213:     /**\n+  214:      * @since Available in iOS 4.0 and later.\n+  215:      */\n+  216:     public boolean shouldCreateThumbnailWithTransform() {\n+  217:         if (has(Keys.CreateThumbnailWithTransform())) {\n+  218:             CFBoolean val = get(Keys.CreateThumbnailWithTransform(), CFBoolean.class);\n+  219:             return val.booleanValue();\n+  220:         }\n+  221:         return false;\n+  222:     }\n   223:     /**\n   224:      * @since Available in iOS 4.0 and later.\n   225:      */\n-  226:     @GlobalValue(symbol=\"kCGImageSourceShouldCache\", optional=true)\n-  227:     protected static native CFString ShouldCacheKey();\n-  228:     /**\n-  229:      * @since Available in iOS 7.0 and later.\n+  226:     public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean shouldCreateThumbnailWithTransform) {\n+  227:         set(Keys.CreateThumbnailWithTransform(), CFBoolean.valueOf(shouldCreateThumbnailWithTransform));\n+  228:         return this;\n+  229:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static void testGetGeocodeFromUrl() {\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n    }\npublic static void testCanHandle() {\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n\n        assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n        assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n    }\n SourceCodeAfterRefactoring:\npublic static void testGetGeocodeFromUrl() {\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        final IConnector wmConnector = getWaymarkingConnector();\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n    }\nprivate static IConnector getWaymarkingConnector() {\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n        return wmConnector;\n    }\npublic static void testCanHandle() {\n        final IConnector wmConnector = getWaymarkingConnector();\n\n        assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n        assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n    }\n DiffSourceCode:\n-    8:     public static void testGetGeocodeFromUrl() {\n-    9:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n-   10:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n-   11: \n-   12:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n-   13:         assertThat(wmConnector).isNotNull();\n-   14: \n-   15:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n-   16:         assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n-   17: \n-   18:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n-   19:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n-   20:     }\n+    8: public class WaymarkingConnectorTest extends TestCase {\n+    9: \n+   10:     private static IConnector getWaymarkingConnector() {\n+   11:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n+   12:         assertThat(wmConnector).isNotNull();\n+   13:         return wmConnector;\n+   14:     }\n+   15: \n+   16:     public static void testGetGeocodeFromUrl() {\n+   17:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n+   18:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n+   19: \n+   20:         final IConnector wmConnector = getWaymarkingConnector();\n    21: \n-   22:     public static void testCanHandle() {\n-   23:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n-   24:         assertThat(wmConnector).isNotNull();\n-   25: \n-   26:         assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n-   27:         assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n-   28:     }\n-   29: }\n+   22:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n+   23:         assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n+   24: \n+   25:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n+   26:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n+   27:     }\n+   28: \n+   29:     public static void testCanHandle() {\n+   30:         final IConnector wmConnector = getWaymarkingConnector();\n+   31: \n+   32:         assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n+   33:         assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n+   34:     }\n\n",
        "contextDescription": "PackageName: org.wordpress.android.models\nClassName: org.wordpress.android.models.Blog\nMethodName: org.wordpress.android.models.Blog#getIconImageURL\n ClassSignature: public class Blog \nInvokedMethod: methodSignature: org.wordpress.android.models.Blog#isBlavatarURL\n methodBody: public boolean isBlavatarURL(String url) {\nreturn url.contains(\"gravatar.com/blavatar\");\n}\nmethodSignature: org.wordpress.android.models.Blog#isPhotonURL\n methodBody: public boolean isPhotonURL(String url) {\nreturn url.contains(\".wp.com\");\n}\nmethodSignature: org.wordpress.android.models.Blog#getUrl\n methodBody: public String getUrl() {\nreturn url;\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\npublic String getIconImageURL(int size) {\n        String blavatarUrl = GravatarUtils.blavatarFromUrl(this.getUrl(), size);\n        if (iconURL == null) {\n            return blavatarUrl;\n        }\n        if (isPhotonURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"w=%d&h=%d\", size, size));\n        }\n        if (isBlavatarURL(iconURL)) {\n            return UrlUtils.removeQuery(iconURL).concat(String.format(\"s=%d\", size));\n        }\n        return blavatarUrl;\n    }\n\nThe context of the source code is as follows:\nPackageName: org.wordpress.android.models\nClassName: org.wordpress.android.models.Blog\nMethodName: org.wordpress.android.models.Blog#getIconImageURL\n ClassSignature: public class Blog \nInvokedMethod: methodSignature: org.wordpress.android.models.Blog#isBlavatarURL\n methodBody: public boolean isBlavatarURL(String url) {\nreturn url.contains(\"gravatar.com/blavatar\");\n}\nmethodSignature: org.wordpress.android.models.Blog#isPhotonURL\n methodBody: public boolean isPhotonURL(String url) {\nreturn url.contains(\".wp.com\");\n}\nmethodSignature: org.wordpress.android.models.Blog#getUrl\n methodBody: public String getUrl() {\nreturn url;\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic byte[] fetch(Feed feed) {\n\t\tString url = feed.getLink() != null ? feed.getLink() : feed.getUrl();\n\n\t\tif (url == null) {\n\t\t\tlog.debug(\"url is null\");\n\t\t\treturn null;\n\t\t}\n\n\t\tint doubleSlash = url.indexOf(\"//\");\n\t\tif (doubleSlash == -1) {\n\t\t\tdoubleSlash = 0;\n\t\t} else {\n\t\t\tdoubleSlash += 2;\n\t\t}\n\t\tint firstSlash = url.indexOf('/', doubleSlash);\n\t\tif (firstSlash != -1) {\n\t\t\turl = url.substring(0, firstSlash);\n\t\t}\n\n\t\tbyte[] icon = getIconAtRoot(url);\n\n\t\tif (icon == null) {\n\t\t\ticon = getIconInPage(url);\n\t\t}\n\n\t\treturn icon;\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic byte[] fetch(Feed feed) {\n\t\tbyte[] icon = fetch(feed.getLink());\n\t\tif (icon == null) {\n\t\t\ticon = fetch(feed.getUrl());\n\t\t}\n\t\treturn icon;\n\t}\nprivate byte[] fetch(String url) {\n\t\tif (url == null) {\n\t\t\tlog.debug(\"url is null\");\n\t\t\treturn null;\n\t\t}\n\n\t\tint doubleSlash = url.indexOf(\"//\");\n\t\tif (doubleSlash == -1) {\n\t\t\tdoubleSlash = 0;\n\t\t} else {\n\t\t\tdoubleSlash += 2;\n\t\t}\n\t\tint firstSlash = url.indexOf('/', doubleSlash);\n\t\tif (firstSlash != -1) {\n\t\t\turl = url.substring(0, firstSlash);\n\t\t}\n\n\t\tbyte[] icon = getIconAtRoot(url);\n\n\t\tif (icon == null) {\n\t\t\ticon = getIconInPage(url);\n\t\t}\n\n\t\treturn icon;\n\t}\n DiffSourceCode:\n    30: \t@Override\n    31: \tpublic byte[] fetch(Feed feed) {\n-   32: \t\tString url = feed.getLink() != null ? feed.getLink() : feed.getUrl();\n-   33: \n-   34: \t\tif (url == null) {\n-   35: \t\t\tlog.debug(\"url is null\");\n-   36: \t\t\treturn null;\n-   37: \t\t}\n+   32: \t\tbyte[] icon = fetch(feed.getLink());\n+   33: \t\tif (icon == null) {\n+   34: \t\t\ticon = fetch(feed.getUrl());\n+   35: \t\t}\n+   36: \t\treturn icon;\n+   37: \t}\n    38: \n-   39: \t\tint doubleSlash = url.indexOf(\"//\");\n-   40: \t\tif (doubleSlash == -1) {\n-   41: \t\t\tdoubleSlash = 0;\n-   42: \t\t} else {\n-   43: \t\t\tdoubleSlash += 2;\n-   44: \t\t}\n-   45: \t\tint firstSlash = url.indexOf('/', doubleSlash);\n-   46: \t\tif (firstSlash != -1) {\n-   47: \t\t\turl = url.substring(0, firstSlash);\n-   48: \t\t}\n-   49: \n-   50: \t\tbyte[] icon = getIconAtRoot(url);\n-   51: \n-   52: \t\tif (icon == null) {\n-   53: \t\t\ticon = getIconInPage(url);\n+   39: \tprivate byte[] fetch(String url) {\n+   40: \t\tif (url == null) {\n+   41: \t\t\tlog.debug(\"url is null\");\n+   42: \t\t\treturn null;\n+   43: \t\t}\n+   44: \n+   45: \t\tint doubleSlash = url.indexOf(\"//\");\n+   46: \t\tif (doubleSlash == -1) {\n+   47: \t\t\tdoubleSlash = 0;\n+   48: \t\t} else {\n+   49: \t\t\tdoubleSlash += 2;\n+   50: \t\t}\n+   51: \t\tint firstSlash = url.indexOf('/', doubleSlash);\n+   52: \t\tif (firstSlash != -1) {\n+   53: \t\t\turl = url.substring(0, firstSlash);\n    54: \t\t}\n    55: \n-   56: \t\treturn icon;\n-   57: \t}\n-   58: \n-   59: \tprivate byte[] getIconAtRoot(String url) {\n-   60: \t\tbyte[] bytes = null;\n-   61: \t\tString contentType = null;\n-   62: \n-   63: \t\ttry {\n+   56: \t\tbyte[] icon = getIconAtRoot(url);\n+   57: \n+   58: \t\tif (icon == null) {\n+   59: \t\t\ticon = getIconInPage(url);\n+   60: \t\t}\n+   61: \n+   62: \t\treturn icon;\n+   63: \t}\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n /**\n     * @since Available in iOS 4.0 and later.\n     */\n    public String getTypeIdentifierHint() {\n        if (data.containsKey(TypeIdentifierHintKey())) {\n            CFString val = data.get(TypeIdentifierHintKey(), CFString.class);\n            return val.toString();\n        }\n        return null;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifier) {\n        data.put(TypeIdentifierHintKey(), new CFString(typeIdentifier));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCache() {\n        if (data.containsKey(ShouldCacheKey())) {\n            CFBoolean val = data.get(ShouldCacheKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCache(boolean cache) {\n        data.put(ShouldCacheKey(), CFBoolean.valueOf(cache));\n        return this;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public boolean shouldCacheImmediately() {\n        if (data.containsKey(ShouldCacheImmediatelyKey())) {\n            CFBoolean val = data.get(ShouldCacheImmediatelyKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public CGImageSourceOptions setShouldCacheImmediately(boolean cache) {\n        data.put(ShouldCacheImmediatelyKey(), CFBoolean.valueOf(cache));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldAllowFloat() {\n        if (data.containsKey(ShouldAllowFloatKey())) {\n            CFBoolean val = data.get(ShouldAllowFloatKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldAllowFloat(boolean allowFloat) {\n        data.put(ShouldAllowFloatKey(), CFBoolean.valueOf(allowFloat));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailFromImageIfAbsent() {\n        if (data.containsKey(CreateThumbnailFromImageIfAbsentKey())) {\n            CFBoolean val = data.get(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean createThumbnail) {\n        data.put(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.valueOf(createThumbnail));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public long getThumbnailMaxPixelSize() {\n        if (data.containsKey(ThumbnailMaxPixelSizeKey())) {\n            CFNumber val = data.get(ThumbnailMaxPixelSizeKey(), CFNumber.class);\n            return val.longValue();\n        }\n        return 0;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setThumbnailMaxPixelSize(long maxSize) {\n        data.put(ThumbnailMaxPixelSizeKey(), CFNumber.valueOf(maxSize));\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailWithTransform() {\n        if (data.containsKey(CreateThumbnailWithTransformKey())) {\n            CFBoolean val = data.get(CreateThumbnailWithTransformKey(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean transform) {\n        data.put(CreateThumbnailWithTransformKey(), CFBoolean.valueOf(transform));\n        return this;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public String getTypeIdentifierHint() {\n        if (has(Keys.TypeIdentifierHint())) {\n            CFString val = get(Keys.TypeIdentifierHint(), CFString.class);\n            return val.toString();\n        }\n        return null;\n    }\npublic boolean has(CFString key) {\n        return data.containsKey(key);\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifierHint) {\n        set(Keys.TypeIdentifierHint(), new CFString(typeIdentifierHint));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCache() {\n        if (has(Keys.ShouldCache())) {\n            CFBoolean val = get(Keys.ShouldCache(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCache(boolean shouldCache) {\n        set(Keys.ShouldCache(), CFBoolean.valueOf(shouldCache));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public boolean shouldCacheImmediately() {\n        if (has(Keys.ShouldCacheImmediately())) {\n            CFBoolean val = get(Keys.ShouldCacheImmediately(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 7.0 and later.\n     */\n    public CGImageSourceOptions setShouldCacheImmediately(boolean shouldCacheImmediately) {\n        set(Keys.ShouldCacheImmediately(), CFBoolean.valueOf(shouldCacheImmediately));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldAllowFloat() {\n        if (has(Keys.ShouldAllowFloat())) {\n            CFBoolean val = get(Keys.ShouldAllowFloat(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldAllowFloat(boolean shouldAllowFloat) {\n        set(Keys.ShouldAllowFloat(), CFBoolean.valueOf(shouldAllowFloat));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailFromImageIfAbsent() {\n        if (has(Keys.CreateThumbnailFromImageIfAbsent())) {\n            CFBoolean val = get(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean shouldCreateThumbnailFromImageIfAbsent) {\n        set(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.valueOf(shouldCreateThumbnailFromImageIfAbsent));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public long getThumbnailMaxPixelSize() {\n        if (has(Keys.ThumbnailMaxPixelSize())) {\n            CFNumber val = get(Keys.ThumbnailMaxPixelSize(), CFNumber.class);\n            return val.longValue();\n        }\n        return 0;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setThumbnailMaxPixelSize(long thumbnailMaxPixelSize) {\n        set(Keys.ThumbnailMaxPixelSize(), CFNumber.valueOf(thumbnailMaxPixelSize));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public boolean shouldCreateThumbnailWithTransform() {\n        if (has(Keys.CreateThumbnailWithTransform())) {\n            CFBoolean val = get(Keys.CreateThumbnailWithTransform(), CFBoolean.class);\n            return val.booleanValue();\n        }\n        return false;\n    }\n/**\n     * @since Available in iOS 4.0 and later.\n     */\n    public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean shouldCreateThumbnailWithTransform) {\n        set(Keys.CreateThumbnailWithTransform(), CFBoolean.valueOf(shouldCreateThumbnailWithTransform));\n        return this;\n    }\npublic CGImageSourceOptions set(CFString key, NativeObject value) {\n        data.put(key, value);\n        return this;\n    }\n DiffSourceCode:\n-   81:     /**\n-   82:      * @since Available in iOS 4.0 and later.\n-   83:      */\n-   84:     public String getTypeIdentifierHint() {\n-   85:         if (data.containsKey(TypeIdentifierHintKey())) {\n-   86:             CFString val = data.get(TypeIdentifierHintKey(), CFString.class);\n-   87:             return val.toString();\n-   88:         }\n-   89:         return null;\n-   90:     }\n-   91:     /**\n-   92:      * @since Available in iOS 4.0 and later.\n-   93:      */\n-   94:     public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifier) {\n-   95:         data.put(TypeIdentifierHintKey(), new CFString(typeIdentifier));\n-   96:         return this;\n-   97:     }\n-   98:     /**\n-   99:      * @since Available in iOS 4.0 and later.\n-  100:      */\n-  101:     public boolean shouldCache() {\n-  102:         if (data.containsKey(ShouldCacheKey())) {\n-  103:             CFBoolean val = data.get(ShouldCacheKey(), CFBoolean.class);\n-  104:             return val.booleanValue();\n-  105:         }\n-  106:         return false;\n-  107:     }\n-  108:     /**\n-  109:      * @since Available in iOS 4.0 and later.\n-  110:      */\n-  111:     public CGImageSourceOptions setShouldCache(boolean cache) {\n-  112:         data.put(ShouldCacheKey(), CFBoolean.valueOf(cache));\n-  113:         return this;\n-  114:     }\n-  115:     /**\n-  116:      * @since Available in iOS 7.0 and later.\n-  117:      */\n-  118:     public boolean shouldCacheImmediately() {\n-  119:         if (data.containsKey(ShouldCacheImmediatelyKey())) {\n-  120:             CFBoolean val = data.get(ShouldCacheImmediatelyKey(), CFBoolean.class);\n-  121:             return val.booleanValue();\n-  122:         }\n-  123:         return false;\n-  124:     }\n-  125:     /**\n-  126:      * @since Available in iOS 7.0 and later.\n-  127:      */\n-  128:     public CGImageSourceOptions setShouldCacheImmediately(boolean cache) {\n-  129:         data.put(ShouldCacheImmediatelyKey(), CFBoolean.valueOf(cache));\n-  130:         return this;\n-  131:     }\n-  132:     /**\n-  133:      * @since Available in iOS 4.0 and later.\n-  134:      */\n-  135:     public boolean shouldAllowFloat() {\n-  136:         if (data.containsKey(ShouldAllowFloatKey())) {\n-  137:             CFBoolean val = data.get(ShouldAllowFloatKey(), CFBoolean.class);\n-  138:             return val.booleanValue();\n-  139:         }\n-  140:         return false;\n-  141:     }\n-  142:     /**\n-  143:      * @since Available in iOS 4.0 and later.\n-  144:      */\n-  145:     public CGImageSourceOptions setShouldAllowFloat(boolean allowFloat) {\n-  146:         data.put(ShouldAllowFloatKey(), CFBoolean.valueOf(allowFloat));\n-  147:         return this;\n-  148:     }\n-  149:     /**\n-  150:      * @since Available in iOS 4.0 and later.\n-  151:      */\n-  152:     public boolean shouldCreateThumbnailFromImageIfAbsent() {\n-  153:         if (data.containsKey(CreateThumbnailFromImageIfAbsentKey())) {\n-  154:             CFBoolean val = data.get(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.class);\n-  155:             return val.booleanValue();\n-  156:         }\n-  157:         return false;\n-  158:     }\n-  159:     /**\n-  160:      * @since Available in iOS 4.0 and later.\n-  161:      */\n-  162:     public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean createThumbnail) {\n-  163:         data.put(CreateThumbnailFromImageIfAbsentKey(), CFBoolean.valueOf(createThumbnail));\n-  164:         return this;\n-  165:     }\n-  166:     /**\n-  167:      * @since Available in iOS 4.0 and later.\n-  168:      */\n-  169:     public boolean shouldCreateThumbnailFromImageAlways() {\n-  170:         if (data.containsKey(CreateThumbnailFromImageAlwaysKey())) {\n-  171:             CFBoolean val = data.get(CreateThumbnailFromImageAlwaysKey(), CFBoolean.class);\n-  172:             return val.booleanValue();\n-  173:         }\n-  174:         return false;\n-  175:     }\n-  176:     /**\n-  177:      * @since Available in iOS 4.0 and later.\n-  178:      */\n-  179:     public CGImageSourceOptions setShouldCreateThumbnailFromImageAlways(boolean createThumbnail) {\n-  180:         data.put(CreateThumbnailFromImageAlwaysKey(), CFBoolean.valueOf(createThumbnail));\n-  181:         return this;\n-  182:     }\n-  183:     /**\n-  184:      * @since Available in iOS 4.0 and later.\n-  185:      */\n-  186:     public long getThumbnailMaxPixelSize() {\n-  187:         if (data.containsKey(ThumbnailMaxPixelSizeKey())) {\n-  188:             CFNumber val = data.get(ThumbnailMaxPixelSizeKey(), CFNumber.class);\n-  189:             return val.longValue();\n-  190:         }\n-  191:         return 0;\n-  192:     }\n-  193:     /**\n-  194:      * @since Available in iOS 4.0 and later.\n-  195:      */\n-  196:     public CGImageSourceOptions setThumbnailMaxPixelSize(long maxSize) {\n-  197:         data.put(ThumbnailMaxPixelSizeKey(), CFNumber.valueOf(maxSize));\n-  198:         return this;\n-  199:     }\n-  200:     /**\n-  201:      * @since Available in iOS 4.0 and later.\n-  202:      */\n-  203:     public boolean shouldCreateThumbnailWithTransform() {\n-  204:         if (data.containsKey(CreateThumbnailWithTransformKey())) {\n-  205:             CFBoolean val = data.get(CreateThumbnailWithTransformKey(), CFBoolean.class);\n-  206:             return val.booleanValue();\n-  207:         }\n-  208:         return false;\n-  209:     }\n-  210:     /**\n-  211:      * @since Available in iOS 4.0 and later.\n-  212:      */\n-  213:     public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean transform) {\n-  214:         data.put(CreateThumbnailWithTransformKey(), CFBoolean.valueOf(transform));\n-  215:         return this;\n-  216:     }\n-  217:     /*<methods>*/\n-  218:     /**\n-  219:      * @since Available in iOS 4.0 and later.\n-  220:      */\n-  221:     @GlobalValue(symbol=\"kCGImageSourceTypeIdentifierHint\", optional=true)\n-  222:     protected static native CFString TypeIdentifierHintKey();\n+   81:                 array.add(i.getDictionary());\n+   82:             }\n+   83:             return CFType.Marshaler.toNative(array, flags);\n+   84:         }\n+   85:     }\n+   86:     /*</marshalers>*/\n+   87: \n+   88:     /*<constructors>*/\n+   89:     CGImageSourceOptions(CFDictionary data) {\n+   90:         super(data);\n+   91:     }\n+   92:     public CGImageSourceOptions() {}\n+   93:     /*</constructors>*/\n+   94: \n+   95:     /*<methods>*/\n+   96:     public boolean has(CFString key) {\n+   97:         return data.containsKey(key);\n+   98:     }\n+   99:     public <T extends NativeObject> T get(CFString key, Class<T> type) {\n+  100:         if (has(key)) {\n+  101:             return data.get(key, type);\n+  102:         }\n+  103:         return null;\n+  104:     }\n+  105:     public CGImageSourceOptions set(CFString key, NativeObject value) {\n+  106:         data.put(key, value);\n+  107:         return this;\n+  108:     }\n+  109:     \n+  110: \n+  111:     /**\n+  112:      * @since Available in iOS 4.0 and later.\n+  113:      */\n+  114:     public String getTypeIdentifierHint() {\n+  115:         if (has(Keys.TypeIdentifierHint())) {\n+  116:             CFString val = get(Keys.TypeIdentifierHint(), CFString.class);\n+  117:             return val.toString();\n+  118:         }\n+  119:         return null;\n+  120:     }\n+  121:     /**\n+  122:      * @since Available in iOS 4.0 and later.\n+  123:      */\n+  124:     public CGImageSourceOptions setTypeIdentifierHint(String typeIdentifierHint) {\n+  125:         set(Keys.TypeIdentifierHint(), new CFString(typeIdentifierHint));\n+  126:         return this;\n+  127:     }\n+  128:     /**\n+  129:      * @since Available in iOS 4.0 and later.\n+  130:      */\n+  131:     public boolean shouldCache() {\n+  132:         if (has(Keys.ShouldCache())) {\n+  133:             CFBoolean val = get(Keys.ShouldCache(), CFBoolean.class);\n+  134:             return val.booleanValue();\n+  135:         }\n+  136:         return false;\n+  137:     }\n+  138:     /**\n+  139:      * @since Available in iOS 4.0 and later.\n+  140:      */\n+  141:     public CGImageSourceOptions setShouldCache(boolean shouldCache) {\n+  142:         set(Keys.ShouldCache(), CFBoolean.valueOf(shouldCache));\n+  143:         return this;\n+  144:     }\n+  145:     /**\n+  146:      * @since Available in iOS 7.0 and later.\n+  147:      */\n+  148:     public boolean shouldCacheImmediately() {\n+  149:         if (has(Keys.ShouldCacheImmediately())) {\n+  150:             CFBoolean val = get(Keys.ShouldCacheImmediately(), CFBoolean.class);\n+  151:             return val.booleanValue();\n+  152:         }\n+  153:         return false;\n+  154:     }\n+  155:     /**\n+  156:      * @since Available in iOS 7.0 and later.\n+  157:      */\n+  158:     public CGImageSourceOptions setShouldCacheImmediately(boolean shouldCacheImmediately) {\n+  159:         set(Keys.ShouldCacheImmediately(), CFBoolean.valueOf(shouldCacheImmediately));\n+  160:         return this;\n+  161:     }\n+  162:     /**\n+  163:      * @since Available in iOS 4.0 and later.\n+  164:      */\n+  165:     public boolean shouldAllowFloat() {\n+  166:         if (has(Keys.ShouldAllowFloat())) {\n+  167:             CFBoolean val = get(Keys.ShouldAllowFloat(), CFBoolean.class);\n+  168:             return val.booleanValue();\n+  169:         }\n+  170:         return false;\n+  171:     }\n+  172:     /**\n+  173:      * @since Available in iOS 4.0 and later.\n+  174:      */\n+  175:     public CGImageSourceOptions setShouldAllowFloat(boolean shouldAllowFloat) {\n+  176:         set(Keys.ShouldAllowFloat(), CFBoolean.valueOf(shouldAllowFloat));\n+  177:         return this;\n+  178:     }\n+  179:     /**\n+  180:      * @since Available in iOS 4.0 and later.\n+  181:      */\n+  182:     public boolean shouldCreateThumbnailFromImageIfAbsent() {\n+  183:         if (has(Keys.CreateThumbnailFromImageIfAbsent())) {\n+  184:             CFBoolean val = get(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.class);\n+  185:             return val.booleanValue();\n+  186:         }\n+  187:         return false;\n+  188:     }\n+  189:     /**\n+  190:      * @since Available in iOS 4.0 and later.\n+  191:      */\n+  192:     public CGImageSourceOptions setShouldCreateThumbnailFromImageIfAbsent(boolean shouldCreateThumbnailFromImageIfAbsent) {\n+  193:         set(Keys.CreateThumbnailFromImageIfAbsent(), CFBoolean.valueOf(shouldCreateThumbnailFromImageIfAbsent));\n+  194:         return this;\n+  195:     }\n+  196:     /**\n+  197:      * @since Available in iOS 4.0 and later.\n+  198:      */\n+  199:     public long getThumbnailMaxPixelSize() {\n+  200:         if (has(Keys.ThumbnailMaxPixelSize())) {\n+  201:             CFNumber val = get(Keys.ThumbnailMaxPixelSize(), CFNumber.class);\n+  202:             return val.longValue();\n+  203:         }\n+  204:         return 0;\n+  205:     }\n+  206:     /**\n+  207:      * @since Available in iOS 4.0 and later.\n+  208:      */\n+  209:     public CGImageSourceOptions setThumbnailMaxPixelSize(long thumbnailMaxPixelSize) {\n+  210:         set(Keys.ThumbnailMaxPixelSize(), CFNumber.valueOf(thumbnailMaxPixelSize));\n+  211:         return this;\n+  212:     }\n+  213:     /**\n+  214:      * @since Available in iOS 4.0 and later.\n+  215:      */\n+  216:     public boolean shouldCreateThumbnailWithTransform() {\n+  217:         if (has(Keys.CreateThumbnailWithTransform())) {\n+  218:             CFBoolean val = get(Keys.CreateThumbnailWithTransform(), CFBoolean.class);\n+  219:             return val.booleanValue();\n+  220:         }\n+  221:         return false;\n+  222:     }\n   223:     /**\n   224:      * @since Available in iOS 4.0 and later.\n   225:      */\n-  226:     @GlobalValue(symbol=\"kCGImageSourceShouldCache\", optional=true)\n-  227:     protected static native CFString ShouldCacheKey();\n-  228:     /**\n-  229:      * @since Available in iOS 7.0 and later.\n+  226:     public CGImageSourceOptions setShouldCreateThumbnailWithTransform(boolean shouldCreateThumbnailWithTransform) {\n+  227:         set(Keys.CreateThumbnailWithTransform(), CFBoolean.valueOf(shouldCreateThumbnailWithTransform));\n+  228:         return this;\n+  229:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static void testGetGeocodeFromUrl() {\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n    }\npublic static void testCanHandle() {\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n\n        assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n        assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n    }\n SourceCodeAfterRefactoring:\npublic static void testGetGeocodeFromUrl() {\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        final IConnector wmConnector = getWaymarkingConnector();\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n        assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n    }\nprivate static IConnector getWaymarkingConnector() {\n        final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n        assertThat(wmConnector).isNotNull();\n        return wmConnector;\n    }\npublic static void testCanHandle() {\n        final IConnector wmConnector = getWaymarkingConnector();\n\n        assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n        assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n    }\n DiffSourceCode:\n-    8:     public static void testGetGeocodeFromUrl() {\n-    9:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n-   10:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n-   11: \n-   12:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n-   13:         assertThat(wmConnector).isNotNull();\n-   14: \n-   15:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n-   16:         assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n-   17: \n-   18:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n-   19:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n-   20:     }\n+    8: public class WaymarkingConnectorTest extends TestCase {\n+    9: \n+   10:     private static IConnector getWaymarkingConnector() {\n+   11:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n+   12:         assertThat(wmConnector).isNotNull();\n+   13:         return wmConnector;\n+   14:     }\n+   15: \n+   16:     public static void testGetGeocodeFromUrl() {\n+   17:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n+   18:         assertThat(ConnectorFactory.getGeocodeFromURL(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n+   19: \n+   20:         final IConnector wmConnector = getWaymarkingConnector();\n    21: \n-   22:     public static void testCanHandle() {\n-   23:         final IConnector wmConnector = ConnectorFactory.getConnector(\"WM1234\");\n-   24:         assertThat(wmConnector).isNotNull();\n-   25: \n-   26:         assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n-   27:         assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n-   28:     }\n-   29: }\n+   22:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/WM1234\")).isEqualTo(\"WM1234\");\n+   23:         assertThat(wmConnector.getGeocodeFromUrl(\"http://www.waymarking.com/waymarks/WMNCDT_American_Legion_Flagpole_1983_University_of_Oregon\")).isEqualTo(\"WMNCDT\");\n+   24: \n+   25:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/GC12ABC\")).isNull();\n+   26:         assertThat(wmConnector.getGeocodeFromUrl(\"http://coord.info/TB1234\")).isNull();\n+   27:     }\n+   28: \n+   29:     public static void testCanHandle() {\n+   30:         final IConnector wmConnector = getWaymarkingConnector();\n+   31: \n+   32:         assertThat(wmConnector.canHandle(\"WM1234\")).isTrue();\n+   33:         assertThat(wmConnector.canHandle(\"GC1234\")).isFalse();\n+   34:     }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/VoltDB/voltdb.git",
        "branch": "master",
        "commitId": "deb8e5ca64fcf633edbd89523af472da813b6772",
        "sourceCodeBeforeRefactoring": "private static void fillTable(Client client, String tbl) throws Exception {\n        Random r = new Random(777);\n        for (int i = 0; i < 1000; ++i) {\n\n            double d;\n            do {\n                d = r.nextGaussian() * 1000;\n            } while (d > Long.MAX_VALUE || d <= Long.MIN_VALUE);\n\n            long val = (long) d;\n            client.callProcedure(tbl + \".Insert\", i, val);\n        }\n    }",
        "refactoredCode": "### Original Code:\n```java\nprivate static void fillTable(Client client, String tbl) throws Exception {\n        Random r = new Random(777);\n        for (int i = 0; i < 1000; ++i) {\n\n            double d;\n            do {\n                d = r.nextGaussian() * 1000;\n            } while (d > Long.MAX_VALUE || d <= Long.MIN_VALUE);\n\n            long val = (long) d;\n            client.callProcedure(tbl + \".Insert\", i, val);\n        }\n    }\n```\n\n### Refactored Code:\n```java\nprivate static void fillTable(Client client, String tbl) throws Exception {\n    Random r = new Random(777);\n    for (int i = 0; i < 1000; ++i) {\n        long val = generateValidRandomValue(r);\n        client.callProcedure(tbl + \".Insert\", i, val);\n    }\n}\n\nprivate static long generateValidRandomValue(Random r) {\n    double d;\n    do {\n        d = r.nextGaussian() * 1000;\n    } while (d > Long.MAX_VALUE || d <= Long.MIN_VALUE);\n    return (long) d;\n}\n```\n\n### Explanation of Refactoring:\n1. **Identified Responsibilities**: The original method `fillTable` had two main responsibilities: generating a valid random value and calling a procedure on the client. The random value generation logic was extracted into a new method called `generateValidRandomValue`.\n\n2. **Method Extraction**: The new method `generateValidRandomValue` encapsulates the logic for generating a valid random value, making the code cleaner and more modular.\n\n3. **Meaningful Naming**: The extracted method has a name that clearly describes its functionality, which improves code readability.\n\n4. **Functionality Unchanged**: The refactored code maintains the original functionality of filling the table with valid random values while improving the structure and readability of the code.",
        "sourceCodeAfterRefactoring": "private static void fillTable(Client client, String tbl) throws Exception {\n        Random r = new Random(777);\n\n        // Insert 1000 rows of data, and 84 (every 13th row) of nulls.\n        for (int i = 0; i < 1084; ++i) {\n\n            // Every 13th row, insert null values, just to make sure\n            // it doesn't mess with the algorithm.\n            if (i % 13 == 0) {\n                client.callProcedure(tbl + \".Insert\", i,\n                        null, null, null, null, null, null, null);\n            }\n            else {\n                // Use a a Gaussian distribution (bell curve), to exercise the hyperloglog hash.\n                final long baseTs = 1437589323966000L; // July 22, 2015 or so\n                client.callProcedure(tbl + \".Insert\",\n                        i,    // primary key\n                        getNormalValue(r, 1000, Long.MIN_VALUE, Long.MAX_VALUE),\n                        getNormalValue(r, 1000, Integer.MIN_VALUE, Integer.MAX_VALUE),\n                        getNormalValue(r, 1000, Short.MIN_VALUE, Short.MAX_VALUE),\n                        getNormalValue(r, 100, Byte.MIN_VALUE, Byte.MAX_VALUE),\n                        r.nextGaussian(), // float\n                        getNormalDecimalValue(r, 1000000000), // decimal\n                        new TimestampType(baseTs + getNormalValue(r, 10000, Short.MIN_VALUE, Short.MAX_VALUE)));\n            }\n        }\n    }\nprivate static long getNormalValue(Random r, double magnitude, long min, long max) {\n        double d;\n        do {\n            d = r.nextGaussian() * magnitude;\n        } while (d > max || d <= min);\n\n        return (long) d;\n    }",
        "diffSourceCode": "-   38:     private static void fillTable(Client client, String tbl) throws Exception {\n-   39:         Random r = new Random(777);\n-   40:         for (int i = 0; i < 1000; ++i) {\n-   41: \n-   42:             double d;\n-   43:             do {\n-   44:                 d = r.nextGaussian() * 1000;\n-   45:             } while (d > Long.MAX_VALUE || d <= Long.MIN_VALUE);\n-   46: \n-   47:             long val = (long) d;\n-   48:             client.callProcedure(tbl + \".Insert\", i, val);\n-   49:         }\n-   50:     }\n-   52:     public void testSimple() throws Exception\n-   53:     {\n-   54:         Client client = getClient();\n-   55: \n-   56:         VoltTable vt = client.callProcedure(\"@AdHoc\", \"select approx_count_distinct(bi) from r;\")\n-   57:                 .getResults()[0];\n-   58:         assertTrue(vt.advanceRow());\n-   59:         assertEquals(0.0, vt.getDouble(0));\n-   70:         // 867 is the exact count, and 820.529 is our estimate.\n-   71:         // That's about 5% error.  Not too bad for 1000 rows?\n-   72:         // Percent error will go down as the actual number of unique values\n-   73:         // goes up (e.g., should only be 2% for 1 billion unique values).\n-   74:         assertFalse(vt.advanceRow());\n-   75:     }\n-   76: \n-   77:     public void testDistributed() throws Exception {\n-   78:         Client client = getClient();\n-   79: \n-   80:         VoltTable vt = client.callProcedure(\"@Explain\", \"select approx_count_distinct(bi) from p;\")\n-   81:                 .getResults()[0];\n-   82: \n-   83:         vt = client.callProcedure(\"@AdHoc\", \"select approx_count_distinct(bi) from p;\")\n-   84:                 .getResults()[0];\n-   85:         assertTrue(vt.advanceRow());\n-   86:         assertEquals(0.0, vt.getDouble(0));\n-   87:         assertFalse(vt.advanceRow());\n-   88: \n-   89:         fillTable(client, \"p\");\n-   90: \n-   91:         vt = client.callProcedure(\"@AdHoc\",\n-   92:                 \"select approx_count_distinct(bi) from p;\")\n-   93:                 .getResults()[0];\n-   94:         assertTrue(vt.advanceRow());\n-   95:         assertEquals(820.529, vt.getDouble(0), 0.01);\n-   96:         assertFalse(vt.advanceRow());\n+   38:     private static final double ALLOWED_PERCENT_ERROR = 1.5;\n+   39: \n+   40:     private static final String COLUMN_NAMES[] = {\n+   41:             \"bi\",\n+   42:             \"ii\",\n+   43:             \"si\",\n+   44:             \"ti\",\n+   45:             \"ff\",\n+   46:             \"dd\",\n+   47:             \"ts\"\n+   48:     };\n+   49: \n+   50:     private static final String TABLE_NAMES[] = {\"r\", \"p\"};\n+   52:     private static long getNormalValue(Random r, double magnitude, long min, long max) {\n+   53:         double d;\n+   54:         do {\n+   55:             d = r.nextGaussian() * magnitude;\n+   56:         } while (d > max || d <= min);\n+   57: \n+   58:         return (long) d;\n+   59:     }\n+   70:     private static void fillTable(Client client, String tbl) throws Exception {\n+   71:         Random r = new Random(777);\n+   72: \n+   73:         // Insert 1000 rows of data, and 84 (every 13th row) of nulls.\n+   74:         for (int i = 0; i < 1084; ++i) {\n+   75: \n+   76:             // Every 13th row, insert null values, just to make sure\n+   77:             // it doesn't mess with the algorithm.\n+   78:             if (i % 13 == 0) {\n+   79:                 client.callProcedure(tbl + \".Insert\", i,\n+   80:                         null, null, null, null, null, null, null);\n+   81:             }\n+   82:             else {\n+   83:                 // Use a a Gaussian distribution (bell curve), to exercise the hyperloglog hash.\n+   84:                 final long baseTs = 1437589323966000L; // July 22, 2015 or so\n+   85:                 client.callProcedure(tbl + \".Insert\",\n+   86:                         i,    // primary key\n+   87:                         getNormalValue(r, 1000, Long.MIN_VALUE, Long.MAX_VALUE),\n+   88:                         getNormalValue(r, 1000, Integer.MIN_VALUE, Integer.MAX_VALUE),\n+   89:                         getNormalValue(r, 1000, Short.MIN_VALUE, Short.MAX_VALUE),\n+   90:                         getNormalValue(r, 100, Byte.MIN_VALUE, Byte.MAX_VALUE),\n+   91:                         r.nextGaussian(), // float\n+   92:                         getNormalDecimalValue(r, 1000000000), // decimal\n+   93:                         new TimestampType(baseTs + getNormalValue(r, 10000, Short.MIN_VALUE, Short.MAX_VALUE)));\n+   94:             }\n+   95:         }\n+   96:     }\n",
        "uniqueId": "deb8e5ca64fcf633edbd89523af472da813b6772_38_50_52_59_70_96",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     *\n     * @throws IllegalArgumentException if {@code names.length != values.length}.\n     */\n    public Insert values(String[] names, Object[] values) {\n        if (names.length != values.length)\n            throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.length, values.length));\n        this.names.addAll(Arrays.asList(names));\n        this.values.addAll(Arrays.asList(values));\n\n        for (int i = 0; i < names.length; i++) {\n            checkForBindMarkers(values[i]);\n            maybeAddRoutingKey(names[i], values[i]);\n        }\n        return this;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     * @throws IllegalArgumentException if {@code names.length != values.length}.\n     */\n    public Insert values(String[] names, Object[] values) {\n        return values(Arrays.asList(names), Arrays.asList(values));\n    }\n/**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     * @throws IllegalArgumentException if {@code names.size() != values.size()}.\n     */\n    public Insert values(List<String> names, List<Object> values) {\n        if (names.size() != values.size())\n            throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.size(), values.size()));\n        this.names.addAll(names);\n        this.values.addAll(values);\n        for (int i = 0; i < names.size(); i++) {\n            checkForBindMarkers(values.get(i));\n            maybeAddRoutingKey(names.get(i), values.get(i));\n        }\n        return this;\n    }\n DiffSourceCode:\n-   86: \n-   87:     /**\n-   88:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n-   89:      *\n-   90:      * @param names a list of column names to insert/update.\n-   91:      * @param values a list of values to insert/update. The {@code i}th\n-   92:      * value in {@code values} will be inserted for the {@code i}th column\n-   93:      * in {@code names}.\n-   94:      * @return this INSERT statement.\n-   95:      *\n-   96:      * @throws IllegalArgumentException if {@code names.length != values.length}.\n-   97:      */\n-   98:     public Insert values(String[] names, Object[] values) {\n-   99:         if (names.length != values.length)\n-  100:             throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.length, values.length));\n-  101:         this.names.addAll(Arrays.asList(names));\n-  102:         this.values.addAll(Arrays.asList(values));\n-  103: \n-  104:         for (int i = 0; i < names.length; i++) {\n-  105:             checkForBindMarkers(values[i]);\n-  106:             maybeAddRoutingKey(names[i], values[i]);\n-  107:         }\n-  108:         return this;\n-  109:     }\n-  110: \n-  111:     /**\n-  112:      * Adds a new options for this INSERT statement.\n-  113:      *\n-  114:      * @param using the option to add.\n-  115:      * @return the options of this INSERT statement.\n-  116:      */\n-  117:     public Options using(Using using) {\n-  118:         return usings.and(using);\n-  119:     }\n-  120: \n+   86:     /**\n+   87:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n+   88:      *\n+   89:      * @param names a list of column names to insert/update.\n+   90:      * @param values a list of values to insert/update. The {@code i}th\n+   91:      * value in {@code values} will be inserted for the {@code i}th column\n+   92:      * in {@code names}.\n+   93:      * @return this INSERT statement.\n+   94:      * @throws IllegalArgumentException if {@code names.length != values.length}.\n+   95:      */\n+   96:     public Insert values(String[] names, Object[] values) {\n+   97:         return values(Arrays.asList(names), Arrays.asList(values));\n+   98:     }\n+   99: \n+  100:     /**\n+  101:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n+  102:      *\n+  103:      * @param names a list of column names to insert/update.\n+  104:      * @param values a list of values to insert/update. The {@code i}th\n+  105:      * value in {@code values} will be inserted for the {@code i}th column\n+  106:      * in {@code names}.\n+  107:      * @return this INSERT statement.\n+  108:      * @throws IllegalArgumentException if {@code names.size() != values.size()}.\n+  109:      */\n+  110:     public Insert values(List<String> names, List<Object> values) {\n+  111:         if (names.size() != values.size())\n+  112:             throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.size(), values.size()));\n+  113:         this.names.addAll(names);\n+  114:         this.values.addAll(values);\n+  115:         for (int i = 0; i < names.size(); i++) {\n+  116:             checkForBindMarkers(values.get(i));\n+  117:             maybeAddRoutingKey(names.get(i), values.get(i));\n+  118:         }\n+  119:         return this;\n+  120:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n    if (virtualFile != null) {\n      PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n      if (file != null) {\n        int targetOffset = target.getOffset();\n        for (int i = 0; i < 2; i++) {\n          Class<? extends PsiElement> clazz = DartComponentName.class;\n          if (i == 1) {\n            clazz = DartReferenceExpression.class;\n          }\n          PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n          if (elementAt != null) {\n            return elementAt;\n          }\n        }\n      }\n    }\n    return null;\n  }\n SourceCodeAfterRefactoring:\n@Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    PsiFile file = findPsiFile(project, targetPath);\n    if (file != null) {\n      int targetOffset = target.getOffset();\n      for (int i = 0; i < 2; i++) {\n        Class<? extends PsiElement> clazz = DartComponentName.class;\n        if (i == 1) {\n          clazz = DartReferenceExpression.class;\n        }\n        PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n        if (elementAt != null) {\n          return elementAt;\n        }\n      }\n    }\n    return null;\n  }\n@Nullable\n  public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n    if (virtualFile != null) {\n      return PsiManager.getInstance(project).findFile(virtualFile);\n    }\n    return null;\n  }\n DiffSourceCode:\n   135:   @Nullable\n   136:   private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n   137:     String targetPath = target.getFile();\n-  138:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n-  139:     if (virtualFile != null) {\n-  140:       PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n-  141:       if (file != null) {\n-  142:         int targetOffset = target.getOffset();\n-  143:         for (int i = 0; i < 2; i++) {\n-  144:           Class<? extends PsiElement> clazz = DartComponentName.class;\n-  145:           if (i == 1) {\n-  146:             clazz = DartReferenceExpression.class;\n-  147:           }\n-  148:           PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n-  149:           if (elementAt != null) {\n-  150:             return elementAt;\n-  151:           }\n-  152:         }\n-  153:       }\n-  154:     }\n-  155:     return null;\n-  156:   }\n-  157: \n-  158:   @NotNull\n-  159:   private static List<PsiElement> toResult(@Nullable PsiElement element) {\n-  160:     if (element == null) {\n-  161:       return Collections.emptyList();\n-  162:     }\n+  138:     PsiFile file = findPsiFile(project, targetPath);\n+  139:     if (file != null) {\n+  140:       int targetOffset = target.getOffset();\n+  141:       for (int i = 0; i < 2; i++) {\n+  142:         Class<? extends PsiElement> clazz = DartComponentName.class;\n+  143:         if (i == 1) {\n+  144:           clazz = DartReferenceExpression.class;\n+  145:         }\n+  146:         PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n+  147:         if (elementAt != null) {\n+  148:           return elementAt;\n+  149:         }\n+  150:       }\n+  151:     }\n+  152:     return null;\n+  153:   }\n+  154: \n+  155:   @Nullable\n+  156:   public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n+  157:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n+  158:     if (virtualFile != null) {\n+  159:       return PsiManager.getInstance(project).findFile(virtualFile);\n+  160:     }\n+  161:     return null;\n+  162:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static void main(String[] args) {\n        System.out.println(\"Generating random array.\");\n        Random random = new Random();\n        unsorted = new Integer[SIZE];\n        int i = 0;\n        while (i < unsorted.length) {\n            int j = random.nextInt(unsorted.length * 10);\n            unsorted[i++] = j;\n        }\n        System.out.println(\"Generated random array.\");\n\n        System.out.println(\"Generating sorted array.\");\n        sorted = new Integer[SIZE];\n        for (i = 0; i < sorted.length; i++) {\n            sorted[i] = i;\n        }\n        System.out.println(\"Generated sorted array.\");\n\n        System.out.println(\"Generating reverse sorted array.\");\n        reverse = new Integer[SIZE];\n        for (i = (reverse.length - 1); i >= 0; i--) {\n            reverse[i] = (SIZE - 1) - i;\n        }\n        System.out.println(\"Generated reverse sorted array.\");\n        System.out.println();\n        System.out.flush();\n\n        System.out.println(\"Starting sorts...\");\n        System.out.println();\n        System.out.flush();\n        if (showInsertion) {\n            // Insertion sort\n            long bInsertion = System.nanoTime();\n            Integer[] result = InsertionSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            long aInsertion = System.nanoTime();\n            double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Random: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            bInsertion = System.nanoTime();\n            result = InsertionSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            aInsertion = System.nanoTime();\n            diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            bInsertion = System.nanoTime();\n            result = InsertionSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            aInsertion = System.nanoTime();\n            diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showBubble) {\n            // Bubble sort\n            long bBubble = System.nanoTime();\n            Integer[] result = BubbleSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            long aBubble = System.nanoTime();\n            double diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Random: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            bBubble = System.nanoTime();\n            result = BubbleSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            aBubble = System.nanoTime();\n            diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            bBubble = System.nanoTime();\n            result = BubbleSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            aBubble = System.nanoTime();\n            diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showShell) {\n            int[] shells = new int[] { 10, 5, 3, 1 };\n            // Shell's sort\n            long bShell = System.nanoTime();\n            Integer[] result = ShellSort.sort(shells, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            long aShell = System.nanoTime();\n            double diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Random: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            bShell = System.nanoTime();\n            result = ShellSort.sort(shells, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            aShell = System.nanoTime();\n            diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            bShell = System.nanoTime();\n            result = ShellSort.sort(shells, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            aShell = System.nanoTime();\n            diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showMergeNotInPlace) {\n            // Merge sort\n            long bMerge = System.nanoTime();\n            Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            long aMerge = System.nanoTime();\n            double diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showMergeInPlace) {\n            // Merge sort\n            long bMerge = System.nanoTime();\n            Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            long aMerge = System.nanoTime();\n            double diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showQuick) {\n            // Quicksort\n            long bQuick = System.nanoTime();\n            Integer[] result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            long aQuick = System.nanoTime();\n            double diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showHeap) {\n            // Heapsort\n            long bHeap = System.nanoTime();\n            Integer[] result = HeapSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            long aHeap = System.nanoTime();\n            double diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Random: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            bHeap = System.nanoTime();\n            result = HeapSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            aHeap = System.nanoTime();\n            diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            bHeap = System.nanoTime();\n            result = HeapSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            aHeap = System.nanoTime();\n            diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showCounting) {\n            // Counting sort\n            long bCounting = System.nanoTime();\n            Integer[] result = CountingSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            long aCounting = System.nanoTime();\n            double diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Random: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            bCounting = System.nanoTime();\n            result = CountingSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            aCounting = System.nanoTime();\n            diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            bCounting = System.nanoTime();\n            result = CountingSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            aCounting = System.nanoTime();\n            diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showRadix) {\n            // Radix sort\n            long bRadix = System.nanoTime();\n            Integer[] result = RadixSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            long aRadix = System.nanoTime();\n            double diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Random: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = RadixSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = RadixSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showAmericanFlag) {\n            // American Flag sort\n            long bRadix = System.nanoTime();\n            Integer[] result = AmericanFlagSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            long aRadix = System.nanoTime();\n            double diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Random: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = AmericanFlagSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = AmericanFlagSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showComparison)\n            showComparison();\n    }\n SourceCodeAfterRefactoring:\npublic static void main(String[] args) {\n        System.out.println(\"Generating random array.\");\n        Random random = new Random();\n        unsorted = new Integer[SIZE];\n        int i = 0;\n        while (i < unsorted.length) {\n            int j = random.nextInt(unsorted.length * 10);\n            unsorted[i++] = j;\n        }\n        System.out.println(\"Generated random array.\");\n\n        System.out.println(\"Generating sorted array.\");\n        sorted = new Integer[SIZE];\n        for (i = 0; i < sorted.length; i++) {\n            sorted[i] = i;\n        }\n        System.out.println(\"Generated sorted array.\");\n\n        System.out.println(\"Generating reverse sorted array.\");\n        reverse = new Integer[SIZE];\n        for (i = (reverse.length - 1); i >= 0; i--) {\n            reverse[i] = (SIZE - 1) - i;\n        }\n        System.out.println(\"Generated reverse sorted array.\");\n        System.out.println();\n        System.out.flush();\n\n        System.out.println(\"Starting sorts...\");\n        System.out.println();\n        System.out.flush();\n\n        insertionResults = new double[1 * 3];\n        insertionCount = runTest(new Insertion(), unsorted, sorted, insertionResults, insertionCount);\n        showComparison();\n\n        bubbleResults = new double[1 * 3];\n        bubbleCount = runTest(new Bubble(), unsorted, sorted, bubbleResults, bubbleCount);\n        showComparison();\n\n        shellResults = new double[1 * 3];\n        shellCount = runTest(new Shell(), unsorted, sorted, shellResults, shellCount);\n        showComparison();\n\n        mergeResults = new double[2 * 3];\n        mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);\n        mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);\n        showComparison();\n\n        quickResults = new double[3 * 3];\n        quickCount = runTest(new QuickFirst(), unsorted, sorted, quickResults, quickCount);\n        quickCount = runTest(new QuickMiddle(), unsorted, sorted, quickResults, quickCount);\n        quickCount = runTest(new QuickRandom(), unsorted, sorted, quickResults, quickCount);\n        showComparison();\n\n        heapResults = new double[1 * 3];\n        heapCount = runTest(new Heap(), unsorted, sorted, heapResults, heapCount);\n        showComparison();\n\n        countingResults = new double[1 * 3];\n        countingCount = runTest(new Counting(), unsorted, sorted, countingResults, countingCount);\n        showComparison();\n\n        radixResults = new double[1 * 3];\n        radixCount = runTest(new Radix(), unsorted, sorted, radixResults, radixCount);\n        showComparison();\n\n        americanFlagResults = new double[1 * 3];\n        americanFlagCount = runTest(new AmericanFlag(), unsorted, sorted, americanFlagResults, americanFlagCount);\n        showComparison();\n    }\nprivate static final int runTest(Testable testable, Integer[] unsorted, Integer[] sorted, double[] results, int count) {\n        long bInsertion = System.nanoTime();\n        Integer[] result = testable.sort(unsorted.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\" failed.\");\n        long aInsertion = System.nanoTime();\n        double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Random: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(unsorted, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        bInsertion = System.nanoTime();\n        result = InsertionSort.sort(sorted.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\" failed.\");\n        aInsertion = System.nanoTime();\n        diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(sorted, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        bInsertion = System.nanoTime();\n        result = InsertionSort.sort(reverse.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\"InsertionSort.\");\n        aInsertion = System.nanoTime();\n        diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Reverse sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(reverse, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        System.out.println();\n        System.out.flush();\n\n        return count;\n    }\n DiffSourceCode:\n-   48:     private static final boolean showInsertion = true;\n-   49:     private static final boolean showBubble = true;\n-   50:     private static final boolean showShell = true;\n-   51:     private static final boolean showMergeInPlace = true;\n-   52:     private static final boolean showMergeNotInPlace = true;\n-   53:     private static final boolean showQuick = true;\n-   54:     private static final boolean showHeap = true;\n-   55:     private static final boolean showCounting = true;\n-   56:     private static final boolean showRadix = true;\n-   57:     private static final boolean showAmericanFlag = true;\n+   48:     public static void main(String[] args) {\n+   49:         System.out.println(\"Generating random array.\");\n+   50:         Random random = new Random();\n+   51:         unsorted = new Integer[SIZE];\n+   52:         int i = 0;\n+   53:         while (i < unsorted.length) {\n+   54:             int j = random.nextInt(unsorted.length * 10);\n+   55:             unsorted[i++] = j;\n+   56:         }\n+   57:         System.out.println(\"Generated random array.\");\n    58: \n-   59:     private static Integer[] unsorted = null;\n-   60:     private static Integer[] sorted = null;\n-   61:     private static Integer[] reverse = null;\n-   62: \n-   63:     public static void main(String[] args) {\n-   64:         System.out.println(\"Generating random array.\");\n-   65:         Random random = new Random();\n-   66:         unsorted = new Integer[SIZE];\n-   67:         int i = 0;\n-   68:         while (i < unsorted.length) {\n-   69:             int j = random.nextInt(unsorted.length * 10);\n-   70:             unsorted[i++] = j;\n-   71:         }\n-   72:         System.out.println(\"Generated random array.\");\n-   73: \n-   74:         System.out.println(\"Generating sorted array.\");\n-   75:         sorted = new Integer[SIZE];\n-   76:         for (i = 0; i < sorted.length; i++) {\n-   77:             sorted[i] = i;\n-   78:         }\n-   79:         System.out.println(\"Generated sorted array.\");\n-   80: \n-   81:         System.out.println(\"Generating reverse sorted array.\");\n-   82:         reverse = new Integer[SIZE];\n-   83:         for (i = (reverse.length - 1); i >= 0; i--) {\n-   84:             reverse[i] = (SIZE - 1) - i;\n-   85:         }\n-   86:         System.out.println(\"Generated reverse sorted array.\");\n-   87:         System.out.println();\n-   88:         System.out.flush();\n-   89: \n-   90:         System.out.println(\"Starting sorts...\");\n-   91:         System.out.println();\n-   92:         System.out.flush();\n-   93:         if (showInsertion) {\n-   94:             // Insertion sort\n-   95:             long bInsertion = System.nanoTime();\n-   96:             Integer[] result = InsertionSort.sort(unsorted.clone());\n-   97:             if (checkResults && !check(result))\n-   98:                 System.err.println(\"InsertionSort failed.\");\n-   99:             long aInsertion = System.nanoTime();\n-  100:             double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  101:             System.out.println(\"Random: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  102:             if (showResult)\n-  103:                 showResult(unsorted, result);\n-  104:             if (showComparison)\n-  105:                 insertionResults[insertionCount++] = diff;\n-  106:             putOutTheGarbage();\n-  107: \n-  108:             bInsertion = System.nanoTime();\n-  109:             result = InsertionSort.sort(sorted.clone());\n-  110:             if (checkResults && !check(result))\n-  111:                 System.err.println(\"InsertionSort failed.\");\n-  112:             aInsertion = System.nanoTime();\n-  113:             diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  114:             System.out.println(\"Sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  115:             if (showResult)\n-  116:                 showResult(sorted, result);\n-  117:             if (showComparison)\n-  118:                 insertionResults[insertionCount++] = diff;\n-  119:             putOutTheGarbage();\n-  120: \n-  121:             bInsertion = System.nanoTime();\n-  122:             result = InsertionSort.sort(reverse.clone());\n-  123:             if (checkResults && !check(result))\n-  124:                 System.err.println(\"InsertionSort failed.\");\n-  125:             aInsertion = System.nanoTime();\n-  126:             diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  127:             System.out.println(\"Reverse sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  128:             if (showResult)\n-  129:                 showResult(reverse, result);\n-  130:             if (showComparison)\n-  131:                 insertionResults[insertionCount++] = diff;\n-  132:             putOutTheGarbage();\n-  133: \n-  134:             System.out.println();\n-  135:             System.out.flush();\n-  136:         }\n-  137: \n-  138:         if (showBubble) {\n-  139:             // Bubble sort\n-  140:             long bBubble = System.nanoTime();\n-  141:             Integer[] result = BubbleSort.sort(unsorted.clone());\n-  142:             if (checkResults && !check(result))\n-  143:                 System.err.println(\"BubbleSort failed.\");\n-  144:             long aBubble = System.nanoTime();\n-  145:             double diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  146:             System.out.println(\"Random: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  147:             if (showResult)\n-  148:                 showResult(unsorted, result);\n-  149:             if (showComparison)\n-  150:                 bubbleResults[bubbleCount++] = diff;\n-  151:             putOutTheGarbage();\n-  152: \n-  153:             bBubble = System.nanoTime();\n-  154:             result = BubbleSort.sort(sorted.clone());\n-  155:             if (checkResults && !check(result))\n-  156:                 System.err.println(\"BubbleSort failed.\");\n-  157:             aBubble = System.nanoTime();\n-  158:             diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  159:             System.out.println(\"Sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  160:             if (showResult)\n-  161:                 showResult(sorted, result);\n-  162:             if (showComparison)\n-  163:                 bubbleResults[bubbleCount++] = diff;\n-  164:             putOutTheGarbage();\n-  165: \n-  166:             bBubble = System.nanoTime();\n-  167:             result = BubbleSort.sort(reverse.clone());\n-  168:             if (checkResults && !check(result))\n-  169:                 System.err.println(\"BubbleSort failed.\");\n-  170:             aBubble = System.nanoTime();\n-  171:             diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  172:             System.out.println(\"Reverse sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  173:             if (showResult)\n-  174:                 showResult(reverse, result);\n-  175:             if (showComparison)\n-  176:                 bubbleResults[bubbleCount++] = diff;\n-  177:             putOutTheGarbage();\n-  178: \n-  179:             System.out.println();\n-  180:             System.out.flush();\n-  181:         }\n+   59:         System.out.println(\"Generating sorted array.\");\n+   60:         sorted = new Integer[SIZE];\n+   61:         for (i = 0; i < sorted.length; i++) {\n+   62:             sorted[i] = i;\n+   63:         }\n+   64:         System.out.println(\"Generated sorted array.\");\n+   65: \n+   66:         System.out.println(\"Generating reverse sorted array.\");\n+   67:         reverse = new Integer[SIZE];\n+   68:         for (i = (reverse.length - 1); i >= 0; i--) {\n+   69:             reverse[i] = (SIZE - 1) - i;\n+   70:         }\n+   71:         System.out.println(\"Generated reverse sorted array.\");\n+   72:         System.out.println();\n+   73:         System.out.flush();\n+   74: \n+   75:         System.out.println(\"Starting sorts...\");\n+   76:         System.out.println();\n+   77:         System.out.flush();\n+   78: \n+   79:         insertionResults = new double[1 * 3];\n+   80:         insertionCount = runTest(new Insertion(), unsorted, sorted, insertionResults, insertionCount);\n+   81:         showComparison();\n+   82: \n+   83:         bubbleResults = new double[1 * 3];\n+   84:         bubbleCount = runTest(new Bubble(), unsorted, sorted, bubbleResults, bubbleCount);\n+   85:         showComparison();\n+   86: \n+   87:         shellResults = new double[1 * 3];\n+   88:         shellCount = runTest(new Shell(), unsorted, sorted, shellResults, shellCount);\n+   89:         showComparison();\n+   90: \n+   91:         mergeResults = new double[2 * 3];\n+   92:         mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);\n+   93:         mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);\n+   94:         showComparison();\n+   95: \n+   96:         quickResults = new double[3 * 3];\n+   97:         quickCount = runTest(new QuickFirst(), unsorted, sorted, quickResults, quickCount);\n+   98:         quickCount = runTest(new QuickMiddle(), unsorted, sorted, quickResults, quickCount);\n+   99:         quickCount = runTest(new QuickRandom(), unsorted, sorted, quickResults, quickCount);\n+  100:         showComparison();\n+  101: \n+  102:         heapResults = new double[1 * 3];\n+  103:         heapCount = runTest(new Heap(), unsorted, sorted, heapResults, heapCount);\n+  104:         showComparison();\n+  105: \n+  106:         countingResults = new double[1 * 3];\n+  107:         countingCount = runTest(new Counting(), unsorted, sorted, countingResults, countingCount);\n+  108:         showComparison();\n+  109: \n+  110:         radixResults = new double[1 * 3];\n+  111:         radixCount = runTest(new Radix(), unsorted, sorted, radixResults, radixCount);\n+  112:         showComparison();\n+  113: \n+  114:         americanFlagResults = new double[1 * 3];\n+  115:         americanFlagCount = runTest(new AmericanFlag(), unsorted, sorted, americanFlagResults, americanFlagCount);\n+  116:         showComparison();\n+  117:     }\n+  118: \n+  119:     private static final int runTest(Testable testable, Integer[] unsorted, Integer[] sorted, double[] results, int count) {\n+  120:         long bInsertion = System.nanoTime();\n+  121:         Integer[] result = testable.sort(unsorted.clone());\n+  122:         if (checkResults && !check(result))\n+  123:             System.err.println(testable.getName()+\" failed.\");\n+  124:         long aInsertion = System.nanoTime();\n+  125:         double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  126:         System.out.println(\"Random: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  127:         if (showResult)\n+  128:             showResult(unsorted, result);\n+  129:         results[count++] = diff;\n+  130:         putOutTheGarbage();\n+  131: \n+  132:         bInsertion = System.nanoTime();\n+  133:         result = InsertionSort.sort(sorted.clone());\n+  134:         if (checkResults && !check(result))\n+  135:             System.err.println(testable.getName()+\" failed.\");\n+  136:         aInsertion = System.nanoTime();\n+  137:         diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  138:         System.out.println(\"Sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  139:         if (showResult)\n+  140:             showResult(sorted, result);\n+  141:         results[count++] = diff;\n+  142:         putOutTheGarbage();\n+  143: \n+  144:         bInsertion = System.nanoTime();\n+  145:         result = InsertionSort.sort(reverse.clone());\n+  146:         if (checkResults && !check(result))\n+  147:             System.err.println(testable.getName()+\"InsertionSort.\");\n+  148:         aInsertion = System.nanoTime();\n+  149:         diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  150:         System.out.println(\"Reverse sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  151:         if (showResult)\n+  152:             showResult(reverse, result);\n+  153:         results[count++] = diff;\n+  154:         putOutTheGarbage();\n+  155: \n+  156:         System.out.println();\n+  157:         System.out.flush();\n+  158: \n+  159:         return count;\n+  160:     }\n+  161: \n+  162:     public static abstract class Testable {\n+  163:         String input = null;\n+  164:         public String getInput() {\n+  165:             return input;\n+  166:         }\n+  167:         public abstract String getName();\n+  168:         public abstract Integer[] sort(Integer[] input);\n+  169:     }\n+  170: \n+  171:     private static class AmericanFlag extends Testable {\n+  172:         @Override\n+  173:         public String getName() {\n+  174:             return \"AmericanFlag sort\";\n+  175:         }\n+  176: \n+  177:         @Override\n+  178:         public Integer[] sort(Integer[] input) {\n+  179:             return AmericanFlagSort.sort(input);\n+  180:         }\n+  181:     }\n   182: \n-  183:         if (showShell) {\n-  184:             int[] shells = new int[] { 10, 5, 3, 1 };\n-  185:             // Shell's sort\n-  186:             long bShell = System.nanoTime();\n-  187:             Integer[] result = ShellSort.sort(shells, unsorted.clone());\n-  188:             if (checkResults && !check(result))\n-  189:                 System.err.println(\"ShellSort failed.\");\n-  190:             long aShell = System.nanoTime();\n-  191:             double diff = (aShell - bShell) / 1000000d / 1000d;\n-  192:             System.out.println(\"Random: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  193:             if (showResult)\n-  194:                 showResult(unsorted, result);\n-  195:             if (showComparison)\n-  196:                 shellResults[shellCount++] = diff;\n-  197:             putOutTheGarbage();\n-  198: \n-  199:             bShell = System.nanoTime();\n-  200:             result = ShellSort.sort(shells, sorted.clone());\n-  201:             if (checkResults && !check(result))\n-  202:                 System.err.println(\"ShellSort failed.\");\n-  203:             aShell = System.nanoTime();\n-  204:             diff = (aShell - bShell) / 1000000d / 1000d;\n-  205:             System.out.println(\"Sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  206:             if (showResult)\n-  207:                 showResult(sorted, result);\n-  208:             if (showComparison)\n-  209:                 shellResults[shellCount++] = diff;\n-  210:             putOutTheGarbage();\n-  211: \n-  212:             bShell = System.nanoTime();\n-  213:             result = ShellSort.sort(shells, reverse.clone());\n-  214:             if (checkResults && !check(result))\n-  215:                 System.err.println(\"ShellSort failed.\");\n-  216:             aShell = System.nanoTime();\n-  217:             diff = (aShell - bShell) / 1000000d / 1000d;\n-  218:             System.out.println(\"Reverse sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  219:             if (showResult)\n-  220:                 showResult(reverse, result);\n-  221:             if (showComparison)\n-  222:                 shellResults[shellCount++] = diff;\n-  223:             putOutTheGarbage();\n+  183:     private static class Bubble extends Testable {\n+  184:         @Override\n+  185:         public String getName() {\n+  186:             return \"Bubble sort\";\n+  187:         }\n+  188: \n+  189:         @Override\n+  190:         public Integer[] sort(Integer[] input) {\n+  191:             return BubbleSort.sort(input);\n+  192:         }\n+  193:     }\n+  194: \n+  195:     private static class Counting extends Testable {\n+  196:         @Override\n+  197:         public String getName() {\n+  198:             return \"Counting sort\";\n+  199:         }\n+  200: \n+  201:         @Override\n+  202:         public Integer[] sort(Integer[] input) {\n+  203:             return CountingSort.sort(input);\n+  204:         }\n+  205:     }\n+  206: \n+  207:     private static class Heap extends Testable {\n+  208:         @Override\n+  209:         public String getName() {\n+  210:             return \"Heap sort\";\n+  211:         }\n+  212: \n+  213:         @Override\n+  214:         public Integer[] sort(Integer[] input) {\n+  215:             return HeapSort.sort(input);\n+  216:         }\n+  217:     }\n+  218: \n+  219:     private static class Insertion extends Testable {\n+  220:         @Override\n+  221:         public String getName() {\n+  222:             return \"Insertion sort\";\n+  223:         }\n   224: \n-  225:             System.out.println();\n-  226:             System.out.flush();\n-  227:         }\n-  228: \n-  229:         if (showMergeNotInPlace) {\n-  230:             // Merge sort\n-  231:             long bMerge = System.nanoTime();\n-  232:             Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, unsorted.clone());\n-  233:             if (checkResults && !check(result))\n-  234:                 System.err.println(\"MergeSort failed.\");\n-  235:             long aMerge = System.nanoTime();\n-  236:             double diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  237:             System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  238:             if (showResult)\n-  239:                 showResult(unsorted, result);\n-  240:             if (showComparison)\n-  241:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  242:             putOutTheGarbage();\n-  243: \n-  244:             bMerge = System.nanoTime();\n-  245:             result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, sorted.clone());\n-  246:             if (checkResults && !check(result))\n-  247:                 System.err.println(\"MergeSort failed.\");\n-  248:             aMerge = System.nanoTime();\n-  249:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  250:             System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  251:             if (showResult)\n-  252:                 showResult(sorted, result);\n-  253:             if (showComparison)\n-  254:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  255:             putOutTheGarbage();\n-  256: \n-  257:             bMerge = System.nanoTime();\n-  258:             result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, reverse.clone());\n-  259:             if (checkResults && !check(result))\n-  260:                 System.err.println(\"MergeSort failed.\");\n-  261:             aMerge = System.nanoTime();\n-  262:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  263:             System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  264:             if (showResult)\n-  265:                 showResult(reverse, result);\n-  266:             if (showComparison)\n-  267:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  268:             putOutTheGarbage();\n-  269: \n-  270:             System.out.println();\n-  271:             System.out.flush();\n-  272:         }\n-  273: \n-  274:         if (showMergeInPlace) {\n-  275:             // Merge sort\n-  276:             long bMerge = System.nanoTime();\n-  277:             Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, unsorted.clone());\n-  278:             if (checkResults && !check(result))\n-  279:                 System.err.println(\"MergeSort failed.\");\n-  280:             long aMerge = System.nanoTime();\n-  281:             double diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  282:             System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  283:             if (showResult)\n-  284:                 showResult(unsorted, result);\n-  285:             if (showComparison)\n-  286:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  287:             putOutTheGarbage();\n-  288: \n-  289:             bMerge = System.nanoTime();\n-  290:             result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, sorted.clone());\n-  291:             if (checkResults && !check(result))\n-  292:                 System.err.println(\"MergeSort failed.\");\n-  293:             aMerge = System.nanoTime();\n-  294:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  295:             System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  296:             if (showResult)\n-  297:                 showResult(sorted, result);\n-  298:             if (showComparison)\n-  299:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  300:             putOutTheGarbage();\n-  301: \n-  302:             bMerge = System.nanoTime();\n-  303:             result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, reverse.clone());\n-  304:             if (checkResults && !check(result))\n-  305:                 System.err.println(\"MergeSort failed.\");\n-  306:             aMerge = System.nanoTime();\n-  307:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  308:             System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  309:             if (showResult)\n-  310:                 showResult(reverse, result);\n-  311:             if (showComparison)\n-  312:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  313:             putOutTheGarbage();\n-  314: \n-  315:             System.out.println();\n-  316:             System.out.flush();\n-  317:         }\n-  318: \n-  319:         if (showQuick) {\n-  320:             // Quicksort\n-  321:             long bQuick = System.nanoTime();\n-  322:             Integer[] result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, unsorted.clone());\n-  323:             if (checkResults && !check(result))\n-  324:                 System.err.println(\"QuickSort failed.\");\n-  325:             long aQuick = System.nanoTime();\n-  326:             double diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  327:             System.out.println(\"Random: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  328:             if (showResult)\n-  329:                 showResult(unsorted, result);\n-  330:             if (showComparison)\n-  331:                 quickResults[quickCount++] = diff;\n-  332:             putOutTheGarbage();\n-  333: \n-  334:             bQuick = System.nanoTime();\n-  335:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, sorted.clone());\n-  336:             if (checkResults && !check(result))\n-  337:                 System.err.println(\"QuickSort failed.\");\n-  338:             aQuick = System.nanoTime();\n-  339:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  340:             System.out.println(\"Sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  341:             if (showResult)\n-  342:                 showResult(sorted, result);\n-  343:             if (showComparison)\n-  344:                 quickResults[quickCount++] = diff;\n-  345:             putOutTheGarbage();\n-  346: \n-  347:             bQuick = System.nanoTime();\n-  348:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, reverse.clone());\n-  349:             if (checkResults && !check(result))\n-  350:                 System.err.println(\"QuickSort failed.\");\n-  351:             aQuick = System.nanoTime();\n-  352:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  353:             System.out.println(\"Reverse sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  354:             if (showResult)\n-  355:                 showResult(reverse, result);\n-  356:             if (showComparison)\n-  357:                 quickResults[quickCount++] = diff;\n-  358:             putOutTheGarbage();\n-  359: \n-  360:             System.out.println();\n-  361:             System.out.flush();\n-  362: \n-  363:             bQuick = System.nanoTime();\n-  364:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, unsorted.clone());\n-  365:             if (checkResults && !check(result))\n-  366:                 System.err.println(\"QuickSort failed.\");\n-  367:             aQuick = System.nanoTime();\n-  368:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  369:             System.out.println(\"Random: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  370:             if (showResult)\n-  371:                 showResult(unsorted, result);\n-  372:             if (showComparison)\n-  373:                 quickResults[quickCount++] = diff;\n-  374:             putOutTheGarbage();\n-  375: \n-  376:             bQuick = System.nanoTime();\n-  377:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, sorted.clone());\n-  378:             if (checkResults && !check(result))\n-  379:                 System.err.println(\"QuickSort failed.\");\n-  380:             aQuick = System.nanoTime();\n-  381:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  382:             System.out.println(\"Sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  383:             if (showResult)\n-  384:                 showResult(sorted, result);\n-  385:             if (showComparison)\n-  386:                 quickResults[quickCount++] = diff;\n-  387:             putOutTheGarbage();\n-  388: \n-  389:             bQuick = System.nanoTime();\n-  390:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, reverse.clone());\n-  391:             if (checkResults && !check(result))\n-  392:                 System.err.println(\"QuickSort failed.\");\n-  393:             aQuick = System.nanoTime();\n-  394:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  395:             System.out.println(\"Reverse sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  396:             if (showResult)\n-  397:                 showResult(reverse, result);\n-  398:             if (showComparison)\n-  399:                 quickResults[quickCount++] = diff;\n-  400:             putOutTheGarbage();\n-  401: \n-  402:             System.out.println();\n-  403:             System.out.flush();\n-  404: \n-  405:             bQuick = System.nanoTime();\n-  406:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, unsorted.clone());\n-  407:             if (checkResults && !check(result))\n-  408:                 System.err.println(\"Random QuickSort failed.\");\n-  409:             aQuick = System.nanoTime();\n-  410:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  411:             System.out.println(\"Random: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  412:             if (showResult)\n-  413:                 showResult(unsorted, result);\n-  414:             if (showComparison)\n-  415:                 quickResults[quickCount++] = diff;\n-  416:             putOutTheGarbage();\n-  417: \n-  418:             bQuick = System.nanoTime();\n-  419:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, sorted.clone());\n-  420:             if (checkResults && !check(result))\n-  421:                 System.err.println(\"Random QuickSort failed.\");\n-  422:             aQuick = System.nanoTime();\n-  423:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  424:             System.out.println(\"Sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  425:             if (showResult)\n-  426:                 showResult(sorted, result);\n-  427:             if (showComparison)\n-  428:                 quickResults[quickCount++] = diff;\n-  429:             putOutTheGarbage();\n-  430: \n-  431:             bQuick = System.nanoTime();\n-  432:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, reverse.clone());\n-  433:             if (checkResults && !check(result))\n-  434:                 System.err.println(\"Random QuickSort failed.\");\n-  435:             aQuick = System.nanoTime();\n-  436:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  437:             System.out.println(\"Reverse sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  438:             if (showResult)\n-  439:                 showResult(reverse, result);\n-  440:             if (showComparison)\n-  441:                 quickResults[quickCount++] = diff;\n-  442:             putOutTheGarbage();\n-  443: \n-  444:             System.out.println();\n-  445:             System.out.flush();\n-  446:         }\n-  447: \n-  448:         if (showHeap) {\n-  449:             // Heapsort\n-  450:             long bHeap = System.nanoTime();\n-  451:             Integer[] result = HeapSort.sort(unsorted.clone());\n-  452:             if (checkResults && !check(result))\n-  453:                 System.err.println(\"HeapSort failed.\");\n-  454:             long aHeap = System.nanoTime();\n-  455:             double diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  456:             System.out.println(\"Random: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  457:             if (showResult)\n-  458:                 showResult(unsorted, result);\n-  459:             if (showComparison)\n-  460:                 heapResults[heapCount++] = diff;\n-  461:             putOutTheGarbage();\n-  462: \n-  463:             bHeap = System.nanoTime();\n-  464:             result = HeapSort.sort(sorted.clone());\n-  465:             if (checkResults && !check(result))\n-  466:                 System.err.println(\"HeapSort failed.\");\n-  467:             aHeap = System.nanoTime();\n-  468:             diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  469:             System.out.println(\"Sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  470:             if (showResult)\n-  471:                 showResult(sorted, result);\n-  472:             if (showComparison)\n-  473:                 heapResults[heapCount++] = diff;\n-  474:             putOutTheGarbage();\n-  475: \n-  476:             bHeap = System.nanoTime();\n-  477:             result = HeapSort.sort(reverse.clone());\n-  478:             if (checkResults && !check(result))\n-  479:                 System.err.println(\"HeapSort failed.\");\n-  480:             aHeap = System.nanoTime();\n-  481:             diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  482:             System.out.println(\"Reverse sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  483:             if (showResult)\n-  484:                 showResult(reverse, result);\n-  485:             if (showComparison)\n-  486:                 heapResults[heapCount++] = diff;\n-  487:             putOutTheGarbage();\n-  488: \n-  489:             System.out.println();\n-  490:             System.out.flush();\n-  491:         }\n-  492: \n-  493:         if (showCounting) {\n-  494:             // Counting sort\n-  495:             long bCounting = System.nanoTime();\n-  496:             Integer[] result = CountingSort.sort(unsorted.clone());\n-  497:             if (checkResults && !check(result))\n-  498:                 System.err.println(\"CountingSort failed.\");\n-  499:             long aCounting = System.nanoTime();\n-  500:             double diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  501:             System.out.println(\"Random: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  502:             if (showResult)\n-  503:                 showResult(unsorted, result);\n-  504:             if (showComparison)\n-  505:                 countingResults[countingCount++] = diff;\n-  506:             putOutTheGarbage();\n-  507: \n-  508:             bCounting = System.nanoTime();\n-  509:             result = CountingSort.sort(sorted.clone());\n-  510:             if (checkResults && !check(result))\n-  511:                 System.err.println(\"CountingSort failed.\");\n-  512:             aCounting = System.nanoTime();\n-  513:             diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  514:             System.out.println(\"Sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  515:             if (showResult)\n-  516:                 showResult(sorted, result);\n-  517:             if (showComparison)\n-  518:                 countingResults[countingCount++] = diff;\n-  519:             putOutTheGarbage();\n-  520: \n-  521:             bCounting = System.nanoTime();\n-  522:             result = CountingSort.sort(reverse.clone());\n-  523:             if (checkResults && !check(result))\n-  524:                 System.err.println(\"CountingSort failed.\");\n-  525:             aCounting = System.nanoTime();\n-  526:             diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  527:             System.out.println(\"Reverse sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  528:             if (showResult)\n-  529:                 showResult(reverse, result);\n-  530:             if (showComparison)\n-  531:                 countingResults[countingCount++] = diff;\n-  532:             putOutTheGarbage();\n-  533: \n-  534:             System.out.println();\n-  535:             System.out.flush();\n-  536:         }\n-  537: \n-  538:         if (showRadix) {\n-  539:             // Radix sort\n-  540:             long bRadix = System.nanoTime();\n-  541:             Integer[] result = RadixSort.sort(unsorted.clone());\n-  542:             if (checkResults && !check(result))\n-  543:                 System.err.println(\"RadixSort failed.\");\n-  544:             long aRadix = System.nanoTime();\n-  545:             double diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  546:             System.out.println(\"Random: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  547:             if (showResult)\n-  548:                 showResult(unsorted, result);\n-  549:             if (showComparison)\n-  550:                 radixResults[radixCount++] = diff;\n-  551:             putOutTheGarbage();\n-  552: \n-  553:             bRadix = System.nanoTime();\n-  554:             result = RadixSort.sort(sorted.clone());\n-  555:             if (checkResults && !check(result))\n-  556:                 System.err.println(\"RadixSort failed.\");\n-  557:             aRadix = System.nanoTime();\n-  558:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  559:             System.out.println(\"Sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  560:             if (showResult)\n-  561:                 showResult(sorted, result);\n-  562:             if (showComparison)\n-  563:                 radixResults[radixCount++] = diff;\n-  564:             putOutTheGarbage();\n-  565: \n-  566:             bRadix = System.nanoTime();\n-  567:             result = RadixSort.sort(reverse.clone());\n-  568:             if (checkResults && !check(result))\n-  569:                 System.err.println(\"RadixSort failed.\");\n-  570:             aRadix = System.nanoTime();\n-  571:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  572:             System.out.println(\"Reverse sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  573:             if (showResult)\n-  574:                 showResult(reverse, result);\n-  575:             if (showComparison)\n-  576:                 radixResults[radixCount++] = diff;\n-  577:             putOutTheGarbage();\n-  578: \n-  579:             System.out.println();\n-  580:             System.out.flush();\n-  581:         }\n-  582: \n-  583:         if (showAmericanFlag) {\n-  584:             // American Flag sort\n-  585:             long bRadix = System.nanoTime();\n-  586:             Integer[] result = AmericanFlagSort.sort(unsorted.clone());\n-  587:             if (checkResults && !check(result))\n-  588:                 System.err.println(\"AmericanFlag sort failed.\");\n-  589:             long aRadix = System.nanoTime();\n-  590:             double diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  591:             System.out.println(\"Random: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  592:             if (showResult)\n-  593:                 showResult(unsorted, result);\n-  594:             if (showComparison)\n-  595:                 americanFlagResults[americanFlagCount++] = diff;\n-  596:             putOutTheGarbage();\n-  597: \n-  598:             bRadix = System.nanoTime();\n-  599:             result = AmericanFlagSort.sort(sorted.clone());\n-  600:             if (checkResults && !check(result))\n-  601:                 System.err.println(\"AmericanFlag sort failed.\");\n-  602:             aRadix = System.nanoTime();\n-  603:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  604:             System.out.println(\"Sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  605:             if (showResult)\n-  606:                 showResult(sorted, result);\n-  607:             if (showComparison)\n-  608:                 americanFlagResults[americanFlagCount++] = diff;\n-  609:             putOutTheGarbage();\n-  610: \n-  611:             bRadix = System.nanoTime();\n-  612:             result = AmericanFlagSort.sort(reverse.clone());\n-  613:             if (checkResults && !check(result))\n-  614:                 System.err.println(\"AmericanFlag sort failed.\");\n-  615:             aRadix = System.nanoTime();\n-  616:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  617:             System.out.println(\"Reverse sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  618:             if (showResult)\n-  619:                 showResult(reverse, result);\n-  620:             if (showComparison)\n-  621:                 americanFlagResults[americanFlagCount++] = diff;\n-  622:             putOutTheGarbage();\n-  623: \n-  624:             System.out.println();\n-  625:             System.out.flush();\n-  626:         }\n-  627: \n-  628:         if (showComparison)\n-  629:             showComparison();\n-  630:     }\n+  225:         @Override\n+  226:         public Integer[] sort(Integer[] input) {\n+  227:             return InsertionSort.sort(input);\n+  228:         }\n+  229:     }\n+  230: \n+  231:     private static class MergeInPlace extends Testable {\n+  232:         @Override\n+  233:         public String getName() {\n+  234:             return \"MergeInPlace sort\";\n+  235:         }\n+  236: \n+  237:         @Override\n+  238:         public Integer[] sort(Integer[] input) {\n+  239:             return MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, input);\n+  240:         }\n+  241:     }\n+  242: \n+  243:     private static class MergeNotInPlace extends Testable {\n+  244:         @Override\n+  245:         public String getName() {\n+  246:             return \"MergeInPlace sort\";\n+  247:         }\n+  248: \n+  249:         @Override\n+  250:         public Integer[] sort(Integer[] input) {\n+  251:             return MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, input);\n+  252:         }\n+  253:     }\n+  254: \n+  255:     private static class QuickFirst extends Testable {\n+  256:         @Override\n+  257:         public String getName() {\n+  258:             return \"Quick (first) sort\";\n+  259:         }\n+  260: \n+  261:         @Override\n+  262:         public Integer[] sort(Integer[] input) {\n+  263:             return QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, input);\n+  264:         }\n+  265:     }\n+  266: \n+  267:     private static class QuickMiddle extends Testable {\n+  268:         @Override\n+  269:         public String getName() {\n+  270:             return \"Quick (middle) sort\";\n+  271:         }\n+  272: \n+  273:         @Override\n+  274:         public Integer[] sort(Integer[] input) {\n+  275:             return QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, input);\n+  276:         }\n+  277:     }\n+  278: \n+  279:     private static class QuickRandom extends Testable {\n+  280:         @Override\n+  281:         public String getName() {\n+  282:             return \"Quick (random) sort\";\n+  283:         }\n+  284: \n+  285:         @Override\n+  286:         public Integer[] sort(Integer[] input) {\n+  287:             return QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, input);\n+  288:         }\n+  289:     }\n+  290: \n+  291:     private static class Radix extends Testable {\n+  292:         @Override\n+  293:         public String getName() {\n+  294:             return \"Radix sort\";\n+  295:         }\n+  296: \n+  297:         @Override\n+  298:         public Integer[] sort(Integer[] input) {\n+  299:             return RadixSort.sort(input);\n+  300:         }\n+  301:     }\n+  302: \n+  303:     private static class Shell extends Testable {\n+  304:         int[] shells = new int[] { 10, 5, 3, 1 };\n+  305:  \n+  306:         @Override\n+  307:         public String getName() {\n+  308:             return \"Shell sort\";\n+  309:         }\n+  310: \n+  311:         @Override\n+  312:         public Integer[] sort(Integer[] input) {\n+  313:             return ShellSort.sort(shells, input);\n+  314:         }\n+  315:     }\n+  316: \n+  317:     private static final void showComparison() {\n+  318:         StringBuilder resultsBuilder = new StringBuilder();\n+  319:         resultsBuilder.append(\"Number of integers = \").append(SIZE).append(\"\\n\");\n+  320:         String format = \"%-32s%-15s%-15s%-15s\\n\";\n+  321:         Formatter formatter = new Formatter(resultsBuilder, Locale.US);\n+  322: \n+  323:         formatter.format(format, \"Algorithm\",\"Random\",\"Sorted\",\"Reverse Sorted\");\n+  324:         if (insertionResults!=null) {\n+  325:             int i = 0;\n+  326:             formatter.format(format, \"Insertion sort\", FORMAT.format(insertionResults[i++]), FORMAT.format(insertionResults[i++]), FORMAT.format(insertionResults[i++]));\n+  327:         }\n+  328:         if (bubbleResults!=null) {\n+  329:             int i = 0;\n+  330:             formatter.format(format, \"Bubble sort\", FORMAT.format(bubbleResults[i++]), FORMAT.format(bubbleResults[i++]), FORMAT.format(bubbleResults[i++]));\n+  331:         }\n+  332:         if (shellResults!=null) {\n+  333:             int i = 0;\n+  334:             formatter.format(format, \"Shell sort\", FORMAT.format(shellResults[i++]), FORMAT.format(shellResults[i++]), FORMAT.format(shellResults[i++]));\n+  335:         }\n+  336:         if (mergeResults!=null) {\n+  337:             int i = 0;\n+  338:             formatter.format(format, \"Merge (in-place) sort\", FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]));\n+  339:             formatter.format(format, \"Merge (not-in-place) sort\", FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]));\n+  340:         }\n+  341:         if (quickResults!=null) {\n+  342:             int i = 0;\n+  343:             formatter.format(format, \"Quicksort with first as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  344:             formatter.format(format, \"Quicksort with middle as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  345:             formatter.format(format, \"Quicksort with random as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  346:         }\n+  347:         if (heapResults!=null) {\n+  348:             int i = 0;\n+  349:             formatter.format(format, \"Heap sort\", FORMAT.format(heapResults[i++]), FORMAT.format(heapResults[i++]), FORMAT.format(heapResults[i++]));\n+  350:         }\n+  351:         if (countingResults!=null) {\n+  352:             int i = 0;\n+  353:             formatter.format(format, \"Counting sort\", FORMAT.format(countingResults[i++]), FORMAT.format(countingResults[i++]), FORMAT.format(countingResults[i++]));\n+  354:         }\n+  355:         if (radixResults!=null) {\n+  356:             int i = 0;\n+  357:             formatter.format(format, \"Radix sort\", FORMAT.format(radixResults[i++]), FORMAT.format(radixResults[i++]), FORMAT.format(radixResults[i++]));\n+  358:         }\n+  359:         if (americanFlagResults!=null) {\n+  360:             int i = 0;\n+  361:             formatter.format(format, \"American Flag sort\", FORMAT.format(americanFlagResults[i++]), FORMAT.format(americanFlagResults[i++]), FORMAT.format(americanFlagResults[i++]));\n+  362:         }\n+  363:         formatter.close();\n+  364:         System.out.println(resultsBuilder.toString());\n+  365:     }\n+  366: \n+  367:     private static final void showResult(Integer[] u, Integer[] r) {\n+  368:         System.out.println(\"Unsorted: \" + print(u));\n+  369:         System.out.println(\"Sorted: \" + print(r));\n+  370:         System.out.flush();\n+  371:     }\n+  372: \n+  373:     private static final boolean check(Integer[] array) {\n+  374:         for (int i = 1; i < array.length; i++) {\n+  375:             if (array[i - 1] > array[i])\n+  376:                 return false;\n+  377:         }\n+  378:         return true;\n+  379:     }\n+  380: \n+  381:     public static final String print(Integer[] array) {\n+  382:         return print(array, 0, array.length);\n+  383:     }\n+  384: \n+  385:     public static final String print(Integer[] array, int start, int length) {\n+  386:         final Integer[] clone = array.clone();\n+  387:         StringBuilder builder = new StringBuilder();\n+  388:         for (int i = 0; i < length; i++) {\n+  389:             int e = clone[start + i];\n+  390:             builder.append(e + \" \");\n+  391:         }\n+  392:         return builder.toString();\n+  393:     }\n+  394: \n+  395:     public static final String printWithPivot(Integer[] array, int pivotIndex, int start, int length) {\n+  396:         final Integer[] clone = array.clone();\n+  397:         StringBuilder builder = new StringBuilder();\n+  398:         for (int i = 0; i < length; i++) {\n+  399:             int e = clone[start + i];\n+  400:             if (i == pivotIndex)\n+  401:                 builder.append(\"`\" + e + \"` \");\n+  402:             else\n+  403:                 builder.append(e + \" \");\n+  404:         }\n+  405:         return builder.toString();\n+  406:     }\n+  407: \n+  408:     private static final void putOutTheGarbage() {\n+  409:         collectGarbage();\n+  410:         collectGarbage();\n+  411:         collectGarbage();\n+  412:     }\n+  413: \n+  414:     private static final long fSLEEP_INTERVAL = 100;\n+  415: \n+  416:     private static final void collectGarbage() {\n+  417:         try {\n+  418:             System.gc();\n+  419:             System.gc();\n+  420:             System.gc();\n+  421:             Thread.sleep(fSLEEP_INTERVAL);\n+  422:             System.runFinalization();\n+  423:             Thread.sleep(fSLEEP_INTERVAL);\n+  424:         } catch (InterruptedException ex) {\n+  425:             ex.printStackTrace();\n+  426:         }\n+  427:     }\n+  428: }\n\n",
        "contextDescription": "PackageName: org.voltdb.regressionsuites\nClassName: org.voltdb.regressionsuites.TestApproxCountDistinctSuite\nMethodName: org.voltdb.regressionsuites.TestApproxCountDistinctSuite#fillTable\n ClassSignature: public class TestApproxCountDistinctSuite extends RegressionSuite \n",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\nprivate static void fillTable(Client client, String tbl) throws Exception {\n        Random r = new Random(777);\n        for (int i = 0; i < 1000; ++i) {\n\n            double d;\n            do {\n                d = r.nextGaussian() * 1000;\n            } while (d > Long.MAX_VALUE || d <= Long.MIN_VALUE);\n\n            long val = (long) d;\n            client.callProcedure(tbl + \".Insert\", i, val);\n        }\n    }\n\nThe context of the source code is as follows:\nPackageName: org.voltdb.regressionsuites\nClassName: org.voltdb.regressionsuites.TestApproxCountDistinctSuite\nMethodName: org.voltdb.regressionsuites.TestApproxCountDistinctSuite#fillTable\n ClassSignature: public class TestApproxCountDistinctSuite extends RegressionSuite\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     *\n     * @throws IllegalArgumentException if {@code names.length != values.length}.\n     */\n    public Insert values(String[] names, Object[] values) {\n        if (names.length != values.length)\n            throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.length, values.length));\n        this.names.addAll(Arrays.asList(names));\n        this.values.addAll(Arrays.asList(values));\n\n        for (int i = 0; i < names.length; i++) {\n            checkForBindMarkers(values[i]);\n            maybeAddRoutingKey(names[i], values[i]);\n        }\n        return this;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     * @throws IllegalArgumentException if {@code names.length != values.length}.\n     */\n    public Insert values(String[] names, Object[] values) {\n        return values(Arrays.asList(names), Arrays.asList(values));\n    }\n/**\n     * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n     *\n     * @param names a list of column names to insert/update.\n     * @param values a list of values to insert/update. The {@code i}th\n     * value in {@code values} will be inserted for the {@code i}th column\n     * in {@code names}.\n     * @return this INSERT statement.\n     * @throws IllegalArgumentException if {@code names.size() != values.size()}.\n     */\n    public Insert values(List<String> names, List<Object> values) {\n        if (names.size() != values.size())\n            throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.size(), values.size()));\n        this.names.addAll(names);\n        this.values.addAll(values);\n        for (int i = 0; i < names.size(); i++) {\n            checkForBindMarkers(values.get(i));\n            maybeAddRoutingKey(names.get(i), values.get(i));\n        }\n        return this;\n    }\n DiffSourceCode:\n-   86: \n-   87:     /**\n-   88:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n-   89:      *\n-   90:      * @param names a list of column names to insert/update.\n-   91:      * @param values a list of values to insert/update. The {@code i}th\n-   92:      * value in {@code values} will be inserted for the {@code i}th column\n-   93:      * in {@code names}.\n-   94:      * @return this INSERT statement.\n-   95:      *\n-   96:      * @throws IllegalArgumentException if {@code names.length != values.length}.\n-   97:      */\n-   98:     public Insert values(String[] names, Object[] values) {\n-   99:         if (names.length != values.length)\n-  100:             throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.length, values.length));\n-  101:         this.names.addAll(Arrays.asList(names));\n-  102:         this.values.addAll(Arrays.asList(values));\n-  103: \n-  104:         for (int i = 0; i < names.length; i++) {\n-  105:             checkForBindMarkers(values[i]);\n-  106:             maybeAddRoutingKey(names[i], values[i]);\n-  107:         }\n-  108:         return this;\n-  109:     }\n-  110: \n-  111:     /**\n-  112:      * Adds a new options for this INSERT statement.\n-  113:      *\n-  114:      * @param using the option to add.\n-  115:      * @return the options of this INSERT statement.\n-  116:      */\n-  117:     public Options using(Using using) {\n-  118:         return usings.and(using);\n-  119:     }\n-  120: \n+   86:     /**\n+   87:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n+   88:      *\n+   89:      * @param names a list of column names to insert/update.\n+   90:      * @param values a list of values to insert/update. The {@code i}th\n+   91:      * value in {@code values} will be inserted for the {@code i}th column\n+   92:      * in {@code names}.\n+   93:      * @return this INSERT statement.\n+   94:      * @throws IllegalArgumentException if {@code names.length != values.length}.\n+   95:      */\n+   96:     public Insert values(String[] names, Object[] values) {\n+   97:         return values(Arrays.asList(names), Arrays.asList(values));\n+   98:     }\n+   99: \n+  100:     /**\n+  101:      * Adds multiple column/value pairs to the values inserted by this INSERT statement.\n+  102:      *\n+  103:      * @param names a list of column names to insert/update.\n+  104:      * @param values a list of values to insert/update. The {@code i}th\n+  105:      * value in {@code values} will be inserted for the {@code i}th column\n+  106:      * in {@code names}.\n+  107:      * @return this INSERT statement.\n+  108:      * @throws IllegalArgumentException if {@code names.size() != values.size()}.\n+  109:      */\n+  110:     public Insert values(List<String> names, List<Object> values) {\n+  111:         if (names.size() != values.size())\n+  112:             throw new IllegalArgumentException(String.format(\"Got %d names but %d values\", names.size(), values.size()));\n+  113:         this.names.addAll(names);\n+  114:         this.values.addAll(values);\n+  115:         for (int i = 0; i < names.size(); i++) {\n+  116:             checkForBindMarkers(values.get(i));\n+  117:             maybeAddRoutingKey(names.get(i), values.get(i));\n+  118:         }\n+  119:         return this;\n+  120:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n    if (virtualFile != null) {\n      PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n      if (file != null) {\n        int targetOffset = target.getOffset();\n        for (int i = 0; i < 2; i++) {\n          Class<? extends PsiElement> clazz = DartComponentName.class;\n          if (i == 1) {\n            clazz = DartReferenceExpression.class;\n          }\n          PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n          if (elementAt != null) {\n            return elementAt;\n          }\n        }\n      }\n    }\n    return null;\n  }\n SourceCodeAfterRefactoring:\n@Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    PsiFile file = findPsiFile(project, targetPath);\n    if (file != null) {\n      int targetOffset = target.getOffset();\n      for (int i = 0; i < 2; i++) {\n        Class<? extends PsiElement> clazz = DartComponentName.class;\n        if (i == 1) {\n          clazz = DartReferenceExpression.class;\n        }\n        PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n        if (elementAt != null) {\n          return elementAt;\n        }\n      }\n    }\n    return null;\n  }\n@Nullable\n  public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n    if (virtualFile != null) {\n      return PsiManager.getInstance(project).findFile(virtualFile);\n    }\n    return null;\n  }\n DiffSourceCode:\n   135:   @Nullable\n   136:   private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n   137:     String targetPath = target.getFile();\n-  138:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n-  139:     if (virtualFile != null) {\n-  140:       PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n-  141:       if (file != null) {\n-  142:         int targetOffset = target.getOffset();\n-  143:         for (int i = 0; i < 2; i++) {\n-  144:           Class<? extends PsiElement> clazz = DartComponentName.class;\n-  145:           if (i == 1) {\n-  146:             clazz = DartReferenceExpression.class;\n-  147:           }\n-  148:           PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n-  149:           if (elementAt != null) {\n-  150:             return elementAt;\n-  151:           }\n-  152:         }\n-  153:       }\n-  154:     }\n-  155:     return null;\n-  156:   }\n-  157: \n-  158:   @NotNull\n-  159:   private static List<PsiElement> toResult(@Nullable PsiElement element) {\n-  160:     if (element == null) {\n-  161:       return Collections.emptyList();\n-  162:     }\n+  138:     PsiFile file = findPsiFile(project, targetPath);\n+  139:     if (file != null) {\n+  140:       int targetOffset = target.getOffset();\n+  141:       for (int i = 0; i < 2; i++) {\n+  142:         Class<? extends PsiElement> clazz = DartComponentName.class;\n+  143:         if (i == 1) {\n+  144:           clazz = DartReferenceExpression.class;\n+  145:         }\n+  146:         PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n+  147:         if (elementAt != null) {\n+  148:           return elementAt;\n+  149:         }\n+  150:       }\n+  151:     }\n+  152:     return null;\n+  153:   }\n+  154: \n+  155:   @Nullable\n+  156:   public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n+  157:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n+  158:     if (virtualFile != null) {\n+  159:       return PsiManager.getInstance(project).findFile(virtualFile);\n+  160:     }\n+  161:     return null;\n+  162:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static void main(String[] args) {\n        System.out.println(\"Generating random array.\");\n        Random random = new Random();\n        unsorted = new Integer[SIZE];\n        int i = 0;\n        while (i < unsorted.length) {\n            int j = random.nextInt(unsorted.length * 10);\n            unsorted[i++] = j;\n        }\n        System.out.println(\"Generated random array.\");\n\n        System.out.println(\"Generating sorted array.\");\n        sorted = new Integer[SIZE];\n        for (i = 0; i < sorted.length; i++) {\n            sorted[i] = i;\n        }\n        System.out.println(\"Generated sorted array.\");\n\n        System.out.println(\"Generating reverse sorted array.\");\n        reverse = new Integer[SIZE];\n        for (i = (reverse.length - 1); i >= 0; i--) {\n            reverse[i] = (SIZE - 1) - i;\n        }\n        System.out.println(\"Generated reverse sorted array.\");\n        System.out.println();\n        System.out.flush();\n\n        System.out.println(\"Starting sorts...\");\n        System.out.println();\n        System.out.flush();\n        if (showInsertion) {\n            // Insertion sort\n            long bInsertion = System.nanoTime();\n            Integer[] result = InsertionSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            long aInsertion = System.nanoTime();\n            double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Random: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            bInsertion = System.nanoTime();\n            result = InsertionSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            aInsertion = System.nanoTime();\n            diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            bInsertion = System.nanoTime();\n            result = InsertionSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"InsertionSort failed.\");\n            aInsertion = System.nanoTime();\n            diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                insertionResults[insertionCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showBubble) {\n            // Bubble sort\n            long bBubble = System.nanoTime();\n            Integer[] result = BubbleSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            long aBubble = System.nanoTime();\n            double diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Random: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            bBubble = System.nanoTime();\n            result = BubbleSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            aBubble = System.nanoTime();\n            diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            bBubble = System.nanoTime();\n            result = BubbleSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"BubbleSort failed.\");\n            aBubble = System.nanoTime();\n            diff = (aBubble - bBubble) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                bubbleResults[bubbleCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showShell) {\n            int[] shells = new int[] { 10, 5, 3, 1 };\n            // Shell's sort\n            long bShell = System.nanoTime();\n            Integer[] result = ShellSort.sort(shells, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            long aShell = System.nanoTime();\n            double diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Random: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            bShell = System.nanoTime();\n            result = ShellSort.sort(shells, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            aShell = System.nanoTime();\n            diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            bShell = System.nanoTime();\n            result = ShellSort.sort(shells, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"ShellSort failed.\");\n            aShell = System.nanoTime();\n            diff = (aShell - bShell) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                shellResults[shellCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showMergeNotInPlace) {\n            // Merge sort\n            long bMerge = System.nanoTime();\n            Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            long aMerge = System.nanoTime();\n            double diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showMergeInPlace) {\n            // Merge sort\n            long bMerge = System.nanoTime();\n            Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            long aMerge = System.nanoTime();\n            double diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            bMerge = System.nanoTime();\n            result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"MergeSort failed.\");\n            aMerge = System.nanoTime();\n            diff = (aMerge - bMerge) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                mergeInPlaceResults[mergeInPlaceCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showQuick) {\n            // Quicksort\n            long bQuick = System.nanoTime();\n            Integer[] result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            long aQuick = System.nanoTime();\n            double diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Random: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            bQuick = System.nanoTime();\n            result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"Random QuickSort failed.\");\n            aQuick = System.nanoTime();\n            diff = (aQuick - bQuick) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                quickResults[quickCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showHeap) {\n            // Heapsort\n            long bHeap = System.nanoTime();\n            Integer[] result = HeapSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            long aHeap = System.nanoTime();\n            double diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Random: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            bHeap = System.nanoTime();\n            result = HeapSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            aHeap = System.nanoTime();\n            diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            bHeap = System.nanoTime();\n            result = HeapSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"HeapSort failed.\");\n            aHeap = System.nanoTime();\n            diff = (aHeap - bHeap) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                heapResults[heapCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showCounting) {\n            // Counting sort\n            long bCounting = System.nanoTime();\n            Integer[] result = CountingSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            long aCounting = System.nanoTime();\n            double diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Random: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            bCounting = System.nanoTime();\n            result = CountingSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            aCounting = System.nanoTime();\n            diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            bCounting = System.nanoTime();\n            result = CountingSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"CountingSort failed.\");\n            aCounting = System.nanoTime();\n            diff = (aCounting - bCounting) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                countingResults[countingCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showRadix) {\n            // Radix sort\n            long bRadix = System.nanoTime();\n            Integer[] result = RadixSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            long aRadix = System.nanoTime();\n            double diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Random: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = RadixSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = RadixSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"RadixSort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                radixResults[radixCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showAmericanFlag) {\n            // American Flag sort\n            long bRadix = System.nanoTime();\n            Integer[] result = AmericanFlagSort.sort(unsorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            long aRadix = System.nanoTime();\n            double diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Random: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(unsorted, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = AmericanFlagSort.sort(sorted.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(sorted, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            bRadix = System.nanoTime();\n            result = AmericanFlagSort.sort(reverse.clone());\n            if (checkResults && !check(result))\n                System.err.println(\"AmericanFlag sort failed.\");\n            aRadix = System.nanoTime();\n            diff = (aRadix - bRadix) / 1000000d / 1000d;\n            System.out.println(\"Reverse sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n            if (showResult)\n                showResult(reverse, result);\n            if (showComparison)\n                americanFlagResults[americanFlagCount++] = diff;\n            putOutTheGarbage();\n\n            System.out.println();\n            System.out.flush();\n        }\n\n        if (showComparison)\n            showComparison();\n    }\n SourceCodeAfterRefactoring:\npublic static void main(String[] args) {\n        System.out.println(\"Generating random array.\");\n        Random random = new Random();\n        unsorted = new Integer[SIZE];\n        int i = 0;\n        while (i < unsorted.length) {\n            int j = random.nextInt(unsorted.length * 10);\n            unsorted[i++] = j;\n        }\n        System.out.println(\"Generated random array.\");\n\n        System.out.println(\"Generating sorted array.\");\n        sorted = new Integer[SIZE];\n        for (i = 0; i < sorted.length; i++) {\n            sorted[i] = i;\n        }\n        System.out.println(\"Generated sorted array.\");\n\n        System.out.println(\"Generating reverse sorted array.\");\n        reverse = new Integer[SIZE];\n        for (i = (reverse.length - 1); i >= 0; i--) {\n            reverse[i] = (SIZE - 1) - i;\n        }\n        System.out.println(\"Generated reverse sorted array.\");\n        System.out.println();\n        System.out.flush();\n\n        System.out.println(\"Starting sorts...\");\n        System.out.println();\n        System.out.flush();\n\n        insertionResults = new double[1 * 3];\n        insertionCount = runTest(new Insertion(), unsorted, sorted, insertionResults, insertionCount);\n        showComparison();\n\n        bubbleResults = new double[1 * 3];\n        bubbleCount = runTest(new Bubble(), unsorted, sorted, bubbleResults, bubbleCount);\n        showComparison();\n\n        shellResults = new double[1 * 3];\n        shellCount = runTest(new Shell(), unsorted, sorted, shellResults, shellCount);\n        showComparison();\n\n        mergeResults = new double[2 * 3];\n        mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);\n        mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);\n        showComparison();\n\n        quickResults = new double[3 * 3];\n        quickCount = runTest(new QuickFirst(), unsorted, sorted, quickResults, quickCount);\n        quickCount = runTest(new QuickMiddle(), unsorted, sorted, quickResults, quickCount);\n        quickCount = runTest(new QuickRandom(), unsorted, sorted, quickResults, quickCount);\n        showComparison();\n\n        heapResults = new double[1 * 3];\n        heapCount = runTest(new Heap(), unsorted, sorted, heapResults, heapCount);\n        showComparison();\n\n        countingResults = new double[1 * 3];\n        countingCount = runTest(new Counting(), unsorted, sorted, countingResults, countingCount);\n        showComparison();\n\n        radixResults = new double[1 * 3];\n        radixCount = runTest(new Radix(), unsorted, sorted, radixResults, radixCount);\n        showComparison();\n\n        americanFlagResults = new double[1 * 3];\n        americanFlagCount = runTest(new AmericanFlag(), unsorted, sorted, americanFlagResults, americanFlagCount);\n        showComparison();\n    }\nprivate static final int runTest(Testable testable, Integer[] unsorted, Integer[] sorted, double[] results, int count) {\n        long bInsertion = System.nanoTime();\n        Integer[] result = testable.sort(unsorted.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\" failed.\");\n        long aInsertion = System.nanoTime();\n        double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Random: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(unsorted, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        bInsertion = System.nanoTime();\n        result = InsertionSort.sort(sorted.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\" failed.\");\n        aInsertion = System.nanoTime();\n        diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(sorted, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        bInsertion = System.nanoTime();\n        result = InsertionSort.sort(reverse.clone());\n        if (checkResults && !check(result))\n            System.err.println(testable.getName()+\"InsertionSort.\");\n        aInsertion = System.nanoTime();\n        diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n        System.out.println(\"Reverse sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n        if (showResult)\n            showResult(reverse, result);\n        results[count++] = diff;\n        putOutTheGarbage();\n\n        System.out.println();\n        System.out.flush();\n\n        return count;\n    }\n DiffSourceCode:\n-   48:     private static final boolean showInsertion = true;\n-   49:     private static final boolean showBubble = true;\n-   50:     private static final boolean showShell = true;\n-   51:     private static final boolean showMergeInPlace = true;\n-   52:     private static final boolean showMergeNotInPlace = true;\n-   53:     private static final boolean showQuick = true;\n-   54:     private static final boolean showHeap = true;\n-   55:     private static final boolean showCounting = true;\n-   56:     private static final boolean showRadix = true;\n-   57:     private static final boolean showAmericanFlag = true;\n+   48:     public static void main(String[] args) {\n+   49:         System.out.println(\"Generating random array.\");\n+   50:         Random random = new Random();\n+   51:         unsorted = new Integer[SIZE];\n+   52:         int i = 0;\n+   53:         while (i < unsorted.length) {\n+   54:             int j = random.nextInt(unsorted.length * 10);\n+   55:             unsorted[i++] = j;\n+   56:         }\n+   57:         System.out.println(\"Generated random array.\");\n    58: \n-   59:     private static Integer[] unsorted = null;\n-   60:     private static Integer[] sorted = null;\n-   61:     private static Integer[] reverse = null;\n-   62: \n-   63:     public static void main(String[] args) {\n-   64:         System.out.println(\"Generating random array.\");\n-   65:         Random random = new Random();\n-   66:         unsorted = new Integer[SIZE];\n-   67:         int i = 0;\n-   68:         while (i < unsorted.length) {\n-   69:             int j = random.nextInt(unsorted.length * 10);\n-   70:             unsorted[i++] = j;\n-   71:         }\n-   72:         System.out.println(\"Generated random array.\");\n-   73: \n-   74:         System.out.println(\"Generating sorted array.\");\n-   75:         sorted = new Integer[SIZE];\n-   76:         for (i = 0; i < sorted.length; i++) {\n-   77:             sorted[i] = i;\n-   78:         }\n-   79:         System.out.println(\"Generated sorted array.\");\n-   80: \n-   81:         System.out.println(\"Generating reverse sorted array.\");\n-   82:         reverse = new Integer[SIZE];\n-   83:         for (i = (reverse.length - 1); i >= 0; i--) {\n-   84:             reverse[i] = (SIZE - 1) - i;\n-   85:         }\n-   86:         System.out.println(\"Generated reverse sorted array.\");\n-   87:         System.out.println();\n-   88:         System.out.flush();\n-   89: \n-   90:         System.out.println(\"Starting sorts...\");\n-   91:         System.out.println();\n-   92:         System.out.flush();\n-   93:         if (showInsertion) {\n-   94:             // Insertion sort\n-   95:             long bInsertion = System.nanoTime();\n-   96:             Integer[] result = InsertionSort.sort(unsorted.clone());\n-   97:             if (checkResults && !check(result))\n-   98:                 System.err.println(\"InsertionSort failed.\");\n-   99:             long aInsertion = System.nanoTime();\n-  100:             double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  101:             System.out.println(\"Random: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  102:             if (showResult)\n-  103:                 showResult(unsorted, result);\n-  104:             if (showComparison)\n-  105:                 insertionResults[insertionCount++] = diff;\n-  106:             putOutTheGarbage();\n-  107: \n-  108:             bInsertion = System.nanoTime();\n-  109:             result = InsertionSort.sort(sorted.clone());\n-  110:             if (checkResults && !check(result))\n-  111:                 System.err.println(\"InsertionSort failed.\");\n-  112:             aInsertion = System.nanoTime();\n-  113:             diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  114:             System.out.println(\"Sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  115:             if (showResult)\n-  116:                 showResult(sorted, result);\n-  117:             if (showComparison)\n-  118:                 insertionResults[insertionCount++] = diff;\n-  119:             putOutTheGarbage();\n-  120: \n-  121:             bInsertion = System.nanoTime();\n-  122:             result = InsertionSort.sort(reverse.clone());\n-  123:             if (checkResults && !check(result))\n-  124:                 System.err.println(\"InsertionSort failed.\");\n-  125:             aInsertion = System.nanoTime();\n-  126:             diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n-  127:             System.out.println(\"Reverse sorted: InsertionSort=\" + FORMAT.format(diff) + \" secs\");\n-  128:             if (showResult)\n-  129:                 showResult(reverse, result);\n-  130:             if (showComparison)\n-  131:                 insertionResults[insertionCount++] = diff;\n-  132:             putOutTheGarbage();\n-  133: \n-  134:             System.out.println();\n-  135:             System.out.flush();\n-  136:         }\n-  137: \n-  138:         if (showBubble) {\n-  139:             // Bubble sort\n-  140:             long bBubble = System.nanoTime();\n-  141:             Integer[] result = BubbleSort.sort(unsorted.clone());\n-  142:             if (checkResults && !check(result))\n-  143:                 System.err.println(\"BubbleSort failed.\");\n-  144:             long aBubble = System.nanoTime();\n-  145:             double diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  146:             System.out.println(\"Random: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  147:             if (showResult)\n-  148:                 showResult(unsorted, result);\n-  149:             if (showComparison)\n-  150:                 bubbleResults[bubbleCount++] = diff;\n-  151:             putOutTheGarbage();\n-  152: \n-  153:             bBubble = System.nanoTime();\n-  154:             result = BubbleSort.sort(sorted.clone());\n-  155:             if (checkResults && !check(result))\n-  156:                 System.err.println(\"BubbleSort failed.\");\n-  157:             aBubble = System.nanoTime();\n-  158:             diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  159:             System.out.println(\"Sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  160:             if (showResult)\n-  161:                 showResult(sorted, result);\n-  162:             if (showComparison)\n-  163:                 bubbleResults[bubbleCount++] = diff;\n-  164:             putOutTheGarbage();\n-  165: \n-  166:             bBubble = System.nanoTime();\n-  167:             result = BubbleSort.sort(reverse.clone());\n-  168:             if (checkResults && !check(result))\n-  169:                 System.err.println(\"BubbleSort failed.\");\n-  170:             aBubble = System.nanoTime();\n-  171:             diff = (aBubble - bBubble) / 1000000d / 1000d;\n-  172:             System.out.println(\"Reverse sorted: BubbleSort=\" + FORMAT.format(diff) + \" secs\");\n-  173:             if (showResult)\n-  174:                 showResult(reverse, result);\n-  175:             if (showComparison)\n-  176:                 bubbleResults[bubbleCount++] = diff;\n-  177:             putOutTheGarbage();\n-  178: \n-  179:             System.out.println();\n-  180:             System.out.flush();\n-  181:         }\n+   59:         System.out.println(\"Generating sorted array.\");\n+   60:         sorted = new Integer[SIZE];\n+   61:         for (i = 0; i < sorted.length; i++) {\n+   62:             sorted[i] = i;\n+   63:         }\n+   64:         System.out.println(\"Generated sorted array.\");\n+   65: \n+   66:         System.out.println(\"Generating reverse sorted array.\");\n+   67:         reverse = new Integer[SIZE];\n+   68:         for (i = (reverse.length - 1); i >= 0; i--) {\n+   69:             reverse[i] = (SIZE - 1) - i;\n+   70:         }\n+   71:         System.out.println(\"Generated reverse sorted array.\");\n+   72:         System.out.println();\n+   73:         System.out.flush();\n+   74: \n+   75:         System.out.println(\"Starting sorts...\");\n+   76:         System.out.println();\n+   77:         System.out.flush();\n+   78: \n+   79:         insertionResults = new double[1 * 3];\n+   80:         insertionCount = runTest(new Insertion(), unsorted, sorted, insertionResults, insertionCount);\n+   81:         showComparison();\n+   82: \n+   83:         bubbleResults = new double[1 * 3];\n+   84:         bubbleCount = runTest(new Bubble(), unsorted, sorted, bubbleResults, bubbleCount);\n+   85:         showComparison();\n+   86: \n+   87:         shellResults = new double[1 * 3];\n+   88:         shellCount = runTest(new Shell(), unsorted, sorted, shellResults, shellCount);\n+   89:         showComparison();\n+   90: \n+   91:         mergeResults = new double[2 * 3];\n+   92:         mergeCount = runTest(new MergeNotInPlace(), unsorted, sorted, mergeResults, mergeCount);\n+   93:         mergeCount = runTest(new MergeInPlace(), unsorted, sorted, mergeResults, mergeCount);\n+   94:         showComparison();\n+   95: \n+   96:         quickResults = new double[3 * 3];\n+   97:         quickCount = runTest(new QuickFirst(), unsorted, sorted, quickResults, quickCount);\n+   98:         quickCount = runTest(new QuickMiddle(), unsorted, sorted, quickResults, quickCount);\n+   99:         quickCount = runTest(new QuickRandom(), unsorted, sorted, quickResults, quickCount);\n+  100:         showComparison();\n+  101: \n+  102:         heapResults = new double[1 * 3];\n+  103:         heapCount = runTest(new Heap(), unsorted, sorted, heapResults, heapCount);\n+  104:         showComparison();\n+  105: \n+  106:         countingResults = new double[1 * 3];\n+  107:         countingCount = runTest(new Counting(), unsorted, sorted, countingResults, countingCount);\n+  108:         showComparison();\n+  109: \n+  110:         radixResults = new double[1 * 3];\n+  111:         radixCount = runTest(new Radix(), unsorted, sorted, radixResults, radixCount);\n+  112:         showComparison();\n+  113: \n+  114:         americanFlagResults = new double[1 * 3];\n+  115:         americanFlagCount = runTest(new AmericanFlag(), unsorted, sorted, americanFlagResults, americanFlagCount);\n+  116:         showComparison();\n+  117:     }\n+  118: \n+  119:     private static final int runTest(Testable testable, Integer[] unsorted, Integer[] sorted, double[] results, int count) {\n+  120:         long bInsertion = System.nanoTime();\n+  121:         Integer[] result = testable.sort(unsorted.clone());\n+  122:         if (checkResults && !check(result))\n+  123:             System.err.println(testable.getName()+\" failed.\");\n+  124:         long aInsertion = System.nanoTime();\n+  125:         double diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  126:         System.out.println(\"Random: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  127:         if (showResult)\n+  128:             showResult(unsorted, result);\n+  129:         results[count++] = diff;\n+  130:         putOutTheGarbage();\n+  131: \n+  132:         bInsertion = System.nanoTime();\n+  133:         result = InsertionSort.sort(sorted.clone());\n+  134:         if (checkResults && !check(result))\n+  135:             System.err.println(testable.getName()+\" failed.\");\n+  136:         aInsertion = System.nanoTime();\n+  137:         diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  138:         System.out.println(\"Sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  139:         if (showResult)\n+  140:             showResult(sorted, result);\n+  141:         results[count++] = diff;\n+  142:         putOutTheGarbage();\n+  143: \n+  144:         bInsertion = System.nanoTime();\n+  145:         result = InsertionSort.sort(reverse.clone());\n+  146:         if (checkResults && !check(result))\n+  147:             System.err.println(testable.getName()+\"InsertionSort.\");\n+  148:         aInsertion = System.nanoTime();\n+  149:         diff = (aInsertion - bInsertion) / 1000000d / 1000d;\n+  150:         System.out.println(\"Reverse sorted: \"+testable.getName()+\"=\" + FORMAT.format(diff) + \" secs\");\n+  151:         if (showResult)\n+  152:             showResult(reverse, result);\n+  153:         results[count++] = diff;\n+  154:         putOutTheGarbage();\n+  155: \n+  156:         System.out.println();\n+  157:         System.out.flush();\n+  158: \n+  159:         return count;\n+  160:     }\n+  161: \n+  162:     public static abstract class Testable {\n+  163:         String input = null;\n+  164:         public String getInput() {\n+  165:             return input;\n+  166:         }\n+  167:         public abstract String getName();\n+  168:         public abstract Integer[] sort(Integer[] input);\n+  169:     }\n+  170: \n+  171:     private static class AmericanFlag extends Testable {\n+  172:         @Override\n+  173:         public String getName() {\n+  174:             return \"AmericanFlag sort\";\n+  175:         }\n+  176: \n+  177:         @Override\n+  178:         public Integer[] sort(Integer[] input) {\n+  179:             return AmericanFlagSort.sort(input);\n+  180:         }\n+  181:     }\n   182: \n-  183:         if (showShell) {\n-  184:             int[] shells = new int[] { 10, 5, 3, 1 };\n-  185:             // Shell's sort\n-  186:             long bShell = System.nanoTime();\n-  187:             Integer[] result = ShellSort.sort(shells, unsorted.clone());\n-  188:             if (checkResults && !check(result))\n-  189:                 System.err.println(\"ShellSort failed.\");\n-  190:             long aShell = System.nanoTime();\n-  191:             double diff = (aShell - bShell) / 1000000d / 1000d;\n-  192:             System.out.println(\"Random: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  193:             if (showResult)\n-  194:                 showResult(unsorted, result);\n-  195:             if (showComparison)\n-  196:                 shellResults[shellCount++] = diff;\n-  197:             putOutTheGarbage();\n-  198: \n-  199:             bShell = System.nanoTime();\n-  200:             result = ShellSort.sort(shells, sorted.clone());\n-  201:             if (checkResults && !check(result))\n-  202:                 System.err.println(\"ShellSort failed.\");\n-  203:             aShell = System.nanoTime();\n-  204:             diff = (aShell - bShell) / 1000000d / 1000d;\n-  205:             System.out.println(\"Sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  206:             if (showResult)\n-  207:                 showResult(sorted, result);\n-  208:             if (showComparison)\n-  209:                 shellResults[shellCount++] = diff;\n-  210:             putOutTheGarbage();\n-  211: \n-  212:             bShell = System.nanoTime();\n-  213:             result = ShellSort.sort(shells, reverse.clone());\n-  214:             if (checkResults && !check(result))\n-  215:                 System.err.println(\"ShellSort failed.\");\n-  216:             aShell = System.nanoTime();\n-  217:             diff = (aShell - bShell) / 1000000d / 1000d;\n-  218:             System.out.println(\"Reverse sorted: ShellSort=\" + FORMAT.format(diff) + \" secs\");\n-  219:             if (showResult)\n-  220:                 showResult(reverse, result);\n-  221:             if (showComparison)\n-  222:                 shellResults[shellCount++] = diff;\n-  223:             putOutTheGarbage();\n+  183:     private static class Bubble extends Testable {\n+  184:         @Override\n+  185:         public String getName() {\n+  186:             return \"Bubble sort\";\n+  187:         }\n+  188: \n+  189:         @Override\n+  190:         public Integer[] sort(Integer[] input) {\n+  191:             return BubbleSort.sort(input);\n+  192:         }\n+  193:     }\n+  194: \n+  195:     private static class Counting extends Testable {\n+  196:         @Override\n+  197:         public String getName() {\n+  198:             return \"Counting sort\";\n+  199:         }\n+  200: \n+  201:         @Override\n+  202:         public Integer[] sort(Integer[] input) {\n+  203:             return CountingSort.sort(input);\n+  204:         }\n+  205:     }\n+  206: \n+  207:     private static class Heap extends Testable {\n+  208:         @Override\n+  209:         public String getName() {\n+  210:             return \"Heap sort\";\n+  211:         }\n+  212: \n+  213:         @Override\n+  214:         public Integer[] sort(Integer[] input) {\n+  215:             return HeapSort.sort(input);\n+  216:         }\n+  217:     }\n+  218: \n+  219:     private static class Insertion extends Testable {\n+  220:         @Override\n+  221:         public String getName() {\n+  222:             return \"Insertion sort\";\n+  223:         }\n   224: \n-  225:             System.out.println();\n-  226:             System.out.flush();\n-  227:         }\n-  228: \n-  229:         if (showMergeNotInPlace) {\n-  230:             // Merge sort\n-  231:             long bMerge = System.nanoTime();\n-  232:             Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, unsorted.clone());\n-  233:             if (checkResults && !check(result))\n-  234:                 System.err.println(\"MergeSort failed.\");\n-  235:             long aMerge = System.nanoTime();\n-  236:             double diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  237:             System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  238:             if (showResult)\n-  239:                 showResult(unsorted, result);\n-  240:             if (showComparison)\n-  241:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  242:             putOutTheGarbage();\n-  243: \n-  244:             bMerge = System.nanoTime();\n-  245:             result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, sorted.clone());\n-  246:             if (checkResults && !check(result))\n-  247:                 System.err.println(\"MergeSort failed.\");\n-  248:             aMerge = System.nanoTime();\n-  249:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  250:             System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  251:             if (showResult)\n-  252:                 showResult(sorted, result);\n-  253:             if (showComparison)\n-  254:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  255:             putOutTheGarbage();\n-  256: \n-  257:             bMerge = System.nanoTime();\n-  258:             result = MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, reverse.clone());\n-  259:             if (checkResults && !check(result))\n-  260:                 System.err.println(\"MergeSort failed.\");\n-  261:             aMerge = System.nanoTime();\n-  262:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  263:             System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  264:             if (showResult)\n-  265:                 showResult(reverse, result);\n-  266:             if (showComparison)\n-  267:                 mergeNotInPlaceResults[mergeNotInPlaceCount++] = diff;\n-  268:             putOutTheGarbage();\n-  269: \n-  270:             System.out.println();\n-  271:             System.out.flush();\n-  272:         }\n-  273: \n-  274:         if (showMergeInPlace) {\n-  275:             // Merge sort\n-  276:             long bMerge = System.nanoTime();\n-  277:             Integer[] result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, unsorted.clone());\n-  278:             if (checkResults && !check(result))\n-  279:                 System.err.println(\"MergeSort failed.\");\n-  280:             long aMerge = System.nanoTime();\n-  281:             double diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  282:             System.out.println(\"Random: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  283:             if (showResult)\n-  284:                 showResult(unsorted, result);\n-  285:             if (showComparison)\n-  286:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  287:             putOutTheGarbage();\n-  288: \n-  289:             bMerge = System.nanoTime();\n-  290:             result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, sorted.clone());\n-  291:             if (checkResults && !check(result))\n-  292:                 System.err.println(\"MergeSort failed.\");\n-  293:             aMerge = System.nanoTime();\n-  294:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  295:             System.out.println(\"Sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  296:             if (showResult)\n-  297:                 showResult(sorted, result);\n-  298:             if (showComparison)\n-  299:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  300:             putOutTheGarbage();\n-  301: \n-  302:             bMerge = System.nanoTime();\n-  303:             result = MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, reverse.clone());\n-  304:             if (checkResults && !check(result))\n-  305:                 System.err.println(\"MergeSort failed.\");\n-  306:             aMerge = System.nanoTime();\n-  307:             diff = (aMerge - bMerge) / 1000000d / 1000d;\n-  308:             System.out.println(\"Reverse sorted: MergeSort=\" + FORMAT.format(diff) + \" secs\");\n-  309:             if (showResult)\n-  310:                 showResult(reverse, result);\n-  311:             if (showComparison)\n-  312:                 mergeInPlaceResults[mergeInPlaceCount++] = diff;\n-  313:             putOutTheGarbage();\n-  314: \n-  315:             System.out.println();\n-  316:             System.out.flush();\n-  317:         }\n-  318: \n-  319:         if (showQuick) {\n-  320:             // Quicksort\n-  321:             long bQuick = System.nanoTime();\n-  322:             Integer[] result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, unsorted.clone());\n-  323:             if (checkResults && !check(result))\n-  324:                 System.err.println(\"QuickSort failed.\");\n-  325:             long aQuick = System.nanoTime();\n-  326:             double diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  327:             System.out.println(\"Random: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  328:             if (showResult)\n-  329:                 showResult(unsorted, result);\n-  330:             if (showComparison)\n-  331:                 quickResults[quickCount++] = diff;\n-  332:             putOutTheGarbage();\n-  333: \n-  334:             bQuick = System.nanoTime();\n-  335:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, sorted.clone());\n-  336:             if (checkResults && !check(result))\n-  337:                 System.err.println(\"QuickSort failed.\");\n-  338:             aQuick = System.nanoTime();\n-  339:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  340:             System.out.println(\"Sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  341:             if (showResult)\n-  342:                 showResult(sorted, result);\n-  343:             if (showComparison)\n-  344:                 quickResults[quickCount++] = diff;\n-  345:             putOutTheGarbage();\n-  346: \n-  347:             bQuick = System.nanoTime();\n-  348:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, reverse.clone());\n-  349:             if (checkResults && !check(result))\n-  350:                 System.err.println(\"QuickSort failed.\");\n-  351:             aQuick = System.nanoTime();\n-  352:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  353:             System.out.println(\"Reverse sorted: QuickSort first element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  354:             if (showResult)\n-  355:                 showResult(reverse, result);\n-  356:             if (showComparison)\n-  357:                 quickResults[quickCount++] = diff;\n-  358:             putOutTheGarbage();\n-  359: \n-  360:             System.out.println();\n-  361:             System.out.flush();\n-  362: \n-  363:             bQuick = System.nanoTime();\n-  364:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, unsorted.clone());\n-  365:             if (checkResults && !check(result))\n-  366:                 System.err.println(\"QuickSort failed.\");\n-  367:             aQuick = System.nanoTime();\n-  368:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  369:             System.out.println(\"Random: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  370:             if (showResult)\n-  371:                 showResult(unsorted, result);\n-  372:             if (showComparison)\n-  373:                 quickResults[quickCount++] = diff;\n-  374:             putOutTheGarbage();\n-  375: \n-  376:             bQuick = System.nanoTime();\n-  377:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, sorted.clone());\n-  378:             if (checkResults && !check(result))\n-  379:                 System.err.println(\"QuickSort failed.\");\n-  380:             aQuick = System.nanoTime();\n-  381:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  382:             System.out.println(\"Sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  383:             if (showResult)\n-  384:                 showResult(sorted, result);\n-  385:             if (showComparison)\n-  386:                 quickResults[quickCount++] = diff;\n-  387:             putOutTheGarbage();\n-  388: \n-  389:             bQuick = System.nanoTime();\n-  390:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, reverse.clone());\n-  391:             if (checkResults && !check(result))\n-  392:                 System.err.println(\"QuickSort failed.\");\n-  393:             aQuick = System.nanoTime();\n-  394:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  395:             System.out.println(\"Reverse sorted: QuickSort middle element pivot=\" + FORMAT.format(diff) + \" secs\");\n-  396:             if (showResult)\n-  397:                 showResult(reverse, result);\n-  398:             if (showComparison)\n-  399:                 quickResults[quickCount++] = diff;\n-  400:             putOutTheGarbage();\n-  401: \n-  402:             System.out.println();\n-  403:             System.out.flush();\n-  404: \n-  405:             bQuick = System.nanoTime();\n-  406:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, unsorted.clone());\n-  407:             if (checkResults && !check(result))\n-  408:                 System.err.println(\"Random QuickSort failed.\");\n-  409:             aQuick = System.nanoTime();\n-  410:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  411:             System.out.println(\"Random: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  412:             if (showResult)\n-  413:                 showResult(unsorted, result);\n-  414:             if (showComparison)\n-  415:                 quickResults[quickCount++] = diff;\n-  416:             putOutTheGarbage();\n-  417: \n-  418:             bQuick = System.nanoTime();\n-  419:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, sorted.clone());\n-  420:             if (checkResults && !check(result))\n-  421:                 System.err.println(\"Random QuickSort failed.\");\n-  422:             aQuick = System.nanoTime();\n-  423:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  424:             System.out.println(\"Sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  425:             if (showResult)\n-  426:                 showResult(sorted, result);\n-  427:             if (showComparison)\n-  428:                 quickResults[quickCount++] = diff;\n-  429:             putOutTheGarbage();\n-  430: \n-  431:             bQuick = System.nanoTime();\n-  432:             result = QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, reverse.clone());\n-  433:             if (checkResults && !check(result))\n-  434:                 System.err.println(\"Random QuickSort failed.\");\n-  435:             aQuick = System.nanoTime();\n-  436:             diff = (aQuick - bQuick) / 1000000d / 1000d;\n-  437:             System.out.println(\"Reverse sorted: Randomized QuickSort=\" + FORMAT.format(diff) + \" secs\");\n-  438:             if (showResult)\n-  439:                 showResult(reverse, result);\n-  440:             if (showComparison)\n-  441:                 quickResults[quickCount++] = diff;\n-  442:             putOutTheGarbage();\n-  443: \n-  444:             System.out.println();\n-  445:             System.out.flush();\n-  446:         }\n-  447: \n-  448:         if (showHeap) {\n-  449:             // Heapsort\n-  450:             long bHeap = System.nanoTime();\n-  451:             Integer[] result = HeapSort.sort(unsorted.clone());\n-  452:             if (checkResults && !check(result))\n-  453:                 System.err.println(\"HeapSort failed.\");\n-  454:             long aHeap = System.nanoTime();\n-  455:             double diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  456:             System.out.println(\"Random: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  457:             if (showResult)\n-  458:                 showResult(unsorted, result);\n-  459:             if (showComparison)\n-  460:                 heapResults[heapCount++] = diff;\n-  461:             putOutTheGarbage();\n-  462: \n-  463:             bHeap = System.nanoTime();\n-  464:             result = HeapSort.sort(sorted.clone());\n-  465:             if (checkResults && !check(result))\n-  466:                 System.err.println(\"HeapSort failed.\");\n-  467:             aHeap = System.nanoTime();\n-  468:             diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  469:             System.out.println(\"Sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  470:             if (showResult)\n-  471:                 showResult(sorted, result);\n-  472:             if (showComparison)\n-  473:                 heapResults[heapCount++] = diff;\n-  474:             putOutTheGarbage();\n-  475: \n-  476:             bHeap = System.nanoTime();\n-  477:             result = HeapSort.sort(reverse.clone());\n-  478:             if (checkResults && !check(result))\n-  479:                 System.err.println(\"HeapSort failed.\");\n-  480:             aHeap = System.nanoTime();\n-  481:             diff = (aHeap - bHeap) / 1000000d / 1000d;\n-  482:             System.out.println(\"Reverse sorted: HeapSort=\" + FORMAT.format(diff) + \" secs\");\n-  483:             if (showResult)\n-  484:                 showResult(reverse, result);\n-  485:             if (showComparison)\n-  486:                 heapResults[heapCount++] = diff;\n-  487:             putOutTheGarbage();\n-  488: \n-  489:             System.out.println();\n-  490:             System.out.flush();\n-  491:         }\n-  492: \n-  493:         if (showCounting) {\n-  494:             // Counting sort\n-  495:             long bCounting = System.nanoTime();\n-  496:             Integer[] result = CountingSort.sort(unsorted.clone());\n-  497:             if (checkResults && !check(result))\n-  498:                 System.err.println(\"CountingSort failed.\");\n-  499:             long aCounting = System.nanoTime();\n-  500:             double diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  501:             System.out.println(\"Random: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  502:             if (showResult)\n-  503:                 showResult(unsorted, result);\n-  504:             if (showComparison)\n-  505:                 countingResults[countingCount++] = diff;\n-  506:             putOutTheGarbage();\n-  507: \n-  508:             bCounting = System.nanoTime();\n-  509:             result = CountingSort.sort(sorted.clone());\n-  510:             if (checkResults && !check(result))\n-  511:                 System.err.println(\"CountingSort failed.\");\n-  512:             aCounting = System.nanoTime();\n-  513:             diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  514:             System.out.println(\"Sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  515:             if (showResult)\n-  516:                 showResult(sorted, result);\n-  517:             if (showComparison)\n-  518:                 countingResults[countingCount++] = diff;\n-  519:             putOutTheGarbage();\n-  520: \n-  521:             bCounting = System.nanoTime();\n-  522:             result = CountingSort.sort(reverse.clone());\n-  523:             if (checkResults && !check(result))\n-  524:                 System.err.println(\"CountingSort failed.\");\n-  525:             aCounting = System.nanoTime();\n-  526:             diff = (aCounting - bCounting) / 1000000d / 1000d;\n-  527:             System.out.println(\"Reverse sorted: CountingSort=\" + FORMAT.format(diff) + \" secs\");\n-  528:             if (showResult)\n-  529:                 showResult(reverse, result);\n-  530:             if (showComparison)\n-  531:                 countingResults[countingCount++] = diff;\n-  532:             putOutTheGarbage();\n-  533: \n-  534:             System.out.println();\n-  535:             System.out.flush();\n-  536:         }\n-  537: \n-  538:         if (showRadix) {\n-  539:             // Radix sort\n-  540:             long bRadix = System.nanoTime();\n-  541:             Integer[] result = RadixSort.sort(unsorted.clone());\n-  542:             if (checkResults && !check(result))\n-  543:                 System.err.println(\"RadixSort failed.\");\n-  544:             long aRadix = System.nanoTime();\n-  545:             double diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  546:             System.out.println(\"Random: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  547:             if (showResult)\n-  548:                 showResult(unsorted, result);\n-  549:             if (showComparison)\n-  550:                 radixResults[radixCount++] = diff;\n-  551:             putOutTheGarbage();\n-  552: \n-  553:             bRadix = System.nanoTime();\n-  554:             result = RadixSort.sort(sorted.clone());\n-  555:             if (checkResults && !check(result))\n-  556:                 System.err.println(\"RadixSort failed.\");\n-  557:             aRadix = System.nanoTime();\n-  558:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  559:             System.out.println(\"Sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  560:             if (showResult)\n-  561:                 showResult(sorted, result);\n-  562:             if (showComparison)\n-  563:                 radixResults[radixCount++] = diff;\n-  564:             putOutTheGarbage();\n-  565: \n-  566:             bRadix = System.nanoTime();\n-  567:             result = RadixSort.sort(reverse.clone());\n-  568:             if (checkResults && !check(result))\n-  569:                 System.err.println(\"RadixSort failed.\");\n-  570:             aRadix = System.nanoTime();\n-  571:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  572:             System.out.println(\"Reverse sorted: RadixSort=\" + FORMAT.format(diff) + \" secs\");\n-  573:             if (showResult)\n-  574:                 showResult(reverse, result);\n-  575:             if (showComparison)\n-  576:                 radixResults[radixCount++] = diff;\n-  577:             putOutTheGarbage();\n-  578: \n-  579:             System.out.println();\n-  580:             System.out.flush();\n-  581:         }\n-  582: \n-  583:         if (showAmericanFlag) {\n-  584:             // American Flag sort\n-  585:             long bRadix = System.nanoTime();\n-  586:             Integer[] result = AmericanFlagSort.sort(unsorted.clone());\n-  587:             if (checkResults && !check(result))\n-  588:                 System.err.println(\"AmericanFlag sort failed.\");\n-  589:             long aRadix = System.nanoTime();\n-  590:             double diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  591:             System.out.println(\"Random: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  592:             if (showResult)\n-  593:                 showResult(unsorted, result);\n-  594:             if (showComparison)\n-  595:                 americanFlagResults[americanFlagCount++] = diff;\n-  596:             putOutTheGarbage();\n-  597: \n-  598:             bRadix = System.nanoTime();\n-  599:             result = AmericanFlagSort.sort(sorted.clone());\n-  600:             if (checkResults && !check(result))\n-  601:                 System.err.println(\"AmericanFlag sort failed.\");\n-  602:             aRadix = System.nanoTime();\n-  603:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  604:             System.out.println(\"Sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  605:             if (showResult)\n-  606:                 showResult(sorted, result);\n-  607:             if (showComparison)\n-  608:                 americanFlagResults[americanFlagCount++] = diff;\n-  609:             putOutTheGarbage();\n-  610: \n-  611:             bRadix = System.nanoTime();\n-  612:             result = AmericanFlagSort.sort(reverse.clone());\n-  613:             if (checkResults && !check(result))\n-  614:                 System.err.println(\"AmericanFlag sort failed.\");\n-  615:             aRadix = System.nanoTime();\n-  616:             diff = (aRadix - bRadix) / 1000000d / 1000d;\n-  617:             System.out.println(\"Reverse sorted: AmericanFlag sort=\" + FORMAT.format(diff) + \" secs\");\n-  618:             if (showResult)\n-  619:                 showResult(reverse, result);\n-  620:             if (showComparison)\n-  621:                 americanFlagResults[americanFlagCount++] = diff;\n-  622:             putOutTheGarbage();\n-  623: \n-  624:             System.out.println();\n-  625:             System.out.flush();\n-  626:         }\n-  627: \n-  628:         if (showComparison)\n-  629:             showComparison();\n-  630:     }\n+  225:         @Override\n+  226:         public Integer[] sort(Integer[] input) {\n+  227:             return InsertionSort.sort(input);\n+  228:         }\n+  229:     }\n+  230: \n+  231:     private static class MergeInPlace extends Testable {\n+  232:         @Override\n+  233:         public String getName() {\n+  234:             return \"MergeInPlace sort\";\n+  235:         }\n+  236: \n+  237:         @Override\n+  238:         public Integer[] sort(Integer[] input) {\n+  239:             return MergeSort.sort(MergeSort.SPACE_TYPE.IN_PLACE, input);\n+  240:         }\n+  241:     }\n+  242: \n+  243:     private static class MergeNotInPlace extends Testable {\n+  244:         @Override\n+  245:         public String getName() {\n+  246:             return \"MergeInPlace sort\";\n+  247:         }\n+  248: \n+  249:         @Override\n+  250:         public Integer[] sort(Integer[] input) {\n+  251:             return MergeSort.sort(MergeSort.SPACE_TYPE.NOT_IN_PLACE, input);\n+  252:         }\n+  253:     }\n+  254: \n+  255:     private static class QuickFirst extends Testable {\n+  256:         @Override\n+  257:         public String getName() {\n+  258:             return \"Quick (first) sort\";\n+  259:         }\n+  260: \n+  261:         @Override\n+  262:         public Integer[] sort(Integer[] input) {\n+  263:             return QuickSort.sort(QuickSort.PIVOT_TYPE.FIRST, input);\n+  264:         }\n+  265:     }\n+  266: \n+  267:     private static class QuickMiddle extends Testable {\n+  268:         @Override\n+  269:         public String getName() {\n+  270:             return \"Quick (middle) sort\";\n+  271:         }\n+  272: \n+  273:         @Override\n+  274:         public Integer[] sort(Integer[] input) {\n+  275:             return QuickSort.sort(QuickSort.PIVOT_TYPE.MIDDLE, input);\n+  276:         }\n+  277:     }\n+  278: \n+  279:     private static class QuickRandom extends Testable {\n+  280:         @Override\n+  281:         public String getName() {\n+  282:             return \"Quick (random) sort\";\n+  283:         }\n+  284: \n+  285:         @Override\n+  286:         public Integer[] sort(Integer[] input) {\n+  287:             return QuickSort.sort(QuickSort.PIVOT_TYPE.RANDOM, input);\n+  288:         }\n+  289:     }\n+  290: \n+  291:     private static class Radix extends Testable {\n+  292:         @Override\n+  293:         public String getName() {\n+  294:             return \"Radix sort\";\n+  295:         }\n+  296: \n+  297:         @Override\n+  298:         public Integer[] sort(Integer[] input) {\n+  299:             return RadixSort.sort(input);\n+  300:         }\n+  301:     }\n+  302: \n+  303:     private static class Shell extends Testable {\n+  304:         int[] shells = new int[] { 10, 5, 3, 1 };\n+  305:  \n+  306:         @Override\n+  307:         public String getName() {\n+  308:             return \"Shell sort\";\n+  309:         }\n+  310: \n+  311:         @Override\n+  312:         public Integer[] sort(Integer[] input) {\n+  313:             return ShellSort.sort(shells, input);\n+  314:         }\n+  315:     }\n+  316: \n+  317:     private static final void showComparison() {\n+  318:         StringBuilder resultsBuilder = new StringBuilder();\n+  319:         resultsBuilder.append(\"Number of integers = \").append(SIZE).append(\"\\n\");\n+  320:         String format = \"%-32s%-15s%-15s%-15s\\n\";\n+  321:         Formatter formatter = new Formatter(resultsBuilder, Locale.US);\n+  322: \n+  323:         formatter.format(format, \"Algorithm\",\"Random\",\"Sorted\",\"Reverse Sorted\");\n+  324:         if (insertionResults!=null) {\n+  325:             int i = 0;\n+  326:             formatter.format(format, \"Insertion sort\", FORMAT.format(insertionResults[i++]), FORMAT.format(insertionResults[i++]), FORMAT.format(insertionResults[i++]));\n+  327:         }\n+  328:         if (bubbleResults!=null) {\n+  329:             int i = 0;\n+  330:             formatter.format(format, \"Bubble sort\", FORMAT.format(bubbleResults[i++]), FORMAT.format(bubbleResults[i++]), FORMAT.format(bubbleResults[i++]));\n+  331:         }\n+  332:         if (shellResults!=null) {\n+  333:             int i = 0;\n+  334:             formatter.format(format, \"Shell sort\", FORMAT.format(shellResults[i++]), FORMAT.format(shellResults[i++]), FORMAT.format(shellResults[i++]));\n+  335:         }\n+  336:         if (mergeResults!=null) {\n+  337:             int i = 0;\n+  338:             formatter.format(format, \"Merge (in-place) sort\", FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]));\n+  339:             formatter.format(format, \"Merge (not-in-place) sort\", FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]), FORMAT.format(mergeResults[i++]));\n+  340:         }\n+  341:         if (quickResults!=null) {\n+  342:             int i = 0;\n+  343:             formatter.format(format, \"Quicksort with first as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  344:             formatter.format(format, \"Quicksort with middle as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  345:             formatter.format(format, \"Quicksort with random as pivot\", FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]), FORMAT.format(quickResults[i++]));\n+  346:         }\n+  347:         if (heapResults!=null) {\n+  348:             int i = 0;\n+  349:             formatter.format(format, \"Heap sort\", FORMAT.format(heapResults[i++]), FORMAT.format(heapResults[i++]), FORMAT.format(heapResults[i++]));\n+  350:         }\n+  351:         if (countingResults!=null) {\n+  352:             int i = 0;\n+  353:             formatter.format(format, \"Counting sort\", FORMAT.format(countingResults[i++]), FORMAT.format(countingResults[i++]), FORMAT.format(countingResults[i++]));\n+  354:         }\n+  355:         if (radixResults!=null) {\n+  356:             int i = 0;\n+  357:             formatter.format(format, \"Radix sort\", FORMAT.format(radixResults[i++]), FORMAT.format(radixResults[i++]), FORMAT.format(radixResults[i++]));\n+  358:         }\n+  359:         if (americanFlagResults!=null) {\n+  360:             int i = 0;\n+  361:             formatter.format(format, \"American Flag sort\", FORMAT.format(americanFlagResults[i++]), FORMAT.format(americanFlagResults[i++]), FORMAT.format(americanFlagResults[i++]));\n+  362:         }\n+  363:         formatter.close();\n+  364:         System.out.println(resultsBuilder.toString());\n+  365:     }\n+  366: \n+  367:     private static final void showResult(Integer[] u, Integer[] r) {\n+  368:         System.out.println(\"Unsorted: \" + print(u));\n+  369:         System.out.println(\"Sorted: \" + print(r));\n+  370:         System.out.flush();\n+  371:     }\n+  372: \n+  373:     private static final boolean check(Integer[] array) {\n+  374:         for (int i = 1; i < array.length; i++) {\n+  375:             if (array[i - 1] > array[i])\n+  376:                 return false;\n+  377:         }\n+  378:         return true;\n+  379:     }\n+  380: \n+  381:     public static final String print(Integer[] array) {\n+  382:         return print(array, 0, array.length);\n+  383:     }\n+  384: \n+  385:     public static final String print(Integer[] array, int start, int length) {\n+  386:         final Integer[] clone = array.clone();\n+  387:         StringBuilder builder = new StringBuilder();\n+  388:         for (int i = 0; i < length; i++) {\n+  389:             int e = clone[start + i];\n+  390:             builder.append(e + \" \");\n+  391:         }\n+  392:         return builder.toString();\n+  393:     }\n+  394: \n+  395:     public static final String printWithPivot(Integer[] array, int pivotIndex, int start, int length) {\n+  396:         final Integer[] clone = array.clone();\n+  397:         StringBuilder builder = new StringBuilder();\n+  398:         for (int i = 0; i < length; i++) {\n+  399:             int e = clone[start + i];\n+  400:             if (i == pivotIndex)\n+  401:                 builder.append(\"`\" + e + \"` \");\n+  402:             else\n+  403:                 builder.append(e + \" \");\n+  404:         }\n+  405:         return builder.toString();\n+  406:     }\n+  407: \n+  408:     private static final void putOutTheGarbage() {\n+  409:         collectGarbage();\n+  410:         collectGarbage();\n+  411:         collectGarbage();\n+  412:     }\n+  413: \n+  414:     private static final long fSLEEP_INTERVAL = 100;\n+  415: \n+  416:     private static final void collectGarbage() {\n+  417:         try {\n+  418:             System.gc();\n+  419:             System.gc();\n+  420:             System.gc();\n+  421:             Thread.sleep(fSLEEP_INTERVAL);\n+  422:             System.runFinalization();\n+  423:             Thread.sleep(fSLEEP_INTERVAL);\n+  424:         } catch (InterruptedException ex) {\n+  425:             ex.printStackTrace();\n+  426:         }\n+  427:     }\n+  428: }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/spring-projects/spring-security.git",
        "branch": "master",
        "commitId": "64938ebcfc2fc8cd9ccd6cf31dbcd8cdd0660aca",
        "sourceCodeBeforeRefactoring": "/**\n\t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n\t * mapped to Spring Expressions. Each entry is considered in order and only the first\n\t * match is used.\n\t *\n\t * For example:\n\t *\n\t * <pre>\n\t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n\t * \n\t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n\t * </pre>\n\t *\n\t * <p>\n\t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n\t * However, only \"/public/**\" would be used since it is the first entry. That means\n\t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n\t * </p>\n\t *\n\t * <p>\n\t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n\t * </p>\n\t *\n\t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n\t * that are turned into an Expression using\n\t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n\t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n\t */\n\tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n\t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n\t\tDefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();\n\n\t\tLinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n\n\t\tfor (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n\t\t\tMessageMatcher<?> matcher = entry.getKey();\n\t\t\tString rawExpression = entry.getValue();\n\t\t\tExpression expression = handler.getExpressionParser().parseExpression(\n\t\t\t\t\trawExpression);\n\t\t\tConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n\t\t\tmatcherToAttrs.put(matcher, Arrays.asList(attribute));\n\t\t}\n\t\treturn new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n\t}",
        "refactoredCode": "### Original Code:\n```java\n/**\n * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n * mapped to Spring Expressions. Each entry is considered in order and only the first\n * match is used.\n *\n * For example:\n *\n * <pre>\n *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n * \n *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n * </pre>\n *\n * <p>\n * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n * However, only \"/public/**\" would be used since it is the first entry. That means\n * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n * </p>\n *\n * <p>\n * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n * </p>\n *\n * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n * that are turned into an Expression using\n * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n */\npublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n        LinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n    DefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();\n\n    LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n\n    for (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n        MessageMatcher<?> matcher = entry.getKey();\n        String rawExpression = entry.getValue();\n        Expression expression = handler.getExpressionParser().parseExpression(\n                rawExpression);\n        ConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n        matcherToAttrs.put(matcher, Arrays.asList(attribute));\n    }\n    return new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n}\n```\n\n### Refactored Code:\n```java\n/**\n * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n * mapped to Spring Expressions. Each entry is considered in order and only the first\n * match is used.\n *\n * For example:\n *\n * <pre>\n *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n * \n *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n * </pre>\n *\n * <p>\n * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n * However, only \"/public/**\" would be used since it is the first entry. That means\n * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n * </p>\n *\n * <p>\n * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n * </p>\n *\n * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n * that are turned into an Expression using\n * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n */\npublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n        LinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n    LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = createMatcherToAttributes(matcherToExpression);\n    return new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n}\n\nprivate static LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> createMatcherToAttributes(\n        LinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n    DefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();\n    LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<>();\n\n    for (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n        MessageMatcher<?> matcher = entry.getKey();\n        String rawExpression = entry.getValue();\n        ConfigAttribute attribute = createConfigAttribute(handler, rawExpression);\n        matcherToAttrs.put(matcher, Arrays.asList(attribute));\n    }\n    return matcherToAttrs;\n}\n\nprivate static ConfigAttribute createConfigAttribute(DefaultMessageSecurityExpressionHandler<Object> handler, String rawExpression) {\n    Expression expression = handler.getExpressionParser().parseExpression(rawExpression);\n    return new MessageExpressionConfigAttribute(expression);\n}\n```\n\n### Explanation of Changes:\n1. **Method Extraction**: The original method `createExpressionMessageMetadataSource` was broken down into three methods:\n   - `createExpressionMessageMetadataSource`: The main orchestrator method that calls the new helper methods.\n   - `createMatcherToAttributes`: Responsible for creating the mapping of matchers to attributes.\n   - `createConfigAttribute`: Responsible for creating a `ConfigAttribute` from a raw expression.\n\n2. **Single Responsibility**: Each new method has a clear, single responsibility, improving readability and maintainability.\n\n3. **Functionality Unchanged**: The refactored code maintains the same functionality as the original code.",
        "sourceCodeAfterRefactoring": "/**\n\t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n\t * mapped to Spring Expressions. Each entry is considered in order and only the first\n\t * match is used.\n\t *\n\t * For example:\n\t *\n\t * <pre>\n\t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n\t *\n\t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n\t * </pre>\n\t *\n\t * <p>\n\t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n\t * However, only \"/public/**\" would be used since it is the first entry. That means\n\t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n\t * </p>\n\t *\n\t * <p>\n\t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n\t * </p>\n\t *\n\t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n\t * that are turned into an Expression using\n\t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n\t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n\t */\n\tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n\t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n\t\treturn createExpressionMessageMetadataSource(matcherToExpression, new DefaultMessageSecurityExpressionHandler<Object>());\n\t}\n/**\n\t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n\t * mapped to Spring Expressions. Each entry is considered in order and only the first\n\t * match is used.\n\t *\n\t * For example:\n\t *\n\t * <pre>\n\t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n\t *\n\t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n\t * </pre>\n\t *\n\t * <p>\n\t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n\t * However, only \"/public/**\" would be used since it is the first entry. That means\n\t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n\t * </p>\n\t *\n\t * <p>\n\t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n\t * </p>\n\t *\n\t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n\t * that are turned into an Expression using\n\t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n\t * @param handler the {@link SecurityExpressionHandler} to use\n\t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n\t */\n\tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n\t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression, SecurityExpressionHandler<Message<Object>> handler) {\n\n\t\tLinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n\n\t\tfor (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n\t\t\tMessageMatcher<?> matcher = entry.getKey();\n\t\t\tString rawExpression = entry.getValue();\n\t\t\tExpression expression = handler.getExpressionParser().parseExpression(\n\t\t\t\t\trawExpression);\n\t\t\tConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n\t\t\tmatcherToAttrs.put(matcher, Arrays.asList(attribute));\n\t\t}\n\t\treturn new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n\t}",
        "diffSourceCode": "-   38: \t/**\n-   39: \t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n-   40: \t * mapped to Spring Expressions. Each entry is considered in order and only the first\n-   41: \t * match is used.\n-   42: \t *\n-   43: \t * For example:\n+   38: public final class ExpressionBasedMessageSecurityMetadataSourceFactory {\n+   39: \n+   40: \t/**\n+   41: \t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n+   42: \t * mapped to Spring Expressions. Each entry is considered in order and only the first\n+   43: \t * match is used.\n    44: \t *\n-   45: \t * <pre>\n-   46: \t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n-   47: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n-   48: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n-   49: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n-   50: \t * \n-   51: \t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n-   52: \t * </pre>\n-   53: \t *\n-   54: \t * <p>\n-   55: \t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n-   56: \t * However, only \"/public/**\" would be used since it is the first entry. That means\n-   57: \t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n-   58: \t * </p>\n-   59: \t *\n-   60: \t * <p>\n-   61: \t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n-   62: \t * </p>\n-   63: \t *\n-   64: \t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n-   65: \t * that are turned into an Expression using\n-   66: \t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n-   67: \t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n-   68: \t */\n-   69: \tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n-   70: \t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n-   71: \t\tDefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();\n-   72: \n-   73: \t\tLinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n-   74: \n-   75: \t\tfor (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n-   76: \t\t\tMessageMatcher<?> matcher = entry.getKey();\n-   77: \t\t\tString rawExpression = entry.getValue();\n-   78: \t\t\tExpression expression = handler.getExpressionParser().parseExpression(\n-   79: \t\t\t\t\trawExpression);\n-   80: \t\t\tConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n-   81: \t\t\tmatcherToAttrs.put(matcher, Arrays.asList(attribute));\n-   82: \t\t}\n-   83: \t\treturn new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n-   84: \t}\n-   85: \n-   86: \tprivate ExpressionBasedMessageSecurityMetadataSourceFactory() {\n-   87: \t}\n-   88: }\n+   45: \t * For example:\n+   46: \t *\n+   47: \t * <pre>\n+   48: \t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n+   49: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n+   50: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n+   51: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n+   52: \t *\n+   53: \t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n+   54: \t * </pre>\n+   55: \t *\n+   56: \t * <p>\n+   57: \t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n+   58: \t * However, only \"/public/**\" would be used since it is the first entry. That means\n+   59: \t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n+   60: \t * </p>\n+   61: \t *\n+   62: \t * <p>\n+   63: \t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n+   64: \t * </p>\n+   65: \t *\n+   66: \t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n+   67: \t * that are turned into an Expression using\n+   68: \t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n+   69: \t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n+   70: \t */\n+   71: \tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n+   72: \t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n+   73: \t\treturn createExpressionMessageMetadataSource(matcherToExpression, new DefaultMessageSecurityExpressionHandler<Object>());\n+   74: \t}\n+   75: \n+   76: \t/**\n+   77: \t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n+   78: \t * mapped to Spring Expressions. Each entry is considered in order and only the first\n+   79: \t * match is used.\n+   80: \t *\n+   81: \t * For example:\n+   82: \t *\n+   83: \t * <pre>\n+   84: \t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n+   85: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n+   86: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n+   87: \t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n+   88: \t *\n+   89: \t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n+   90: \t * </pre>\n+   91: \t *\n+   92: \t * <p>\n+   93: \t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n+   94: \t * However, only \"/public/**\" would be used since it is the first entry. That means\n+   95: \t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n+   96: \t * </p>\n+   97: \t *\n+   98: \t * <p>\n+   99: \t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n+  100: \t * </p>\n+  101: \t *\n+  102: \t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n+  103: \t * that are turned into an Expression using\n+  104: \t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n+  105: \t * @param handler the {@link SecurityExpressionHandler} to use\n+  106: \t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n+  107: \t */\n+  108: \tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n+  109: \t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression, SecurityExpressionHandler<Message<Object>> handler) {\n+  110: \n+  111: \t\tLinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n+  112: \n+  113: \t\tfor (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n+  114: \t\t\tMessageMatcher<?> matcher = entry.getKey();\n+  115: \t\t\tString rawExpression = entry.getValue();\n+  116: \t\t\tExpression expression = handler.getExpressionParser().parseExpression(\n+  117: \t\t\t\t\trawExpression);\n+  118: \t\t\tConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n+  119: \t\t\tmatcherToAttrs.put(matcher, Arrays.asList(attribute));\n+  120: \t\t}\n+  121: \t\treturn new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n+  122: \t}\n",
        "uniqueId": "64938ebcfc2fc8cd9ccd6cf31dbcd8cdd0660aca_38_84_76_122_40_74",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n /**\n\t * This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n\t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n\t * on the output message. It then calls {@link #writeInternal}.\n\t */\n\t@Override\n\tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType type = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (type != null ? type : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() == -1) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n\t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n\t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n SourceCodeAfterRefactoring:\n/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */\n\t@Override\n\tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n\t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n\t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n\t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n\t * @since 4.2\n\t */\n\tprotected void addDefaultHeaders(final HttpHeaders headers, final T t, MediaType contentType)\n\t\t\tthrows IOException{\n\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() == -1) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}\n DiffSourceCode:\n   162: \t/**\n-  163: \t * This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n-  164: \t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n-  165: \t * on the output message. It then calls {@link #writeInternal}.\n-  166: \t */\n-  167: \t@Override\n-  168: \tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n-  169: \t\t\tthrows IOException, HttpMessageNotWritableException {\n-  170: \n-  171: \t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n-  172: \t\tif (headers.getContentType() == null) {\n-  173: \t\t\tMediaType contentTypeToUse = contentType;\n-  174: \t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n-  175: \t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n-  176: \t\t\t}\n-  177: \t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n-  178: \t\t\t\tMediaType type = getDefaultContentType(t);\n-  179: \t\t\t\tcontentTypeToUse = (type != null ? type : contentTypeToUse);\n-  180: \t\t\t}\n-  181: \t\t\tif (contentTypeToUse != null) {\n-  182: \t\t\t\theaders.setContentType(contentTypeToUse);\n-  183: \t\t\t}\n-  184: \t\t}\n-  185: \t\tif (headers.getContentLength() == -1) {\n-  186: \t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n-  187: \t\t\tif (contentLength != null) {\n-  188: \t\t\t\theaders.setContentLength(contentLength);\n-  189: \t\t\t}\n-  190: \t\t}\n-  191: \n-  192: \t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n-  193: \t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n-  194: \t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n-  195: \t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n-  196: \t\t\t\t@Override\n-  197: \t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n-  198: \t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n-  199: \t\t\t\t\t\t@Override\n-  200: \t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n-  201: \t\t\t\t\t\t\treturn outputStream;\n-  202: \t\t\t\t\t\t}\n-  203: \t\t\t\t\t\t@Override\n-  204: \t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n-  205: \t\t\t\t\t\t\treturn headers;\n-  206: \t\t\t\t\t\t}\n-  207: \t\t\t\t\t});\n-  208: \t\t\t\t}\n-  209: \t\t\t});\n-  210: \t\t}\n-  211: \t\telse {\n-  212: \t\t\twriteInternal(t, outputMessage);\n-  213: \t\t\toutputMessage.getBody().flush();\n-  214: \t\t}\n-  215: \t}\n-  216: \n-  217: \t/**\n-  218: \t * Returns the default content type for the given type. Called when {@link #write}\n-  219: \t * is invoked without a specified content type parameter.\n-  220: \t * <p>By default, this returns the first element of the\n-  221: \t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} property, if any.\n-  222: \t * Can be overridden in subclasses.\n-  223: \t * @param t the type to return the content type for\n-  224: \t * @return the content type, or {@code null} if not known\n-  225: \t */\n-  226: \tprotected MediaType getDefaultContentType(T t) throws IOException {\n+  163: \t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n+  164: \t * and then calls {@link #writeInternal}.\n+  165: \t */\n+  166: \t@Override\n+  167: \tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n+  168: \t\t\tthrows IOException, HttpMessageNotWritableException {\n+  169: \n+  170: \t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n+  171: \t\taddDefaultHeaders(headers, t, contentType);\n+  172: \n+  173: \t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n+  174: \t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n+  175: \t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n+  176: \t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n+  177: \t\t\t\t@Override\n+  178: \t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n+  179: \t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n+  180: \t\t\t\t\t\t@Override\n+  181: \t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n+  182: \t\t\t\t\t\t\treturn outputStream;\n+  183: \t\t\t\t\t\t}\n+  184: \t\t\t\t\t\t@Override\n+  185: \t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n+  186: \t\t\t\t\t\t\treturn headers;\n+  187: \t\t\t\t\t\t}\n+  188: \t\t\t\t\t});\n+  189: \t\t\t\t}\n+  190: \t\t\t});\n+  191: \t\t}\n+  192: \t\telse {\n+  193: \t\t\twriteInternal(t, outputMessage);\n+  194: \t\t\toutputMessage.getBody().flush();\n+  195: \t\t}\n+  196: \t}\n+  197: \n+  198: \t/**\n+  199: \t * Add default headers to the output message.\n+  200: \t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n+  201: \t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n+  202: \t * @since 4.2\n+  203: \t */\n+  204: \tprotected void addDefaultHeaders(final HttpHeaders headers, final T t, MediaType contentType)\n+  205: \t\t\tthrows IOException{\n+  206: \n+  207: \t\tif (headers.getContentType() == null) {\n+  208: \t\t\tMediaType contentTypeToUse = contentType;\n+  209: \t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n+  210: \t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n+  211: \t\t\t}\n+  212: \t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n+  213: \t\t\t\tMediaType mediaType = getDefaultContentType(t);\n+  214: \t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n+  215: \t\t\t}\n+  216: \t\t\tif (contentTypeToUse != null) {\n+  217: \t\t\t\theaders.setContentType(contentTypeToUse);\n+  218: \t\t\t}\n+  219: \t\t}\n+  220: \t\tif (headers.getContentLength() == -1) {\n+  221: \t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n+  222: \t\t\tif (contentLength != null) {\n+  223: \t\t\t\theaders.setContentLength(contentLength);\n+  224: \t\t\t}\n+  225: \t\t}\n+  226: \t}\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Test\n\tpublic void handerAdaptersCreated() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n\t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n\t\t\t\t.getMessageConverters().isEmpty());\n\t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n\t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n\t\t\t\t\t\t.getMessageConverters());\n\t}\n@Test\n\tpublic void handerMappingsCreated() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n\t}\n@Test\n\tpublic void resourceHandlerMapping() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(5));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(WebJars.class, Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideAll() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingDisabled() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.resources.add-mappings:false\");\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.size(), equalTo(0));\n\t}\n@Test\n\tpublic void noLocaleResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n\t\tthis.context.getBean(LocaleResolver.class);\n\t}\n@Test\n\tpublic void overrideLocale() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\t// set fixed locale\n\t\tEnvironmentTestUtils.addEnvironment(this.context, \"spring.mvc.locale:en_UK\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\t// mock request and set user preferred locale\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n\t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n\t\tLocale locale = localeResolver.resolveLocale(request);\n\t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n\t\t// test locale resolver uses fixed locale and not user preferred locale\n\t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n\t}\n@Test\n\tpublic void noDateFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\t// formatting cs should use simple toString()\n\t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n\t}\n@Test\n\tpublic void overrideDateFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\t// set fixed date format\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.dateFormat:dd*MM*yyyy\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n\t}\n@Test\n\tpublic void noMessageCodesResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void overrideMessageCodesFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertEquals(true,\n\t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n\t}\n@Test\n\tpublic void customViewResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, CustomViewResolver.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n\t}\n@Test\n\tpublic void customContentNegotiatingViewResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, CustomContentNegotiatingViewResolver.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n\t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n\t\tassertThat(beans.size(), equalTo(1));\n\t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n\t}\n@Test\n\tpublic void faviconMapping() throws IllegalAccessException {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n\t\t\t\t\t\t\"faviconRequestHandler\"), is(notNullValue()));\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n\t\t\t\t\t\t\"faviconHandlerMapping\"), is(notNullValue()));\n\t\tMap<String, List<Resource>> mappingLocations = getFaviconMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**/favicon.ico\").size(), equalTo(5));\n\t}\n@Test\n\tpublic void faviconMappingDisabled() throws IllegalAccessException {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.favicon.enabled:false\");\n\t\tthis.context.refresh();\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n\t\t\t\t\t\t\"faviconRequestHandler\"), is(nullValue()));\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n\t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n\t}\n@Test\n\tpublic void defaultAsyncRequestTimeout() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n\t}\n@Test\n\tpublic void customAsyncRequestTimeout() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.async.request-timeout:123456\");\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tObject actual = ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\");\n\t\tassertEquals(123456L, actual);\n\t}\n SourceCodeAfterRefactoring:\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n\t\tload(WebJars.class);\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\t public void resourceHandlerMappingOverrideAll() throws Exception {\n\t\tload(AllResources.class);\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void noLocaleResolver() throws Exception {\n\t\tload(AllResources.class);\n\t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n\t\tthis.context.getBean(LocaleResolver.class);\n\t}\n@Test\n\tpublic void overrideLocale() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.locale:en_UK\");\n\n\t\t// mock request and set user preferred locale\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n\t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n\t\tLocale locale = localeResolver.resolveLocale(request);\n\t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n\t\t// test locale resolver uses fixed locale and not user preferred locale\n\t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n\t}\n@Test\n\tpublic void noDateFormat() throws Exception {\n\t\tload(AllResources.class);\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\t// formatting cs should use simple toString()\n\t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n\t}\n@Test\n\tpublic void overrideDateFormat() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.dateFormat:dd*MM*yyyy\");\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n\t}\n@Test\n\tpublic void noMessageCodesResolver() throws Exception {\n\t\tload(AllResources.class);\n\t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void overrideMessageCodesFormat() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n\t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void customViewResolver() throws Exception {\n\t\tload(CustomViewResolver.class);\n\t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n\t}\n@Test\n\tpublic void customContentNegotiatingViewResolver() throws Exception {\n\t\tload(CustomContentNegotiatingViewResolver.class);\n\t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n\t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n\t\tassertThat(beans.size(), equalTo(1));\n\t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n DiffSourceCode:\n-   99: \t@Test\n-  100: \tpublic void handerAdaptersCreated() throws Exception {\n-  101: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  102: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  103: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  104: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  105: \t\tthis.context.refresh();\n-  106: \t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n-  107: \t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n-  108: \t\t\t\t.getMessageConverters().isEmpty());\n-  109: \t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n-  110: \t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n-  111: \t\t\t\t\t\t.getMessageConverters());\n-  112: \t}\n-  114: \t@Test\n-  115: \tpublic void handerMappingsCreated() throws Exception {\n-  116: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  117: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  118: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  119: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  120: \t\tthis.context.refresh();\n-  121: \t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n-  122: \t}\n-  124: \t@Test\n-  125: \tpublic void resourceHandlerMapping() throws Exception {\n-  126: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  127: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  128: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  129: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  130: \t\tthis.context.refresh();\n-  131: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  132: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(5));\n+   99: \t\t}\n+  100: \t}\n+  101: \n+  102: \t@Test\n+  103: \tpublic void handerAdaptersCreated() throws Exception {\n+  104: \t\tload();\n+  105: \t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n+  106: \t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n+  107: \t\t\t\t.getMessageConverters().isEmpty());\n+  108: \t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n+  109: \t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n+  110: \t\t\t\t\t\t.getMessageConverters());\n+  111: \t}\n+  112: \n+  114: \tpublic void handerMappingsCreated() throws Exception {\n+  115: \t\tload();\n+  116: \t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n+  117: \t}\n+  118: \n+  119: \t@Test\n+  120: \tpublic void resourceHandlerMapping() throws Exception {\n+  121: \t\tload();\n+  122: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n+  124: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n+  125: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n+  126: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n+  127: \t}\n+  128: \n+  129: \t@Test\n+  130: \tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n+  131: \t\tload(WebJars.class);\n+  132: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n   133: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n   134: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n-  135: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n+  135: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n   136: \t}\n   138: \t@Test\n-  139: \tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n-  140: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  141: \t\tthis.context.register(WebJars.class, Config.class, WebMvcAutoConfiguration.class,\n-  142: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  143: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  144: \t\tthis.context.refresh();\n-  145: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  146: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n-  147: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n-  148: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n-  149: \t}\n-  151: \t@Test\n-  152: \tpublic void resourceHandlerMappingOverrideAll() throws Exception {\n-  153: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  154: \t\tthis.context.register(AllResources.class, Config.class,\n-  155: \t\t\t\tWebMvcAutoConfiguration.class,\n-  156: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  157: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  158: \t\tthis.context.refresh();\n-  159: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  160: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n-  161: \t\tassertThat(mappingLocations.get(\"/**\").get(0),\n-  162: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n-  163: \t}\n+  139: \t public void resourceHandlerMappingOverrideAll() throws Exception {\n+  140: \t\tload(AllResources.class);\n+  141: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n+  142: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n+  143: \t\tassertThat(mappingLocations.get(\"/**\").get(0),\n+  144: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n+  145: \t}\n+  146: \n+  147: \t@Test\n+  148: \tpublic void resourceHandlerMappingDisabled() throws Exception {\n+  149: \t\tload(\"spring.resources.add-mappings:false\");\n+  151: \t\tassertThat(mappingLocations.size(), equalTo(0));\n+  152: \t}\n+  153: \n+  154: \t@Test\n+  155: \tpublic void noLocaleResolver() throws Exception {\n+  156: \t\tload(AllResources.class);\n+  157: \t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n+  158: \t\tthis.context.getBean(LocaleResolver.class);\n+  159: \t}\n+  160: \n+  161: \t@Test\n+  162: \tpublic void overrideLocale() throws Exception {\n+  163: \t\tload(AllResources.class, \"spring.mvc.locale:en_UK\");\n   164: \n-  165: \t@Test\n-  166: \tpublic void resourceHandlerMappingDisabled() throws Exception {\n-  167: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  168: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  169: \t\t\t\t\"spring.resources.add-mappings:false\");\n-  170: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  171: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  172: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  173: \t\tthis.context.refresh();\n-  174: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  175: \t\tassertThat(mappingLocations.size(), equalTo(0));\n-  176: \t}\n-  177: \n-  178: \t@Test\n-  179: \tpublic void noLocaleResolver() throws Exception {\n-  180: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  181: \t\tthis.context.register(AllResources.class, Config.class,\n-  182: \t\t\t\tWebMvcAutoConfiguration.class,\n-  183: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  184: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  185: \t\tthis.context.refresh();\n-  186: \t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n-  187: \t\tthis.context.getBean(LocaleResolver.class);\n-  188: \t}\n-  189: \n-  190: \t@Test\n-  191: \tpublic void overrideLocale() throws Exception {\n-  192: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  193: \t\t// set fixed locale\n-  194: \t\tEnvironmentTestUtils.addEnvironment(this.context, \"spring.mvc.locale:en_UK\");\n-  195: \t\tthis.context.register(AllResources.class, Config.class,\n-  196: \t\t\t\tWebMvcAutoConfiguration.class,\n-  197: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  198: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  199: \t\tthis.context.refresh();\n-  200: \t\t// mock request and set user preferred locale\n-  201: \t\tMockHttpServletRequest request = new MockHttpServletRequest();\n-  202: \t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n-  203: \t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n-  204: \t\tLocale locale = localeResolver.resolveLocale(request);\n-  205: \t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n-  206: \t\t// test locale resolver uses fixed locale and not user preferred locale\n-  207: \t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n-  208: \t}\n-  210: \t@Test\n-  211: \tpublic void noDateFormat() throws Exception {\n-  212: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  213: \t\tthis.context.register(AllResources.class, Config.class,\n-  214: \t\t\t\tWebMvcAutoConfiguration.class,\n-  215: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  216: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  217: \t\tthis.context.refresh();\n-  218: \t\tFormattingConversionService cs = this.context\n-  219: \t\t\t\t.getBean(FormattingConversionService.class);\n-  220: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n-  221: \t\t// formatting cs should use simple toString()\n-  222: \t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n-  223: \t}\n-  225: \t@Test\n-  226: \tpublic void overrideDateFormat() throws Exception {\n-  227: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  228: \t\t// set fixed date format\n-  229: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  230: \t\t\t\t\"spring.mvc.dateFormat:dd*MM*yyyy\");\n-  231: \t\tthis.context.register(AllResources.class, Config.class,\n-  232: \t\t\t\tWebMvcAutoConfiguration.class,\n-  233: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  234: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  235: \t\tthis.context.refresh();\n-  236: \t\tFormattingConversionService cs = this.context\n-  237: \t\t\t\t.getBean(FormattingConversionService.class);\n-  238: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n-  239: \t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n-  240: \t}\n-  242: \t@Test\n-  243: \tpublic void noMessageCodesResolver() throws Exception {\n-  244: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  245: \t\tthis.context.register(AllResources.class, Config.class,\n-  246: \t\t\t\tWebMvcAutoConfiguration.class,\n-  247: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  248: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  249: \t\tthis.context.refresh();\n-  250: \t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n-  251: \t\t\t\t.getMessageCodesResolver());\n-  252: \t}\n-  254: \t@Test\n-  255: \tpublic void overrideMessageCodesFormat() throws Exception {\n-  256: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  257: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  258: \t\t\t\t\"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n-  259: \t\tthis.context.register(AllResources.class, Config.class,\n-  260: \t\t\t\tWebMvcAutoConfiguration.class,\n-  261: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  262: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  263: \t\tthis.context.refresh();\n-  264: \t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n-  265: \t\t\t\t.getMessageCodesResolver());\n-  266: \t}\n-  267: \n-  268: \tprotected Map<String, List<Resource>> getFaviconMappingLocations()\n-  269: \t\t\tthrows IllegalAccessException {\n-  271: \t\t\t\t.getBean(\"faviconHandlerMapping\");\n-  272: \t\treturn getMappingLocations(mapping);\n-  273: \t}\n-  274: \n-  275: \tprotected Map<String, List<Resource>> getResourceMappingLocations()\n-  276: \t\t\tthrows IllegalAccessException {\n-  277: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n-  278: \t\t\t\t.getBean(\"resourceHandlerMapping\");\n-  301: \t@Test\n-  302: \tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n-  303: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  304: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  305: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  306: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  307: \t\tthis.context.refresh();\n-  308: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  309: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  310: \t\tassertEquals(true,\n-  311: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n-  312: \t}\n-  322: \t\tthis.context.refresh();\n-  323: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  324: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  325: \t\tassertEquals(false,\n-  326: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n-  327: \t}\n-  328: \n-  329: \t@Test\n-  330: \tpublic void customViewResolver() throws Exception {\n-  331: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  332: \t\tthis.context.register(Config.class, CustomViewResolver.class,\n-  333: \t\t\t\tWebMvcAutoConfiguration.class,\n-  334: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  335: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  336: \t\tthis.context.refresh();\n-  337: \t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n-  338: \t}\n-  340: \t@Test\n-  341: \tpublic void customContentNegotiatingViewResolver() throws Exception {\n-  342: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  343: \t\tthis.context.register(Config.class, CustomContentNegotiatingViewResolver.class,\n-  344: \t\t\t\tWebMvcAutoConfiguration.class,\n-  345: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  346: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  347: \t\tthis.context.refresh();\n-  348: \t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n-  349: \t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n-  350: \t\tassertThat(beans.size(), equalTo(1));\n-  351: \t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n-  352: \t}\n-  354: \t@Test\n-  355: \tpublic void faviconMapping() throws IllegalAccessException {\n-  356: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  357: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  358: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  359: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  360: \t\tthis.context.refresh();\n-  361: \t\tassertThat(\n-  362: \t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n-  363: \t\t\t\t\t\t\"faviconRequestHandler\"), is(notNullValue()));\n-  364: \t\tassertThat(\n-  365: \t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n-  366: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(notNullValue()));\n-  367: \t\tMap<String, List<Resource>> mappingLocations = getFaviconMappingLocations();\n-  368: \t\tassertThat(mappingLocations.get(\"/**/favicon.ico\").size(), equalTo(5));\n+  165: \t\t// mock request and set user preferred locale\n+  166: \t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+  167: \t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n+  168: \t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n+  169: \t\tLocale locale = localeResolver.resolveLocale(request);\n+  170: \t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n+  171: \t\t// test locale resolver uses fixed locale and not user preferred locale\n+  172: \t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n+  173: \t}\n+  174: \n+  175: \t@Test\n+  176: \tpublic void noDateFormat() throws Exception {\n+  177: \t\tload(AllResources.class);\n+  178: \t\tFormattingConversionService cs = this.context\n+  179: \t\t\t\t.getBean(FormattingConversionService.class);\n+  180: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n+  181: \t\t// formatting cs should use simple toString()\n+  182: \t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n+  183: \t}\n+  184: \n+  185: \t@Test\n+  186: \tpublic void overrideDateFormat() throws Exception {\n+  187: \t\tload(AllResources.class, \"spring.mvc.dateFormat:dd*MM*yyyy\");\n+  188: \t\tFormattingConversionService cs = this.context\n+  189: \t\t\t\t.getBean(FormattingConversionService.class);\n+  190: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n+  191: \t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n+  192: \t}\n+  193: \n+  194: \t@Test\n+  195: \tpublic void noMessageCodesResolver() throws Exception {\n+  196: \t\tload(AllResources.class);\n+  197: \t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n+  198: \t\t\t\t.getMessageCodesResolver());\n+  199: \t}\n+  200: \n+  201: \t@Test\n+  202: \tpublic void overrideMessageCodesFormat() throws Exception {\n+  203: \t\tload(AllResources.class, \"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n+  204: \t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n+  205: \t\t\t\t.getMessageCodesResolver());\n+  206: \t}\n+  207: \n+  208: \tprotected Map<String, List<Resource>> getFaviconMappingLocations()\n+  210: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n+  211: \t\t\t\t.getBean(\"faviconHandlerMapping\");\n+  212: \t\treturn getMappingLocations(mapping);\n+  213: \t}\n+  214: \n+  215: \tprotected Map<String, List<Resource>> getResourceMappingLocations()\n+  216: \t\t\tthrows IllegalAccessException {\n+  217: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n+  218: \t\t\t\t.getBean(\"resourceHandlerMapping\");\n+  219: \t\treturn getMappingLocations(mapping);\n+  220: \t}\n+  221: \n+  222: \t@SuppressWarnings(\"unchecked\")\n+  223: \tprotected Map<String, List<Resource>> getMappingLocations(HandlerMapping mapping)\n+  225: \t\tMap<String, List<Resource>> mappingLocations = new LinkedHashMap<String, List<Resource>>();\n+  226: \t\tif (mapping instanceof SimpleUrlHandlerMapping) {\n+  227: \t\t\tField locationsField = ReflectionUtils.findField(\n+  228: \t\t\t\t\tResourceHttpRequestHandler.class, \"locations\");\n+  229: \t\t\tlocationsField.setAccessible(true);\n+  230: \t\t\tfor (Map.Entry<String, Object> entry : ((SimpleUrlHandlerMapping) mapping)\n+  231: \t\t\t\t\t.getHandlerMap().entrySet()) {\n+  232: \t\t\t\tResourceHttpRequestHandler handler = (ResourceHttpRequestHandler) entry\n+  233: \t\t\t\t\t\t.getValue();\n+  234: \t\t\t\tmappingLocations.put(entry.getKey(),\n+  235: \t\t\t\t\t\t(List<Resource>) locationsField.get(handler));\n+  236: \t\t\t}\n+  237: \t\t}\n+  238: \t\treturn mappingLocations;\n+  239: \t}\n+  240: \n+  242: \tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n+  243: \t\tload();\n+  244: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  245: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  246: \t\tassertEquals(true,\n+  247: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n+  248: \t}\n+  249: \n+  250: \t@Test\n+  251: \tpublic void overrideIgnoreDefaultModelOnRedirect() throws Exception {\n+  252: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n+  254: \t\t\t\t\"spring.mvc.ignore-default-model-on-redirect:false\");\n+  255: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n+  256: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n+  257: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n+  258: \t\tthis.context.refresh();\n+  259: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  260: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  261: \t\tassertEquals(false,\n+  262: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n+  263: \t}\n+  264: \n+  265: \t@Test\n+  266: \tpublic void customViewResolver() throws Exception {\n+  267: \t\tload(CustomViewResolver.class);\n+  268: \t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n+  269: \t}\n+  271: \t@Test\n+  272: \tpublic void customContentNegotiatingViewResolver() throws Exception {\n+  273: \t\tload(CustomContentNegotiatingViewResolver.class);\n+  274: \t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n+  275: \t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n+  276: \t\tassertThat(beans.size(), equalTo(1));\n+  277: \t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n+  278: \t}\n+  301: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n+  302: \t}\n+  303: \n+  304: \t@Test\n+  305: \tpublic void defaultAsyncRequestTimeout() throws Exception {\n+  306: \t\tload();\n+  307: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  308: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  309: \t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n+  310: \t}\n+  311: \n+  312: \t@Test\n+  322: \t@SuppressWarnings(\"unchecked\")\n+  323: \tprivate void load(Class<?> config, String... environment) {\n+  324: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n+  325: \t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n+  326: \t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n+  327: \t\tif (config != null) {\n+  328: \t\t\tconfigClasses.add(config);\n+  329: \t\t}\n+  330: \t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n+  331: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n+  332: \t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n+  333: \t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n+  334: \t\tthis.context.refresh();\n+  335: \t}\n+  336: \n+  337: \tprivate void load(String... environment) {\n+  338: \t\tload(null, environment);\n+  340: \n+  341: \n+  342: \t@Configuration\n+  343: \tprotected static class ViewConfig {\n+  344: \n+  345: \t\t@Bean\n+  346: \t\tpublic View jsonView() {\n+  347: \t\t\treturn new AbstractView() {\n+  348: \n+  349: \t\t\t\t@Override\n+  350: \t\t\t\tprotected void renderMergedOutputModel(Map<String, Object> model,\n+  351: \t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response)\n+  352: \t\t\t\t\t\tthrows Exception {\n+  354: \t\t\t\t}\n+  355: \t\t\t};\n+  356: \t\t}\n+  357: \n+  358: \t}\n+  359: \n+  360: \t@Configuration\n+  361: \tprotected static class WebJars extends WebMvcConfigurerAdapter {\n+  362: \n+  363: \t\t@Override\n+  364: \t\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n+  365: \t\t\tregistry.addResourceHandler(\"/webjars/**\").addResourceLocations(\n+  366: \t\t\t\t\t\"classpath:/foo/\");\n+  367: \t\t}\n+  368: \n   369: \t}\n-  371: \t@Test\n-  372: \tpublic void faviconMappingDisabled() throws IllegalAccessException {\n-  373: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  374: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  375: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  376: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  377: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  378: \t\t\t\t\"spring.mvc.favicon.enabled:false\");\n-  379: \t\tthis.context.refresh();\n-  380: \t\tassertThat(\n-  381: \t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n-  382: \t\t\t\t\t\t\"faviconRequestHandler\"), is(nullValue()));\n-  383: \t\tassertThat(\n-  384: \t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n-  385: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n-  386: \t}\n-  388: \t@Test\n-  389: \tpublic void defaultAsyncRequestTimeout() throws Exception {\n-  390: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  391: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  392: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  393: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  394: \t\tthis.context.refresh();\n-  395: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  396: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  397: \t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n-  398: \t}\n-  400: \t@Test\n-  401: \tpublic void customAsyncRequestTimeout() throws Exception {\n-  402: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  403: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  404: \t\t\t\t\"spring.mvc.async.request-timeout:123456\");\n-  405: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  406: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  407: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  408: \t\tthis.context.refresh();\n-  409: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  410: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  411: \t\tObject actual = ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\");\n-  412: \t\tassertEquals(123456L, actual);\n-  413: \t}\n+  371: \t@Configuration\n+  372: \tprotected static class AllResources extends WebMvcConfigurerAdapter {\n+  373: \n+  374: \t\t@Override\n+  375: \t\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n+  376: \t\t\tregistry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/foo/\");\n+  377: \t\t}\n+  378: \n+  379: \t}\n+  380: \n+  381: \t@Configuration\n+  382: \tpublic static class Config {\n+  383: \n+  384: \t\t@Bean\n+  385: \t\tpublic EmbeddedServletContainerFactory containerFactory() {\n+  386: \t\t\treturn containerFactory;\n+  388: \n+  389: \t\t@Bean\n+  390: \t\tpublic EmbeddedServletContainerCustomizerBeanPostProcessor embeddedServletContainerCustomizerBeanPostProcessor() {\n+  391: \t\t\treturn new EmbeddedServletContainerCustomizerBeanPostProcessor();\n+  392: \t\t}\n+  393: \n+  394: \t}\n+  395: \n+  396: \t@Configuration\n+  397: \tpublic static class CustomViewResolver {\n+  398: \n+  400: \t\tpublic ViewResolver viewResolver() {\n+  401: \t\t\treturn new MyViewResolver();\n+  402: \t\t}\n+  403: \n+  404: \t}\n+  405: \n+  406: \t@Configuration\n+  407: \tpublic static class CustomContentNegotiatingViewResolver {\n+  408: \n+  409: \t\t@Bean\n+  410: \t\tpublic ContentNegotiatingViewResolver myViewResolver() {\n+  411: \t\t\treturn new ContentNegotiatingViewResolver();\n+  412: \t\t}\n+  413: \n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n /**\n\t * Creates a new count query for the given {@link Specification}.\n\t * \n\t * @param spec can be {@literal null}.\n\t * @return\n\t */\n\tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n\n\t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n\t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n\n\t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n\n\t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, QueryMode.COUNT);\n\t\tquery = context.getQuery();\n\t\troot = context.getRoot();\n\n\t\tif (query.isDistinct()) {\n\t\t\tquery.select(builder.countDistinct(root));\n\t\t} else {\n\t\t\tquery.select(builder.count(root));\n\t\t}\n\n\t\treturn em.createQuery(query);\n\t}\n SourceCodeAfterRefactoring:\n/**\n\t * Creates a new count query for the given {@link Specification}.\n\t * \n\t * @param spec can be {@literal null}.\n\t * @return\n\t */\n\tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n\t\treturn getCountQuery(spec, QueryMode.COUNT);\n\t}\nprotected TypedQuery<Long> getCountQuery(Specification<T> spec, QueryMode mode) {\n\n\t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n\t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n\n\t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n\n\t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, mode);\n\t\tquery = context.getQuery();\n\t\troot = context.getRoot();\n\n\t\tif (query.isDistinct()) {\n\t\t\tquery.select(builder.countDistinct(root));\n\t\t} else {\n\t\t\tquery.select(builder.count(root));\n\t\t}\n\n\t\treturn em.createQuery(query);\n\t}\n DiffSourceCode:\n-  593: \t\troot = context.getRoot();\n-  594: \n-  595: \t\tquery.select(root);\n-  596: \n-  597: \t\tif (sort != null) {\n-  598: \t\t\tquery.orderBy(toOrders(sort, root, builder));\n-  599: \t\t}\n-  600: \n-  601: \t\treturn applyRepositoryMethodMetadata(em.createQuery(query));\n-  603: \n-  604: \t/**\n-  605: \t * Creates a new count query for the given {@link Specification}.\n-  606: \t * \n-  607: \t * @param spec can be {@literal null}.\n-  608: \t * @return\n-  609: \t */\n-  610: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n-  611: \n-  612: \t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n-  613: \t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n-  614: \n-  615: \t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n-  616: \n-  617: \t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, QueryMode.COUNT);\n-  618: \t\tquery = context.getQuery();\n-  619: \t\troot = context.getRoot();\n-  620: \n-  621: \t\tif (query.isDistinct()) {\n-  622: \t\t\tquery.select(builder.countDistinct(root));\n-  623: \t\t} else {\n-  624: \t\t\tquery.select(builder.count(root));\n-  625: \t\t}\n-  626: \n-  627: \t\treturn em.createQuery(query);\n-  628: \t}\n+  593: \t/**\n+  594: \t * Creates a new count query for the given {@link Specification}.\n+  595: \t * \n+  596: \t * @param spec can be {@literal null}.\n+  597: \t * @return\n+  598: \t */\n+  599: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n+  600: \t\treturn getCountQuery(spec, QueryMode.COUNT);\n+  601: \t}\n+  603: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec, QueryMode mode) {\n+  604: \n+  605: \t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n+  606: \t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n+  607: \n+  608: \t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n+  609: \n+  610: \t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, mode);\n+  611: \t\tquery = context.getQuery();\n+  612: \t\troot = context.getRoot();\n+  613: \n+  614: \t\tif (query.isDistinct()) {\n+  615: \t\t\tquery.select(builder.countDistinct(root));\n+  616: \t\t} else {\n+  617: \t\t\tquery.select(builder.count(root));\n+  618: \t\t}\n+  619: \n+  620: \t\treturn em.createQuery(query);\n+  621: \t}\n+  622: \n+  623: \t/**\n+  624: \t * Applies the given {@link Specification} to the given {@link CriteriaQuery}.\n+  625: \t * \n+  626: \t * @param spec can be {@literal null}.\n+  627: \t * @param query must not be {@literal null}.\n+  628: \t * @return\n\n",
        "contextDescription": "PackageName: org.springframework.security.messaging.access.expression\nClassName: org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory\nMethodName: org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory#createExpressionMessageMetadataSource\n ClassSignature: public final class ExpressionBasedMessageSecurityMetadataSourceFactory \n",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n/**\n\t * Create a {@link MessageSecurityMetadataSource} that uses {@link MessageMatcher}\n\t * mapped to Spring Expressions. Each entry is considered in order and only the first\n\t * match is used.\n\t *\n\t * For example:\n\t *\n\t * <pre>\n\t *     LinkedHashMap<MessageMatcher<?> matcherToExpression = new LinkedHashMap<MessageMatcher<Object>();\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/public/**\"), \"permitAll\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/admin/**\"), \"hasRole('ROLE_ADMIN')\");\n\t *     matcherToExpression.put(new SimDestinationMessageMatcher(\"/**\"), \"authenticated\");\n\t * \n\t *     MessageSecurityMetadataSource metadataSource = createExpressionMessageMetadataSource(matcherToExpression);\n\t * </pre>\n\t *\n\t * <p>\n\t * If our destination is \"/public/hello\", it would match on \"/public/**\" and on \"/**\".\n\t * However, only \"/public/**\" would be used since it is the first entry. That means\n\t * that a destination of \"/public/hello\" will be mapped to \"permitAll\".\n\t * </p>\n\t *\n\t * <p>\n\t * For a complete listing of expressions see {@link MessageSecurityExpressionRoot}\n\t * </p>\n\t *\n\t * @param matcherToExpression an ordered mapping of {@link MessageMatcher} to Strings\n\t * that are turned into an Expression using\n\t * {@link DefaultMessageSecurityExpressionHandler#getExpressionParser()}\n\t * @return the {@link MessageSecurityMetadataSource} to use. Cannot be null.\n\t */\n\tpublic static MessageSecurityMetadataSource createExpressionMessageMetadataSource(\n\t\t\tLinkedHashMap<MessageMatcher<?>, String> matcherToExpression) {\n\t\tDefaultMessageSecurityExpressionHandler<Object> handler = new DefaultMessageSecurityExpressionHandler<Object>();\n\n\t\tLinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>> matcherToAttrs = new LinkedHashMap<MessageMatcher<?>, Collection<ConfigAttribute>>();\n\n\t\tfor (Map.Entry<MessageMatcher<?>, String> entry : matcherToExpression.entrySet()) {\n\t\t\tMessageMatcher<?> matcher = entry.getKey();\n\t\t\tString rawExpression = entry.getValue();\n\t\t\tExpression expression = handler.getExpressionParser().parseExpression(\n\t\t\t\t\trawExpression);\n\t\t\tConfigAttribute attribute = new MessageExpressionConfigAttribute(expression);\n\t\t\tmatcherToAttrs.put(matcher, Arrays.asList(attribute));\n\t\t}\n\t\treturn new DefaultMessageSecurityMetadataSource(matcherToAttrs);\n\t}\n\nThe context of the source code is as follows:\nPackageName: org.springframework.security.messaging.access.expression\nClassName: org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory\nMethodName: org.springframework.security.messaging.access.expression.ExpressionBasedMessageSecurityMetadataSourceFactory#createExpressionMessageMetadataSource\n ClassSignature: public final class ExpressionBasedMessageSecurityMetadataSourceFactory\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n /**\n\t * This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n\t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n\t * on the output message. It then calls {@link #writeInternal}.\n\t */\n\t@Override\n\tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType type = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (type != null ? type : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() == -1) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n\t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n\t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n SourceCodeAfterRefactoring:\n/**\n\t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n\t * and then calls {@link #writeInternal}.\n\t */\n\t@Override\n\tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n\t\taddDefaultHeaders(headers, t, contentType);\n\n\t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n\t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n\t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n\t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n\t\t\t\t@Override\n\t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n\t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n\t\t\t\t\t\t\treturn outputStream;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n\t\t\t\t\t\t\treturn headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\twriteInternal(t, outputMessage);\n\t\t\toutputMessage.getBody().flush();\n\t\t}\n\t}\n/**\n\t * Add default headers to the output message.\n\t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n\t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n\t * @since 4.2\n\t */\n\tprotected void addDefaultHeaders(final HttpHeaders headers, final T t, MediaType contentType)\n\t\t\tthrows IOException{\n\n\t\tif (headers.getContentType() == null) {\n\t\t\tMediaType contentTypeToUse = contentType;\n\t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n\t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n\t\t\t}\n\t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n\t\t\t\tMediaType mediaType = getDefaultContentType(t);\n\t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n\t\t\t}\n\t\t\tif (contentTypeToUse != null) {\n\t\t\t\theaders.setContentType(contentTypeToUse);\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() == -1) {\n\t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n\t\t\tif (contentLength != null) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t}\n DiffSourceCode:\n   162: \t/**\n-  163: \t * This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n-  164: \t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n-  165: \t * on the output message. It then calls {@link #writeInternal}.\n-  166: \t */\n-  167: \t@Override\n-  168: \tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n-  169: \t\t\tthrows IOException, HttpMessageNotWritableException {\n-  170: \n-  171: \t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n-  172: \t\tif (headers.getContentType() == null) {\n-  173: \t\t\tMediaType contentTypeToUse = contentType;\n-  174: \t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n-  175: \t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n-  176: \t\t\t}\n-  177: \t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n-  178: \t\t\t\tMediaType type = getDefaultContentType(t);\n-  179: \t\t\t\tcontentTypeToUse = (type != null ? type : contentTypeToUse);\n-  180: \t\t\t}\n-  181: \t\t\tif (contentTypeToUse != null) {\n-  182: \t\t\t\theaders.setContentType(contentTypeToUse);\n-  183: \t\t\t}\n-  184: \t\t}\n-  185: \t\tif (headers.getContentLength() == -1) {\n-  186: \t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n-  187: \t\t\tif (contentLength != null) {\n-  188: \t\t\t\theaders.setContentLength(contentLength);\n-  189: \t\t\t}\n-  190: \t\t}\n-  191: \n-  192: \t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n-  193: \t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n-  194: \t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n-  195: \t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n-  196: \t\t\t\t@Override\n-  197: \t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n-  198: \t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n-  199: \t\t\t\t\t\t@Override\n-  200: \t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n-  201: \t\t\t\t\t\t\treturn outputStream;\n-  202: \t\t\t\t\t\t}\n-  203: \t\t\t\t\t\t@Override\n-  204: \t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n-  205: \t\t\t\t\t\t\treturn headers;\n-  206: \t\t\t\t\t\t}\n-  207: \t\t\t\t\t});\n-  208: \t\t\t\t}\n-  209: \t\t\t});\n-  210: \t\t}\n-  211: \t\telse {\n-  212: \t\t\twriteInternal(t, outputMessage);\n-  213: \t\t\toutputMessage.getBody().flush();\n-  214: \t\t}\n-  215: \t}\n-  216: \n-  217: \t/**\n-  218: \t * Returns the default content type for the given type. Called when {@link #write}\n-  219: \t * is invoked without a specified content type parameter.\n-  220: \t * <p>By default, this returns the first element of the\n-  221: \t * {@link #setSupportedMediaTypes(List) supportedMediaTypes} property, if any.\n-  222: \t * Can be overridden in subclasses.\n-  223: \t * @param t the type to return the content type for\n-  224: \t * @return the content type, or {@code null} if not known\n-  225: \t */\n-  226: \tprotected MediaType getDefaultContentType(T t) throws IOException {\n+  163: \t * This implementation sets the default headers by calling {@link #addDefaultHeaders},\n+  164: \t * and then calls {@link #writeInternal}.\n+  165: \t */\n+  166: \t@Override\n+  167: \tpublic final void write(final T t, MediaType contentType, HttpOutputMessage outputMessage)\n+  168: \t\t\tthrows IOException, HttpMessageNotWritableException {\n+  169: \n+  170: \t\tfinal HttpHeaders headers = outputMessage.getHeaders();\n+  171: \t\taddDefaultHeaders(headers, t, contentType);\n+  172: \n+  173: \t\tif (outputMessage instanceof StreamingHttpOutputMessage) {\n+  174: \t\t\tStreamingHttpOutputMessage streamingOutputMessage =\n+  175: \t\t\t\t\t(StreamingHttpOutputMessage) outputMessage;\n+  176: \t\t\tstreamingOutputMessage.setBody(new StreamingHttpOutputMessage.Body() {\n+  177: \t\t\t\t@Override\n+  178: \t\t\t\tpublic void writeTo(final OutputStream outputStream) throws IOException {\n+  179: \t\t\t\t\twriteInternal(t, new HttpOutputMessage() {\n+  180: \t\t\t\t\t\t@Override\n+  181: \t\t\t\t\t\tpublic OutputStream getBody() throws IOException {\n+  182: \t\t\t\t\t\t\treturn outputStream;\n+  183: \t\t\t\t\t\t}\n+  184: \t\t\t\t\t\t@Override\n+  185: \t\t\t\t\t\tpublic HttpHeaders getHeaders() {\n+  186: \t\t\t\t\t\t\treturn headers;\n+  187: \t\t\t\t\t\t}\n+  188: \t\t\t\t\t});\n+  189: \t\t\t\t}\n+  190: \t\t\t});\n+  191: \t\t}\n+  192: \t\telse {\n+  193: \t\t\twriteInternal(t, outputMessage);\n+  194: \t\t\toutputMessage.getBody().flush();\n+  195: \t\t}\n+  196: \t}\n+  197: \n+  198: \t/**\n+  199: \t * Add default headers to the output message.\n+  200: \t * <p>This implementation delegates to {@link #getDefaultContentType(Object)} if a content\n+  201: \t * type was not provided, calls {@link #getContentLength}, and sets the corresponding headers\n+  202: \t * @since 4.2\n+  203: \t */\n+  204: \tprotected void addDefaultHeaders(final HttpHeaders headers, final T t, MediaType contentType)\n+  205: \t\t\tthrows IOException{\n+  206: \n+  207: \t\tif (headers.getContentType() == null) {\n+  208: \t\t\tMediaType contentTypeToUse = contentType;\n+  209: \t\t\tif (contentType == null || contentType.isWildcardType() || contentType.isWildcardSubtype()) {\n+  210: \t\t\t\tcontentTypeToUse = getDefaultContentType(t);\n+  211: \t\t\t}\n+  212: \t\t\telse if (MediaType.APPLICATION_OCTET_STREAM.equals(contentType)) {\n+  213: \t\t\t\tMediaType mediaType = getDefaultContentType(t);\n+  214: \t\t\t\tcontentTypeToUse = (mediaType != null ? mediaType : contentTypeToUse);\n+  215: \t\t\t}\n+  216: \t\t\tif (contentTypeToUse != null) {\n+  217: \t\t\t\theaders.setContentType(contentTypeToUse);\n+  218: \t\t\t}\n+  219: \t\t}\n+  220: \t\tif (headers.getContentLength() == -1) {\n+  221: \t\t\tLong contentLength = getContentLength(t, headers.getContentType());\n+  222: \t\t\tif (contentLength != null) {\n+  223: \t\t\t\theaders.setContentLength(contentLength);\n+  224: \t\t\t}\n+  225: \t\t}\n+  226: \t}\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Test\n\tpublic void handerAdaptersCreated() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n\t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n\t\t\t\t.getMessageConverters().isEmpty());\n\t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n\t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n\t\t\t\t\t\t.getMessageConverters());\n\t}\n@Test\n\tpublic void handerMappingsCreated() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n\t}\n@Test\n\tpublic void resourceHandlerMapping() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(5));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(WebJars.class, Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideAll() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\tpublic void resourceHandlerMappingDisabled() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.resources.add-mappings:false\");\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.size(), equalTo(0));\n\t}\n@Test\n\tpublic void noLocaleResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n\t\tthis.context.getBean(LocaleResolver.class);\n\t}\n@Test\n\tpublic void overrideLocale() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\t// set fixed locale\n\t\tEnvironmentTestUtils.addEnvironment(this.context, \"spring.mvc.locale:en_UK\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\t// mock request and set user preferred locale\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n\t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n\t\tLocale locale = localeResolver.resolveLocale(request);\n\t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n\t\t// test locale resolver uses fixed locale and not user preferred locale\n\t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n\t}\n@Test\n\tpublic void noDateFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\t// formatting cs should use simple toString()\n\t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n\t}\n@Test\n\tpublic void overrideDateFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\t// set fixed date format\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.dateFormat:dd*MM*yyyy\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n\t}\n@Test\n\tpublic void noMessageCodesResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void overrideMessageCodesFormat() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n\t\tthis.context.register(AllResources.class, Config.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertEquals(true,\n\t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n\t}\n@Test\n\tpublic void customViewResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, CustomViewResolver.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n\t}\n@Test\n\tpublic void customContentNegotiatingViewResolver() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, CustomContentNegotiatingViewResolver.class,\n\t\t\t\tWebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n\t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n\t\tassertThat(beans.size(), equalTo(1));\n\t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n\t}\n@Test\n\tpublic void faviconMapping() throws IllegalAccessException {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n\t\t\t\t\t\t\"faviconRequestHandler\"), is(notNullValue()));\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n\t\t\t\t\t\t\"faviconHandlerMapping\"), is(notNullValue()));\n\t\tMap<String, List<Resource>> mappingLocations = getFaviconMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**/favicon.ico\").size(), equalTo(5));\n\t}\n@Test\n\tpublic void faviconMappingDisabled() throws IllegalAccessException {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.favicon.enabled:false\");\n\t\tthis.context.refresh();\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n\t\t\t\t\t\t\"faviconRequestHandler\"), is(nullValue()));\n\t\tassertThat(\n\t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n\t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n\t}\n@Test\n\tpublic void defaultAsyncRequestTimeout() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n\t}\n@Test\n\tpublic void customAsyncRequestTimeout() throws Exception {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context,\n\t\t\t\t\"spring.mvc.async.request-timeout:123456\");\n\t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n\t\tthis.context.refresh();\n\t\tRequestMappingHandlerAdapter adapter = this.context\n\t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n\t\tObject actual = ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\");\n\t\tassertEquals(123456L, actual);\n\t}\n SourceCodeAfterRefactoring:\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n\t\tload(WebJars.class);\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@Test\n\t public void resourceHandlerMappingOverrideAll() throws Exception {\n\t\tload(AllResources.class);\n\t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n\t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n\t\tassertThat(mappingLocations.get(\"/**\").get(0),\n\t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void noLocaleResolver() throws Exception {\n\t\tload(AllResources.class);\n\t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n\t\tthis.context.getBean(LocaleResolver.class);\n\t}\n@Test\n\tpublic void overrideLocale() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.locale:en_UK\");\n\n\t\t// mock request and set user preferred locale\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n\t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n\t\tLocale locale = localeResolver.resolveLocale(request);\n\t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n\t\t// test locale resolver uses fixed locale and not user preferred locale\n\t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n\t}\n@Test\n\tpublic void noDateFormat() throws Exception {\n\t\tload(AllResources.class);\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\t// formatting cs should use simple toString()\n\t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n\t}\n@Test\n\tpublic void overrideDateFormat() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.dateFormat:dd*MM*yyyy\");\n\t\tFormattingConversionService cs = this.context\n\t\t\t\t.getBean(FormattingConversionService.class);\n\t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n\t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n\t}\n@Test\n\tpublic void noMessageCodesResolver() throws Exception {\n\t\tload(AllResources.class);\n\t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@Test\n\tpublic void overrideMessageCodesFormat() throws Exception {\n\t\tload(AllResources.class, \"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n\t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n\t\t\t\t.getMessageCodesResolver());\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@Test\n\tpublic void customViewResolver() throws Exception {\n\t\tload(CustomViewResolver.class);\n\t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n\t}\n@Test\n\tpublic void customContentNegotiatingViewResolver() throws Exception {\n\t\tload(CustomContentNegotiatingViewResolver.class);\n\t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n\t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n\t\tassertThat(beans.size(), equalTo(1));\n\t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n@SuppressWarnings(\"unchecked\")\n\tprivate void load(Class<?> config, String... environment) {\n\t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n\t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n\t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n\t\tif (config != null) {\n\t\t\tconfigClasses.add(config);\n\t\t}\n\t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n\t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n\t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n\t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n\t\tthis.context.refresh();\n\t}\n DiffSourceCode:\n-   99: \t@Test\n-  100: \tpublic void handerAdaptersCreated() throws Exception {\n-  101: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  102: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  103: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  104: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  105: \t\tthis.context.refresh();\n-  106: \t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n-  107: \t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n-  108: \t\t\t\t.getMessageConverters().isEmpty());\n-  109: \t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n-  110: \t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n-  111: \t\t\t\t\t\t.getMessageConverters());\n-  112: \t}\n-  114: \t@Test\n-  115: \tpublic void handerMappingsCreated() throws Exception {\n-  116: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  117: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  118: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  119: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  120: \t\tthis.context.refresh();\n-  121: \t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n-  122: \t}\n-  124: \t@Test\n-  125: \tpublic void resourceHandlerMapping() throws Exception {\n-  126: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  127: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  128: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  129: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  130: \t\tthis.context.refresh();\n-  131: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  132: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(5));\n+   99: \t\t}\n+  100: \t}\n+  101: \n+  102: \t@Test\n+  103: \tpublic void handerAdaptersCreated() throws Exception {\n+  104: \t\tload();\n+  105: \t\tassertEquals(3, this.context.getBeanNamesForType(HandlerAdapter.class).length);\n+  106: \t\tassertFalse(this.context.getBean(RequestMappingHandlerAdapter.class)\n+  107: \t\t\t\t.getMessageConverters().isEmpty());\n+  108: \t\tassertEquals(this.context.getBean(HttpMessageConverters.class).getConverters(),\n+  109: \t\t\t\tthis.context.getBean(RequestMappingHandlerAdapter.class)\n+  110: \t\t\t\t\t\t.getMessageConverters());\n+  111: \t}\n+  112: \n+  114: \tpublic void handerMappingsCreated() throws Exception {\n+  115: \t\tload();\n+  116: \t\tassertEquals(6, this.context.getBeanNamesForType(HandlerMapping.class).length);\n+  117: \t}\n+  118: \n+  119: \t@Test\n+  120: \tpublic void resourceHandlerMapping() throws Exception {\n+  121: \t\tload();\n+  122: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n+  124: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n+  125: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n+  126: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n+  127: \t}\n+  128: \n+  129: \t@Test\n+  130: \tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n+  131: \t\tload(WebJars.class);\n+  132: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n   133: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n   134: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n-  135: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/META-INF/resources/webjars/\")));\n+  135: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n   136: \t}\n   138: \t@Test\n-  139: \tpublic void resourceHandlerMappingOverrideWebjars() throws Exception {\n-  140: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  141: \t\tthis.context.register(WebJars.class, Config.class, WebMvcAutoConfiguration.class,\n-  142: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  143: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  144: \t\tthis.context.refresh();\n-  145: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  146: \t\tassertThat(mappingLocations.get(\"/webjars/**\").size(), equalTo(1));\n-  147: \t\tassertThat(mappingLocations.get(\"/webjars/**\").get(0),\n-  148: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n-  149: \t}\n-  151: \t@Test\n-  152: \tpublic void resourceHandlerMappingOverrideAll() throws Exception {\n-  153: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  154: \t\tthis.context.register(AllResources.class, Config.class,\n-  155: \t\t\t\tWebMvcAutoConfiguration.class,\n-  156: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  157: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  158: \t\tthis.context.refresh();\n-  159: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  160: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n-  161: \t\tassertThat(mappingLocations.get(\"/**\").get(0),\n-  162: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n-  163: \t}\n+  139: \t public void resourceHandlerMappingOverrideAll() throws Exception {\n+  140: \t\tload(AllResources.class);\n+  141: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n+  142: \t\tassertThat(mappingLocations.get(\"/**\").size(), equalTo(1));\n+  143: \t\tassertThat(mappingLocations.get(\"/**\").get(0),\n+  144: \t\t\t\tequalTo((Resource) new ClassPathResource(\"/foo/\")));\n+  145: \t}\n+  146: \n+  147: \t@Test\n+  148: \tpublic void resourceHandlerMappingDisabled() throws Exception {\n+  149: \t\tload(\"spring.resources.add-mappings:false\");\n+  151: \t\tassertThat(mappingLocations.size(), equalTo(0));\n+  152: \t}\n+  153: \n+  154: \t@Test\n+  155: \tpublic void noLocaleResolver() throws Exception {\n+  156: \t\tload(AllResources.class);\n+  157: \t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n+  158: \t\tthis.context.getBean(LocaleResolver.class);\n+  159: \t}\n+  160: \n+  161: \t@Test\n+  162: \tpublic void overrideLocale() throws Exception {\n+  163: \t\tload(AllResources.class, \"spring.mvc.locale:en_UK\");\n   164: \n-  165: \t@Test\n-  166: \tpublic void resourceHandlerMappingDisabled() throws Exception {\n-  167: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  168: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  169: \t\t\t\t\"spring.resources.add-mappings:false\");\n-  170: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  171: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  172: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  173: \t\tthis.context.refresh();\n-  174: \t\tMap<String, List<Resource>> mappingLocations = getResourceMappingLocations();\n-  175: \t\tassertThat(mappingLocations.size(), equalTo(0));\n-  176: \t}\n-  177: \n-  178: \t@Test\n-  179: \tpublic void noLocaleResolver() throws Exception {\n-  180: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  181: \t\tthis.context.register(AllResources.class, Config.class,\n-  182: \t\t\t\tWebMvcAutoConfiguration.class,\n-  183: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  184: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  185: \t\tthis.context.refresh();\n-  186: \t\tthis.thrown.expect(NoSuchBeanDefinitionException.class);\n-  187: \t\tthis.context.getBean(LocaleResolver.class);\n-  188: \t}\n-  189: \n-  190: \t@Test\n-  191: \tpublic void overrideLocale() throws Exception {\n-  192: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  193: \t\t// set fixed locale\n-  194: \t\tEnvironmentTestUtils.addEnvironment(this.context, \"spring.mvc.locale:en_UK\");\n-  195: \t\tthis.context.register(AllResources.class, Config.class,\n-  196: \t\t\t\tWebMvcAutoConfiguration.class,\n-  197: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  198: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  199: \t\tthis.context.refresh();\n-  200: \t\t// mock request and set user preferred locale\n-  201: \t\tMockHttpServletRequest request = new MockHttpServletRequest();\n-  202: \t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n-  203: \t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n-  204: \t\tLocale locale = localeResolver.resolveLocale(request);\n-  205: \t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n-  206: \t\t// test locale resolver uses fixed locale and not user preferred locale\n-  207: \t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n-  208: \t}\n-  210: \t@Test\n-  211: \tpublic void noDateFormat() throws Exception {\n-  212: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  213: \t\tthis.context.register(AllResources.class, Config.class,\n-  214: \t\t\t\tWebMvcAutoConfiguration.class,\n-  215: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  216: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  217: \t\tthis.context.refresh();\n-  218: \t\tFormattingConversionService cs = this.context\n-  219: \t\t\t\t.getBean(FormattingConversionService.class);\n-  220: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n-  221: \t\t// formatting cs should use simple toString()\n-  222: \t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n-  223: \t}\n-  225: \t@Test\n-  226: \tpublic void overrideDateFormat() throws Exception {\n-  227: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  228: \t\t// set fixed date format\n-  229: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  230: \t\t\t\t\"spring.mvc.dateFormat:dd*MM*yyyy\");\n-  231: \t\tthis.context.register(AllResources.class, Config.class,\n-  232: \t\t\t\tWebMvcAutoConfiguration.class,\n-  233: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  234: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  235: \t\tthis.context.refresh();\n-  236: \t\tFormattingConversionService cs = this.context\n-  237: \t\t\t\t.getBean(FormattingConversionService.class);\n-  238: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n-  239: \t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n-  240: \t}\n-  242: \t@Test\n-  243: \tpublic void noMessageCodesResolver() throws Exception {\n-  244: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  245: \t\tthis.context.register(AllResources.class, Config.class,\n-  246: \t\t\t\tWebMvcAutoConfiguration.class,\n-  247: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  248: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  249: \t\tthis.context.refresh();\n-  250: \t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n-  251: \t\t\t\t.getMessageCodesResolver());\n-  252: \t}\n-  254: \t@Test\n-  255: \tpublic void overrideMessageCodesFormat() throws Exception {\n-  256: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  257: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  258: \t\t\t\t\"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n-  259: \t\tthis.context.register(AllResources.class, Config.class,\n-  260: \t\t\t\tWebMvcAutoConfiguration.class,\n-  261: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  262: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  263: \t\tthis.context.refresh();\n-  264: \t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n-  265: \t\t\t\t.getMessageCodesResolver());\n-  266: \t}\n-  267: \n-  268: \tprotected Map<String, List<Resource>> getFaviconMappingLocations()\n-  269: \t\t\tthrows IllegalAccessException {\n-  271: \t\t\t\t.getBean(\"faviconHandlerMapping\");\n-  272: \t\treturn getMappingLocations(mapping);\n-  273: \t}\n-  274: \n-  275: \tprotected Map<String, List<Resource>> getResourceMappingLocations()\n-  276: \t\t\tthrows IllegalAccessException {\n-  277: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n-  278: \t\t\t\t.getBean(\"resourceHandlerMapping\");\n-  301: \t@Test\n-  302: \tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n-  303: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  304: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  305: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  306: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  307: \t\tthis.context.refresh();\n-  308: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  309: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  310: \t\tassertEquals(true,\n-  311: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n-  312: \t}\n-  322: \t\tthis.context.refresh();\n-  323: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  324: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  325: \t\tassertEquals(false,\n-  326: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n-  327: \t}\n-  328: \n-  329: \t@Test\n-  330: \tpublic void customViewResolver() throws Exception {\n-  331: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  332: \t\tthis.context.register(Config.class, CustomViewResolver.class,\n-  333: \t\t\t\tWebMvcAutoConfiguration.class,\n-  334: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  335: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  336: \t\tthis.context.refresh();\n-  337: \t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n-  338: \t}\n-  340: \t@Test\n-  341: \tpublic void customContentNegotiatingViewResolver() throws Exception {\n-  342: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  343: \t\tthis.context.register(Config.class, CustomContentNegotiatingViewResolver.class,\n-  344: \t\t\t\tWebMvcAutoConfiguration.class,\n-  345: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  346: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  347: \t\tthis.context.refresh();\n-  348: \t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n-  349: \t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n-  350: \t\tassertThat(beans.size(), equalTo(1));\n-  351: \t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n-  352: \t}\n-  354: \t@Test\n-  355: \tpublic void faviconMapping() throws IllegalAccessException {\n-  356: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  357: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  358: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  359: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  360: \t\tthis.context.refresh();\n-  361: \t\tassertThat(\n-  362: \t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n-  363: \t\t\t\t\t\t\"faviconRequestHandler\"), is(notNullValue()));\n-  364: \t\tassertThat(\n-  365: \t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n-  366: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(notNullValue()));\n-  367: \t\tMap<String, List<Resource>> mappingLocations = getFaviconMappingLocations();\n-  368: \t\tassertThat(mappingLocations.get(\"/**/favicon.ico\").size(), equalTo(5));\n+  165: \t\t// mock request and set user preferred locale\n+  166: \t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+  167: \t\trequest.addPreferredLocale(StringUtils.parseLocaleString(\"nl_NL\"));\n+  168: \t\tLocaleResolver localeResolver = this.context.getBean(LocaleResolver.class);\n+  169: \t\tLocale locale = localeResolver.resolveLocale(request);\n+  170: \t\tassertThat(localeResolver, instanceOf(FixedLocaleResolver.class));\n+  171: \t\t// test locale resolver uses fixed locale and not user preferred locale\n+  172: \t\tassertThat(locale.toString(), equalTo(\"en_UK\"));\n+  173: \t}\n+  174: \n+  175: \t@Test\n+  176: \tpublic void noDateFormat() throws Exception {\n+  177: \t\tload(AllResources.class);\n+  178: \t\tFormattingConversionService cs = this.context\n+  179: \t\t\t\t.getBean(FormattingConversionService.class);\n+  180: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n+  181: \t\t// formatting cs should use simple toString()\n+  182: \t\tassertThat(cs.convert(date, String.class), equalTo(date.toString()));\n+  183: \t}\n+  184: \n+  185: \t@Test\n+  186: \tpublic void overrideDateFormat() throws Exception {\n+  187: \t\tload(AllResources.class, \"spring.mvc.dateFormat:dd*MM*yyyy\");\n+  188: \t\tFormattingConversionService cs = this.context\n+  189: \t\t\t\t.getBean(FormattingConversionService.class);\n+  190: \t\tDate date = new DateTime(1988, 6, 25, 20, 30).toDate();\n+  191: \t\tassertThat(cs.convert(date, String.class), equalTo(\"25*06*1988\"));\n+  192: \t}\n+  193: \n+  194: \t@Test\n+  195: \tpublic void noMessageCodesResolver() throws Exception {\n+  196: \t\tload(AllResources.class);\n+  197: \t\tassertNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n+  198: \t\t\t\t.getMessageCodesResolver());\n+  199: \t}\n+  200: \n+  201: \t@Test\n+  202: \tpublic void overrideMessageCodesFormat() throws Exception {\n+  203: \t\tload(AllResources.class, \"spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE\");\n+  204: \t\tassertNotNull(this.context.getBean(WebMvcAutoConfigurationAdapter.class)\n+  205: \t\t\t\t.getMessageCodesResolver());\n+  206: \t}\n+  207: \n+  208: \tprotected Map<String, List<Resource>> getFaviconMappingLocations()\n+  210: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n+  211: \t\t\t\t.getBean(\"faviconHandlerMapping\");\n+  212: \t\treturn getMappingLocations(mapping);\n+  213: \t}\n+  214: \n+  215: \tprotected Map<String, List<Resource>> getResourceMappingLocations()\n+  216: \t\t\tthrows IllegalAccessException {\n+  217: \t\tHandlerMapping mapping = (HandlerMapping) this.context\n+  218: \t\t\t\t.getBean(\"resourceHandlerMapping\");\n+  219: \t\treturn getMappingLocations(mapping);\n+  220: \t}\n+  221: \n+  222: \t@SuppressWarnings(\"unchecked\")\n+  223: \tprotected Map<String, List<Resource>> getMappingLocations(HandlerMapping mapping)\n+  225: \t\tMap<String, List<Resource>> mappingLocations = new LinkedHashMap<String, List<Resource>>();\n+  226: \t\tif (mapping instanceof SimpleUrlHandlerMapping) {\n+  227: \t\t\tField locationsField = ReflectionUtils.findField(\n+  228: \t\t\t\t\tResourceHttpRequestHandler.class, \"locations\");\n+  229: \t\t\tlocationsField.setAccessible(true);\n+  230: \t\t\tfor (Map.Entry<String, Object> entry : ((SimpleUrlHandlerMapping) mapping)\n+  231: \t\t\t\t\t.getHandlerMap().entrySet()) {\n+  232: \t\t\t\tResourceHttpRequestHandler handler = (ResourceHttpRequestHandler) entry\n+  233: \t\t\t\t\t\t.getValue();\n+  234: \t\t\t\tmappingLocations.put(entry.getKey(),\n+  235: \t\t\t\t\t\t(List<Resource>) locationsField.get(handler));\n+  236: \t\t\t}\n+  237: \t\t}\n+  238: \t\treturn mappingLocations;\n+  239: \t}\n+  240: \n+  242: \tpublic void ignoreDefaultModelOnRedirectIsTrue() throws Exception {\n+  243: \t\tload();\n+  244: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  245: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  246: \t\tassertEquals(true,\n+  247: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n+  248: \t}\n+  249: \n+  250: \t@Test\n+  251: \tpublic void overrideIgnoreDefaultModelOnRedirect() throws Exception {\n+  252: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n+  254: \t\t\t\t\"spring.mvc.ignore-default-model-on-redirect:false\");\n+  255: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n+  256: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n+  257: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n+  258: \t\tthis.context.refresh();\n+  259: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  260: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  261: \t\tassertEquals(false,\n+  262: \t\t\t\tReflectionTestUtils.getField(adapter, \"ignoreDefaultModelOnRedirect\"));\n+  263: \t}\n+  264: \n+  265: \t@Test\n+  266: \tpublic void customViewResolver() throws Exception {\n+  267: \t\tload(CustomViewResolver.class);\n+  268: \t\tassertThat(this.context.getBean(\"viewResolver\"), instanceOf(MyViewResolver.class));\n+  269: \t}\n+  271: \t@Test\n+  272: \tpublic void customContentNegotiatingViewResolver() throws Exception {\n+  273: \t\tload(CustomContentNegotiatingViewResolver.class);\n+  274: \t\tMap<String, ContentNegotiatingViewResolver> beans = this.context\n+  275: \t\t\t\t.getBeansOfType(ContentNegotiatingViewResolver.class);\n+  276: \t\tassertThat(beans.size(), equalTo(1));\n+  277: \t\tassertThat(beans.keySet().iterator().next(), equalTo(\"myViewResolver\"));\n+  278: \t}\n+  301: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n+  302: \t}\n+  303: \n+  304: \t@Test\n+  305: \tpublic void defaultAsyncRequestTimeout() throws Exception {\n+  306: \t\tload();\n+  307: \t\tRequestMappingHandlerAdapter adapter = this.context\n+  308: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n+  309: \t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n+  310: \t}\n+  311: \n+  312: \t@Test\n+  322: \t@SuppressWarnings(\"unchecked\")\n+  323: \tprivate void load(Class<?> config, String... environment) {\n+  324: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n+  325: \t\tEnvironmentTestUtils.addEnvironment(this.context, environment);\n+  326: \t\tList<Class<?>> configClasses = new ArrayList<Class<?>>();\n+  327: \t\tif (config != null) {\n+  328: \t\t\tconfigClasses.add(config);\n+  329: \t\t}\n+  330: \t\tconfigClasses.addAll(Arrays.asList(Config.class, WebMvcAutoConfiguration.class,\n+  331: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n+  332: \t\t\t\tPropertyPlaceholderAutoConfiguration.class));\n+  333: \t\tthis.context.register(configClasses.toArray(new Class<?>[configClasses.size()]));\n+  334: \t\tthis.context.refresh();\n+  335: \t}\n+  336: \n+  337: \tprivate void load(String... environment) {\n+  338: \t\tload(null, environment);\n+  340: \n+  341: \n+  342: \t@Configuration\n+  343: \tprotected static class ViewConfig {\n+  344: \n+  345: \t\t@Bean\n+  346: \t\tpublic View jsonView() {\n+  347: \t\t\treturn new AbstractView() {\n+  348: \n+  349: \t\t\t\t@Override\n+  350: \t\t\t\tprotected void renderMergedOutputModel(Map<String, Object> model,\n+  351: \t\t\t\t\t\tHttpServletRequest request, HttpServletResponse response)\n+  352: \t\t\t\t\t\tthrows Exception {\n+  354: \t\t\t\t}\n+  355: \t\t\t};\n+  356: \t\t}\n+  357: \n+  358: \t}\n+  359: \n+  360: \t@Configuration\n+  361: \tprotected static class WebJars extends WebMvcConfigurerAdapter {\n+  362: \n+  363: \t\t@Override\n+  364: \t\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n+  365: \t\t\tregistry.addResourceHandler(\"/webjars/**\").addResourceLocations(\n+  366: \t\t\t\t\t\"classpath:/foo/\");\n+  367: \t\t}\n+  368: \n   369: \t}\n-  371: \t@Test\n-  372: \tpublic void faviconMappingDisabled() throws IllegalAccessException {\n-  373: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  374: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  375: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  376: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  377: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  378: \t\t\t\t\"spring.mvc.favicon.enabled:false\");\n-  379: \t\tthis.context.refresh();\n-  380: \t\tassertThat(\n-  381: \t\t\t\tthis.context.getBeansOfType(ResourceHttpRequestHandler.class).get(\n-  382: \t\t\t\t\t\t\"faviconRequestHandler\"), is(nullValue()));\n-  383: \t\tassertThat(\n-  384: \t\t\t\tthis.context.getBeansOfType(SimpleUrlHandlerMapping.class).get(\n-  385: \t\t\t\t\t\t\"faviconHandlerMapping\"), is(nullValue()));\n-  386: \t}\n-  388: \t@Test\n-  389: \tpublic void defaultAsyncRequestTimeout() throws Exception {\n-  390: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  391: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  392: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  393: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  394: \t\tthis.context.refresh();\n-  395: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  396: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  397: \t\tassertNull(ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\"));\n-  398: \t}\n-  400: \t@Test\n-  401: \tpublic void customAsyncRequestTimeout() throws Exception {\n-  402: \t\tthis.context = new AnnotationConfigEmbeddedWebApplicationContext();\n-  403: \t\tEnvironmentTestUtils.addEnvironment(this.context,\n-  404: \t\t\t\t\"spring.mvc.async.request-timeout:123456\");\n-  405: \t\tthis.context.register(Config.class, WebMvcAutoConfiguration.class,\n-  406: \t\t\t\tHttpMessageConvertersAutoConfiguration.class,\n-  407: \t\t\t\tPropertyPlaceholderAutoConfiguration.class);\n-  408: \t\tthis.context.refresh();\n-  409: \t\tRequestMappingHandlerAdapter adapter = this.context\n-  410: \t\t\t\t.getBean(RequestMappingHandlerAdapter.class);\n-  411: \t\tObject actual = ReflectionTestUtils.getField(adapter, \"asyncRequestTimeout\");\n-  412: \t\tassertEquals(123456L, actual);\n-  413: \t}\n+  371: \t@Configuration\n+  372: \tprotected static class AllResources extends WebMvcConfigurerAdapter {\n+  373: \n+  374: \t\t@Override\n+  375: \t\tpublic void addResourceHandlers(ResourceHandlerRegistry registry) {\n+  376: \t\t\tregistry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/foo/\");\n+  377: \t\t}\n+  378: \n+  379: \t}\n+  380: \n+  381: \t@Configuration\n+  382: \tpublic static class Config {\n+  383: \n+  384: \t\t@Bean\n+  385: \t\tpublic EmbeddedServletContainerFactory containerFactory() {\n+  386: \t\t\treturn containerFactory;\n+  388: \n+  389: \t\t@Bean\n+  390: \t\tpublic EmbeddedServletContainerCustomizerBeanPostProcessor embeddedServletContainerCustomizerBeanPostProcessor() {\n+  391: \t\t\treturn new EmbeddedServletContainerCustomizerBeanPostProcessor();\n+  392: \t\t}\n+  393: \n+  394: \t}\n+  395: \n+  396: \t@Configuration\n+  397: \tpublic static class CustomViewResolver {\n+  398: \n+  400: \t\tpublic ViewResolver viewResolver() {\n+  401: \t\t\treturn new MyViewResolver();\n+  402: \t\t}\n+  403: \n+  404: \t}\n+  405: \n+  406: \t@Configuration\n+  407: \tpublic static class CustomContentNegotiatingViewResolver {\n+  408: \n+  409: \t\t@Bean\n+  410: \t\tpublic ContentNegotiatingViewResolver myViewResolver() {\n+  411: \t\t\treturn new ContentNegotiatingViewResolver();\n+  412: \t\t}\n+  413: \n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n /**\n\t * Creates a new count query for the given {@link Specification}.\n\t * \n\t * @param spec can be {@literal null}.\n\t * @return\n\t */\n\tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n\n\t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n\t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n\n\t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n\n\t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, QueryMode.COUNT);\n\t\tquery = context.getQuery();\n\t\troot = context.getRoot();\n\n\t\tif (query.isDistinct()) {\n\t\t\tquery.select(builder.countDistinct(root));\n\t\t} else {\n\t\t\tquery.select(builder.count(root));\n\t\t}\n\n\t\treturn em.createQuery(query);\n\t}\n SourceCodeAfterRefactoring:\n/**\n\t * Creates a new count query for the given {@link Specification}.\n\t * \n\t * @param spec can be {@literal null}.\n\t * @return\n\t */\n\tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n\t\treturn getCountQuery(spec, QueryMode.COUNT);\n\t}\nprotected TypedQuery<Long> getCountQuery(Specification<T> spec, QueryMode mode) {\n\n\t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n\t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n\n\t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n\n\t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, mode);\n\t\tquery = context.getQuery();\n\t\troot = context.getRoot();\n\n\t\tif (query.isDistinct()) {\n\t\t\tquery.select(builder.countDistinct(root));\n\t\t} else {\n\t\t\tquery.select(builder.count(root));\n\t\t}\n\n\t\treturn em.createQuery(query);\n\t}\n DiffSourceCode:\n-  593: \t\troot = context.getRoot();\n-  594: \n-  595: \t\tquery.select(root);\n-  596: \n-  597: \t\tif (sort != null) {\n-  598: \t\t\tquery.orderBy(toOrders(sort, root, builder));\n-  599: \t\t}\n-  600: \n-  601: \t\treturn applyRepositoryMethodMetadata(em.createQuery(query));\n-  603: \n-  604: \t/**\n-  605: \t * Creates a new count query for the given {@link Specification}.\n-  606: \t * \n-  607: \t * @param spec can be {@literal null}.\n-  608: \t * @return\n-  609: \t */\n-  610: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n-  611: \n-  612: \t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n-  613: \t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n-  614: \n-  615: \t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n-  616: \n-  617: \t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, QueryMode.COUNT);\n-  618: \t\tquery = context.getQuery();\n-  619: \t\troot = context.getRoot();\n-  620: \n-  621: \t\tif (query.isDistinct()) {\n-  622: \t\t\tquery.select(builder.countDistinct(root));\n-  623: \t\t} else {\n-  624: \t\t\tquery.select(builder.count(root));\n-  625: \t\t}\n-  626: \n-  627: \t\treturn em.createQuery(query);\n-  628: \t}\n+  593: \t/**\n+  594: \t * Creates a new count query for the given {@link Specification}.\n+  595: \t * \n+  596: \t * @param spec can be {@literal null}.\n+  597: \t * @return\n+  598: \t */\n+  599: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec) {\n+  600: \t\treturn getCountQuery(spec, QueryMode.COUNT);\n+  601: \t}\n+  603: \tprotected TypedQuery<Long> getCountQuery(Specification<T> spec, QueryMode mode) {\n+  604: \n+  605: \t\tCriteriaBuilder builder = em.getCriteriaBuilder();\n+  606: \t\tCriteriaQuery<Long> query = builder.createQuery(Long.class);\n+  607: \n+  608: \t\tRoot<T> root = applySpecificationToCriteria(spec, query);\n+  609: \n+  610: \t\tJpaCriteriaQueryContext<Long, T> context = potentiallyAugment(query, root, mode);\n+  611: \t\tquery = context.getQuery();\n+  612: \t\troot = context.getRoot();\n+  613: \n+  614: \t\tif (query.isDistinct()) {\n+  615: \t\t\tquery.select(builder.countDistinct(root));\n+  616: \t\t} else {\n+  617: \t\t\tquery.select(builder.count(root));\n+  618: \t\t}\n+  619: \n+  620: \t\treturn em.createQuery(query);\n+  621: \t}\n+  622: \n+  623: \t/**\n+  624: \t * Applies the given {@link Specification} to the given {@link CriteriaQuery}.\n+  625: \t * \n+  626: \t * @param spec can be {@literal null}.\n+  627: \t * @param query must not be {@literal null}.\n+  628: \t * @return\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/BroadleafCommerce/BroadleafCommerce.git",
        "branch": "master",
        "commitId": "9687048f76519fc89b4151cbe2841bbba61a401d",
        "sourceCodeBeforeRefactoring": "/**\n     * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n     * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n     * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n     * will never have values set.\n     * \n     * @param info\n     * @return the entity form\n     * @throws ServiceException\n     */\n    protected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) \n            throws ServiceException {\n        // We need to inspect with the second custom criteria set to the id of\n        // the desired structured content type\n        PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n                .withCeilingEntityClassname(info.getCeilingClassName())\n                .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n                .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n        ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n        \n        EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n        dynamicForm.clearFieldsMap();\n\n        if (dynamicFormOverride != null) {\n            dynamicFormOverride.clearFieldsMap();\n            Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n            for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n                if (dynamicForm.getFields().containsKey(override.getKey())) {\n                    dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n                }\n            }\n        }\n        \n        // Set the specialized name for these fields - we need to handle them separately\n        dynamicForm.clearFieldsMap();\n        for (Tab tab : dynamicForm.getTabs()) {\n            for (FieldGroup group : tab.getFieldGroups()) {\n                for (Field field : group.getFields()) {\n                    field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n                }\n            }\n        }\n\n        //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n\n        return dynamicForm;\n    }",
        "refactoredCode": "### Original Code:\n```java\n/**\n * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n * will never have values set.\n * \n * @param info\n * @return the entity form\n * @throws ServiceException\n */\nprotected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) \n        throws ServiceException {\n    // We need to inspect with the second custom criteria set to the id of\n    // the desired structured content type\n    PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n            .withCeilingEntityClassname(info.getCeilingClassName())\n            .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n            .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n    ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n    \n    EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n    dynamicForm.clearFieldsMap();\n\n    if (dynamicFormOverride != null) {\n        dynamicFormOverride.clearFieldsMap();\n        Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n        for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n            if (dynamicForm.getFields().containsKey(override.getKey())) {\n                dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n            }\n        }\n    }\n    \n    // Set the specialized name for these fields - we need to handle them separately\n    dynamicForm.clearFieldsMap();\n    for (Tab tab : dynamicForm.getTabs()) {\n        for (FieldGroup group : tab.getFieldGroups()) {\n            for (Field field : group.getFields()) {\n                field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n            }\n        }\n    }\n\n    //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n\n    return dynamicForm;\n}\n```\n\n### Refactored Code:\n```java\n/**\n * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n * will never have values set.\n * \n * @param info\n * @return the entity form\n * @throws ServiceException\n */\nprotected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) \n        throws ServiceException {\n    ClassMetadata cmd = getClassMetadata(info);\n    EntityForm dynamicForm = createAndClearDynamicForm(cmd);\n    \n    if (dynamicFormOverride != null) {\n        applyFieldOverrides(dynamicForm, dynamicFormOverride);\n    }\n    \n    setFieldNames(dynamicForm, info);\n    \n    return dynamicForm;\n}\n\nprivate ClassMetadata getClassMetadata(DynamicEntityFormInfo info) throws ServiceException {\n    PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n            .withCeilingEntityClassname(info.getCeilingClassName())\n            .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n            .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n    return service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n}\n\nprivate EntityForm createAndClearDynamicForm(ClassMetadata cmd) {\n    EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n    dynamicForm.clearFieldsMap();\n    return dynamicForm;\n}\n\nprivate void applyFieldOverrides(EntityForm dynamicForm, EntityForm dynamicFormOverride) {\n    dynamicFormOverride.clearFieldsMap();\n    Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n    for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n        if (dynamicForm.getFields().containsKey(override.getKey())) {\n            dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n        }\n    }\n}\n\nprivate void setFieldNames(EntityForm dynamicForm, DynamicEntityFormInfo info) {\n    dynamicForm.clearFieldsMap();\n    for (Tab tab : dynamicForm.getTabs()) {\n        for (FieldGroup group : tab.getFieldGroups()) {\n            for (Field field : group.getFields()) {\n                field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n            }\n        }\n    }\n}\n```",
        "sourceCodeAfterRefactoring": "/**\n     * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n     * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n     * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n     * will never have values set.\n     *\n     * We only add fields that are not considered Master fields\n     * \n     * @param info\n     * @return the entity form\n     * @throws ServiceException\n     */\n    protected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride)\n            throws ServiceException {\n        EntityForm dynamicForm = getEntityForm(info, dynamicFormOverride);\n\n        // Set the specialized name for these fields - we need to handle them separately\n        dynamicForm.clearFieldsMap();\n        for (Tab tab : dynamicForm.getTabs()) {\n            for (FieldGroup group : tab.getFieldGroups()) {\n                for (Field field : group.getFields()) {\n                    if (!field.isMasterField()) {\n                        field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n                    } else {\n                        group.removeField(field);\n                    }\n                }\n            }\n        }\n\n        //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n\n        return dynamicForm;\n    }\nprotected EntityForm getEntityForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) throws ServiceException {\n        // We need to inspect with the second custom criteria set to the id of\n        // the desired structured content type\n        PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n                .withCeilingEntityClassname(info.getCeilingClassName())\n                .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n                .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n        ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n\n        EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n        dynamicForm.clearFieldsMap();\n\n        if (dynamicFormOverride != null) {\n            dynamicFormOverride.clearFieldsMap();\n            Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n            for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n                if (dynamicForm.getFields().containsKey(override.getKey())) {\n                    dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n                }\n            }\n        }\n        return dynamicForm;\n    }",
        "diffSourceCode": "   240:     /**\n-  241:      * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n-  242:      * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n-  243:      * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n-  244:      * will never have values set.\n-  245:      * \n-  246:      * @param info\n-  247:      * @return the entity form\n-  248:      * @throws ServiceException\n-  249:      */\n-  250:     protected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) \n-  251:             throws ServiceException {\n-  252:         // We need to inspect with the second custom criteria set to the id of\n-  253:         // the desired structured content type\n-  254:         PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n-  255:                 .withCeilingEntityClassname(info.getCeilingClassName())\n-  256:                 .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n-  257:                 .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n-  258:         ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n-  259:         \n-  260:         EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n-  261:         dynamicForm.clearFieldsMap();\n-  262: \n-  263:         if (dynamicFormOverride != null) {\n-  264:             dynamicFormOverride.clearFieldsMap();\n-  265:             Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n-  266:             for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n-  267:                 if (dynamicForm.getFields().containsKey(override.getKey())) {\n-  268:                     dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n-  269:                 }\n-  270:             }\n-  271:         }\n-  272:         \n-  273:         // Set the specialized name for these fields - we need to handle them separately\n-  274:         dynamicForm.clearFieldsMap();\n-  275:         for (Tab tab : dynamicForm.getTabs()) {\n-  276:             for (FieldGroup group : tab.getFieldGroups()) {\n-  277:                 for (Field field : group.getFields()) {\n-  278:                     field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n-  279:                 }\n-  280:             }\n-  281:         }\n-  282: \n-  283:         //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n-  284: \n-  285:         return dynamicForm;\n-  286:     }\n-  287:     \n-  288:     /**\n-  289:      * Convenience method for obtaining a dynamic field template form for a particular entity. This method differs from\n-  290:      * {@link #getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo)} in that it will fill out the current values for \n-  291:      * the fields in this dynamic form from the database. This method is invoked when the initial view of a page containing\n-  292:      * a dynamic form is triggered.\n-  293:      * \n-  294:      * Optionally, you can pass in a pre-existing dynamic form to this method that already has updated values. Example usage\n-  295:      * would be for after validation has failed and you do not want to lookup old values from the database again.\n-  296:      * \n-  297:      * @param info\n-  298:      * @param entityId\n-  300:      * @return the entity form\n-  301:      * @throws ServiceException\n-  302:      */\n-  303:     protected EntityForm getDynamicFieldTemplateForm(DynamicEntityFormInfo info, String entityId, EntityForm dynamicFormOverride) \n-  304:             throws ServiceException {\n-  305:         // We need to inspect with the second custom criteria set to the id of\n-  306:         // the desired structured content type\n-  307:         PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n-  308:                 .withCeilingEntityClassname(info.getCeilingClassName())\n-  309:                 .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n-  310:                 .withCustomCriteria(new String[] { info.getCriteriaName(), entityId, info.getPropertyName(), info.getPropertyValue() });\n-  311:         ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n-  312:         \n-  313:         // However, when we fetch, the second custom criteria needs to be the id\n-  314:         // of this particular structured content entity\n-  315:         ppr.setCustomCriteria(new String[] { info.getCriteriaName(), entityId });\n-  316:         Entity entity = service.getRecord(ppr, info.getPropertyValue(), cmd, true).getDynamicResultSet().getRecords()[0];\n-  317:         \n-  318:         List<Field> fieldsToMove = new ArrayList<Field>();\n-  319:         // override the results of the entity with the dynamic form passed in\n-  320:         if (dynamicFormOverride != null) {\n-  321:             dynamicFormOverride.clearFieldsMap();\n-  322:             Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n+  241:      * Convenience method to build a blank form for a Master Field Group.\n+  242:      *\n+  243:      * @param info\n+  244:      * @throws ServiceException\n+  245:      */\n+  246:     protected EntityForm getBlankDynamicMasterFieldGroupTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) throws ServiceException {\n+  247:         EntityForm dynamicForm = getEntityForm(info, dynamicFormOverride);\n+  248: \n+  249:         // Set the specialized name for these fields - we need to handle them separately\n+  250:         dynamicForm.clearFieldsMap();\n+  251:         for (Tab tab : dynamicForm.getTabs()) {\n+  252:             for (FieldGroup group : tab.getFieldGroups()) {\n+  253:                 for (Field field : group.getFields()) {\n+  254:                     if (field.isMasterField()) {\n+  255:                         field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n+  256:                     } else {\n+  257:                         group.removeField(field);\n+  258:                     }\n+  259:                 }\n+  260:             }\n+  261:         }\n+  262:         return dynamicForm;\n+  263:     }\n+  264: \n+  265:     /**\n+  266:      * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n+  267:      * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n+  268:      * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n+  269:      * will never have values set.\n+  270:      *\n+  271:      * We only add fields that are not considered Master fields\n+  272:      * \n+  273:      * @param info\n+  274:      * @return the entity form\n+  275:      * @throws ServiceException\n+  276:      */\n+  277:     protected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride)\n+  278:             throws ServiceException {\n+  279:         EntityForm dynamicForm = getEntityForm(info, dynamicFormOverride);\n+  280: \n+  281:         // Set the specialized name for these fields - we need to handle them separately\n+  282:         dynamicForm.clearFieldsMap();\n+  283:         for (Tab tab : dynamicForm.getTabs()) {\n+  284:             for (FieldGroup group : tab.getFieldGroups()) {\n+  285:                 for (Field field : group.getFields()) {\n+  286:                     if (!field.isMasterField()) {\n+  287:                         field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n+  288:                     } else {\n+  289:                         group.removeField(field);\n+  290:                     }\n+  291:                 }\n+  292:             }\n+  293:         }\n+  294: \n+  295:         //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n+  296: \n+  297:         return dynamicForm;\n+  298:     }\n+  300:     protected EntityForm getEntityForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) throws ServiceException {\n+  301:         // We need to inspect with the second custom criteria set to the id of\n+  302:         // the desired structured content type\n+  303:         PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n+  304:                 .withCeilingEntityClassname(info.getCeilingClassName())\n+  305:                 .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n+  306:                 .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n+  307:         ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n+  308: \n+  309:         EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n+  310:         dynamicForm.clearFieldsMap();\n+  311: \n+  312:         if (dynamicFormOverride != null) {\n+  313:             dynamicFormOverride.clearFieldsMap();\n+  314:             Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n+  315:             for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n+  316:                 if (dynamicForm.getFields().containsKey(override.getKey())) {\n+  317:                     dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n+  318:                 }\n+  319:             }\n+  320:         }\n+  321:         return dynamicForm;\n+  322:     }\n",
        "uniqueId": "9687048f76519fc89b4151cbe2841bbba61a401d_240_286_300_322_265_298",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n\n    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n    {\n      arrayClass._extends(_directArrayClass.narrow(itemJClass));\n    }\n    else\n    {\n      arrayClass._extends(_wrappingArrayClass.narrow(itemJClass));\n    }\n\n    /** see {@link #schemaForArrayItemsOrMapValues} */\n    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n\n    generateConstructorWithNoArg(arrayClass, _dataListClass);\n    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n    generateConstructorWithCollection(arrayClass, itemJClass);\n    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n\n    generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n\n    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n\n    generateCopierMethods(arrayClass);\n  }\nprotected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass valueJClass = generate(mapSpec.getValueClass());\n    final JClass dataJClass = generate(mapSpec.getValueDataClass());\n\n    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n    {\n      mapClass._extends(_directMapClass.narrow(valueJClass));\n    }\n    else\n    {\n      mapClass._extends(_wrappingMapClass.narrow(valueJClass));\n    }\n\n    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n    final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n\n    generateConstructorWithNoArg(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n    generateConstructorWithMap(mapClass, valueJClass);\n    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n\n    generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n\n    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n\n    generateCopierMethods(mapClass);\n  }\nprotected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n      throws JClassAlreadyExistsException\n  {\n    templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n\n    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n\n    templateClass._extends(_recordClass);\n\n    generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n\n    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n\n    for (RecordTemplateSpec.Field field : recordSpec.getFields())\n    {\n      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n\n      if (field.getCustomInfo() != null)\n      {\n        generateCustomClassInitialization(templateClass, field.getCustomInfo());\n      }\n    }\n\n    generateCopierMethods(templateClass);\n  }\nprotected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n      throws JClassAlreadyExistsException\n  {\n    unionClass._extends(getUnionClass());\n\n    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n\n    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n    generateConstructorWithObjectArg(unionClass, schemaField);\n\n    for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n    {\n      if (member.getClassTemplateSpec() != null)\n      {\n        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n      }\n    }\n\n    generatePathSpecMethodsForUnion(unionSpec, unionClass);\n\n    generateCopierMethods(unionClass);\n\n    if (unionSpec.getTyperefClass() != null)\n    {\n      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n      generateTyperef(typerefInfoClass, typerefClassSpec);\n\n      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n      typerefInfoField.init(JExpr._new(typerefInfoClass));\n\n      unionClass._implements(HasTyperefInfo.class);\n      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n      typerefInfoMethod.body()._return(typerefInfoField);\n    }\n  }\n SourceCodeAfterRefactoring:\nprotected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n\n    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n    {\n      arrayClass._extends(_directArrayBaseClass.narrow(itemJClass));\n    }\n    else\n    {\n      extendWrappingArrayBaseClass(itemJClass, arrayClass);\n    }\n\n    /** see {@link #schemaForArrayItemsOrMapValues} */\n    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n\n    generateConstructorWithNoArg(arrayClass, _dataListClass);\n    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n    generateConstructorWithCollection(arrayClass, itemJClass);\n    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n    }\n\n    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(arrayClass);\n    }\n  }\nprotected void extendWrappingArrayBaseClass(JClass itemJClass, JDefinedClass arrayClass)\n  {\n    arrayClass._extends(_wrappingArrayBaseClass.narrow(itemJClass));\n  }\nprotected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass valueJClass = generate(mapSpec.getValueClass());\n    final JClass dataJClass = generate(mapSpec.getValueDataClass());\n\n    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n    {\n      mapClass._extends(_directMapBaseClass.narrow(valueJClass));\n    }\n    else\n    {\n      extendWrappingMapBaseClass(valueJClass, mapClass);\n    }\n\n    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n    final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n\n    generateConstructorWithNoArg(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n    generateConstructorWithMap(mapClass, valueJClass);\n    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n    }\n\n    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(mapClass);\n    }\n  }\nprotected void extendWrappingMapBaseClass(JClass valueJClass, JDefinedClass mapClass)\n  {\n    mapClass._extends(_wrappingMapBaseClass.narrow(valueJClass));\n  }\nprotected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n      throws JClassAlreadyExistsException\n  {\n    templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n\n    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n\n    extendRecordBaseClass(templateClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n    }\n\n    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n\n    for (RecordTemplateSpec.Field field : recordSpec.getFields())\n    {\n      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n\n      if (field.getCustomInfo() != null)\n      {\n        generateCustomClassInitialization(templateClass, field.getCustomInfo());\n      }\n    }\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(templateClass);\n    }\n  }\nprotected void extendRecordBaseClass(JDefinedClass templateClass)\n  {\n    templateClass._extends(_recordBaseClass);\n  }\nprotected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n      throws JClassAlreadyExistsException\n  {\n    extendUnionBaseClass(unionClass);\n\n    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n\n    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n    generateConstructorWithObjectArg(unionClass, schemaField);\n\n    for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n    {\n      if (member.getClassTemplateSpec() != null)\n      {\n        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n      }\n    }\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForUnion(unionSpec, unionClass);\n    }\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(unionClass);\n    }\n\n    if (unionSpec.getTyperefClass() != null)\n    {\n      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n      generateTyperef(typerefInfoClass, typerefClassSpec);\n\n      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n      typerefInfoField.init(JExpr._new(typerefInfoClass));\n\n      unionClass._implements(HasTyperefInfo.class);\n      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n      typerefInfoMethod.body()._return(typerefInfoField);\n    }\n  }\nprotected void extendUnionBaseClass(JDefinedClass unionClass)\n  {\n    unionClass._extends(_unionBaseClass);\n  }\n DiffSourceCode:\n-  419:   protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n-  420:       throws JClassAlreadyExistsException\n-  421:   {\n-  422:     final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n-  423:     final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n-  424: \n-  425:     if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n-  426:     {\n-  427:       arrayClass._extends(_directArrayClass.narrow(itemJClass));\n-  428:     }\n-  429:     else\n-  430:     {\n-  431:       arrayClass._extends(_wrappingArrayClass.narrow(itemJClass));\n-  432:     }\n-  433: \n-  434:     /** see {@link #schemaForArrayItemsOrMapValues} */\n-  435:     final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n-  436:     final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n-  437: \n-  438:     generateConstructorWithNoArg(arrayClass, _dataListClass);\n-  439:     generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n-  440:     generateConstructorWithCollection(arrayClass, itemJClass);\n-  441:     generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n-  442: \n-  443:     generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n-  444: \n-  445:     generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n-  446: \n-  447:     generateCopierMethods(arrayClass);\n-  448:   }\n-  456:     generateSchemaField(enumClass, enumSpec.getSchema());\n-  457: \n-  458:     for (String value : enumSpec.getSchema().getSymbols())\n-  459:     {\n-  460:       if (isReserved(value))\n-  461:       {\n-  462:         throw new IllegalArgumentException(\"Enum contains Java reserved symbol: \" + value + \" schema: \" + enumSpec.getSchema());\n-  463:       }\n-  464: \n-  465:       final JEnumConstant enumConstant = enumClass.enumConstant(value);\n-  466: \n-  467:       final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);\n-  468: \n-  469:       if (enumConstantDoc != null)\n-  470:       {\n-  471:         enumConstant.javadoc().append(enumConstantDoc);\n-  472:       }\n-  473: \n-  474:       setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);\n-  475:     }\n-  476:     enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);\n-  477:   }\n-  478: \n-  479:   protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)\n-  480:   {\n-  481:     fixedClass.javadoc().append(fixedSpec.getSchema().getDoc());\n-  482: \n-  483:     setDeprecatedAnnotationAndJavadoc(fixedSpec.getSchema(), fixedClass);\n+  419:     if (result == null)\n+  420:     {\n+  421:       final int jmodValue = getJModValue(classTemplateSpec.getModifiers());\n+  422:       final JClassContainer container;\n+  423:       if (classTemplateSpec.getEnclosingClass() == null)\n+  424:       {\n+  425:         container = getPackage(classTemplateSpec.getNamespace());\n+  426:       }\n+  427:       else\n+  428:       {\n+  429:         container = defineClass(classTemplateSpec.getEnclosingClass());\n+  430:       }\n+  431: \n+  432:       if (classTemplateSpec instanceof ArrayTemplateSpec ||\n+  433:           classTemplateSpec instanceof FixedTemplateSpec ||\n+  434:           classTemplateSpec instanceof MapTemplateSpec ||\n+  435:           classTemplateSpec instanceof RecordTemplateSpec ||\n+  436:           classTemplateSpec instanceof TyperefTemplateSpec ||\n+  437:           classTemplateSpec instanceof UnionTemplateSpec)\n+  438:       {\n+  439:         result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()));\n+  440:       }\n+  441:       else if (classTemplateSpec instanceof EnumTemplateSpec)\n+  442:       {\n+  443:         result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()), ClassType.ENUM);\n+  444:       }\n+  445:       else\n+  446:       {\n+  447:         throw new RuntimeException();\n+  448:       }\n+  456:   protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n+  457:       throws JClassAlreadyExistsException\n+  458:   {\n+  459:     final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n+  460:     final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n+  461: \n+  462:     if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n+  463:     {\n+  464:       arrayClass._extends(_directArrayBaseClass.narrow(itemJClass));\n+  465:     }\n+  466:     else\n+  467:     {\n+  468:       extendWrappingArrayBaseClass(itemJClass, arrayClass);\n+  469:     }\n+  470: \n+  471:     /** see {@link #schemaForArrayItemsOrMapValues} */\n+  472:     final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n+  473:     final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n+  474: \n+  475:     generateConstructorWithNoArg(arrayClass, _dataListClass);\n+  476:     generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n+  477:     generateConstructorWithCollection(arrayClass, itemJClass);\n+  478:     generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n+  479: \n+  480:     if (_pathSpecMethods)\n+  481:     {\n+  482:       generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n+  483:     }\n   484: \n-  485:     fixedClass._extends(FixedTemplate.class);\n+  485:     generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n   486: \n-  487:     final JVar schemaField = generateSchemaField(fixedClass, fixedSpec.getSchema());\n-  488: \n-  489:     final JMethod bytesConstructor = fixedClass.constructor(JMod.PUBLIC);\n-  490:     final JVar param = bytesConstructor.param(ByteString.class, \"value\");\n-  491:     bytesConstructor.body().invoke(SUPER).arg(param).arg(schemaField);\n-  493:     generateConstructorWithObjectArg(fixedClass, schemaField);\n-  494: \n-  495:     generateCopierMethods(fixedClass);\n+  487:     if (_copierMethods)\n+  488:     {\n+  489:       generateCopierMethods(arrayClass);\n+  490:     }\n+  491:   }\n+  493:   protected void extendWrappingArrayBaseClass(JClass itemJClass, JDefinedClass arrayClass)\n+  494:   {\n+  495:     arrayClass._extends(_wrappingArrayBaseClass.narrow(itemJClass));\n   496:   }\n-  498:   protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n-  499:       throws JClassAlreadyExistsException\n-  500:   {\n-  501:     final JClass valueJClass = generate(mapSpec.getValueClass());\n-  502:     final JClass dataJClass = generate(mapSpec.getValueDataClass());\n+  498:   protected void generateEnum(JDefinedClass enumClass, EnumTemplateSpec enumSpec)\n+  499:   {\n+  500:     enumClass.javadoc().append(enumSpec.getSchema().getDoc());\n+  501: \n+  502:     setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), enumClass);\n   503: \n-  504:     if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n-  505:     {\n-  506:       mapClass._extends(_directMapClass.narrow(valueJClass));\n-  507:     }\n-  508:     else\n-  509:     {\n-  510:       mapClass._extends(_wrappingMapClass.narrow(valueJClass));\n-  511:     }\n+  504:     generateSchemaField(enumClass, enumSpec.getSchema());\n+  505: \n+  506:     for (String value : enumSpec.getSchema().getSymbols())\n+  507:     {\n+  508:       if (isReserved(value))\n+  509:       {\n+  510:         throw new IllegalArgumentException(\"Enum contains Java reserved symbol: \" + value + \" schema: \" + enumSpec.getSchema());\n+  511:       }\n   512: \n-  513:     final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n-  514:     final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n-  515: \n-  516:     generateConstructorWithNoArg(mapClass, _dataMapClass);\n-  517:     generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n-  518:     generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n-  519:     generateConstructorWithMap(mapClass, valueJClass);\n-  520:     generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n+  513:       final JEnumConstant enumConstant = enumClass.enumConstant(value);\n+  514: \n+  515:       final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);\n+  516: \n+  517:       if (enumConstantDoc != null)\n+  518:       {\n+  519:         enumConstant.javadoc().append(enumConstantDoc);\n+  520:       }\n   521: \n-  522:     generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n-  523: \n-  524:     generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n-  525: \n-  526:     generateCopierMethods(mapClass);\n-  527:   }\n-  549:         return getCodeModel().FLOAT.boxify();\n-  550: \n-  551:       case BYTES:\n-  552:         return _byteStringClass;\n-  553: \n-  554:       default:\n-  555:         throw new RuntimeException(\"Not supported primitive: \" + primitiveSpec);\n-  556:     }\n-  557:   }\n-  558: \n-  559:   protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n-  560:       throws JClassAlreadyExistsException\n-  561:   {\n-  562:     templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n+  522:       setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);\n+  523:     }\n+  524:     enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);\n+  525:   }\n+  526: \n+  527:   protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)\n+  549:   protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n+  550:       throws JClassAlreadyExistsException\n+  551:   {\n+  552:     final JClass valueJClass = generate(mapSpec.getValueClass());\n+  553:     final JClass dataJClass = generate(mapSpec.getValueDataClass());\n+  554: \n+  555:     if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n+  556:     {\n+  557:       mapClass._extends(_directMapBaseClass.narrow(valueJClass));\n+  558:     }\n+  559:     else\n+  560:     {\n+  561:       extendWrappingMapBaseClass(valueJClass, mapClass);\n+  562:     }\n   563: \n-  564:     setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n-  565: \n-  566:     templateClass._extends(_recordClass);\n-  567: \n-  568:     generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n-  569: \n-  570:     final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n-  571:     generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n-  572:     generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n-  573: \n-  574:     for (RecordTemplateSpec.Field field : recordSpec.getFields())\n-  575:     {\n-  576:       generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n+  564:     final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n+  565:     final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n+  566: \n+  567:     generateConstructorWithNoArg(mapClass, _dataMapClass);\n+  568:     generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n+  569:     generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n+  570:     generateConstructorWithMap(mapClass, valueJClass);\n+  571:     generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n+  572: \n+  573:     if (_pathSpecMethods)\n+  574:     {\n+  575:       generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n+  576:     }\n   577: \n-  578:       if (field.getCustomInfo() != null)\n-  579:       {\n-  580:         generateCustomClassInitialization(templateClass, field.getCustomInfo());\n-  581:       }\n-  582:     }\n-  583: \n-  584:     generateCopierMethods(templateClass);\n-  585:   }\n-  586: \n-  587:   private void generatePathSpecMethodsForRecord(List<RecordTemplateSpec.Field> fieldSpecs, JDefinedClass templateClass)\n-  588:       throws JClassAlreadyExistsException\n-  589:   {\n-  621:     if (isDirect)\n-  622:     {\n-  623:       wrappedOrDirect = (field.getCustomInfo() == null ? \"Direct\" : \"CustomType\");\n-  624:     }\n-  625:     else\n-  626:     {\n-  627:       wrappedOrDirect = \"Wrapped\";\n-  628:     }\n-  629:     final String capitalizedName = CodeUtil.capitalize(schemaField.getName());\n-  630: \n-  631:     final String fieldFieldName = \"FIELD_\" + capitalizedName;\n-  632:     final JFieldVar fieldField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, RecordDataSchema.Field.class, fieldFieldName);\n-  633:     fieldField.init(schemaFieldVar.invoke(\"getField\").arg(schemaField.getName()));\n+  578:     generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n+  579: \n+  580:     if (_copierMethods)\n+  581:     {\n+  582:       generateCopierMethods(mapClass);\n+  583:     }\n+  584:   }\n+  585: \n+  586:   protected void extendWrappingMapBaseClass(JClass valueJClass, JDefinedClass mapClass)\n+  587:   {\n+  588:     mapClass._extends(_wrappingMapBaseClass.narrow(valueJClass));\n+  589:   }\n+  621:   protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n+  622:       throws JClassAlreadyExistsException\n+  623:   {\n+  624:     templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n+  625: \n+  626:     setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n+  627: \n+  628:     extendRecordBaseClass(templateClass);\n+  629: \n+  630:     if (_pathSpecMethods)\n+  631:     {\n+  632:       generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n+  633:     }\n   634: \n-  635:     // Generate has method.\n-  636:     final JMethod has = templateClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, \"has\" + capitalizedName);\n-  637:     addAccessorDoc(has, schemaField, \"Existence checker\");\n-  638:     setDeprecatedAnnotationAndJavadoc(has, schemaField);\n-  639:     final JBlock hasBody = has.body();\n-  640:     JExpression res = JExpr.invoke(\"contains\").arg(fieldField);\n-  641:     hasBody._return(res);\n+  635:     final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n+  636:     generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n+  637:     generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n+  638: \n+  639:     for (RecordTemplateSpec.Field field : recordSpec.getFields())\n+  640:     {\n+  641:       generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n   642: \n-  643:     // Generate remove method.\n-  644:     final String removeName = \"remove\" + capitalizedName;\n-  645:     final JMethod remove = templateClass.method(JMod.PUBLIC, getCodeModel().VOID, removeName);\n-  646:     addAccessorDoc(remove, schemaField, \"Remover\");\n-  647:     setDeprecatedAnnotationAndJavadoc(remove, schemaField);\n-  648:     final JBlock removeBody = remove.body();\n-  649:     removeBody.invoke(\"remove\").arg(fieldField);\n-  650: \n-  651:     final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);\n-  652: \n-  653:     if (_recordFieldAccessorWithMode)\n-  655:       // Getter method with mode.\n-  656:       final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);\n-  657:       addAccessorDoc(getterWithMode, schemaField, \"Getter\");\n-  658:       setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);\n-  726:   protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n-  727:       throws JClassAlreadyExistsException\n-  728:   {\n-  729:     unionClass._extends(getUnionClass());\n-  730: \n-  731:     final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n-  732: \n-  733:     generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n-  734:     generateConstructorWithObjectArg(unionClass, schemaField);\n-  735: \n-  736:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n-  737:     {\n-  738:       if (member.getClassTemplateSpec() != null)\n-  739:       {\n-  740:         generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n-  741:       }\n-  742:     }\n-  743: \n-  744:     generatePathSpecMethodsForUnion(unionSpec, unionClass);\n-  745: \n-  746:     generateCopierMethods(unionClass);\n-  747: \n-  748:     if (unionSpec.getTyperefClass() != null)\n-  749:     {\n-  750:       final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n-  751:       final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n-  752:       generateTyperef(typerefInfoClass, typerefClassSpec);\n-  753: \n-  754:       final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n-  755:       typerefInfoField.init(JExpr._new(typerefInfoClass));\n-  756: \n-  757:       unionClass._implements(HasTyperefInfo.class);\n-  758:       final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n-  759:       typerefInfoMethod.body()._return(typerefInfoField);\n-  760:     }\n-  761:   }\n-  802:     final JInvocation inv = setter.body().invoke(\"select\" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass));\n-  803:     dataClassArg(inv, dataClass).arg(memberKey).arg(param);\n-  804:   }\n-  805: \n-  806:   private void generatePathSpecMethodsForUnion(UnionTemplateSpec unionSpec, JDefinedClass unionClass)\n-  807:       throws JClassAlreadyExistsException\n-  808:   {\n-  809:     final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(unionClass);\n-  810: \n-  811:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n-  812:     {\n-  813:       JClass fieldsRefType = _pathSpecClass;\n-  814:       if (hasNestedFields(member.getSchema()))\n+  643:       if (field.getCustomInfo() != null)\n+  644:       {\n+  645:         generateCustomClassInitialization(templateClass, field.getCustomInfo());\n+  646:       }\n+  647:     }\n+  648: \n+  649:     if (_copierMethods)\n+  650:     {\n+  651:       generateCopierMethods(templateClass);\n+  652:     }\n+  653:   }\n+  655:   protected void extendRecordBaseClass(JDefinedClass templateClass)\n+  656:   {\n+  657:     templateClass._extends(_recordBaseClass);\n+  658:   }\n+  726: \n+  727:     final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);\n+  728: \n+  729:     if (_recordFieldAccessorWithMode)\n+  730:     {\n+  731:       // Getter method with mode.\n+  732:       final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);\n+  733:       addAccessorDoc(getterWithMode, schemaField, \"Getter\");\n+  734:       setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);\n+  735:       JVar modeParam = getterWithMode.param(_getModeClass, \"mode\");\n+  736:       final JBlock getterWithModeBody = getterWithMode.body();\n+  737:       res = JExpr.invoke(\"obtain\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(modeParam);\n+  738:       getterWithModeBody._return(res);\n+  739:     }\n+  740: \n+  741:     // Getter method without mode.\n+  742:     final JMethod getterWithoutMode = templateClass.method(JMod.PUBLIC, type, getterName);\n+  743:     addAccessorDoc(getterWithoutMode, schemaField, \"Getter\");\n+  744:     setDeprecatedAnnotationAndJavadoc(getterWithoutMode, schemaField);\n+  745:     final JBlock getterWithoutModeBody = getterWithoutMode.body();\n+  746:     res = JExpr.invoke(\"obtain\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(_strictGetMode);\n+  747:     getterWithoutModeBody._return(res);\n+  748: \n+  749:     // Determine dataClass\n+  750:     final JClass dataClass = generate(field.getDataClass());\n+  751:     final String setterName = \"set\" + capitalizedName;\n+  752: \n+  753:     if (_recordFieldAccessorWithMode)\n+  754:     {\n+  755:       // Setter method with mode\n+  756:       final JMethod setterWithMode = templateClass.method(JMod.PUBLIC, templateClass, setterName);\n+  757:       addAccessorDoc(setterWithMode, schemaField, \"Setter\");\n+  758:       setDeprecatedAnnotationAndJavadoc(setterWithMode, schemaField);\n+  759:       JVar param = setterWithMode.param(type, \"value\");\n+  760:       JVar modeParam = setterWithMode.param(_setModeClass, \"mode\");\n+  761:       JInvocation inv = setterWithMode.body().invoke(\"put\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));\n+  802:   protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n+  803:       throws JClassAlreadyExistsException\n+  804:   {\n+  805:     extendUnionBaseClass(unionClass);\n+  806: \n+  807:     final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n+  808: \n+  809:     generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n+  810:     generateConstructorWithObjectArg(unionClass, schemaField);\n+  811: \n+  812:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n+  813:     {\n+  814:       if (member.getClassTemplateSpec() != null)\n   815:       {\n-  816:         final JClass unionMemberClass = generate(member.getClassTemplateSpec());\n-  817:         fieldsRefType = getCodeModel().ref(unionMemberClass.fullName() + \".Fields\");\n-  818:       }\n-  819:       final JMethod accessorMethod = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, CodeUtil.getUnionMemberName(member.getSchema()));\n-  820:       accessorMethod.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke(\"getPathComponents\")).arg(member.getSchema().getUnionMemberKey()));\n-  821:     }\n-  822:   }\n-  823: \n-  824:   private void populateClassContent(ClassTemplateSpec classTemplateSpec, JDefinedClass definedClass)\n-  825:       throws JClassAlreadyExistsException\n-  826:   {\n-  827:     if (!_generatedClasses.containsKey(definedClass))\n-  828:     {\n-  829:       _generatedClasses.put(definedClass, classTemplateSpec);\n-  830: \n-  831:       JavaCodeUtil.annotate(definedClass, \"Data Template\", classTemplateSpec.getLocation());\n-  832: \n-  833:       if (classTemplateSpec instanceof ArrayTemplateSpec)\n-  834:       {\n-  835:         generateArray(definedClass, (ArrayTemplateSpec) classTemplateSpec);\n-  836:       }\n-  837:       else if (classTemplateSpec instanceof EnumTemplateSpec)\n-  838:       {\n-  839:         generateEnum(definedClass, (EnumTemplateSpec) classTemplateSpec);\n-  840:       }\n-  841:       else if (classTemplateSpec instanceof FixedTemplateSpec)\n-  842:       {\n-  843:         generateFixed(definedClass, (FixedTemplateSpec) classTemplateSpec);\n-  845:       else if (classTemplateSpec instanceof MapTemplateSpec)\n-  846:       {\n-  847:         generateMap(definedClass, (MapTemplateSpec) classTemplateSpec);\n-  848:       }\n+  816:         generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n+  817:       }\n+  818:     }\n+  819: \n+  820:     if (_pathSpecMethods)\n+  821:     {\n+  822:       generatePathSpecMethodsForUnion(unionSpec, unionClass);\n+  823:     }\n+  824: \n+  825:     if (_copierMethods)\n+  826:     {\n+  827:       generateCopierMethods(unionClass);\n+  828:     }\n+  829: \n+  830:     if (unionSpec.getTyperefClass() != null)\n+  831:     {\n+  832:       final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n+  833:       final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n+  834:       generateTyperef(typerefInfoClass, typerefClassSpec);\n+  835: \n+  836:       final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n+  837:       typerefInfoField.init(JExpr._new(typerefInfoClass));\n+  838: \n+  839:       unionClass._implements(HasTyperefInfo.class);\n+  840:       final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n+  841:       typerefInfoMethod.body()._return(typerefInfoField);\n+  842:     }\n+  843:   }\n+  845:   protected void extendUnionBaseClass(JDefinedClass unionClass)\n+  846:   {\n+  847:     unionClass._extends(_unionBaseClass);\n+  848:   }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Test\n\tpublic void overridePidFileWithSpring() throws Exception {\n\t\tFile file = this.temporaryFolder.newFile();\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tMockPropertySource propertySource = new MockPropertySource();\n\t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n\t\tgiven(context.getEnvironment()).willReturn(environment);\n\t\tApplicationPreparedEvent event = new ApplicationPreparedEvent(\n\t\t\t\tnew SpringApplication(), new String[] {}, context);\n\t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n\t}\n@Test\n\tpublic void differentEventTypes() throws Exception {\n\t\tFile file = this.temporaryFolder.newFile();\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tMockPropertySource propertySource = new MockPropertySource();\n\t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\tApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(\n\t\t\t\tnew SpringApplication(), new String[] {}, environment);\n\t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n\t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n\t}\n SourceCodeAfterRefactoring:\nprivate SpringApplicationEvent createPreparedEvent(String propName, String propValue) {\n\t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n\t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n\t\tgiven(context.getEnvironment()).willReturn(environment);\n\t\treturn new ApplicationPreparedEvent(new SpringApplication(), new String[] {},\n\t\t\t\tcontext);\n\t}\nprivate ConfigurableEnvironment createEnvironment(String propName, String propValue) {\n\t\tMockPropertySource propertySource = mockPropertySource(propName, propValue);\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\treturn environment;\n\t}\nprivate SpringApplicationEvent createEnvironmentPreparedEvent(String propName,\n\t\t\tString propValue) {\n\t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n\t\treturn new ApplicationEnvironmentPreparedEvent(new SpringApplication(),\n\t\t\t\tnew String[] {}, environment);\n\t}\n DiffSourceCode:\n-   85: \t@Test\n-   86: \tpublic void overridePidFileWithSpring() throws Exception {\n-   87: \t\tFile file = this.temporaryFolder.newFile();\n-   88: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n-   89: \t\tMockPropertySource propertySource = new MockPropertySource();\n-   90: \t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n-   91: \t\tenvironment.getPropertySources().addLast(propertySource);\n-   92: \t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n-   93: \t\tgiven(context.getEnvironment()).willReturn(environment);\n-   94: \t\tApplicationPreparedEvent event = new ApplicationPreparedEvent(\n-   95: \t\t\t\tnew SpringApplication(), new String[] {}, context);\n-   96: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n-   97: \t\tlistener.onApplicationEvent(event);\n-   98: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n-   99: \t}\n-  101: \t@Test\n-  102: \tpublic void differentEventTypes() throws Exception {\n-  103: \t\tFile file = this.temporaryFolder.newFile();\n-  104: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n-  105: \t\tMockPropertySource propertySource = new MockPropertySource();\n-  106: \t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n-  107: \t\tenvironment.getPropertySources().addLast(propertySource);\n-  108: \t\tApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(\n-  109: \t\t\t\tnew SpringApplication(), new String[] {}, environment);\n-  110: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+   85: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);\n+   86: \t\tlistener.onApplicationEvent(EVENT);\n+   87: \t\tassertThat(\n+   88: \t\t\t\tFileCopyUtils.copyToString(new FileReader(System.getProperty(\"PIDFILE\"))),\n+   89: \t\t\t\tnot(isEmptyString()));\n+   90: \t}\n+   91: \n+   92: \t@Test\n+   93: \tpublic void overridePidFileWithSpring() throws Exception {\n+   94: \t\tFile file = this.temporaryFolder.newFile();\n+   95: \t\tSpringApplicationEvent event = createPreparedEvent(\"spring.pidfile\",\n+   96: \t\t\t\tfile.getAbsolutePath());\n+   97: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+   98: \t\tlistener.onApplicationEvent(event);\n+   99: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n+  101: \n+  102: \t@Test\n+  103: \tpublic void differentEventTypes() throws Exception {\n+  104: \t\tFile file = this.temporaryFolder.newFile();\n+  105: \t\tSpringApplicationEvent event = createEnvironmentPreparedEvent(\"spring.pidfile\",\n+  106: \t\t\t\tfile.getAbsolutePath());\n+  107: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+  108: \t\tlistener.onApplicationEvent(event);\n+  109: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n+  110: \t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n   111: \t\tlistener.onApplicationEvent(event);\n-  112: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n-  113: \t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n-  114: \t\tlistener.onApplicationEvent(event);\n-  115: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n-  116: \t}\n+  112: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n+  113: \t}\n+  114: \n+  115: \t@Test\n+  116: \tpublic void withNoEnvironment() throws Exception {\n+  157: \tprivate SpringApplicationEvent createEnvironmentPreparedEvent(String propName,\n+  158: \t\t\tString propValue) {\n+  159: \t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n+  160: \t\treturn new ApplicationEnvironmentPreparedEvent(new SpringApplication(),\n+  161: \t\t\t\tnew String[] {}, environment);\n+  162: \t}\n+  164: \tprivate SpringApplicationEvent createPreparedEvent(String propName, String propValue) {\n+  165: \t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n+  166: \t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n+  167: \t\tgiven(context.getEnvironment()).willReturn(environment);\n+  168: \t\treturn new ApplicationPreparedEvent(new SpringApplication(), new String[] {},\n+  169: \t\t\t\tcontext);\n+  170: \t}\n+  172: \tprivate ConfigurableEnvironment createEnvironment(String propName, String propValue) {\n+  173: \t\tMockPropertySource propertySource = mockPropertySource(propName, propValue);\n+  174: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n+  175: \t\tenvironment.getPropertySources().addLast(propertySource);\n+  176: \t\treturn environment;\n+  177: \t}\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n /**\n     * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n     */\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      MethodMetadata data = new MethodMetadata();\n      data.returnType(method.getGenericReturnType());\n      data.configKey(Feign.configKey(method));\n\n      for (Annotation methodAnnotation : method.getAnnotations()) {\n        processAnnotationOnMethod(data, methodAnnotation, method);\n      }\n      checkState(data.template().method() != null,\n                 \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n                 method.getName());\n      Class<?>[] parameterTypes = method.getParameterTypes();\n\n      Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n      int count = parameterAnnotations.length;\n      for (int i = 0; i < count; i++) {\n        boolean isHttpAnnotation = false;\n        if (parameterAnnotations[i] != null) {\n          isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n        }\n        if (parameterTypes[i] == URI.class) {\n          data.urlIndex(i);\n        } else if (!isHttpAnnotation) {\n          checkState(data.formParams().isEmpty(),\n                     \"Body parameters cannot be used with form parameters.\");\n          checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n          data.bodyIndex(i);\n          data.bodyType(method.getGenericParameterTypes()[i]);\n        }\n      }\n      return data;\n    }\n@Override\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      MethodMetadata data = super.parseAndValidatateMetadata(method);\n      if (method.getDeclaringClass().isAnnotationPresent(Headers.class)) {\n        String[] headersOnType = method.getDeclaringClass().getAnnotation(Headers.class).value();\n        checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n                   method.getDeclaringClass().getName());\n        Map<String, Collection<String>> headers = toMap(headersOnType);\n        headers.putAll(data.template().headers());\n        data.template().headers(null); // to clear\n        data.template().headers(headers);\n      }\n      return data;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * @deprecated use {@link #parseAndValidateMetadata(Class, Method)} instead.\n     */\n    @Deprecated\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      return parseAndValidateMetadata(method.getDeclaringClass(), method);\n    }\n/**\n     * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n     */\n    protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n      MethodMetadata data = new MethodMetadata();\n      data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));\n      data.configKey(Feign.configKey(targetType, method));\n\n      for (Annotation methodAnnotation : method.getAnnotations()) {\n        processAnnotationOnMethod(data, methodAnnotation, method);\n      }\n      checkState(data.template().method() != null,\n                 \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n                 method.getName());\n      Class<?>[] parameterTypes = method.getParameterTypes();\n\n      Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n      int count = parameterAnnotations.length;\n      for (int i = 0; i < count; i++) {\n        boolean isHttpAnnotation = false;\n        if (parameterAnnotations[i] != null) {\n          isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n        }\n        if (parameterTypes[i] == URI.class) {\n          data.urlIndex(i);\n        } else if (!isHttpAnnotation) {\n          checkState(data.formParams().isEmpty(),\n                     \"Body parameters cannot be used with form parameters.\");\n          checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n          data.bodyIndex(i);\n          data.bodyType(Types.resolve(targetType, targetType, method.getGenericParameterTypes()[i]));\n        }\n      }\n      return data;\n    }\n@Override\n    protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n      MethodMetadata data = super.parseAndValidateMetadata(targetType, method);\n      headersFromAnnotation(method.getDeclaringClass(), data);\n      if (method.getDeclaringClass() != targetType) {\n        headersFromAnnotation(targetType, data);\n      }\n      return data;\n    }\nprivate void headersFromAnnotation(Class<?> targetType, MethodMetadata data) {\n      if (targetType.isAnnotationPresent(Headers.class)) {\n        String[] headersOnType = targetType.getAnnotation(Headers.class).value();\n        checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n                   targetType.getName());\n        Map<String, Collection<String>> headers = toMap(headersOnType);\n        headers.putAll(data.template().headers());\n        data.template().headers(null); // to clear\n        data.template().headers(headers);\n      }\n    }\n DiffSourceCode:\n-   54:     /**\n-   55:      * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n-   56:      */\n-   57:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n-   58:       MethodMetadata data = new MethodMetadata();\n-   59:       data.returnType(method.getGenericReturnType());\n-   60:       data.configKey(Feign.configKey(method));\n-   61: \n-   62:       for (Annotation methodAnnotation : method.getAnnotations()) {\n-   63:         processAnnotationOnMethod(data, methodAnnotation, method);\n-   64:       }\n-   65:       checkState(data.template().method() != null,\n-   66:                  \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n-   67:                  method.getName());\n-   68:       Class<?>[] parameterTypes = method.getParameterTypes();\n-   69: \n-   70:       Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n-   71:       int count = parameterAnnotations.length;\n-   72:       for (int i = 0; i < count; i++) {\n-   73:         boolean isHttpAnnotation = false;\n-   74:         if (parameterAnnotations[i] != null) {\n-   75:           isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n-   76:         }\n-   77:         if (parameterTypes[i] == URI.class) {\n-   78:           data.urlIndex(i);\n-   79:         } else if (!isHttpAnnotation) {\n-   80:           checkState(data.formParams().isEmpty(),\n-   81:                      \"Body parameters cannot be used with form parameters.\");\n-   82:           checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n-   83:           data.bodyIndex(i);\n-   84:           data.bodyType(method.getGenericParameterTypes()[i]);\n-   85:         }\n-   86:       }\n-   87:       return data;\n-   88:     }\n-   89: \n-   90:     /**\n-   91:      * @param data       metadata collected so far relating to the current java method.\n-   92:      * @param annotation annotations present on the current method annotation.\n-   93:      * @param method     method currently being processed.\n-   94:      */\n-   95:     protected abstract void processAnnotationOnMethod(MethodMetadata data, Annotation annotation,\n-   96:                                                       Method method);\n-   97: \n-   98:     /**\n-   99:      * @param data        metadata collected so far relating to the current java method.\n-  100:      * @param annotations annotations present on the current parameter annotation.\n-  101:      * @param paramIndex  if you find a name in {@code annotations}, call {@link\n-  102:      *                    #nameParam(MethodMetadata, String, int)} with this as the last parameter.\n-  103:      * @return true if you called {@link #nameParam(MethodMetadata, String, int)} after finding an\n-  104:      * http-relevant annotation.\n-  105:      */\n-  106:     protected abstract boolean processAnnotationsOnParameter(MethodMetadata data,\n-  107:                                                              Annotation[] annotations,\n-  108:                                                              int paramIndex);\n-  109: \n-  110: \n-  111:     protected Collection<String> addTemplatedParam(Collection<String> possiblyNull, String name) {\n-  133:     @Override\n-  134:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n-  135:       MethodMetadata data = super.parseAndValidatateMetadata(method);\n-  136:       if (method.getDeclaringClass().isAnnotationPresent(Headers.class)) {\n-  137:         String[] headersOnType = method.getDeclaringClass().getAnnotation(Headers.class).value();\n-  138:         checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n-  139:                    method.getDeclaringClass().getName());\n-  140:         Map<String, Collection<String>> headers = toMap(headersOnType);\n-  141:         headers.putAll(data.template().headers());\n-  142:         data.template().headers(null); // to clear\n-  143:         data.template().headers(headers);\n-  144:       }\n-  145:       return data;\n-  146:     }\n-  156:         if (requestLine.indexOf(' ') == -1) {\n-  157:           data.template().method(requestLine);\n-  158:           return;\n-  159:         }\n-  160:         data.template().method(requestLine.substring(0, requestLine.indexOf(' ')));\n-  161:         if (requestLine.indexOf(' ') == requestLine.lastIndexOf(' ')) {\n-  162:           // no HTTP version is ok\n-  163:           data.template().append(requestLine.substring(requestLine.indexOf(' ') + 1));\n-  164:         } else {\n-  166:           data.template().append(\n-  167:               requestLine.substring(requestLine.indexOf(' ') + 1, requestLine.lastIndexOf(' ')));\n-  168:         }\n-  169:         \n-  170:         data.template().decodeSlash(RequestLine.class.cast(methodAnnotation).decodeSlash());\n-  171:         \n-  172:       } else if (annotationType == Body.class) {\n-  173:         String body = Body.class.cast(methodAnnotation).value();\n-  174:         checkState(emptyToNull(body) != null, \"Body annotation was empty on method %s.\",\n-  175:                    method.getName());\n-  176:         if (body.indexOf('{') == -1) {\n+   54:                    targetType.getSimpleName());\n+   55:       }\n+   56:       Map<String, MethodMetadata> result = new LinkedHashMap<String, MethodMetadata>();\n+   57:       for (Method method : targetType.getMethods()) {\n+   58:         if (method.getDeclaringClass() == Object.class) {\n+   59:           continue;\n+   60:         }\n+   61:         MethodMetadata metadata = parseAndValidateMetadata(targetType, method);\n+   62:         checkState(!result.containsKey(metadata.configKey()), \"Overrides unsupported: %s\",\n+   63:                    metadata.configKey());\n+   64:         result.put(metadata.configKey(), metadata);\n+   65:       }\n+   66:       return new ArrayList<MethodMetadata>(result.values());\n+   67:     }\n+   68: \n+   69:     /**\n+   70:      * @deprecated use {@link #parseAndValidateMetadata(Class, Method)} instead.\n+   71:      */\n+   72:     @Deprecated\n+   73:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n+   74:       return parseAndValidateMetadata(method.getDeclaringClass(), method);\n+   75:     }\n+   76: \n+   77:     /**\n+   78:      * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n+   79:      */\n+   80:     protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n+   81:       MethodMetadata data = new MethodMetadata();\n+   82:       data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));\n+   83:       data.configKey(Feign.configKey(targetType, method));\n+   84: \n+   85:       for (Annotation methodAnnotation : method.getAnnotations()) {\n+   86:         processAnnotationOnMethod(data, methodAnnotation, method);\n+   87:       }\n+   88:       checkState(data.template().method() != null,\n+   89:                  \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n+   90:                  method.getName());\n+   91:       Class<?>[] parameterTypes = method.getParameterTypes();\n+   92: \n+   93:       Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n+   94:       int count = parameterAnnotations.length;\n+   95:       for (int i = 0; i < count; i++) {\n+   96:         boolean isHttpAnnotation = false;\n+   97:         if (parameterAnnotations[i] != null) {\n+   98:           isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n+   99:         }\n+  100:         if (parameterTypes[i] == URI.class) {\n+  101:           data.urlIndex(i);\n+  102:         } else if (!isHttpAnnotation) {\n+  103:           checkState(data.formParams().isEmpty(),\n+  104:                      \"Body parameters cannot be used with form parameters.\");\n+  105:           checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n+  106:           data.bodyIndex(i);\n+  107:           data.bodyType(Types.resolve(targetType, targetType, method.getGenericParameterTypes()[i]));\n+  108:         }\n+  109:       }\n+  110:       return data;\n+  111:     }\n+  133: \n+  134:     protected Collection<String> addTemplatedParam(Collection<String> possiblyNull, String name) {\n+  135:       if (possiblyNull == null) {\n+  136:         possiblyNull = new ArrayList<String>();\n+  137:       }\n+  138:       possiblyNull.add(String.format(\"{%s}\", name));\n+  139:       return possiblyNull;\n+  140:     }\n+  141: \n+  142:     /**\n+  143:      * links a parameter name to its index in the method signature.\n+  144:      */\n+  145:     protected void nameParam(MethodMetadata data, String name, int i) {\n+  146:       Collection<String>\n+  156:     @Override\n+  157:     protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n+  158:       MethodMetadata data = super.parseAndValidateMetadata(targetType, method);\n+  159:       headersFromAnnotation(method.getDeclaringClass(), data);\n+  160:       if (method.getDeclaringClass() != targetType) {\n+  161:         headersFromAnnotation(targetType, data);\n+  162:       }\n+  163:       return data;\n+  164:     }\n+  166:     private void headersFromAnnotation(Class<?> targetType, MethodMetadata data) {\n+  167:       if (targetType.isAnnotationPresent(Headers.class)) {\n+  168:         String[] headersOnType = targetType.getAnnotation(Headers.class).value();\n+  169:         checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n+  170:                    targetType.getName());\n+  171:         Map<String, Collection<String>> headers = toMap(headersOnType);\n+  172:         headers.putAll(data.template().headers());\n+  173:         data.template().headers(null); // to clear\n+  174:         data.template().headers(headers);\n+  175:       }\n+  176:     }\n\n",
        "contextDescription": "PackageName: org.broadleafcommerce.openadmin.web.controller\nClassName: org.broadleafcommerce.openadmin.web.controller.AdminAbstractController\nMethodName: org.broadleafcommerce.openadmin.web.controller.AdminAbstractController#getBlankDynamicFieldTemplateForm\n ClassSignature: public abstract class AdminAbstractController extends BroadleafAbstractController \n",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n/**\n     * Convenience method for obtaining a blank dynamic field template form. For example, if the main entity form should\n     * render different fields depending on the value of a specific field in that main form itself, the \"dynamic\" fields\n     * are generated by this method. Because this is invoked when a new value is chosen, the form generated by this method\n     * will never have values set.\n     * \n     * @param info\n     * @return the entity form\n     * @throws ServiceException\n     */\n    protected EntityForm getBlankDynamicFieldTemplateForm(DynamicEntityFormInfo info, EntityForm dynamicFormOverride) \n            throws ServiceException {\n        // We need to inspect with the second custom criteria set to the id of\n        // the desired structured content type\n        PersistencePackageRequest ppr = PersistencePackageRequest.standard()\n                .withCeilingEntityClassname(info.getCeilingClassName())\n                .withSecurityCeilingEntityClassname(info.getSecurityCeilingClassName())\n                .withCustomCriteria(new String[] { info.getCriteriaName(), null, info.getPropertyName(), info.getPropertyValue() });\n        ClassMetadata cmd = service.getClassMetadata(ppr).getDynamicResultSet().getClassMetaData();\n        \n        EntityForm dynamicForm = formService.createEntityForm(cmd, null);\n        dynamicForm.clearFieldsMap();\n\n        if (dynamicFormOverride != null) {\n            dynamicFormOverride.clearFieldsMap();\n            Map<String, Field> fieldOverrides = dynamicFormOverride.getFields();\n            for (Entry<String, Field> override : fieldOverrides.entrySet()) {\n                if (dynamicForm.getFields().containsKey(override.getKey())) {\n                    dynamicForm.getFields().get(override.getKey()).setValue(override.getValue().getValue());\n                }\n            }\n        }\n        \n        // Set the specialized name for these fields - we need to handle them separately\n        dynamicForm.clearFieldsMap();\n        for (Tab tab : dynamicForm.getTabs()) {\n            for (FieldGroup group : tab.getFieldGroups()) {\n                for (Field field : group.getFields()) {\n                    field.setName(info.getPropertyName() + DynamicEntityFormInfo.FIELD_SEPARATOR + field.getName());\n                }\n            }\n        }\n\n        //extensionManager.getProxy().modifyDynamicForm(dynamicForm, );\n\n        return dynamicForm;\n    }\n\nThe context of the source code is as follows:\nPackageName: org.broadleafcommerce.openadmin.web.controller\nClassName: org.broadleafcommerce.openadmin.web.controller.AdminAbstractController\nMethodName: org.broadleafcommerce.openadmin.web.controller.AdminAbstractController#getBlankDynamicFieldTemplateForm\n ClassSignature: public abstract class AdminAbstractController extends BroadleafAbstractController\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n\n    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n    {\n      arrayClass._extends(_directArrayClass.narrow(itemJClass));\n    }\n    else\n    {\n      arrayClass._extends(_wrappingArrayClass.narrow(itemJClass));\n    }\n\n    /** see {@link #schemaForArrayItemsOrMapValues} */\n    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n\n    generateConstructorWithNoArg(arrayClass, _dataListClass);\n    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n    generateConstructorWithCollection(arrayClass, itemJClass);\n    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n\n    generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n\n    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n\n    generateCopierMethods(arrayClass);\n  }\nprotected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass valueJClass = generate(mapSpec.getValueClass());\n    final JClass dataJClass = generate(mapSpec.getValueDataClass());\n\n    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n    {\n      mapClass._extends(_directMapClass.narrow(valueJClass));\n    }\n    else\n    {\n      mapClass._extends(_wrappingMapClass.narrow(valueJClass));\n    }\n\n    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n    final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n\n    generateConstructorWithNoArg(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n    generateConstructorWithMap(mapClass, valueJClass);\n    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n\n    generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n\n    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n\n    generateCopierMethods(mapClass);\n  }\nprotected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n      throws JClassAlreadyExistsException\n  {\n    templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n\n    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n\n    templateClass._extends(_recordClass);\n\n    generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n\n    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n\n    for (RecordTemplateSpec.Field field : recordSpec.getFields())\n    {\n      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n\n      if (field.getCustomInfo() != null)\n      {\n        generateCustomClassInitialization(templateClass, field.getCustomInfo());\n      }\n    }\n\n    generateCopierMethods(templateClass);\n  }\nprotected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n      throws JClassAlreadyExistsException\n  {\n    unionClass._extends(getUnionClass());\n\n    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n\n    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n    generateConstructorWithObjectArg(unionClass, schemaField);\n\n    for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n    {\n      if (member.getClassTemplateSpec() != null)\n      {\n        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n      }\n    }\n\n    generatePathSpecMethodsForUnion(unionSpec, unionClass);\n\n    generateCopierMethods(unionClass);\n\n    if (unionSpec.getTyperefClass() != null)\n    {\n      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n      generateTyperef(typerefInfoClass, typerefClassSpec);\n\n      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n      typerefInfoField.init(JExpr._new(typerefInfoClass));\n\n      unionClass._implements(HasTyperefInfo.class);\n      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n      typerefInfoMethod.body()._return(typerefInfoField);\n    }\n  }\n SourceCodeAfterRefactoring:\nprotected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n    final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n\n    if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n    {\n      arrayClass._extends(_directArrayBaseClass.narrow(itemJClass));\n    }\n    else\n    {\n      extendWrappingArrayBaseClass(itemJClass, arrayClass);\n    }\n\n    /** see {@link #schemaForArrayItemsOrMapValues} */\n    final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n    final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n\n    generateConstructorWithNoArg(arrayClass, _dataListClass);\n    generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n    generateConstructorWithCollection(arrayClass, itemJClass);\n    generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n    }\n\n    generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(arrayClass);\n    }\n  }\nprotected void extendWrappingArrayBaseClass(JClass itemJClass, JDefinedClass arrayClass)\n  {\n    arrayClass._extends(_wrappingArrayBaseClass.narrow(itemJClass));\n  }\nprotected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n      throws JClassAlreadyExistsException\n  {\n    final JClass valueJClass = generate(mapSpec.getValueClass());\n    final JClass dataJClass = generate(mapSpec.getValueDataClass());\n\n    if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n    {\n      mapClass._extends(_directMapBaseClass.narrow(valueJClass));\n    }\n    else\n    {\n      extendWrappingMapBaseClass(valueJClass, mapClass);\n    }\n\n    final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n    final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n\n    generateConstructorWithNoArg(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n    generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n    generateConstructorWithMap(mapClass, valueJClass);\n    generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n    }\n\n    generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(mapClass);\n    }\n  }\nprotected void extendWrappingMapBaseClass(JClass valueJClass, JDefinedClass mapClass)\n  {\n    mapClass._extends(_wrappingMapBaseClass.narrow(valueJClass));\n  }\nprotected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n      throws JClassAlreadyExistsException\n  {\n    templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n\n    setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n\n    extendRecordBaseClass(templateClass);\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n    }\n\n    final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n    generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n    generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n\n    for (RecordTemplateSpec.Field field : recordSpec.getFields())\n    {\n      generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n\n      if (field.getCustomInfo() != null)\n      {\n        generateCustomClassInitialization(templateClass, field.getCustomInfo());\n      }\n    }\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(templateClass);\n    }\n  }\nprotected void extendRecordBaseClass(JDefinedClass templateClass)\n  {\n    templateClass._extends(_recordBaseClass);\n  }\nprotected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n      throws JClassAlreadyExistsException\n  {\n    extendUnionBaseClass(unionClass);\n\n    final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n\n    generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n    generateConstructorWithObjectArg(unionClass, schemaField);\n\n    for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n    {\n      if (member.getClassTemplateSpec() != null)\n      {\n        generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n      }\n    }\n\n    if (_pathSpecMethods)\n    {\n      generatePathSpecMethodsForUnion(unionSpec, unionClass);\n    }\n\n    if (_copierMethods)\n    {\n      generateCopierMethods(unionClass);\n    }\n\n    if (unionSpec.getTyperefClass() != null)\n    {\n      final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n      final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n      generateTyperef(typerefInfoClass, typerefClassSpec);\n\n      final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n      typerefInfoField.init(JExpr._new(typerefInfoClass));\n\n      unionClass._implements(HasTyperefInfo.class);\n      final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n      typerefInfoMethod.body()._return(typerefInfoField);\n    }\n  }\nprotected void extendUnionBaseClass(JDefinedClass unionClass)\n  {\n    unionClass._extends(_unionBaseClass);\n  }\n DiffSourceCode:\n-  419:   protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n-  420:       throws JClassAlreadyExistsException\n-  421:   {\n-  422:     final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n-  423:     final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n-  424: \n-  425:     if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n-  426:     {\n-  427:       arrayClass._extends(_directArrayClass.narrow(itemJClass));\n-  428:     }\n-  429:     else\n-  430:     {\n-  431:       arrayClass._extends(_wrappingArrayClass.narrow(itemJClass));\n-  432:     }\n-  433: \n-  434:     /** see {@link #schemaForArrayItemsOrMapValues} */\n-  435:     final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n-  436:     final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n-  437: \n-  438:     generateConstructorWithNoArg(arrayClass, _dataListClass);\n-  439:     generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n-  440:     generateConstructorWithCollection(arrayClass, itemJClass);\n-  441:     generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n-  442: \n-  443:     generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n-  444: \n-  445:     generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n-  446: \n-  447:     generateCopierMethods(arrayClass);\n-  448:   }\n-  456:     generateSchemaField(enumClass, enumSpec.getSchema());\n-  457: \n-  458:     for (String value : enumSpec.getSchema().getSymbols())\n-  459:     {\n-  460:       if (isReserved(value))\n-  461:       {\n-  462:         throw new IllegalArgumentException(\"Enum contains Java reserved symbol: \" + value + \" schema: \" + enumSpec.getSchema());\n-  463:       }\n-  464: \n-  465:       final JEnumConstant enumConstant = enumClass.enumConstant(value);\n-  466: \n-  467:       final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);\n-  468: \n-  469:       if (enumConstantDoc != null)\n-  470:       {\n-  471:         enumConstant.javadoc().append(enumConstantDoc);\n-  472:       }\n-  473: \n-  474:       setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);\n-  475:     }\n-  476:     enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);\n-  477:   }\n-  478: \n-  479:   protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)\n-  480:   {\n-  481:     fixedClass.javadoc().append(fixedSpec.getSchema().getDoc());\n-  482: \n-  483:     setDeprecatedAnnotationAndJavadoc(fixedSpec.getSchema(), fixedClass);\n+  419:     if (result == null)\n+  420:     {\n+  421:       final int jmodValue = getJModValue(classTemplateSpec.getModifiers());\n+  422:       final JClassContainer container;\n+  423:       if (classTemplateSpec.getEnclosingClass() == null)\n+  424:       {\n+  425:         container = getPackage(classTemplateSpec.getNamespace());\n+  426:       }\n+  427:       else\n+  428:       {\n+  429:         container = defineClass(classTemplateSpec.getEnclosingClass());\n+  430:       }\n+  431: \n+  432:       if (classTemplateSpec instanceof ArrayTemplateSpec ||\n+  433:           classTemplateSpec instanceof FixedTemplateSpec ||\n+  434:           classTemplateSpec instanceof MapTemplateSpec ||\n+  435:           classTemplateSpec instanceof RecordTemplateSpec ||\n+  436:           classTemplateSpec instanceof TyperefTemplateSpec ||\n+  437:           classTemplateSpec instanceof UnionTemplateSpec)\n+  438:       {\n+  439:         result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()));\n+  440:       }\n+  441:       else if (classTemplateSpec instanceof EnumTemplateSpec)\n+  442:       {\n+  443:         result = container._class(jmodValue, escapeReserved(classTemplateSpec.getClassName()), ClassType.ENUM);\n+  444:       }\n+  445:       else\n+  446:       {\n+  447:         throw new RuntimeException();\n+  448:       }\n+  456:   protected void generateArray(JDefinedClass arrayClass, ArrayTemplateSpec arrayDataTemplateSpec)\n+  457:       throws JClassAlreadyExistsException\n+  458:   {\n+  459:     final JClass itemJClass = generate(arrayDataTemplateSpec.getItemClass());\n+  460:     final JClass dataJClass = generate(arrayDataTemplateSpec.getItemDataClass());\n+  461: \n+  462:     if (CodeUtil.isDirectType(arrayDataTemplateSpec.getSchema().getItems()))\n+  463:     {\n+  464:       arrayClass._extends(_directArrayBaseClass.narrow(itemJClass));\n+  465:     }\n+  466:     else\n+  467:     {\n+  468:       extendWrappingArrayBaseClass(itemJClass, arrayClass);\n+  469:     }\n+  470: \n+  471:     /** see {@link #schemaForArrayItemsOrMapValues} */\n+  472:     final DataSchema bareSchema = new ArrayDataSchema(schemaForArrayItemsOrMapValues(arrayDataTemplateSpec.getCustomInfo(), arrayDataTemplateSpec.getSchema().getItems()));\n+  473:     final JVar schemaField = generateSchemaField(arrayClass, bareSchema);\n+  474: \n+  475:     generateConstructorWithNoArg(arrayClass, _dataListClass);\n+  476:     generateConstructorWithInitialCapacity(arrayClass, _dataListClass);\n+  477:     generateConstructorWithCollection(arrayClass, itemJClass);\n+  478:     generateConstructorWithArg(arrayClass, schemaField, _dataListClass, itemJClass, dataJClass);\n+  479: \n+  480:     if (_pathSpecMethods)\n+  481:     {\n+  482:       generatePathSpecMethodsForCollection(arrayClass, arrayDataTemplateSpec.getSchema(), itemJClass, \"items\");\n+  483:     }\n   484: \n-  485:     fixedClass._extends(FixedTemplate.class);\n+  485:     generateCustomClassInitialization(arrayClass, arrayDataTemplateSpec.getCustomInfo());\n   486: \n-  487:     final JVar schemaField = generateSchemaField(fixedClass, fixedSpec.getSchema());\n-  488: \n-  489:     final JMethod bytesConstructor = fixedClass.constructor(JMod.PUBLIC);\n-  490:     final JVar param = bytesConstructor.param(ByteString.class, \"value\");\n-  491:     bytesConstructor.body().invoke(SUPER).arg(param).arg(schemaField);\n-  493:     generateConstructorWithObjectArg(fixedClass, schemaField);\n-  494: \n-  495:     generateCopierMethods(fixedClass);\n+  487:     if (_copierMethods)\n+  488:     {\n+  489:       generateCopierMethods(arrayClass);\n+  490:     }\n+  491:   }\n+  493:   protected void extendWrappingArrayBaseClass(JClass itemJClass, JDefinedClass arrayClass)\n+  494:   {\n+  495:     arrayClass._extends(_wrappingArrayBaseClass.narrow(itemJClass));\n   496:   }\n-  498:   protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n-  499:       throws JClassAlreadyExistsException\n-  500:   {\n-  501:     final JClass valueJClass = generate(mapSpec.getValueClass());\n-  502:     final JClass dataJClass = generate(mapSpec.getValueDataClass());\n+  498:   protected void generateEnum(JDefinedClass enumClass, EnumTemplateSpec enumSpec)\n+  499:   {\n+  500:     enumClass.javadoc().append(enumSpec.getSchema().getDoc());\n+  501: \n+  502:     setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), enumClass);\n   503: \n-  504:     if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n-  505:     {\n-  506:       mapClass._extends(_directMapClass.narrow(valueJClass));\n-  507:     }\n-  508:     else\n-  509:     {\n-  510:       mapClass._extends(_wrappingMapClass.narrow(valueJClass));\n-  511:     }\n+  504:     generateSchemaField(enumClass, enumSpec.getSchema());\n+  505: \n+  506:     for (String value : enumSpec.getSchema().getSymbols())\n+  507:     {\n+  508:       if (isReserved(value))\n+  509:       {\n+  510:         throw new IllegalArgumentException(\"Enum contains Java reserved symbol: \" + value + \" schema: \" + enumSpec.getSchema());\n+  511:       }\n   512: \n-  513:     final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n-  514:     final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n-  515: \n-  516:     generateConstructorWithNoArg(mapClass, _dataMapClass);\n-  517:     generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n-  518:     generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n-  519:     generateConstructorWithMap(mapClass, valueJClass);\n-  520:     generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n+  513:       final JEnumConstant enumConstant = enumClass.enumConstant(value);\n+  514: \n+  515:       final String enumConstantDoc = enumSpec.getSchema().getSymbolDocs().get(value);\n+  516: \n+  517:       if (enumConstantDoc != null)\n+  518:       {\n+  519:         enumConstant.javadoc().append(enumConstantDoc);\n+  520:       }\n   521: \n-  522:     generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n-  523: \n-  524:     generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n-  525: \n-  526:     generateCopierMethods(mapClass);\n-  527:   }\n-  549:         return getCodeModel().FLOAT.boxify();\n-  550: \n-  551:       case BYTES:\n-  552:         return _byteStringClass;\n-  553: \n-  554:       default:\n-  555:         throw new RuntimeException(\"Not supported primitive: \" + primitiveSpec);\n-  556:     }\n-  557:   }\n-  558: \n-  559:   protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n-  560:       throws JClassAlreadyExistsException\n-  561:   {\n-  562:     templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n+  522:       setDeprecatedAnnotationAndJavadoc(enumSpec.getSchema(), value, enumConstant);\n+  523:     }\n+  524:     enumClass.enumConstant(DataTemplateUtil.UNKNOWN_ENUM);\n+  525:   }\n+  526: \n+  527:   protected void generateFixed(JDefinedClass fixedClass, FixedTemplateSpec fixedSpec)\n+  549:   protected void generateMap(JDefinedClass mapClass, MapTemplateSpec mapSpec)\n+  550:       throws JClassAlreadyExistsException\n+  551:   {\n+  552:     final JClass valueJClass = generate(mapSpec.getValueClass());\n+  553:     final JClass dataJClass = generate(mapSpec.getValueDataClass());\n+  554: \n+  555:     if (CodeUtil.isDirectType(mapSpec.getSchema().getValues()))\n+  556:     {\n+  557:       mapClass._extends(_directMapBaseClass.narrow(valueJClass));\n+  558:     }\n+  559:     else\n+  560:     {\n+  561:       extendWrappingMapBaseClass(valueJClass, mapClass);\n+  562:     }\n   563: \n-  564:     setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n-  565: \n-  566:     templateClass._extends(_recordClass);\n-  567: \n-  568:     generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n-  569: \n-  570:     final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n-  571:     generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n-  572:     generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n-  573: \n-  574:     for (RecordTemplateSpec.Field field : recordSpec.getFields())\n-  575:     {\n-  576:       generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n+  564:     final DataSchema bareSchema = new MapDataSchema(schemaForArrayItemsOrMapValues(mapSpec.getCustomInfo(), mapSpec.getSchema().getValues()));\n+  565:     final JVar schemaField = generateSchemaField(mapClass, bareSchema);\n+  566: \n+  567:     generateConstructorWithNoArg(mapClass, _dataMapClass);\n+  568:     generateConstructorWithInitialCapacity(mapClass, _dataMapClass);\n+  569:     generateConstructorWithInitialCapacityAndLoadFactor(mapClass);\n+  570:     generateConstructorWithMap(mapClass, valueJClass);\n+  571:     generateConstructorWithArg(mapClass, schemaField, _dataMapClass, valueJClass, dataJClass);\n+  572: \n+  573:     if (_pathSpecMethods)\n+  574:     {\n+  575:       generatePathSpecMethodsForCollection(mapClass, mapSpec.getSchema(), valueJClass, \"values\");\n+  576:     }\n   577: \n-  578:       if (field.getCustomInfo() != null)\n-  579:       {\n-  580:         generateCustomClassInitialization(templateClass, field.getCustomInfo());\n-  581:       }\n-  582:     }\n-  583: \n-  584:     generateCopierMethods(templateClass);\n-  585:   }\n-  586: \n-  587:   private void generatePathSpecMethodsForRecord(List<RecordTemplateSpec.Field> fieldSpecs, JDefinedClass templateClass)\n-  588:       throws JClassAlreadyExistsException\n-  589:   {\n-  621:     if (isDirect)\n-  622:     {\n-  623:       wrappedOrDirect = (field.getCustomInfo() == null ? \"Direct\" : \"CustomType\");\n-  624:     }\n-  625:     else\n-  626:     {\n-  627:       wrappedOrDirect = \"Wrapped\";\n-  628:     }\n-  629:     final String capitalizedName = CodeUtil.capitalize(schemaField.getName());\n-  630: \n-  631:     final String fieldFieldName = \"FIELD_\" + capitalizedName;\n-  632:     final JFieldVar fieldField = templateClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, RecordDataSchema.Field.class, fieldFieldName);\n-  633:     fieldField.init(schemaFieldVar.invoke(\"getField\").arg(schemaField.getName()));\n+  578:     generateCustomClassInitialization(mapClass, mapSpec.getCustomInfo());\n+  579: \n+  580:     if (_copierMethods)\n+  581:     {\n+  582:       generateCopierMethods(mapClass);\n+  583:     }\n+  584:   }\n+  585: \n+  586:   protected void extendWrappingMapBaseClass(JClass valueJClass, JDefinedClass mapClass)\n+  587:   {\n+  588:     mapClass._extends(_wrappingMapBaseClass.narrow(valueJClass));\n+  589:   }\n+  621:   protected void generateRecord(JDefinedClass templateClass, RecordTemplateSpec recordSpec)\n+  622:       throws JClassAlreadyExistsException\n+  623:   {\n+  624:     templateClass.javadoc().append(recordSpec.getSchema().getDoc());\n+  625: \n+  626:     setDeprecatedAnnotationAndJavadoc(recordSpec.getSchema(), templateClass);\n+  627: \n+  628:     extendRecordBaseClass(templateClass);\n+  629: \n+  630:     if (_pathSpecMethods)\n+  631:     {\n+  632:       generatePathSpecMethodsForRecord(recordSpec.getFields(), templateClass);\n+  633:     }\n   634: \n-  635:     // Generate has method.\n-  636:     final JMethod has = templateClass.method(JMod.PUBLIC, getCodeModel().BOOLEAN, \"has\" + capitalizedName);\n-  637:     addAccessorDoc(has, schemaField, \"Existence checker\");\n-  638:     setDeprecatedAnnotationAndJavadoc(has, schemaField);\n-  639:     final JBlock hasBody = has.body();\n-  640:     JExpression res = JExpr.invoke(\"contains\").arg(fieldField);\n-  641:     hasBody._return(res);\n+  635:     final JFieldVar schemaFieldVar = generateSchemaField(templateClass, recordSpec.getSchema());\n+  636:     generateConstructorWithNoArg(templateClass, schemaFieldVar, _dataMapClass);\n+  637:     generateConstructorWithArg(templateClass, schemaFieldVar, _dataMapClass);\n+  638: \n+  639:     for (RecordTemplateSpec.Field field : recordSpec.getFields())\n+  640:     {\n+  641:       generateRecordFieldAccessors(templateClass, field, generate(field.getType()), schemaFieldVar);\n   642: \n-  643:     // Generate remove method.\n-  644:     final String removeName = \"remove\" + capitalizedName;\n-  645:     final JMethod remove = templateClass.method(JMod.PUBLIC, getCodeModel().VOID, removeName);\n-  646:     addAccessorDoc(remove, schemaField, \"Remover\");\n-  647:     setDeprecatedAnnotationAndJavadoc(remove, schemaField);\n-  648:     final JBlock removeBody = remove.body();\n-  649:     removeBody.invoke(\"remove\").arg(fieldField);\n-  650: \n-  651:     final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);\n-  652: \n-  653:     if (_recordFieldAccessorWithMode)\n-  655:       // Getter method with mode.\n-  656:       final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);\n-  657:       addAccessorDoc(getterWithMode, schemaField, \"Getter\");\n-  658:       setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);\n-  726:   protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n-  727:       throws JClassAlreadyExistsException\n-  728:   {\n-  729:     unionClass._extends(getUnionClass());\n-  730: \n-  731:     final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n-  732: \n-  733:     generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n-  734:     generateConstructorWithObjectArg(unionClass, schemaField);\n-  735: \n-  736:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n-  737:     {\n-  738:       if (member.getClassTemplateSpec() != null)\n-  739:       {\n-  740:         generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n-  741:       }\n-  742:     }\n-  743: \n-  744:     generatePathSpecMethodsForUnion(unionSpec, unionClass);\n-  745: \n-  746:     generateCopierMethods(unionClass);\n-  747: \n-  748:     if (unionSpec.getTyperefClass() != null)\n-  749:     {\n-  750:       final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n-  751:       final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n-  752:       generateTyperef(typerefInfoClass, typerefClassSpec);\n-  753: \n-  754:       final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n-  755:       typerefInfoField.init(JExpr._new(typerefInfoClass));\n-  756: \n-  757:       unionClass._implements(HasTyperefInfo.class);\n-  758:       final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n-  759:       typerefInfoMethod.body()._return(typerefInfoField);\n-  760:     }\n-  761:   }\n-  802:     final JInvocation inv = setter.body().invoke(\"select\" + wrappedOrDirect).arg(memberField).arg(JExpr.dotclass(memberClass));\n-  803:     dataClassArg(inv, dataClass).arg(memberKey).arg(param);\n-  804:   }\n-  805: \n-  806:   private void generatePathSpecMethodsForUnion(UnionTemplateSpec unionSpec, JDefinedClass unionClass)\n-  807:       throws JClassAlreadyExistsException\n-  808:   {\n-  809:     final JDefinedClass fieldsNestedClass = generatePathSpecNestedClass(unionClass);\n-  810: \n-  811:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n-  812:     {\n-  813:       JClass fieldsRefType = _pathSpecClass;\n-  814:       if (hasNestedFields(member.getSchema()))\n+  643:       if (field.getCustomInfo() != null)\n+  644:       {\n+  645:         generateCustomClassInitialization(templateClass, field.getCustomInfo());\n+  646:       }\n+  647:     }\n+  648: \n+  649:     if (_copierMethods)\n+  650:     {\n+  651:       generateCopierMethods(templateClass);\n+  652:     }\n+  653:   }\n+  655:   protected void extendRecordBaseClass(JDefinedClass templateClass)\n+  656:   {\n+  657:     templateClass._extends(_recordBaseClass);\n+  658:   }\n+  726: \n+  727:     final String getterName = JavaCodeUtil.getGetterName(getCodeModel(), type, capitalizedName);\n+  728: \n+  729:     if (_recordFieldAccessorWithMode)\n+  730:     {\n+  731:       // Getter method with mode.\n+  732:       final JMethod getterWithMode = templateClass.method(JMod.PUBLIC, type, getterName);\n+  733:       addAccessorDoc(getterWithMode, schemaField, \"Getter\");\n+  734:       setDeprecatedAnnotationAndJavadoc(getterWithMode, schemaField);\n+  735:       JVar modeParam = getterWithMode.param(_getModeClass, \"mode\");\n+  736:       final JBlock getterWithModeBody = getterWithMode.body();\n+  737:       res = JExpr.invoke(\"obtain\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(modeParam);\n+  738:       getterWithModeBody._return(res);\n+  739:     }\n+  740: \n+  741:     // Getter method without mode.\n+  742:     final JMethod getterWithoutMode = templateClass.method(JMod.PUBLIC, type, getterName);\n+  743:     addAccessorDoc(getterWithoutMode, schemaField, \"Getter\");\n+  744:     setDeprecatedAnnotationAndJavadoc(getterWithoutMode, schemaField);\n+  745:     final JBlock getterWithoutModeBody = getterWithoutMode.body();\n+  746:     res = JExpr.invoke(\"obtain\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type)).arg(_strictGetMode);\n+  747:     getterWithoutModeBody._return(res);\n+  748: \n+  749:     // Determine dataClass\n+  750:     final JClass dataClass = generate(field.getDataClass());\n+  751:     final String setterName = \"set\" + capitalizedName;\n+  752: \n+  753:     if (_recordFieldAccessorWithMode)\n+  754:     {\n+  755:       // Setter method with mode\n+  756:       final JMethod setterWithMode = templateClass.method(JMod.PUBLIC, templateClass, setterName);\n+  757:       addAccessorDoc(setterWithMode, schemaField, \"Setter\");\n+  758:       setDeprecatedAnnotationAndJavadoc(setterWithMode, schemaField);\n+  759:       JVar param = setterWithMode.param(type, \"value\");\n+  760:       JVar modeParam = setterWithMode.param(_setModeClass, \"mode\");\n+  761:       JInvocation inv = setterWithMode.body().invoke(\"put\" + wrappedOrDirect).arg(fieldField).arg(JExpr.dotclass(type));\n+  802:   protected void generateUnion(JDefinedClass unionClass, UnionTemplateSpec unionSpec)\n+  803:       throws JClassAlreadyExistsException\n+  804:   {\n+  805:     extendUnionBaseClass(unionClass);\n+  806: \n+  807:     final JVar schemaField = generateSchemaField(unionClass, unionSpec.getSchema());\n+  808: \n+  809:     generateConstructorWithNoArg(unionClass, schemaField, _dataMapClass);\n+  810:     generateConstructorWithObjectArg(unionClass, schemaField);\n+  811: \n+  812:     for (UnionTemplateSpec.Member member : unionSpec.getMembers())\n+  813:     {\n+  814:       if (member.getClassTemplateSpec() != null)\n   815:       {\n-  816:         final JClass unionMemberClass = generate(member.getClassTemplateSpec());\n-  817:         fieldsRefType = getCodeModel().ref(unionMemberClass.fullName() + \".Fields\");\n-  818:       }\n-  819:       final JMethod accessorMethod = fieldsNestedClass.method(JMod.PUBLIC, fieldsRefType, CodeUtil.getUnionMemberName(member.getSchema()));\n-  820:       accessorMethod.body()._return(JExpr._new(fieldsRefType).arg(JExpr.invoke(\"getPathComponents\")).arg(member.getSchema().getUnionMemberKey()));\n-  821:     }\n-  822:   }\n-  823: \n-  824:   private void populateClassContent(ClassTemplateSpec classTemplateSpec, JDefinedClass definedClass)\n-  825:       throws JClassAlreadyExistsException\n-  826:   {\n-  827:     if (!_generatedClasses.containsKey(definedClass))\n-  828:     {\n-  829:       _generatedClasses.put(definedClass, classTemplateSpec);\n-  830: \n-  831:       JavaCodeUtil.annotate(definedClass, \"Data Template\", classTemplateSpec.getLocation());\n-  832: \n-  833:       if (classTemplateSpec instanceof ArrayTemplateSpec)\n-  834:       {\n-  835:         generateArray(definedClass, (ArrayTemplateSpec) classTemplateSpec);\n-  836:       }\n-  837:       else if (classTemplateSpec instanceof EnumTemplateSpec)\n-  838:       {\n-  839:         generateEnum(definedClass, (EnumTemplateSpec) classTemplateSpec);\n-  840:       }\n-  841:       else if (classTemplateSpec instanceof FixedTemplateSpec)\n-  842:       {\n-  843:         generateFixed(definedClass, (FixedTemplateSpec) classTemplateSpec);\n-  845:       else if (classTemplateSpec instanceof MapTemplateSpec)\n-  846:       {\n-  847:         generateMap(definedClass, (MapTemplateSpec) classTemplateSpec);\n-  848:       }\n+  816:         generateUnionMemberAccessors(unionClass, member.getSchema(), generate(member.getClassTemplateSpec()), generate(member.getDataClass()), schemaField);\n+  817:       }\n+  818:     }\n+  819: \n+  820:     if (_pathSpecMethods)\n+  821:     {\n+  822:       generatePathSpecMethodsForUnion(unionSpec, unionClass);\n+  823:     }\n+  824: \n+  825:     if (_copierMethods)\n+  826:     {\n+  827:       generateCopierMethods(unionClass);\n+  828:     }\n+  829: \n+  830:     if (unionSpec.getTyperefClass() != null)\n+  831:     {\n+  832:       final TyperefTemplateSpec typerefClassSpec = unionSpec.getTyperefClass();\n+  833:       final JDefinedClass typerefInfoClass = unionClass._class(getJModValue(typerefClassSpec.getModifiers()), escapeReserved(typerefClassSpec.getClassName()));\n+  834:       generateTyperef(typerefInfoClass, typerefClassSpec);\n+  835: \n+  836:       final JFieldVar typerefInfoField = unionClass.field(JMod.PRIVATE | JMod.STATIC | JMod.FINAL, TyperefInfo.class, DataTemplateUtil.TYPEREFINFO_FIELD_NAME);\n+  837:       typerefInfoField.init(JExpr._new(typerefInfoClass));\n+  838: \n+  839:       unionClass._implements(HasTyperefInfo.class);\n+  840:       final JMethod typerefInfoMethod = unionClass.method(JMod.PUBLIC, TyperefInfo.class, \"typerefInfo\");\n+  841:       typerefInfoMethod.body()._return(typerefInfoField);\n+  842:     }\n+  843:   }\n+  845:   protected void extendUnionBaseClass(JDefinedClass unionClass)\n+  846:   {\n+  847:     unionClass._extends(_unionBaseClass);\n+  848:   }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Test\n\tpublic void overridePidFileWithSpring() throws Exception {\n\t\tFile file = this.temporaryFolder.newFile();\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tMockPropertySource propertySource = new MockPropertySource();\n\t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n\t\tgiven(context.getEnvironment()).willReturn(environment);\n\t\tApplicationPreparedEvent event = new ApplicationPreparedEvent(\n\t\t\t\tnew SpringApplication(), new String[] {}, context);\n\t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n\t}\n@Test\n\tpublic void differentEventTypes() throws Exception {\n\t\tFile file = this.temporaryFolder.newFile();\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tMockPropertySource propertySource = new MockPropertySource();\n\t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\tApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(\n\t\t\t\tnew SpringApplication(), new String[] {}, environment);\n\t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n\t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n\t\tlistener.onApplicationEvent(event);\n\t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n\t}\n SourceCodeAfterRefactoring:\nprivate SpringApplicationEvent createPreparedEvent(String propName, String propValue) {\n\t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n\t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n\t\tgiven(context.getEnvironment()).willReturn(environment);\n\t\treturn new ApplicationPreparedEvent(new SpringApplication(), new String[] {},\n\t\t\t\tcontext);\n\t}\nprivate ConfigurableEnvironment createEnvironment(String propName, String propValue) {\n\t\tMockPropertySource propertySource = mockPropertySource(propName, propValue);\n\t\tConfigurableEnvironment environment = new StandardEnvironment();\n\t\tenvironment.getPropertySources().addLast(propertySource);\n\t\treturn environment;\n\t}\nprivate SpringApplicationEvent createEnvironmentPreparedEvent(String propName,\n\t\t\tString propValue) {\n\t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n\t\treturn new ApplicationEnvironmentPreparedEvent(new SpringApplication(),\n\t\t\t\tnew String[] {}, environment);\n\t}\n DiffSourceCode:\n-   85: \t@Test\n-   86: \tpublic void overridePidFileWithSpring() throws Exception {\n-   87: \t\tFile file = this.temporaryFolder.newFile();\n-   88: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n-   89: \t\tMockPropertySource propertySource = new MockPropertySource();\n-   90: \t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n-   91: \t\tenvironment.getPropertySources().addLast(propertySource);\n-   92: \t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n-   93: \t\tgiven(context.getEnvironment()).willReturn(environment);\n-   94: \t\tApplicationPreparedEvent event = new ApplicationPreparedEvent(\n-   95: \t\t\t\tnew SpringApplication(), new String[] {}, context);\n-   96: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n-   97: \t\tlistener.onApplicationEvent(event);\n-   98: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n-   99: \t}\n-  101: \t@Test\n-  102: \tpublic void differentEventTypes() throws Exception {\n-  103: \t\tFile file = this.temporaryFolder.newFile();\n-  104: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n-  105: \t\tMockPropertySource propertySource = new MockPropertySource();\n-  106: \t\tpropertySource.setProperty(\"spring.pidfile\", file.getAbsolutePath());\n-  107: \t\tenvironment.getPropertySources().addLast(propertySource);\n-  108: \t\tApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(\n-  109: \t\t\t\tnew SpringApplication(), new String[] {}, environment);\n-  110: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+   85: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);\n+   86: \t\tlistener.onApplicationEvent(EVENT);\n+   87: \t\tassertThat(\n+   88: \t\t\t\tFileCopyUtils.copyToString(new FileReader(System.getProperty(\"PIDFILE\"))),\n+   89: \t\t\t\tnot(isEmptyString()));\n+   90: \t}\n+   91: \n+   92: \t@Test\n+   93: \tpublic void overridePidFileWithSpring() throws Exception {\n+   94: \t\tFile file = this.temporaryFolder.newFile();\n+   95: \t\tSpringApplicationEvent event = createPreparedEvent(\"spring.pidfile\",\n+   96: \t\t\t\tfile.getAbsolutePath());\n+   97: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+   98: \t\tlistener.onApplicationEvent(event);\n+   99: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n+  101: \n+  102: \t@Test\n+  103: \tpublic void differentEventTypes() throws Exception {\n+  104: \t\tFile file = this.temporaryFolder.newFile();\n+  105: \t\tSpringApplicationEvent event = createEnvironmentPreparedEvent(\"spring.pidfile\",\n+  106: \t\t\t\tfile.getAbsolutePath());\n+  107: \t\tApplicationPidFileWriter listener = new ApplicationPidFileWriter();\n+  108: \t\tlistener.onApplicationEvent(event);\n+  109: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n+  110: \t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n   111: \t\tlistener.onApplicationEvent(event);\n-  112: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), isEmptyString());\n-  113: \t\tlistener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);\n-  114: \t\tlistener.onApplicationEvent(event);\n-  115: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n-  116: \t}\n+  112: \t\tassertThat(FileCopyUtils.copyToString(new FileReader(file)), not(isEmptyString()));\n+  113: \t}\n+  114: \n+  115: \t@Test\n+  116: \tpublic void withNoEnvironment() throws Exception {\n+  157: \tprivate SpringApplicationEvent createEnvironmentPreparedEvent(String propName,\n+  158: \t\t\tString propValue) {\n+  159: \t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n+  160: \t\treturn new ApplicationEnvironmentPreparedEvent(new SpringApplication(),\n+  161: \t\t\t\tnew String[] {}, environment);\n+  162: \t}\n+  164: \tprivate SpringApplicationEvent createPreparedEvent(String propName, String propValue) {\n+  165: \t\tConfigurableEnvironment environment = createEnvironment(propName, propValue);\n+  166: \t\tConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);\n+  167: \t\tgiven(context.getEnvironment()).willReturn(environment);\n+  168: \t\treturn new ApplicationPreparedEvent(new SpringApplication(), new String[] {},\n+  169: \t\t\t\tcontext);\n+  170: \t}\n+  172: \tprivate ConfigurableEnvironment createEnvironment(String propName, String propValue) {\n+  173: \t\tMockPropertySource propertySource = mockPropertySource(propName, propValue);\n+  174: \t\tConfigurableEnvironment environment = new StandardEnvironment();\n+  175: \t\tenvironment.getPropertySources().addLast(propertySource);\n+  176: \t\treturn environment;\n+  177: \t}\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n /**\n     * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n     */\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      MethodMetadata data = new MethodMetadata();\n      data.returnType(method.getGenericReturnType());\n      data.configKey(Feign.configKey(method));\n\n      for (Annotation methodAnnotation : method.getAnnotations()) {\n        processAnnotationOnMethod(data, methodAnnotation, method);\n      }\n      checkState(data.template().method() != null,\n                 \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n                 method.getName());\n      Class<?>[] parameterTypes = method.getParameterTypes();\n\n      Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n      int count = parameterAnnotations.length;\n      for (int i = 0; i < count; i++) {\n        boolean isHttpAnnotation = false;\n        if (parameterAnnotations[i] != null) {\n          isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n        }\n        if (parameterTypes[i] == URI.class) {\n          data.urlIndex(i);\n        } else if (!isHttpAnnotation) {\n          checkState(data.formParams().isEmpty(),\n                     \"Body parameters cannot be used with form parameters.\");\n          checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n          data.bodyIndex(i);\n          data.bodyType(method.getGenericParameterTypes()[i]);\n        }\n      }\n      return data;\n    }\n@Override\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      MethodMetadata data = super.parseAndValidatateMetadata(method);\n      if (method.getDeclaringClass().isAnnotationPresent(Headers.class)) {\n        String[] headersOnType = method.getDeclaringClass().getAnnotation(Headers.class).value();\n        checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n                   method.getDeclaringClass().getName());\n        Map<String, Collection<String>> headers = toMap(headersOnType);\n        headers.putAll(data.template().headers());\n        data.template().headers(null); // to clear\n        data.template().headers(headers);\n      }\n      return data;\n    }\n SourceCodeAfterRefactoring:\n/**\n     * @deprecated use {@link #parseAndValidateMetadata(Class, Method)} instead.\n     */\n    @Deprecated\n    public MethodMetadata parseAndValidatateMetadata(Method method) {\n      return parseAndValidateMetadata(method.getDeclaringClass(), method);\n    }\n/**\n     * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n     */\n    protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n      MethodMetadata data = new MethodMetadata();\n      data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));\n      data.configKey(Feign.configKey(targetType, method));\n\n      for (Annotation methodAnnotation : method.getAnnotations()) {\n        processAnnotationOnMethod(data, methodAnnotation, method);\n      }\n      checkState(data.template().method() != null,\n                 \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n                 method.getName());\n      Class<?>[] parameterTypes = method.getParameterTypes();\n\n      Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n      int count = parameterAnnotations.length;\n      for (int i = 0; i < count; i++) {\n        boolean isHttpAnnotation = false;\n        if (parameterAnnotations[i] != null) {\n          isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n        }\n        if (parameterTypes[i] == URI.class) {\n          data.urlIndex(i);\n        } else if (!isHttpAnnotation) {\n          checkState(data.formParams().isEmpty(),\n                     \"Body parameters cannot be used with form parameters.\");\n          checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n          data.bodyIndex(i);\n          data.bodyType(Types.resolve(targetType, targetType, method.getGenericParameterTypes()[i]));\n        }\n      }\n      return data;\n    }\n@Override\n    protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n      MethodMetadata data = super.parseAndValidateMetadata(targetType, method);\n      headersFromAnnotation(method.getDeclaringClass(), data);\n      if (method.getDeclaringClass() != targetType) {\n        headersFromAnnotation(targetType, data);\n      }\n      return data;\n    }\nprivate void headersFromAnnotation(Class<?> targetType, MethodMetadata data) {\n      if (targetType.isAnnotationPresent(Headers.class)) {\n        String[] headersOnType = targetType.getAnnotation(Headers.class).value();\n        checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n                   targetType.getName());\n        Map<String, Collection<String>> headers = toMap(headersOnType);\n        headers.putAll(data.template().headers());\n        data.template().headers(null); // to clear\n        data.template().headers(headers);\n      }\n    }\n DiffSourceCode:\n-   54:     /**\n-   55:      * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n-   56:      */\n-   57:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n-   58:       MethodMetadata data = new MethodMetadata();\n-   59:       data.returnType(method.getGenericReturnType());\n-   60:       data.configKey(Feign.configKey(method));\n-   61: \n-   62:       for (Annotation methodAnnotation : method.getAnnotations()) {\n-   63:         processAnnotationOnMethod(data, methodAnnotation, method);\n-   64:       }\n-   65:       checkState(data.template().method() != null,\n-   66:                  \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n-   67:                  method.getName());\n-   68:       Class<?>[] parameterTypes = method.getParameterTypes();\n-   69: \n-   70:       Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n-   71:       int count = parameterAnnotations.length;\n-   72:       for (int i = 0; i < count; i++) {\n-   73:         boolean isHttpAnnotation = false;\n-   74:         if (parameterAnnotations[i] != null) {\n-   75:           isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n-   76:         }\n-   77:         if (parameterTypes[i] == URI.class) {\n-   78:           data.urlIndex(i);\n-   79:         } else if (!isHttpAnnotation) {\n-   80:           checkState(data.formParams().isEmpty(),\n-   81:                      \"Body parameters cannot be used with form parameters.\");\n-   82:           checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n-   83:           data.bodyIndex(i);\n-   84:           data.bodyType(method.getGenericParameterTypes()[i]);\n-   85:         }\n-   86:       }\n-   87:       return data;\n-   88:     }\n-   89: \n-   90:     /**\n-   91:      * @param data       metadata collected so far relating to the current java method.\n-   92:      * @param annotation annotations present on the current method annotation.\n-   93:      * @param method     method currently being processed.\n-   94:      */\n-   95:     protected abstract void processAnnotationOnMethod(MethodMetadata data, Annotation annotation,\n-   96:                                                       Method method);\n-   97: \n-   98:     /**\n-   99:      * @param data        metadata collected so far relating to the current java method.\n-  100:      * @param annotations annotations present on the current parameter annotation.\n-  101:      * @param paramIndex  if you find a name in {@code annotations}, call {@link\n-  102:      *                    #nameParam(MethodMetadata, String, int)} with this as the last parameter.\n-  103:      * @return true if you called {@link #nameParam(MethodMetadata, String, int)} after finding an\n-  104:      * http-relevant annotation.\n-  105:      */\n-  106:     protected abstract boolean processAnnotationsOnParameter(MethodMetadata data,\n-  107:                                                              Annotation[] annotations,\n-  108:                                                              int paramIndex);\n-  109: \n-  110: \n-  111:     protected Collection<String> addTemplatedParam(Collection<String> possiblyNull, String name) {\n-  133:     @Override\n-  134:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n-  135:       MethodMetadata data = super.parseAndValidatateMetadata(method);\n-  136:       if (method.getDeclaringClass().isAnnotationPresent(Headers.class)) {\n-  137:         String[] headersOnType = method.getDeclaringClass().getAnnotation(Headers.class).value();\n-  138:         checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n-  139:                    method.getDeclaringClass().getName());\n-  140:         Map<String, Collection<String>> headers = toMap(headersOnType);\n-  141:         headers.putAll(data.template().headers());\n-  142:         data.template().headers(null); // to clear\n-  143:         data.template().headers(headers);\n-  144:       }\n-  145:       return data;\n-  146:     }\n-  156:         if (requestLine.indexOf(' ') == -1) {\n-  157:           data.template().method(requestLine);\n-  158:           return;\n-  159:         }\n-  160:         data.template().method(requestLine.substring(0, requestLine.indexOf(' ')));\n-  161:         if (requestLine.indexOf(' ') == requestLine.lastIndexOf(' ')) {\n-  162:           // no HTTP version is ok\n-  163:           data.template().append(requestLine.substring(requestLine.indexOf(' ') + 1));\n-  164:         } else {\n-  166:           data.template().append(\n-  167:               requestLine.substring(requestLine.indexOf(' ') + 1, requestLine.lastIndexOf(' ')));\n-  168:         }\n-  169:         \n-  170:         data.template().decodeSlash(RequestLine.class.cast(methodAnnotation).decodeSlash());\n-  171:         \n-  172:       } else if (annotationType == Body.class) {\n-  173:         String body = Body.class.cast(methodAnnotation).value();\n-  174:         checkState(emptyToNull(body) != null, \"Body annotation was empty on method %s.\",\n-  175:                    method.getName());\n-  176:         if (body.indexOf('{') == -1) {\n+   54:                    targetType.getSimpleName());\n+   55:       }\n+   56:       Map<String, MethodMetadata> result = new LinkedHashMap<String, MethodMetadata>();\n+   57:       for (Method method : targetType.getMethods()) {\n+   58:         if (method.getDeclaringClass() == Object.class) {\n+   59:           continue;\n+   60:         }\n+   61:         MethodMetadata metadata = parseAndValidateMetadata(targetType, method);\n+   62:         checkState(!result.containsKey(metadata.configKey()), \"Overrides unsupported: %s\",\n+   63:                    metadata.configKey());\n+   64:         result.put(metadata.configKey(), metadata);\n+   65:       }\n+   66:       return new ArrayList<MethodMetadata>(result.values());\n+   67:     }\n+   68: \n+   69:     /**\n+   70:      * @deprecated use {@link #parseAndValidateMetadata(Class, Method)} instead.\n+   71:      */\n+   72:     @Deprecated\n+   73:     public MethodMetadata parseAndValidatateMetadata(Method method) {\n+   74:       return parseAndValidateMetadata(method.getDeclaringClass(), method);\n+   75:     }\n+   76: \n+   77:     /**\n+   78:      * Called indirectly by {@link #parseAndValidatateMetadata(Class)}.\n+   79:      */\n+   80:     protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n+   81:       MethodMetadata data = new MethodMetadata();\n+   82:       data.returnType(Types.resolve(targetType, targetType, method.getGenericReturnType()));\n+   83:       data.configKey(Feign.configKey(targetType, method));\n+   84: \n+   85:       for (Annotation methodAnnotation : method.getAnnotations()) {\n+   86:         processAnnotationOnMethod(data, methodAnnotation, method);\n+   87:       }\n+   88:       checkState(data.template().method() != null,\n+   89:                  \"Method %s not annotated with HTTP method type (ex. GET, POST)\",\n+   90:                  method.getName());\n+   91:       Class<?>[] parameterTypes = method.getParameterTypes();\n+   92: \n+   93:       Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n+   94:       int count = parameterAnnotations.length;\n+   95:       for (int i = 0; i < count; i++) {\n+   96:         boolean isHttpAnnotation = false;\n+   97:         if (parameterAnnotations[i] != null) {\n+   98:           isHttpAnnotation = processAnnotationsOnParameter(data, parameterAnnotations[i], i);\n+   99:         }\n+  100:         if (parameterTypes[i] == URI.class) {\n+  101:           data.urlIndex(i);\n+  102:         } else if (!isHttpAnnotation) {\n+  103:           checkState(data.formParams().isEmpty(),\n+  104:                      \"Body parameters cannot be used with form parameters.\");\n+  105:           checkState(data.bodyIndex() == null, \"Method has too many Body parameters: %s\", method);\n+  106:           data.bodyIndex(i);\n+  107:           data.bodyType(Types.resolve(targetType, targetType, method.getGenericParameterTypes()[i]));\n+  108:         }\n+  109:       }\n+  110:       return data;\n+  111:     }\n+  133: \n+  134:     protected Collection<String> addTemplatedParam(Collection<String> possiblyNull, String name) {\n+  135:       if (possiblyNull == null) {\n+  136:         possiblyNull = new ArrayList<String>();\n+  137:       }\n+  138:       possiblyNull.add(String.format(\"{%s}\", name));\n+  139:       return possiblyNull;\n+  140:     }\n+  141: \n+  142:     /**\n+  143:      * links a parameter name to its index in the method signature.\n+  144:      */\n+  145:     protected void nameParam(MethodMetadata data, String name, int i) {\n+  146:       Collection<String>\n+  156:     @Override\n+  157:     protected MethodMetadata parseAndValidateMetadata(Class<?> targetType, Method method) {\n+  158:       MethodMetadata data = super.parseAndValidateMetadata(targetType, method);\n+  159:       headersFromAnnotation(method.getDeclaringClass(), data);\n+  160:       if (method.getDeclaringClass() != targetType) {\n+  161:         headersFromAnnotation(targetType, data);\n+  162:       }\n+  163:       return data;\n+  164:     }\n+  166:     private void headersFromAnnotation(Class<?> targetType, MethodMetadata data) {\n+  167:       if (targetType.isAnnotationPresent(Headers.class)) {\n+  168:         String[] headersOnType = targetType.getAnnotation(Headers.class).value();\n+  169:         checkState(headersOnType.length > 0, \"Headers annotation was empty on type %s.\",\n+  170:                    targetType.getName());\n+  171:         Map<String, Collection<String>> headers = toMap(headersOnType);\n+  172:         headers.putAll(data.template().headers());\n+  173:         data.template().headers(null); // to clear\n+  174:         data.template().headers(headers);\n+  175:       }\n+  176:     }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/osmandapp/Osmand.git",
        "branch": "master",
        "commitId": "c45b9e6615181b7d8f4d7b5b1cc141169081c02c",
        "sourceCodeBeforeRefactoring": "private void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tRouteDirectionInfo nf = null;\n\t\t\n\t\tdouble DISTANCE_ACTION = 35;\n\t\tif(zoom >= 17) {\n\t\t\tDISTANCE_ACTION = 15;\n\t\t} else if (zoom == 15) {\n\t\t\tDISTANCE_ACTION = 70;\n\t\t} else if (zoom < 15) {\n\t\t\tDISTANCE_ACTION = 110;\n\t\t}\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevFinishPoint = -2;\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif(nf != null) {\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif(pnt < i + cd ) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif (pnt < i + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && (nf.routePointOffset == i + cd ||\n\t\t\t\t\t(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n\t\t\tif(!action) {\n\t\t\t\tif(previousAction != null) {\n\t\t\t\t\tfloat dist = ls.distanceTo(previousAction);\n\t\t\t\t\tactionDist += dist;\n\t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));\n\t\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\t\tprevFinishPoint = i;\n\t\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\t\tactionDist = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif(visible) {\n\t\t\t\t\t// visible action point\n\t\t\t\t\tif (previousAction == null) {\n\t\t\t\t\t\t// put some points in front\n\t\t\t\t\t\tint ind = actionPoints.size();\n\t\t\t\t\t\tLocation lprevious = ls;\n\t\t\t\t\t\tdouble dist = 0;\n\t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\t\t\t\t\tfloat loc = lprevious.distanceTo(l);\n\t\t\t\t\t\t\tif(prevFinishPoint == k) {\n\t\t\t\t\t\t\t\tif(ind >= 2) {\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprevFinishPoint = -2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist += loc;\n\t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t\t\tif(loc > 1) {\n\t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\t\t\t\t\tlprevious = l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(previousAction != null) {\n\t\t\tactionPoints.add(null);\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\nprivate void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tRouteDirectionInfo nf = null;\n\t\t\n\t\tdouble DISTANCE_ACTION = 35;\n\t\tif(zoom >= 17) {\n\t\t\tDISTANCE_ACTION = 15;\n\t\t} else if (zoom == 15) {\n\t\t\tDISTANCE_ACTION = 70;\n\t\t} else if (zoom < 15) {\n\t\t\tDISTANCE_ACTION = 110;\n\t\t}\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevFinishPoint = -2;\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif(nf != null) {\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif(pnt < i + cd ) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif (pnt < i + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && (nf.routePointOffset == i + cd ||\n\t\t\t\t\t(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n\t\t\tif(!action) {\n\t\t\t\tif(previousAction != null) {\n\t\t\t\t\tfloat dist = ls.distanceTo(previousAction);\n\t\t\t\t\tactionDist += dist;\n\t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));\n\t\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\t\tprevFinishPoint = i;\n\t\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\t\tactionDist = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif(visible) {\n\t\t\t\t\t// visible action point\n\t\t\t\t\tif (previousAction == null) {\n\t\t\t\t\t\t// put some points in front\n\t\t\t\t\t\tint ind = actionPoints.size();\n\t\t\t\t\t\tLocation lprevious = ls;\n\t\t\t\t\t\tdouble dist = 0;\n\t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\t\t\t\t\tfloat loc = lprevious.distanceTo(l);\n\t\t\t\t\t\t\tif(prevFinishPoint == k) {\n\t\t\t\t\t\t\t\tif(ind >= 2) {\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprevFinishPoint = -2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist += loc;\n\t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t\t\tif(loc > 1) {\n\t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\t\t\t\t\tlprevious = l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(previousAction != null) {\n\t\t\tactionPoints.add(null);\n\t\t}\n\t}\n```\n\n### Refactored Code:\n```java\nprivate void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tdouble DISTANCE_ACTION = determineDistanceAction(zoom);\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevFinishPoint = -2;\n\t\tRouteDirectionInfo nf = null;\n\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tnf = updateRouteDirectionInfo(nf, it, i, cd);\n\t\t\tboolean action = isActionPoint(nf, i, cd);\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = isLocationVisible(ls, topLatitude, leftLongitude, bottomLatitude, rightLongitude);\n\t\t\tif(!action) {\n\t\t\t\thandleNonActionPoint(ls, previousAction, DISTANCE_ACTION, actionDist, prevFinishPoint, i);\n\t\t\t} else {\n\t\t\t\thandleActionPoint(ls, previousAction, visible, i, lastProjection, DISTANCE_ACTION);\n\t\t\t}\n\t\t}\n\t\tif(previousAction != null) {\n\t\t\tactionPoints.add(null);\n\t\t}\n\t}\n\nprivate double determineDistanceAction(int zoom) {\n\t\tif(zoom >= 17) {\n\t\t\treturn 15;\n\t\t} else if (zoom == 15) {\n\t\t\treturn 70;\n\t\t} else {\n\t\t\treturn 110;\n\t\t}\n\t}\n\nprivate RouteDirectionInfo updateRouteDirectionInfo(RouteDirectionInfo nf, Iterator<RouteDirectionInfo> it, int i, int cd) {\n\t\tif(nf != null) {\n\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\tif(pnt < i + cd ) {\n\t\t\t\tnf = null;\n\t\t\t}\n\t\t}\n\t\twhile (nf == null && it.hasNext()) {\n\t\t\tnf = it.next();\n\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\tif (pnt < i + cd) {\n\t\t\t\tnf = null;\n\t\t\t}\n\t\t}\n\t\treturn nf;\n\t}\n\nprivate boolean isActionPoint(RouteDirectionInfo nf, int i, int cd) {\n\t\treturn nf != null && (nf.routePointOffset == i + cd ||\n\t\t\t\t(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));\n\t}\n\nprivate boolean isLocationVisible(Location ls, double topLatitude, double leftLongitude, double bottomLatitude, double rightLongitude) {\n\t\treturn leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && \n\t\t\t\tbottomLatitude <= ls.getLatitude() && ls.getLatitude() <= topLatitude;\n\t}\n\nprivate void handleNonActionPoint(Location ls, Location previousAction, double DISTANCE_ACTION, double actionDist, int prevFinishPoint, int i) {\n\t\tif(previousAction != null) {\n\t\t\tfloat dist = ls.distanceTo(previousAction);\n\t\t\tactionDist += dist;\n\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));\n\t\t\t\tactionPoints.add(null);\n\t\t\t\tprevFinishPoint = i;\n\t\t\t\tpreviousAction = null;\n\t\t\t\tactionDist = 0;\n\t\t\t} else {\n\t\t\t\tactionPoints.add(ls);\n\t\t\t\tpreviousAction = ls;\n\t\t\t}\n\t\t}\n\t}\n\nprivate void handleActionPoint(Location ls, Location previousAction, boolean visible, int i, Location lastProjection, double DISTANCE_ACTION) {\n\t\tif(visible) {\n\t\t\tif (previousAction == null) {\n\t\t\t\taddPointsInFront(ls, i, lastProjection, DISTANCE_ACTION);\n\t\t\t}\n\t\t\tactionPoints.add(ls);\n\t\t\tpreviousAction = ls;\n\t\t}\n\t}\n\nprivate void addPointsInFront(Location ls, int i, Location lastProjection, double DISTANCE_ACTION) {\n\t\tint ind = actionPoints.size();\n\t\tLocation lprevious = ls;\n\t\tdouble dist = 0;\n\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\tfloat loc = lprevious.distanceTo(l);\n\t\t\tif(prevFinishPoint == k) {\n\t\t\t\tif(ind >= 2) {\n\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t}\n\t\t\t\tprevFinishPoint = -2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdist += loc;\n\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\tif(loc > 1) {\n\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\tlprevious = l;\n\t\t\t}\n\t\t}\n\t}\n```\n\nThis refactoring breaks down the original method into smaller, more manageable methods, each with a single responsibility, improving readability and maintainability while preserving the original functionality.",
        "sourceCodeAfterRefactoring": "private void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tRouteDirectionInfo nf = null;\n\t\t\n\t\tdouble DISTANCE_ACTION = 35;\n\t\tif(zoom >= 17) {\n\t\t\tDISTANCE_ACTION = 15;\n\t\t} else if (zoom == 15) {\n\t\t\tDISTANCE_ACTION = 70;\n\t\t} else if (zoom < 15) {\n\t\t\tDISTANCE_ACTION = 110;\n\t\t}\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevFinishPoint = -1;\n\t\tfor (int routePoint = 0; routePoint < routeNodes.size(); routePoint++) {\n\t\t\tLocation loc = routeNodes.get(routePoint);\n\t\t\tif(nf != null) {\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif(pnt < routePoint + cd ) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif (pnt < routePoint + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && (nf.routePointOffset == routePoint + cd ||\n\t\t\t\t\t(nf.routePointOffset <= routePoint + cd && routePoint + cd  <= nf.routeEndPointOffset));\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\t// no need to check\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= loc.getLongitude() && loc.getLongitude() <= rightLongitude && bottomLatitude <= loc.getLatitude()\n\t\t\t\t\t&& loc.getLatitude() <= topLatitude;\n\t\t\tif(action && !visible && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!action) {\n\t\t\t\t// previousAction != null\n\t\t\t\tfloat dist = loc.distanceTo(previousAction);\n\t\t\t\tactionDist += dist;\n\t\t\t\tif (actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, loc));\n\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\tprevFinishPoint = routePoint;\n\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t} else {\n\t\t\t\t\tactionPoints.add(loc);\n\t\t\t\t\tpreviousAction = loc;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif (previousAction == null) {\n\t\t\t\t\taddPreviousToActionPoints(lastProjection, routeNodes, DISTANCE_ACTION,\n\t\t\t\t\t\t\tprevFinishPoint, routePoint, loc);\n\t\t\t\t}\n\t\t\t\tactionPoints.add(loc);\n\t\t\t\tpreviousAction = loc;\n\t\t\t\tprevFinishPoint = -1;\n\t\t\t\tactionDist = 0;\n\t\t\t}\n\t\t}\n\t\tif(previousAction != null) {\n\t\t\tactionPoints.add(null);\n\t\t}\n\t}\nprivate void addPreviousToActionPoints(Location lastProjection, List<Location> routeNodes, double DISTANCE_ACTION,\n\t\t\tint prevFinishPoint, int routePoint, Location loc) {\n\t\t// put some points in front\n\t\tint ind = actionPoints.size();\n\t\tLocation lprevious = loc;\n\t\tdouble dist = 0;\n\t\tfor (int k = routePoint - 1; k >= -1; k--) {\n\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\tfloat locDist = lprevious.distanceTo(l);\n\t\t\tdist += locDist;\n\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\tif (locDist > 1) {\n\t\t\t\t\tactionPoints.add(ind,\n\t\t\t\t\t\t\tcalculateProjection(1 - (dist - DISTANCE_ACTION) / locDist, lprevious, l));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\tlprevious = l;\n\t\t\t}\n\t\t\tif (prevFinishPoint == k) {\n\t\t\t\tif (ind >= 2) {\n\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}",
        "diffSourceCode": "   362: \tprivate void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n   363: \t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n   364: \t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n   365: \t\tRouteDirectionInfo nf = null;\n   366: \t\t\n   367: \t\tdouble DISTANCE_ACTION = 35;\n   368: \t\tif(zoom >= 17) {\n   369: \t\t\tDISTANCE_ACTION = 15;\n   370: \t\t} else if (zoom == 15) {\n   371: \t\t\tDISTANCE_ACTION = 70;\n   372: \t\t} else if (zoom < 15) {\n   373: \t\t\tDISTANCE_ACTION = 110;\n   374: \t\t}\n   375: \t\tdouble actionDist = 0;\n   376: \t\tLocation previousAction = null; \n   377: \t\tactionPoints.clear();\n-  378: \t\tint prevFinishPoint = -2;\n-  379: \t\tfor (int i = 0; i < routeNodes.size(); i++) {\n-  380: \t\t\tLocation ls = routeNodes.get(i);\n+  378: \t\tint prevFinishPoint = -1;\n+  379: \t\tfor (int routePoint = 0; routePoint < routeNodes.size(); routePoint++) {\n+  380: \t\t\tLocation loc = routeNodes.get(routePoint);\n   381: \t\t\tif(nf != null) {\n   382: \t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n-  383: \t\t\t\tif(pnt < i + cd ) {\n+  383: \t\t\t\tif(pnt < routePoint + cd ) {\n   384: \t\t\t\t\tnf = null;\n   385: \t\t\t\t}\n   386: \t\t\t}\n   387: \t\t\twhile (nf == null && it.hasNext()) {\n   388: \t\t\t\tnf = it.next();\n   389: \t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n-  390: \t\t\t\tif (pnt < i + cd) {\n+  390: \t\t\t\tif (pnt < routePoint + cd) {\n   391: \t\t\t\t\tnf = null;\n   392: \t\t\t\t}\n   393: \t\t\t}\n-  394: \t\t\tboolean action = nf != null && (nf.routePointOffset == i + cd ||\n-  395: \t\t\t\t\t(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));\n+  394: \t\t\tboolean action = nf != null && (nf.routePointOffset == routePoint + cd ||\n+  395: \t\t\t\t\t(nf.routePointOffset <= routePoint + cd && routePoint + cd  <= nf.routeEndPointOffset));\n   396: \t\t\tif(!action && previousAction == null) {\n-  397: \t\t\t\tcontinue;\n-  398: \t\t\t}\n-  399: \t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n-  400: \t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n-  401: \t\t\tif(!action) {\n-  402: \t\t\t\tif(previousAction != null) {\n-  403: \t\t\t\t\tfloat dist = ls.distanceTo(previousAction);\n-  404: \t\t\t\t\tactionDist += dist;\n-  405: \t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n-  406: \t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));\n-  407: \t\t\t\t\t\tactionPoints.add(null);\n-  408: \t\t\t\t\t\tprevFinishPoint = i;\n-  409: \t\t\t\t\t\tpreviousAction = null;\n-  410: \t\t\t\t\t\tactionDist = 0;\n-  411: \t\t\t\t\t} else {\n-  412: \t\t\t\t\t\tactionPoints.add(ls);\n-  413: \t\t\t\t\t\tpreviousAction = ls;\n-  414: \t\t\t\t\t}\n-  415: \t\t\t\t}\n-  416: \t\t\t} else {\n-  417: \t\t\t\t// action point\n-  418: \t\t\t\tif(visible) {\n-  419: \t\t\t\t\t// visible action point\n-  420: \t\t\t\t\tif (previousAction == null) {\n-  421: \t\t\t\t\t\t// put some points in front\n-  422: \t\t\t\t\t\tint ind = actionPoints.size();\n-  423: \t\t\t\t\t\tLocation lprevious = ls;\n-  424: \t\t\t\t\t\tdouble dist = 0;\n-  425: \t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n-  426: \t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n-  427: \t\t\t\t\t\t\tfloat loc = lprevious.distanceTo(l);\n-  428: \t\t\t\t\t\t\tif(prevFinishPoint == k) {\n-  429: \t\t\t\t\t\t\t\tif(ind >= 2) {\n-  430: \t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n-  431: \t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n-  432: \t\t\t\t\t\t\t\t}\n-  433: \t\t\t\t\t\t\t\tprevFinishPoint = -2;\n-  434: \t\t\t\t\t\t\t\tbreak;\n-  435: \t\t\t\t\t\t\t}\n-  436: \t\t\t\t\t\t\tdist += loc;\n-  437: \t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n-  438: \t\t\t\t\t\t\t\tif(loc > 1) {\n-  439: \t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));\n-  440: \t\t\t\t\t\t\t\t}\n-  441: \t\t\t\t\t\t\t\tbreak;\n-  442: \t\t\t\t\t\t\t} else {\n-  443: \t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n-  444: \t\t\t\t\t\t\t\tlprevious = l;\n-  445: \t\t\t\t\t\t\t}\n-  446: \t\t\t\t\t\t\t\n-  447: \t\t\t\t\t\t}\n-  448: \t\t\t\t\t}\n-  449: \t\t\t\t\tactionPoints.add(ls);\n-  450: \t\t\t\t\tpreviousAction = ls;\n-  451: \t\t\t\t\tactionDist = 0;\n-  452: \t\t\t\t}\n-  453: \t\t\t}\n-  454: \t\t}\n-  455: \t\tif(previousAction != null) {\n-  456: \t\t\tactionPoints.add(null);\n-  457: \t\t}\n-  458: \t}\n-  459: \t\n-  460: \tprivate Location calculateProjection(double part, Location lp, Location l) {\n-  461: \t\tLocation p = new Location(l);\n-  462: \t\tp.setLatitude(lp.getLatitude() + part * (l.getLatitude() - lp.getLatitude()));\n-  463: \t\tp.setLongitude(lp.getLongitude() + part * (l.getLongitude() - lp.getLongitude()));\n-  464: \t\treturn p;\n+  397: \t\t\t\t// no need to check\n+  398: \t\t\t\tcontinue;\n+  399: \t\t\t}\n+  400: \t\t\tboolean visible = leftLongitude <= loc.getLongitude() && loc.getLongitude() <= rightLongitude && bottomLatitude <= loc.getLatitude()\n+  401: \t\t\t\t\t&& loc.getLatitude() <= topLatitude;\n+  402: \t\t\tif(action && !visible && previousAction == null) {\n+  403: \t\t\t\tcontinue;\n+  404: \t\t\t}\n+  405: \t\t\tif (!action) {\n+  406: \t\t\t\t// previousAction != null\n+  407: \t\t\t\tfloat dist = loc.distanceTo(previousAction);\n+  408: \t\t\t\tactionDist += dist;\n+  409: \t\t\t\tif (actionDist >= DISTANCE_ACTION) {\n+  410: \t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, loc));\n+  411: \t\t\t\t\tactionPoints.add(null);\n+  412: \t\t\t\t\tprevFinishPoint = routePoint;\n+  413: \t\t\t\t\tpreviousAction = null;\n+  414: \t\t\t\t\tactionDist = 0;\n+  415: \t\t\t\t} else {\n+  416: \t\t\t\t\tactionPoints.add(loc);\n+  417: \t\t\t\t\tpreviousAction = loc;\n+  418: \t\t\t\t}\n+  419: \t\t\t} else {\n+  420: \t\t\t\t// action point\n+  421: \t\t\t\tif (previousAction == null) {\n+  422: \t\t\t\t\taddPreviousToActionPoints(lastProjection, routeNodes, DISTANCE_ACTION,\n+  423: \t\t\t\t\t\t\tprevFinishPoint, routePoint, loc);\n+  424: \t\t\t\t}\n+  425: \t\t\t\tactionPoints.add(loc);\n+  426: \t\t\t\tpreviousAction = loc;\n+  427: \t\t\t\tprevFinishPoint = -1;\n+  428: \t\t\t\tactionDist = 0;\n+  429: \t\t\t}\n+  430: \t\t}\n+  431: \t\tif(previousAction != null) {\n+  432: \t\t\tactionPoints.add(null);\n+  433: \t\t}\n+  434: \t}\n+  435: \n+  436: \n+  437: \tprivate void addPreviousToActionPoints(Location lastProjection, List<Location> routeNodes, double DISTANCE_ACTION,\n+  438: \t\t\tint prevFinishPoint, int routePoint, Location loc) {\n+  439: \t\t// put some points in front\n+  440: \t\tint ind = actionPoints.size();\n+  441: \t\tLocation lprevious = loc;\n+  442: \t\tdouble dist = 0;\n+  443: \t\tfor (int k = routePoint - 1; k >= -1; k--) {\n+  444: \t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n+  445: \t\t\tfloat locDist = lprevious.distanceTo(l);\n+  446: \t\t\tdist += locDist;\n+  447: \t\t\tif (dist >= DISTANCE_ACTION) {\n+  448: \t\t\t\tif (locDist > 1) {\n+  449: \t\t\t\t\tactionPoints.add(ind,\n+  450: \t\t\t\t\t\t\tcalculateProjection(1 - (dist - DISTANCE_ACTION) / locDist, lprevious, l));\n+  451: \t\t\t\t}\n+  452: \t\t\t\tbreak;\n+  453: \t\t\t} else {\n+  454: \t\t\t\tactionPoints.add(ind, l);\n+  455: \t\t\t\tlprevious = l;\n+  456: \t\t\t}\n+  457: \t\t\tif (prevFinishPoint == k) {\n+  458: \t\t\t\tif (ind >= 2) {\n+  459: \t\t\t\t\tactionPoints.remove(ind - 2);\n+  460: \t\t\t\t\tactionPoints.remove(ind - 2);\n+  461: \t\t\t\t}\n+  462: \t\t\t\tbreak;\n+  463: \t\t\t}\n+  464: \t\t}\n   465: \t}\n",
        "uniqueId": "c45b9e6615181b7d8f4d7b5b1cc141169081c02c_362_458_437_465_362_434",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n /**\n     *\n     * @param initialStep the initial step size\n     * @param parameters the parameters to optimize\n     * @param gradients the line/rate of change\n     * @return the next step size\n     * @throws InvalidStepException\n     */\n    public double optimize (double initialStep,INDArray parameters,INDArray gradients) throws InvalidStepException {\n        double slope, test, alamin, alam, alam2, tmplam;\n        double rhs1, rhs2, a, b, disc, oldAlam;double f, fold, f2;\n        INDArray oldParameters = parameters.dup();\n        INDArray gDup = gradients.dup();\n\n        alam2 = 0.0;\n        f2 = fold = optimizer.score();\n\n        if (logger.isDebugEnabled()) {\n            logger.trace (\"ENTERING BACKTRACK\\n\");\n            logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n                    +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+ FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n        }\n\n        double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n        if(sum > stpmax) {\n            logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n                    \", stpmax= \"+ stpmax);\n            gradients.muli(stpmax / sum);\n        }\n\n        //dot product\n        slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n        logger.debug(\"slope = \" + slope);\n\n        if (slope < 0)\n            throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n\n        if (slope == 0)\n            throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n\n        // find maximum lambda\n        // converge when (delta x) / x < REL_TOLX for all coordinates.\n        //  the largest step size that triggers this threshold is\n        //  precomputed and saved in alamin\n        INDArray maxOldParams = abs(oldParameters);\n        Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n\n\n\n        INDArray testMatrix = abs(gradients).divi(maxOldParams);\n        test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n\n        alamin = relTolx / test;\n\n        alam  = 1.0;\n        oldAlam = 0.0;\n        int iteration;\n        // look for step size in direction given by \"line\"\n        for(iteration = 0; iteration < maxIterations; iteration++) {\n            // initially, alam = 1.0, i.e. take full Newton step\n            logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n            logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n            assert(alam != oldAlam) : \"alam == oldAlam\";\n\n            if(stepFunction == null)\n                stepFunction =  new DefaultStepFunction();\n            //scale wrt updates\n            stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n\n            if(logger.isDebugEnabled())  {\n                double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n                logger.debug (\"after step, x.1norm: \" + norm1);\n            }\n\n            // check for convergence\n            //convergence on delta x\n            //if all of the parameters are < 1e-12\n\n            if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n                    parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n                function.setParams(oldParameters);\n                function.setScore();\n                f = function.score();\n                logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n                return 0.0;\n            }\n\n            function.setParams(parameters);\n            oldAlam = alam;\n            function.setScore();\n            f = function.score();\n\n            logger.debug(\"value = \" + f);\n\n            // sufficient function increase (Wolf condition)\n            if(f >= fold + ALF * alam * slope) {\n\n                logger.debug(\"EXITING BACKTRACK: value=\" + f);\n\n                if (f < fold)\n                    throw new IllegalStateException\n                            (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n                return alam;\n            }\n\n\n            // if value is infinite, i.e. we've\n            // jumped to unstable territory, then scale down jump\n            else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n                logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n                tmplam = .2 * alam;\n                if(alam < alamin) { //convergence on delta x\n                    function.setParams(oldParameters);\n                    function.setScore();\n                    f = function.score();\n                    logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n                    return 0.0;\n                }\n            }\n            else { // backtrack\n                if(alam == 1.0) // first time through\n                    tmplam = -slope / (2.0 * ( f - fold - slope ));\n                else {\n                    rhs1 = f - fold- alam * slope;\n                    rhs2 = f2 - fold - alam2 * slope;\n                    if((alam - alam2) == 0)\n                        throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n                    a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n                    b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n                    if(a == 0.0)\n                        tmplam = -slope / (2.0 * b);\n                    else {\n                        disc = b * b - 3.0 * a * slope;\n                        if(disc < 0.0) {\n                            tmplam = .5f * alam;\n                        }\n                        else if (b <= 0.0)\n                            tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n                        else\n                            tmplam = -slope / (b +FastMath.sqrt(disc));\n                    }\n                    if (tmplam > .5f * alam)\n                        tmplam = .5f * alam;    // lambda <= .5 lambda_1\n                }\n            }\n\n            alam2 = alam;\n            f2 = f;\n            logger.debug(\"tmplam:\" + tmplam);\n            alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n\n        }\n\n        return 0.0;\n    }\n SourceCodeAfterRefactoring:\n/**\n     *\n     * @param initialStep the initial step size\n     * @param parameters the parameters to optimize\n     * @param gradients the line/rate of change\n     * @return the next step size\n     * @throws InvalidStepException\n     */\n    public double optimize (double initialStep, INDArray parameters, INDArray gradients) throws InvalidStepException {\n        double test, alamin, alam, alam2, oldAlam, tmplam;\n        double rhs1, rhs2, a, b, disc, f, fold, f2;\n\n        INDArray oldParameters = parameters.dup();\n        INDArray gDup = gradients.dup();\n        double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n        double slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n\n        INDArray maxOldParams = abs(oldParameters);\n        Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n        INDArray testMatrix = abs(gradients).divi(maxOldParams);\n        test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n\n        alam  = 1.0; // initially, alam = 1.0, i.e. take full Newton step\n        alamin = relTolx / test; // relative convergence tolerance\n        oldAlam = 0.0;\n        alam2 = 0.0;\n\n        f2 = fold = layer.score();\n\n        if (logger.isDebugEnabled()) {\n            logger.trace (\"ENTERING BACKTRACK\\n\");\n            logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n                    +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+\n                    FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n        }\n\n        if(sum > stpmax) {\n            logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n                    \", stpmax= \"+ stpmax);\n            gradients.muli(stpmax / sum);\n        }\n\n        logger.debug(\"slope = \" + slope);\n\n        if (slope < 0)\n            throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n        else if (slope == 0)\n            throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n\n        // find maximum lambda\n        // converge when (delta x) / x < REL_TOLX for all coordinates.\n        // the largest step size that triggers this threshold is precomputed and saved in alamin\n        // look for step size in direction given by \"line\"\n\n        for(int iteration = 0; iteration < maxIterations; iteration++) {\n            logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n            logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n            assert(alam != oldAlam) : \"alam == oldAlam\";\n\n            if(stepFunction == null)\n                stepFunction =  new DefaultStepFunction();\n            //scale wrt updates\n            stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n            oldAlam = alam;\n\n            if(logger.isDebugEnabled())  {\n                double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n                logger.debug (\"after step, x.1norm: \" + norm1);\n            }\n\n            // check for convergence on delta x\n            // if all of the parameters are < 1e-12\n\n            if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n                    parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n                f = getNewScore(oldParameters);\n                logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n                return 0.0;\n            }\n\n            f = getNewScore(oldParameters);\n            logger.debug(\"value = \" + f);\n\n            // sufficient increase (Wolf condition)\n\n            if(f >= fold + ALF * alam * slope) {\n\n                logger.debug(\"EXITING BACKTRACK: value=\" + f);\n                if (f < fold)\n                    throw new IllegalStateException\n                            (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n                return alam;\n            }\n\n            // if value is infinite, i.e. we've\n            // jumped to unstable territory, then scale down jump\n\n            else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n                logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n                tmplam = .2 * alam;\n                if(alam < alamin) { //convergence on delta x\n                    f = getNewScore(oldParameters);\n                    logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n                    return 0.0;\n                }\n            }\n\n            // backtrack\n\n            else {\n                if(alam == 1.0) // first time through\n                    tmplam = -slope / (2.0 * ( f - fold - slope ));\n                else {\n                    rhs1 = f - fold- alam * slope;\n                    rhs2 = f2 - fold - alam2 * slope;\n                    if(alam == alam2)\n                        throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n                    a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n                    b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n                    if(a == 0.0)\n                        tmplam = -slope / (2.0 * b);\n                    else {\n                        disc = b * b - 3.0 * a * slope;\n                        if(disc < 0.0) {\n                            tmplam = .5f * alam;\n                        }\n                        else if (b <= 0.0)\n                            tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n                        else\n                            tmplam = -slope / (b +FastMath.sqrt(disc));\n                    }\n                    if (tmplam > .5f * alam)\n                        tmplam = .5f * alam;    // lambda <= .5 lambda_1\n                }\n            }\n\n            alam2 = alam;\n            f2 = f;\n            logger.debug(\"tmplam:\" + tmplam);\n            alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n\n        }\n\n        return 0.0;\n    }\nprivate double getNewScore(INDArray oldParameters){\n        layer.setParams(oldParameters);\n        layer.setScore();\n        return layer.score();\n    }\n DiffSourceCode:\n-  132:     /**\n-  133:      *\n-  134:      * @param initialStep the initial step size\n-  135:      * @param parameters the parameters to optimize\n-  136:      * @param gradients the line/rate of change\n-  137:      * @return the next step size\n-  138:      * @throws InvalidStepException\n-  139:      */\n-  140:     public double optimize (double initialStep,INDArray parameters,INDArray gradients) throws InvalidStepException {\n-  141:         double slope, test, alamin, alam, alam2, tmplam;\n-  142:         double rhs1, rhs2, a, b, disc, oldAlam;double f, fold, f2;\n-  143:         INDArray oldParameters = parameters.dup();\n-  144:         INDArray gDup = gradients.dup();\n-  145: \n-  146:         alam2 = 0.0;\n-  147:         f2 = fold = optimizer.score();\n-  148: \n-  149:         if (logger.isDebugEnabled()) {\n-  150:             logger.trace (\"ENTERING BACKTRACK\\n\");\n-  151:             logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n-  152:                     +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+ FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n-  153:         }\n+  132:     private double getNewScore(INDArray oldParameters){\n+  133:         layer.setParams(oldParameters);\n+  134:         layer.setScore();\n+  135:         return layer.score();\n+  136:     }\n+  137: \n+  138:     /**\n+  139:      *\n+  140:      * @param initialStep the initial step size\n+  141:      * @param parameters the parameters to optimize\n+  142:      * @param gradients the line/rate of change\n+  143:      * @return the next step size\n+  144:      * @throws InvalidStepException\n+  145:      */\n+  146:     public double optimize (double initialStep, INDArray parameters, INDArray gradients) throws InvalidStepException {\n+  147:         double test, alamin, alam, alam2, oldAlam, tmplam;\n+  148:         double rhs1, rhs2, a, b, disc, f, fold, f2;\n+  149: \n+  150:         INDArray oldParameters = parameters.dup();\n+  151:         INDArray gDup = gradients.dup();\n+  152:         double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n+  153:         double slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n   154: \n-  155:         double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n-  156:         if(sum > stpmax) {\n-  157:             logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n-  158:                     \", stpmax= \"+ stpmax);\n-  159:             gradients.muli(stpmax / sum);\n-  160:         }\n-  161: \n-  162:         //dot product\n-  163:         slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n-  164:         logger.debug(\"slope = \" + slope);\n-  165: \n-  166:         if (slope < 0)\n-  167:             throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n-  168: \n-  169:         if (slope == 0)\n-  170:             throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n-  171: \n-  172:         // find maximum lambda\n-  173:         // converge when (delta x) / x < REL_TOLX for all coordinates.\n-  174:         //  the largest step size that triggers this threshold is\n-  175:         //  precomputed and saved in alamin\n-  176:         INDArray maxOldParams = abs(oldParameters);\n-  177:         Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n-  178: \n+  155:         INDArray maxOldParams = abs(oldParameters);\n+  156:         Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n+  157:         INDArray testMatrix = abs(gradients).divi(maxOldParams);\n+  158:         test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n+  159: \n+  160:         alam  = 1.0; // initially, alam = 1.0, i.e. take full Newton step\n+  161:         alamin = relTolx / test; // relative convergence tolerance\n+  162:         oldAlam = 0.0;\n+  163:         alam2 = 0.0;\n+  164: \n+  165:         f2 = fold = layer.score();\n+  166: \n+  167:         if (logger.isDebugEnabled()) {\n+  168:             logger.trace (\"ENTERING BACKTRACK\\n\");\n+  169:             logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n+  170:                     +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+\n+  171:                     FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n+  172:         }\n+  173: \n+  174:         if(sum > stpmax) {\n+  175:             logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n+  176:                     \", stpmax= \"+ stpmax);\n+  177:             gradients.muli(stpmax / sum);\n+  178:         }\n   179: \n-  180: \n-  181:         INDArray testMatrix = abs(gradients).divi(maxOldParams);\n-  182:         test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n-  183: \n-  184:         alamin = relTolx / test;\n-  185: \n-  186:         alam  = 1.0;\n-  187:         oldAlam = 0.0;\n-  188:         int iteration;\n-  189:         // look for step size in direction given by \"line\"\n-  190:         for(iteration = 0; iteration < maxIterations; iteration++) {\n-  191:             // initially, alam = 1.0, i.e. take full Newton step\n-  192:             logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n-  193:             logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n-  194:             assert(alam != oldAlam) : \"alam == oldAlam\";\n-  195: \n-  196:             if(stepFunction == null)\n-  197:                 stepFunction =  new DefaultStepFunction();\n-  198:             //scale wrt updates\n-  199:             stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n-  200: \n-  201:             if(logger.isDebugEnabled())  {\n-  202:                 double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n-  203:                 logger.debug (\"after step, x.1norm: \" + norm1);\n-  204:             }\n-  205: \n-  206:             // check for convergence\n-  207:             //convergence on delta x\n-  208:             //if all of the parameters are < 1e-12\n-  209: \n-  210:             if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n-  211:                     parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n-  212:                 function.setParams(oldParameters);\n-  213:                 function.setScore();\n-  214:                 f = function.score();\n-  215:                 logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n-  216:                 return 0.0;\n-  217:             }\n-  218: \n-  219:             function.setParams(parameters);\n-  220:             oldAlam = alam;\n-  221:             function.setScore();\n-  222:             f = function.score();\n-  223: \n-  224:             logger.debug(\"value = \" + f);\n-  225: \n-  226:             // sufficient function increase (Wolf condition)\n-  227:             if(f >= fold + ALF * alam * slope) {\n-  228: \n-  229:                 logger.debug(\"EXITING BACKTRACK: value=\" + f);\n-  230: \n-  231:                 if (f < fold)\n-  232:                     throw new IllegalStateException\n-  233:                             (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n-  234:                 return alam;\n-  235:             }\n-  236: \n-  237: \n-  238:             // if value is infinite, i.e. we've\n-  239:             // jumped to unstable territory, then scale down jump\n-  240:             else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n-  241:                 logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n-  242:                 tmplam = .2 * alam;\n-  243:                 if(alam < alamin) { //convergence on delta x\n-  244:                     function.setParams(oldParameters);\n-  245:                     function.setScore();\n-  246:                     f = function.score();\n-  247:                     logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n-  248:                     return 0.0;\n-  249:                 }\n-  250:             }\n-  251:             else { // backtrack\n-  252:                 if(alam == 1.0) // first time through\n-  253:                     tmplam = -slope / (2.0 * ( f - fold - slope ));\n-  254:                 else {\n-  255:                     rhs1 = f - fold- alam * slope;\n-  256:                     rhs2 = f2 - fold - alam2 * slope;\n-  257:                     if((alam - alam2) == 0)\n-  258:                         throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n-  259:                     a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n-  260:                     b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n-  261:                     if(a == 0.0)\n-  262:                         tmplam = -slope / (2.0 * b);\n-  263:                     else {\n-  264:                         disc = b * b - 3.0 * a * slope;\n-  265:                         if(disc < 0.0) {\n-  266:                             tmplam = .5f * alam;\n-  267:                         }\n-  268:                         else if (b <= 0.0)\n-  269:                             tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n-  270:                         else\n-  271:                             tmplam = -slope / (b +FastMath.sqrt(disc));\n-  272:                     }\n-  273:                     if (tmplam > .5f * alam)\n-  274:                         tmplam = .5f * alam;    // lambda <= .5 lambda_1\n-  275:                 }\n-  276:             }\n-  277: \n-  278:             alam2 = alam;\n-  279:             f2 = f;\n-  280:             logger.debug(\"tmplam:\" + tmplam);\n-  281:             alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n-  282: \n-  283:         }\n+  180:         logger.debug(\"slope = \" + slope);\n+  181: \n+  182:         if (slope < 0)\n+  183:             throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n+  184:         else if (slope == 0)\n+  185:             throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n+  186: \n+  187:         // find maximum lambda\n+  188:         // converge when (delta x) / x < REL_TOLX for all coordinates.\n+  189:         // the largest step size that triggers this threshold is precomputed and saved in alamin\n+  190:         // look for step size in direction given by \"line\"\n+  191: \n+  192:         for(int iteration = 0; iteration < maxIterations; iteration++) {\n+  193:             logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n+  194:             logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n+  195:             assert(alam != oldAlam) : \"alam == oldAlam\";\n+  196: \n+  197:             if(stepFunction == null)\n+  198:                 stepFunction =  new DefaultStepFunction();\n+  199:             //scale wrt updates\n+  200:             stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n+  201:             oldAlam = alam;\n+  202: \n+  203:             if(logger.isDebugEnabled())  {\n+  204:                 double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n+  205:                 logger.debug (\"after step, x.1norm: \" + norm1);\n+  206:             }\n+  207: \n+  208:             // check for convergence on delta x\n+  209:             // if all of the parameters are < 1e-12\n+  210: \n+  211:             if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n+  212:                     parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n+  213:                 f = getNewScore(oldParameters);\n+  214:                 logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n+  215:                 return 0.0;\n+  216:             }\n+  217: \n+  218:             f = getNewScore(oldParameters);\n+  219:             logger.debug(\"value = \" + f);\n+  220: \n+  221:             // sufficient increase (Wolf condition)\n+  222: \n+  223:             if(f >= fold + ALF * alam * slope) {\n+  224: \n+  225:                 logger.debug(\"EXITING BACKTRACK: value=\" + f);\n+  226:                 if (f < fold)\n+  227:                     throw new IllegalStateException\n+  228:                             (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n+  229:                 return alam;\n+  230:             }\n+  231: \n+  232:             // if value is infinite, i.e. we've\n+  233:             // jumped to unstable territory, then scale down jump\n+  234: \n+  235:             else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n+  236:                 logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n+  237:                 tmplam = .2 * alam;\n+  238:                 if(alam < alamin) { //convergence on delta x\n+  239:                     f = getNewScore(oldParameters);\n+  240:                     logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n+  241:                     return 0.0;\n+  242:                 }\n+  243:             }\n+  244: \n+  245:             // backtrack\n+  246: \n+  247:             else {\n+  248:                 if(alam == 1.0) // first time through\n+  249:                     tmplam = -slope / (2.0 * ( f - fold - slope ));\n+  250:                 else {\n+  251:                     rhs1 = f - fold- alam * slope;\n+  252:                     rhs2 = f2 - fold - alam2 * slope;\n+  253:                     if(alam == alam2)\n+  254:                         throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n+  255:                     a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n+  256:                     b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n+  257:                     if(a == 0.0)\n+  258:                         tmplam = -slope / (2.0 * b);\n+  259:                     else {\n+  260:                         disc = b * b - 3.0 * a * slope;\n+  261:                         if(disc < 0.0) {\n+  262:                             tmplam = .5f * alam;\n+  263:                         }\n+  264:                         else if (b <= 0.0)\n+  265:                             tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n+  266:                         else\n+  267:                             tmplam = -slope / (b +FastMath.sqrt(disc));\n+  268:                     }\n+  269:                     if (tmplam > .5f * alam)\n+  270:                         tmplam = .5f * alam;    // lambda <= .5 lambda_1\n+  271:                 }\n+  272:             }\n+  273: \n+  274:             alam2 = alam;\n+  275:             f2 = f;\n+  276:             logger.debug(\"tmplam:\" + tmplam);\n+  277:             alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n+  278: \n+  279:         }\n+  280: \n+  281:         return 0.0;\n+  282:     }\n+  283: \n   284: \n-  285:         return 0.0;\n-  286:     }\n+  285: \n+  286: \n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n    if (virtualFile != null) {\n      PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n      if (file != null) {\n        int targetOffset = target.getOffset();\n        for (int i = 0; i < 2; i++) {\n          Class<? extends PsiElement> clazz = DartComponentName.class;\n          if (i == 1) {\n            clazz = DartReferenceExpression.class;\n          }\n          PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n          if (elementAt != null) {\n            return elementAt;\n          }\n        }\n      }\n    }\n    return null;\n  }\n SourceCodeAfterRefactoring:\n@Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    PsiFile file = findPsiFile(project, targetPath);\n    if (file != null) {\n      int targetOffset = target.getOffset();\n      for (int i = 0; i < 2; i++) {\n        Class<? extends PsiElement> clazz = DartComponentName.class;\n        if (i == 1) {\n          clazz = DartReferenceExpression.class;\n        }\n        PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n        if (elementAt != null) {\n          return elementAt;\n        }\n      }\n    }\n    return null;\n  }\n@Nullable\n  public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n    if (virtualFile != null) {\n      return PsiManager.getInstance(project).findFile(virtualFile);\n    }\n    return null;\n  }\n DiffSourceCode:\n   135:   @Nullable\n   136:   private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n   137:     String targetPath = target.getFile();\n-  138:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n-  139:     if (virtualFile != null) {\n-  140:       PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n-  141:       if (file != null) {\n-  142:         int targetOffset = target.getOffset();\n-  143:         for (int i = 0; i < 2; i++) {\n-  144:           Class<? extends PsiElement> clazz = DartComponentName.class;\n-  145:           if (i == 1) {\n-  146:             clazz = DartReferenceExpression.class;\n-  147:           }\n-  148:           PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n-  149:           if (elementAt != null) {\n-  150:             return elementAt;\n-  151:           }\n-  152:         }\n-  153:       }\n-  154:     }\n-  155:     return null;\n-  156:   }\n-  157: \n-  158:   @NotNull\n-  159:   private static List<PsiElement> toResult(@Nullable PsiElement element) {\n-  160:     if (element == null) {\n-  161:       return Collections.emptyList();\n-  162:     }\n+  138:     PsiFile file = findPsiFile(project, targetPath);\n+  139:     if (file != null) {\n+  140:       int targetOffset = target.getOffset();\n+  141:       for (int i = 0; i < 2; i++) {\n+  142:         Class<? extends PsiElement> clazz = DartComponentName.class;\n+  143:         if (i == 1) {\n+  144:           clazz = DartReferenceExpression.class;\n+  145:         }\n+  146:         PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n+  147:         if (elementAt != null) {\n+  148:           return elementAt;\n+  149:         }\n+  150:       }\n+  151:     }\n+  152:     return null;\n+  153:   }\n+  154: \n+  155:   @Nullable\n+  156:   public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n+  157:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n+  158:     if (virtualFile != null) {\n+  159:       return PsiManager.getInstance(project).findFile(virtualFile);\n+  160:     }\n+  161:     return null;\n+  162:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n\t\tthis.source = source;\n\t\tthis.fexpr = fexpr;\n\t\tthis.args = args;\n\t\tthis.line = line;\n\t\tthis.column = column;\n\t\tthis.tailPosition = tailPosition;\n\n\t\tif(fexpr instanceof VarExpr)\n\t\t\t{\n\t\t\tVar fvar = ((VarExpr)fexpr).var;\n\t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n\t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n\t\t\t\t{\n\t\t\t\tthis.isProtocol = true;\n\t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n\t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n\t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n\t\t\t\tif(this.protocolOn != null)\n\t\t\t\t\t{\n\t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n                    Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n                    if (mmapVal == null) {\n                        throw new IllegalArgumentException(\n                              \"No method of interface: \" + protocolOn.getName() +\n                              \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n                              \" (The protocol method may have been defined before and removed.)\");\n                    }\n                    String mname = munge(mmapVal.sym.toString());\n \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n\t\t\t\t\tif(methods.size() != 1)\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n\t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n\t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (tag != null) {\n\t\t    this.tag = tag;\n\t\t} else if (fexpr instanceof VarExpr) {\n\t\t    Object arglists = RT.get(RT.meta(((VarExpr) fexpr).var), arglistsKey);\n\t\t    Object sigTag = null;\n\t\t    for(ISeq s = RT.seq(arglists); s != null; s = s.next()) {\n                APersistentVector sig = (APersistentVector) s.first();\n                int restOffset = sig.indexOf(_AMP_);\n                if (args.count() == sig.count() || (restOffset > -1 && args.count() >= restOffset)) {\n                    sigTag = tagOf(sig);\n                    break;\n                }\n            }\n\t\t    \n\t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n\t\t} else {\n\t\t    this.tag = null;\n\t\t}\n\t}\n SourceCodeAfterRefactoring:\npublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n\t\tthis.source = source;\n\t\tthis.fexpr = fexpr;\n\t\tthis.args = args;\n\t\tthis.line = line;\n\t\tthis.column = column;\n\t\tthis.tailPosition = tailPosition;\n\n\t\tif(fexpr instanceof VarExpr)\n\t\t\t{\n\t\t\tVar fvar = ((VarExpr)fexpr).var;\n\t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n\t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n\t\t\t\t{\n\t\t\t\tthis.isProtocol = true;\n\t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n\t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n\t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n\t\t\t\tif(this.protocolOn != null)\n\t\t\t\t\t{\n\t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n                    Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n                    if (mmapVal == null) {\n                        throw new IllegalArgumentException(\n                              \"No method of interface: \" + protocolOn.getName() +\n                              \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n                              \" (The protocol method may have been defined before and removed.)\");\n                    }\n                    String mname = munge(mmapVal.sym.toString());\n \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n\t\t\t\t\tif(methods.size() != 1)\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n\t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n\t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (tag != null) {\n\t\t    this.tag = tag;\n\t\t} else if (fexpr instanceof VarExpr) {\n            Var v = ((VarExpr) fexpr).var;\n\t\t    Object arglists = RT.get(RT.meta(v), arglistsKey);\n\t\t    Object sigTag = sigTag(args.count(),v);\n\t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n\t\t} else {\n\t\t    this.tag = null;\n\t\t}\n\t}\nstatic Object sigTag(int argcount, Var v){\n        Object arglists = RT.get(RT.meta(v), arglistsKey);\n        Object sigTag = null;\n        for(ISeq s = RT.seq(arglists); s != null; s = s.next())\n            {\n            APersistentVector sig = (APersistentVector) s.first();\n            int restOffset = sig.indexOf(_AMP_);\n            if(argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))\n                return tagOf(sig);\n            }\n        return null;\n        }\n DiffSourceCode:\n- 3585: \tpublic Class protocolOn;\n- 3586: \tpublic java.lang.reflect.Method onMethod;\n- 3587: \tstatic Keyword onKey = Keyword.intern(\"on\");\n- 3588: \tstatic Keyword methodMapKey = Keyword.intern(\"method-map\");\n- 3589: \n- 3590: \tpublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n- 3591: \t\tthis.source = source;\n- 3592: \t\tthis.fexpr = fexpr;\n- 3593: \t\tthis.args = args;\n- 3594: \t\tthis.line = line;\n- 3595: \t\tthis.column = column;\n- 3596: \t\tthis.tailPosition = tailPosition;\n+ 3585:     static Object sigTag(int argcount, Var v){\n+ 3586:         Object arglists = RT.get(RT.meta(v), arglistsKey);\n+ 3587:         Object sigTag = null;\n+ 3588:         for(ISeq s = RT.seq(arglists); s != null; s = s.next())\n+ 3589:             {\n+ 3590:             APersistentVector sig = (APersistentVector) s.first();\n+ 3591:             int restOffset = sig.indexOf(_AMP_);\n+ 3592:             if(argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))\n+ 3593:                 return tagOf(sig);\n+ 3594:             }\n+ 3595:         return null;\n+ 3596:         }\n  3597: \n- 3598: \t\tif(fexpr instanceof VarExpr)\n- 3599: \t\t\t{\n- 3600: \t\t\tVar fvar = ((VarExpr)fexpr).var;\n- 3601: \t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n- 3602: \t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n- 3603: \t\t\t\t{\n- 3604: \t\t\t\tthis.isProtocol = true;\n- 3605: \t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n- 3606: \t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n- 3607: \t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n- 3608: \t\t\t\tif(this.protocolOn != null)\n- 3609: \t\t\t\t\t{\n- 3610: \t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n- 3611:                     Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n- 3612:                     if (mmapVal == null) {\n- 3613:                         throw new IllegalArgumentException(\n- 3614:                               \"No method of interface: \" + protocolOn.getName() +\n- 3615:                               \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n- 3616:                               \" (The protocol method may have been defined before and removed.)\");\n- 3617:                     }\n- 3618:                     String mname = munge(mmapVal.sym.toString());\n- 3619:  \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n- 3620: \t\t\t\t\tif(methods.size() != 1)\n- 3621: \t\t\t\t\t\tthrow new IllegalArgumentException(\n- 3622: \t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n- 3623: \t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n- 3624: \t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n- 3625: \t\t\t\t\t}\n- 3626: \t\t\t\t}\n- 3627: \t\t\t}\n- 3628: \t\t\n- 3629: \t\tif (tag != null) {\n- 3630: \t\t    this.tag = tag;\n- 3631: \t\t} else if (fexpr instanceof VarExpr) {\n- 3632: \t\t    Object arglists = RT.get(RT.meta(((VarExpr) fexpr).var), arglistsKey);\n- 3633: \t\t    Object sigTag = null;\n- 3634: \t\t    for(ISeq s = RT.seq(arglists); s != null; s = s.next()) {\n- 3635:                 APersistentVector sig = (APersistentVector) s.first();\n- 3636:                 int restOffset = sig.indexOf(_AMP_);\n- 3637:                 if (args.count() == sig.count() || (restOffset > -1 && args.count() >= restOffset)) {\n- 3638:                     sigTag = tagOf(sig);\n- 3639:                     break;\n- 3640:                 }\n- 3641:             }\n- 3642: \t\t    \n+ 3598: \tpublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n+ 3599: \t\tthis.source = source;\n+ 3600: \t\tthis.fexpr = fexpr;\n+ 3601: \t\tthis.args = args;\n+ 3602: \t\tthis.line = line;\n+ 3603: \t\tthis.column = column;\n+ 3604: \t\tthis.tailPosition = tailPosition;\n+ 3605: \n+ 3606: \t\tif(fexpr instanceof VarExpr)\n+ 3607: \t\t\t{\n+ 3608: \t\t\tVar fvar = ((VarExpr)fexpr).var;\n+ 3609: \t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n+ 3610: \t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n+ 3611: \t\t\t\t{\n+ 3612: \t\t\t\tthis.isProtocol = true;\n+ 3613: \t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n+ 3614: \t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n+ 3615: \t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n+ 3616: \t\t\t\tif(this.protocolOn != null)\n+ 3617: \t\t\t\t\t{\n+ 3618: \t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n+ 3619:                     Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n+ 3620:                     if (mmapVal == null) {\n+ 3621:                         throw new IllegalArgumentException(\n+ 3622:                               \"No method of interface: \" + protocolOn.getName() +\n+ 3623:                               \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n+ 3624:                               \" (The protocol method may have been defined before and removed.)\");\n+ 3625:                     }\n+ 3626:                     String mname = munge(mmapVal.sym.toString());\n+ 3627:  \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n+ 3628: \t\t\t\t\tif(methods.size() != 1)\n+ 3629: \t\t\t\t\t\tthrow new IllegalArgumentException(\n+ 3630: \t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n+ 3631: \t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n+ 3632: \t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n+ 3633: \t\t\t\t\t}\n+ 3634: \t\t\t\t}\n+ 3635: \t\t\t}\n+ 3636: \t\t\n+ 3637: \t\tif (tag != null) {\n+ 3638: \t\t    this.tag = tag;\n+ 3639: \t\t} else if (fexpr instanceof VarExpr) {\n+ 3640:             Var v = ((VarExpr) fexpr).var;\n+ 3641: \t\t    Object arglists = RT.get(RT.meta(v), arglistsKey);\n+ 3642: \t\t    Object sigTag = sigTag(args.count(),v);\n  3643: \t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n  3644: \t\t} else {\n  3645: \t\t    this.tag = null;\n  3646: \t\t}\n  3647: \t}\n\n",
        "contextDescription": "PackageName: net.osmand.plus.views\nClassName: net.osmand.plus.views.RouteLayer\nMethodName: net.osmand.plus.views.RouteLayer#calculateActionPoints\n ClassSignature: public class RouteLayer extends OsmandMapLayer \nInvokedMethod: methodSignature: net.osmand.plus.views.RouteLayer#calculateProjection\n methodBody: private Location calculateProjection(double part, Location lp, Location l) {\nLocation p=new Location(l);\np.setLatitude(lp.getLatitude() + part * (l.getLatitude() - lp.getLatitude()));\np.setLongitude(lp.getLongitude() + part * (l.getLongitude() - lp.getLongitude()));\nreturn p;\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\nprivate void calculateActionPoints(double topLatitude, double leftLongitude, double bottomLatitude,\n\t\t\tdouble rightLongitude, Location lastProjection, List<Location> routeNodes, int cd,\n\t\t\tIterator<RouteDirectionInfo> it, int zoom) {\n\t\tRouteDirectionInfo nf = null;\n\t\t\n\t\tdouble DISTANCE_ACTION = 35;\n\t\tif(zoom >= 17) {\n\t\t\tDISTANCE_ACTION = 15;\n\t\t} else if (zoom == 15) {\n\t\t\tDISTANCE_ACTION = 70;\n\t\t} else if (zoom < 15) {\n\t\t\tDISTANCE_ACTION = 110;\n\t\t}\n\t\tdouble actionDist = 0;\n\t\tLocation previousAction = null; \n\t\tactionPoints.clear();\n\t\tint prevFinishPoint = -2;\n\t\tfor (int i = 0; i < routeNodes.size(); i++) {\n\t\t\tLocation ls = routeNodes.get(i);\n\t\t\tif(nf != null) {\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif(pnt < i + cd ) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (nf == null && it.hasNext()) {\n\t\t\t\tnf = it.next();\n\t\t\t\tint pnt = nf.routeEndPointOffset == 0 ? nf.routePointOffset : nf.routeEndPointOffset;\n\t\t\t\tif (pnt < i + cd) {\n\t\t\t\t\tnf = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean action = nf != null && (nf.routePointOffset == i + cd ||\n\t\t\t\t\t(nf.routePointOffset <= i + cd && i + cd  <= nf.routeEndPointOffset));\n\t\t\tif(!action && previousAction == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean visible = leftLongitude <= ls.getLongitude() && ls.getLongitude() <= rightLongitude && bottomLatitude <= ls.getLatitude()\n\t\t\t\t\t&& ls.getLatitude() <= topLatitude;\n\t\t\tif(!action) {\n\t\t\t\tif(previousAction != null) {\n\t\t\t\t\tfloat dist = ls.distanceTo(previousAction);\n\t\t\t\t\tactionDist += dist;\n\t\t\t\t\tif(actionDist >= DISTANCE_ACTION) {\n\t\t\t\t\t\tactionPoints.add(calculateProjection(1 - (actionDist - DISTANCE_ACTION) / dist, previousAction, ls));\n\t\t\t\t\t\tactionPoints.add(null);\n\t\t\t\t\t\tprevFinishPoint = i;\n\t\t\t\t\t\tpreviousAction = null;\n\t\t\t\t\t\tactionDist = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// action point\n\t\t\t\tif(visible) {\n\t\t\t\t\t// visible action point\n\t\t\t\t\tif (previousAction == null) {\n\t\t\t\t\t\t// put some points in front\n\t\t\t\t\t\tint ind = actionPoints.size();\n\t\t\t\t\t\tLocation lprevious = ls;\n\t\t\t\t\t\tdouble dist = 0;\n\t\t\t\t\t\tfor (int k = i - 1; k >= -1; k--) {\n\t\t\t\t\t\t\tLocation l = k == -1 ? lastProjection : routeNodes.get(k);\n\t\t\t\t\t\t\tfloat loc = lprevious.distanceTo(l);\n\t\t\t\t\t\t\tif(prevFinishPoint == k) {\n\t\t\t\t\t\t\t\tif(ind >= 2) {\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t\tactionPoints.remove(ind - 2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tprevFinishPoint = -2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdist += loc;\n\t\t\t\t\t\t\tif (dist >= DISTANCE_ACTION) {\n\t\t\t\t\t\t\t\tif(loc > 1) {\n\t\t\t\t\t\t\t\t\tactionPoints.add(ind, calculateProjection(1 - (dist - DISTANCE_ACTION) / loc, lprevious, l));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tactionPoints.add(ind, l);\n\t\t\t\t\t\t\t\tlprevious = l;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tactionPoints.add(ls);\n\t\t\t\t\tpreviousAction = ls;\n\t\t\t\t\tactionDist = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(previousAction != null) {\n\t\t\tactionPoints.add(null);\n\t\t}\n\t}\n\nThe context of the source code is as follows:\nPackageName: net.osmand.plus.views\nClassName: net.osmand.plus.views.RouteLayer\nMethodName: net.osmand.plus.views.RouteLayer#calculateActionPoints\n ClassSignature: public class RouteLayer extends OsmandMapLayer \nInvokedMethod: methodSignature: net.osmand.plus.views.RouteLayer#calculateProjection\n methodBody: private Location calculateProjection(double part, Location lp, Location l) {\nLocation p=new Location(l);\np.setLatitude(lp.getLatitude() + part * (l.getLatitude() - lp.getLatitude()));\np.setLongitude(lp.getLongitude() + part * (l.getLongitude() - lp.getLongitude()));\nreturn p;\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n /**\n     *\n     * @param initialStep the initial step size\n     * @param parameters the parameters to optimize\n     * @param gradients the line/rate of change\n     * @return the next step size\n     * @throws InvalidStepException\n     */\n    public double optimize (double initialStep,INDArray parameters,INDArray gradients) throws InvalidStepException {\n        double slope, test, alamin, alam, alam2, tmplam;\n        double rhs1, rhs2, a, b, disc, oldAlam;double f, fold, f2;\n        INDArray oldParameters = parameters.dup();\n        INDArray gDup = gradients.dup();\n\n        alam2 = 0.0;\n        f2 = fold = optimizer.score();\n\n        if (logger.isDebugEnabled()) {\n            logger.trace (\"ENTERING BACKTRACK\\n\");\n            logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n                    +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+ FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n        }\n\n        double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n        if(sum > stpmax) {\n            logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n                    \", stpmax= \"+ stpmax);\n            gradients.muli(stpmax / sum);\n        }\n\n        //dot product\n        slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n        logger.debug(\"slope = \" + slope);\n\n        if (slope < 0)\n            throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n\n        if (slope == 0)\n            throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n\n        // find maximum lambda\n        // converge when (delta x) / x < REL_TOLX for all coordinates.\n        //  the largest step size that triggers this threshold is\n        //  precomputed and saved in alamin\n        INDArray maxOldParams = abs(oldParameters);\n        Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n\n\n\n        INDArray testMatrix = abs(gradients).divi(maxOldParams);\n        test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n\n        alamin = relTolx / test;\n\n        alam  = 1.0;\n        oldAlam = 0.0;\n        int iteration;\n        // look for step size in direction given by \"line\"\n        for(iteration = 0; iteration < maxIterations; iteration++) {\n            // initially, alam = 1.0, i.e. take full Newton step\n            logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n            logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n            assert(alam != oldAlam) : \"alam == oldAlam\";\n\n            if(stepFunction == null)\n                stepFunction =  new DefaultStepFunction();\n            //scale wrt updates\n            stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n\n            if(logger.isDebugEnabled())  {\n                double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n                logger.debug (\"after step, x.1norm: \" + norm1);\n            }\n\n            // check for convergence\n            //convergence on delta x\n            //if all of the parameters are < 1e-12\n\n            if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n                    parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n                function.setParams(oldParameters);\n                function.setScore();\n                f = function.score();\n                logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n                return 0.0;\n            }\n\n            function.setParams(parameters);\n            oldAlam = alam;\n            function.setScore();\n            f = function.score();\n\n            logger.debug(\"value = \" + f);\n\n            // sufficient function increase (Wolf condition)\n            if(f >= fold + ALF * alam * slope) {\n\n                logger.debug(\"EXITING BACKTRACK: value=\" + f);\n\n                if (f < fold)\n                    throw new IllegalStateException\n                            (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n                return alam;\n            }\n\n\n            // if value is infinite, i.e. we've\n            // jumped to unstable territory, then scale down jump\n            else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n                logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n                tmplam = .2 * alam;\n                if(alam < alamin) { //convergence on delta x\n                    function.setParams(oldParameters);\n                    function.setScore();\n                    f = function.score();\n                    logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n                    return 0.0;\n                }\n            }\n            else { // backtrack\n                if(alam == 1.0) // first time through\n                    tmplam = -slope / (2.0 * ( f - fold - slope ));\n                else {\n                    rhs1 = f - fold- alam * slope;\n                    rhs2 = f2 - fold - alam2 * slope;\n                    if((alam - alam2) == 0)\n                        throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n                    a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n                    b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n                    if(a == 0.0)\n                        tmplam = -slope / (2.0 * b);\n                    else {\n                        disc = b * b - 3.0 * a * slope;\n                        if(disc < 0.0) {\n                            tmplam = .5f * alam;\n                        }\n                        else if (b <= 0.0)\n                            tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n                        else\n                            tmplam = -slope / (b +FastMath.sqrt(disc));\n                    }\n                    if (tmplam > .5f * alam)\n                        tmplam = .5f * alam;    // lambda <= .5 lambda_1\n                }\n            }\n\n            alam2 = alam;\n            f2 = f;\n            logger.debug(\"tmplam:\" + tmplam);\n            alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n\n        }\n\n        return 0.0;\n    }\n SourceCodeAfterRefactoring:\n/**\n     *\n     * @param initialStep the initial step size\n     * @param parameters the parameters to optimize\n     * @param gradients the line/rate of change\n     * @return the next step size\n     * @throws InvalidStepException\n     */\n    public double optimize (double initialStep, INDArray parameters, INDArray gradients) throws InvalidStepException {\n        double test, alamin, alam, alam2, oldAlam, tmplam;\n        double rhs1, rhs2, a, b, disc, f, fold, f2;\n\n        INDArray oldParameters = parameters.dup();\n        INDArray gDup = gradients.dup();\n        double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n        double slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n\n        INDArray maxOldParams = abs(oldParameters);\n        Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n        INDArray testMatrix = abs(gradients).divi(maxOldParams);\n        test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n\n        alam  = 1.0; // initially, alam = 1.0, i.e. take full Newton step\n        alamin = relTolx / test; // relative convergence tolerance\n        oldAlam = 0.0;\n        alam2 = 0.0;\n\n        f2 = fold = layer.score();\n\n        if (logger.isDebugEnabled()) {\n            logger.trace (\"ENTERING BACKTRACK\\n\");\n            logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n                    +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+\n                    FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n        }\n\n        if(sum > stpmax) {\n            logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n                    \", stpmax= \"+ stpmax);\n            gradients.muli(stpmax / sum);\n        }\n\n        logger.debug(\"slope = \" + slope);\n\n        if (slope < 0)\n            throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n        else if (slope == 0)\n            throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n\n        // find maximum lambda\n        // converge when (delta x) / x < REL_TOLX for all coordinates.\n        // the largest step size that triggers this threshold is precomputed and saved in alamin\n        // look for step size in direction given by \"line\"\n\n        for(int iteration = 0; iteration < maxIterations; iteration++) {\n            logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n            logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n            assert(alam != oldAlam) : \"alam == oldAlam\";\n\n            if(stepFunction == null)\n                stepFunction =  new DefaultStepFunction();\n            //scale wrt updates\n            stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n            oldAlam = alam;\n\n            if(logger.isDebugEnabled())  {\n                double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n                logger.debug (\"after step, x.1norm: \" + norm1);\n            }\n\n            // check for convergence on delta x\n            // if all of the parameters are < 1e-12\n\n            if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n                    parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n                f = getNewScore(oldParameters);\n                logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n                return 0.0;\n            }\n\n            f = getNewScore(oldParameters);\n            logger.debug(\"value = \" + f);\n\n            // sufficient increase (Wolf condition)\n\n            if(f >= fold + ALF * alam * slope) {\n\n                logger.debug(\"EXITING BACKTRACK: value=\" + f);\n                if (f < fold)\n                    throw new IllegalStateException\n                            (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n                return alam;\n            }\n\n            // if value is infinite, i.e. we've\n            // jumped to unstable territory, then scale down jump\n\n            else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n                logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n                tmplam = .2 * alam;\n                if(alam < alamin) { //convergence on delta x\n                    f = getNewScore(oldParameters);\n                    logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n                    return 0.0;\n                }\n            }\n\n            // backtrack\n\n            else {\n                if(alam == 1.0) // first time through\n                    tmplam = -slope / (2.0 * ( f - fold - slope ));\n                else {\n                    rhs1 = f - fold- alam * slope;\n                    rhs2 = f2 - fold - alam2 * slope;\n                    if(alam == alam2)\n                        throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n                    a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n                    b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n                    if(a == 0.0)\n                        tmplam = -slope / (2.0 * b);\n                    else {\n                        disc = b * b - 3.0 * a * slope;\n                        if(disc < 0.0) {\n                            tmplam = .5f * alam;\n                        }\n                        else if (b <= 0.0)\n                            tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n                        else\n                            tmplam = -slope / (b +FastMath.sqrt(disc));\n                    }\n                    if (tmplam > .5f * alam)\n                        tmplam = .5f * alam;    // lambda <= .5 lambda_1\n                }\n            }\n\n            alam2 = alam;\n            f2 = f;\n            logger.debug(\"tmplam:\" + tmplam);\n            alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n\n        }\n\n        return 0.0;\n    }\nprivate double getNewScore(INDArray oldParameters){\n        layer.setParams(oldParameters);\n        layer.setScore();\n        return layer.score();\n    }\n DiffSourceCode:\n-  132:     /**\n-  133:      *\n-  134:      * @param initialStep the initial step size\n-  135:      * @param parameters the parameters to optimize\n-  136:      * @param gradients the line/rate of change\n-  137:      * @return the next step size\n-  138:      * @throws InvalidStepException\n-  139:      */\n-  140:     public double optimize (double initialStep,INDArray parameters,INDArray gradients) throws InvalidStepException {\n-  141:         double slope, test, alamin, alam, alam2, tmplam;\n-  142:         double rhs1, rhs2, a, b, disc, oldAlam;double f, fold, f2;\n-  143:         INDArray oldParameters = parameters.dup();\n-  144:         INDArray gDup = gradients.dup();\n-  145: \n-  146:         alam2 = 0.0;\n-  147:         f2 = fold = optimizer.score();\n-  148: \n-  149:         if (logger.isDebugEnabled()) {\n-  150:             logger.trace (\"ENTERING BACKTRACK\\n\");\n-  151:             logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n-  152:                     +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+ FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n-  153:         }\n+  132:     private double getNewScore(INDArray oldParameters){\n+  133:         layer.setParams(oldParameters);\n+  134:         layer.setScore();\n+  135:         return layer.score();\n+  136:     }\n+  137: \n+  138:     /**\n+  139:      *\n+  140:      * @param initialStep the initial step size\n+  141:      * @param parameters the parameters to optimize\n+  142:      * @param gradients the line/rate of change\n+  143:      * @return the next step size\n+  144:      * @throws InvalidStepException\n+  145:      */\n+  146:     public double optimize (double initialStep, INDArray parameters, INDArray gradients) throws InvalidStepException {\n+  147:         double test, alamin, alam, alam2, oldAlam, tmplam;\n+  148:         double rhs1, rhs2, a, b, disc, f, fold, f2;\n+  149: \n+  150:         INDArray oldParameters = parameters.dup();\n+  151:         INDArray gDup = gradients.dup();\n+  152:         double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n+  153:         double slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n   154: \n-  155:         double sum = gradients.norm2(Integer.MAX_VALUE).getDouble(0);\n-  156:         if(sum > stpmax) {\n-  157:             logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n-  158:                     \", stpmax= \"+ stpmax);\n-  159:             gradients.muli(stpmax / sum);\n-  160:         }\n-  161: \n-  162:         //dot product\n-  163:         slope = Nd4j.getBlasWrapper().dot(gDup, gradients);\n-  164:         logger.debug(\"slope = \" + slope);\n-  165: \n-  166:         if (slope < 0)\n-  167:             throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n-  168: \n-  169:         if (slope == 0)\n-  170:             throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n-  171: \n-  172:         // find maximum lambda\n-  173:         // converge when (delta x) / x < REL_TOLX for all coordinates.\n-  174:         //  the largest step size that triggers this threshold is\n-  175:         //  precomputed and saved in alamin\n-  176:         INDArray maxOldParams = abs(oldParameters);\n-  177:         Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n-  178: \n+  155:         INDArray maxOldParams = abs(oldParameters);\n+  156:         Nd4j.getExecutioner().exec(new ScalarSetValue(maxOldParams,1));\n+  157:         INDArray testMatrix = abs(gradients).divi(maxOldParams);\n+  158:         test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n+  159: \n+  160:         alam  = 1.0; // initially, alam = 1.0, i.e. take full Newton step\n+  161:         alamin = relTolx / test; // relative convergence tolerance\n+  162:         oldAlam = 0.0;\n+  163:         alam2 = 0.0;\n+  164: \n+  165:         f2 = fold = layer.score();\n+  166: \n+  167:         if (logger.isDebugEnabled()) {\n+  168:             logger.trace (\"ENTERING BACKTRACK\\n\");\n+  169:             logger.trace(\"Entering BackTrackLinnSearch, value = \" + fold + \",\\ndirection.oneNorm:\"\n+  170:                     +\tgDup.norm1(Integer.MAX_VALUE) + \"  direction.infNorm:\"+\n+  171:                     FastMath.max(Float.NEGATIVE_INFINITY,abs(gDup).max(Integer.MAX_VALUE).getDouble(0)));\n+  172:         }\n+  173: \n+  174:         if(sum > stpmax) {\n+  175:             logger.warn(\"attempted step too big. scaling: sum= \" + sum +\n+  176:                     \", stpmax= \"+ stpmax);\n+  177:             gradients.muli(stpmax / sum);\n+  178:         }\n   179: \n-  180: \n-  181:         INDArray testMatrix = abs(gradients).divi(maxOldParams);\n-  182:         test = testMatrix.max(Integer.MAX_VALUE).getDouble(0);\n-  183: \n-  184:         alamin = relTolx / test;\n-  185: \n-  186:         alam  = 1.0;\n-  187:         oldAlam = 0.0;\n-  188:         int iteration;\n-  189:         // look for step size in direction given by \"line\"\n-  190:         for(iteration = 0; iteration < maxIterations; iteration++) {\n-  191:             // initially, alam = 1.0, i.e. take full Newton step\n-  192:             logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n-  193:             logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n-  194:             assert(alam != oldAlam) : \"alam == oldAlam\";\n-  195: \n-  196:             if(stepFunction == null)\n-  197:                 stepFunction =  new DefaultStepFunction();\n-  198:             //scale wrt updates\n-  199:             stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n-  200: \n-  201:             if(logger.isDebugEnabled())  {\n-  202:                 double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n-  203:                 logger.debug (\"after step, x.1norm: \" + norm1);\n-  204:             }\n-  205: \n-  206:             // check for convergence\n-  207:             //convergence on delta x\n-  208:             //if all of the parameters are < 1e-12\n-  209: \n-  210:             if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n-  211:                     parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n-  212:                 function.setParams(oldParameters);\n-  213:                 function.setScore();\n-  214:                 f = function.score();\n-  215:                 logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n-  216:                 return 0.0;\n-  217:             }\n-  218: \n-  219:             function.setParams(parameters);\n-  220:             oldAlam = alam;\n-  221:             function.setScore();\n-  222:             f = function.score();\n-  223: \n-  224:             logger.debug(\"value = \" + f);\n-  225: \n-  226:             // sufficient function increase (Wolf condition)\n-  227:             if(f >= fold + ALF * alam * slope) {\n-  228: \n-  229:                 logger.debug(\"EXITING BACKTRACK: value=\" + f);\n-  230: \n-  231:                 if (f < fold)\n-  232:                     throw new IllegalStateException\n-  233:                             (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n-  234:                 return alam;\n-  235:             }\n-  236: \n-  237: \n-  238:             // if value is infinite, i.e. we've\n-  239:             // jumped to unstable territory, then scale down jump\n-  240:             else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n-  241:                 logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n-  242:                 tmplam = .2 * alam;\n-  243:                 if(alam < alamin) { //convergence on delta x\n-  244:                     function.setParams(oldParameters);\n-  245:                     function.setScore();\n-  246:                     f = function.score();\n-  247:                     logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n-  248:                     return 0.0;\n-  249:                 }\n-  250:             }\n-  251:             else { // backtrack\n-  252:                 if(alam == 1.0) // first time through\n-  253:                     tmplam = -slope / (2.0 * ( f - fold - slope ));\n-  254:                 else {\n-  255:                     rhs1 = f - fold- alam * slope;\n-  256:                     rhs2 = f2 - fold - alam2 * slope;\n-  257:                     if((alam - alam2) == 0)\n-  258:                         throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n-  259:                     a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n-  260:                     b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n-  261:                     if(a == 0.0)\n-  262:                         tmplam = -slope / (2.0 * b);\n-  263:                     else {\n-  264:                         disc = b * b - 3.0 * a * slope;\n-  265:                         if(disc < 0.0) {\n-  266:                             tmplam = .5f * alam;\n-  267:                         }\n-  268:                         else if (b <= 0.0)\n-  269:                             tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n-  270:                         else\n-  271:                             tmplam = -slope / (b +FastMath.sqrt(disc));\n-  272:                     }\n-  273:                     if (tmplam > .5f * alam)\n-  274:                         tmplam = .5f * alam;    // lambda <= .5 lambda_1\n-  275:                 }\n-  276:             }\n-  277: \n-  278:             alam2 = alam;\n-  279:             f2 = f;\n-  280:             logger.debug(\"tmplam:\" + tmplam);\n-  281:             alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n-  282: \n-  283:         }\n+  180:         logger.debug(\"slope = \" + slope);\n+  181: \n+  182:         if (slope < 0)\n+  183:             throw new InvalidStepException(\"Slope = \" + slope + \" is negative\");\n+  184:         else if (slope == 0)\n+  185:             throw new InvalidStepException (\"Slope = \" + slope + \" is zero\");\n+  186: \n+  187:         // find maximum lambda\n+  188:         // converge when (delta x) / x < REL_TOLX for all coordinates.\n+  189:         // the largest step size that triggers this threshold is precomputed and saved in alamin\n+  190:         // look for step size in direction given by \"line\"\n+  191: \n+  192:         for(int iteration = 0; iteration < maxIterations; iteration++) {\n+  193:             logger.trace(\"BackTrack loop iteration \" + iteration +\" : alam=\" + alam +\" oldAlam=\" + oldAlam);\n+  194:             logger.trace (\"before step, x.1norm: \" + parameters.norm1(Integer.MAX_VALUE) +  \"\\nalam: \" + alam + \"\\noldAlam: \" + oldAlam);\n+  195:             assert(alam != oldAlam) : \"alam == oldAlam\";\n+  196: \n+  197:             if(stepFunction == null)\n+  198:                 stepFunction =  new DefaultStepFunction();\n+  199:             //scale wrt updates\n+  200:             stepFunction.step(parameters, gradients, new Object[]{alam,oldAlam}); //step\n+  201:             oldAlam = alam;\n+  202: \n+  203:             if(logger.isDebugEnabled())  {\n+  204:                 double norm1 = parameters.norm1(Integer.MAX_VALUE).getDouble(0);\n+  205:                 logger.debug (\"after step, x.1norm: \" + norm1);\n+  206:             }\n+  207: \n+  208:             // check for convergence on delta x\n+  209:             // if all of the parameters are < 1e-12\n+  210: \n+  211:             if ((alam < alamin) || Nd4j.getExecutioner().execAndReturn(new Eps(oldParameters, parameters,\n+  212:                     parameters.dup(), parameters.length())).sum(Integer.MAX_VALUE).getDouble(0) == parameters.length()) {\n+  213:                 f = getNewScore(oldParameters);\n+  214:                 logger.trace(\"EXITING BACKTRACK: Jump too small (alamin = \"+ alamin + \"). Exiting and using xold. Value = \" + f);\n+  215:                 return 0.0;\n+  216:             }\n+  217: \n+  218:             f = getNewScore(oldParameters);\n+  219:             logger.debug(\"value = \" + f);\n+  220: \n+  221:             // sufficient increase (Wolf condition)\n+  222: \n+  223:             if(f >= fold + ALF * alam * slope) {\n+  224: \n+  225:                 logger.debug(\"EXITING BACKTRACK: value=\" + f);\n+  226:                 if (f < fold)\n+  227:                     throw new IllegalStateException\n+  228:                             (\"Function did not increase: f = \" + f + \" < \" + fold + \" = fold\");\n+  229:                 return alam;\n+  230:             }\n+  231: \n+  232:             // if value is infinite, i.e. we've\n+  233:             // jumped to unstable territory, then scale down jump\n+  234: \n+  235:             else if(Double.isInfinite(f) || Double.isInfinite(f2)) {\n+  236:                 logger.warn (\"Value is infinite after jump \" + oldAlam + \". f=\"+ f +\", f2=\" + f2 + \". Scaling back step size...\");\n+  237:                 tmplam = .2 * alam;\n+  238:                 if(alam < alamin) { //convergence on delta x\n+  239:                     f = getNewScore(oldParameters);\n+  240:                     logger.warn(\"EXITING BACKTRACK: Jump too small. Exiting and using xold. Value=\"+ f );\n+  241:                     return 0.0;\n+  242:                 }\n+  243:             }\n+  244: \n+  245:             // backtrack\n+  246: \n+  247:             else {\n+  248:                 if(alam == 1.0) // first time through\n+  249:                     tmplam = -slope / (2.0 * ( f - fold - slope ));\n+  250:                 else {\n+  251:                     rhs1 = f - fold- alam * slope;\n+  252:                     rhs2 = f2 - fold - alam2 * slope;\n+  253:                     if(alam == alam2)\n+  254:                         throw new IllegalStateException(\"FAILURE: dividing by alam-alam2. alam=\" + alam);\n+  255:                     a = ( rhs1 / (FastMath.pow(alam, 2)) - rhs2 /  ( FastMath.pow(alam2, 2) )) / (alam - alam2);\n+  256:                     b = ( -alam2 * rhs1/( alam* alam ) + alam * rhs2 / ( alam2 *  alam2 )) / ( alam - alam2);\n+  257:                     if(a == 0.0)\n+  258:                         tmplam = -slope / (2.0 * b);\n+  259:                     else {\n+  260:                         disc = b * b - 3.0 * a * slope;\n+  261:                         if(disc < 0.0) {\n+  262:                             tmplam = .5f * alam;\n+  263:                         }\n+  264:                         else if (b <= 0.0)\n+  265:                             tmplam = (-b + FastMath.sqrt(disc))/(3.0f * a );\n+  266:                         else\n+  267:                             tmplam = -slope / (b +FastMath.sqrt(disc));\n+  268:                     }\n+  269:                     if (tmplam > .5f * alam)\n+  270:                         tmplam = .5f * alam;    // lambda <= .5 lambda_1\n+  271:                 }\n+  272:             }\n+  273: \n+  274:             alam2 = alam;\n+  275:             f2 = f;\n+  276:             logger.debug(\"tmplam:\" + tmplam);\n+  277:             alam = Math.max(tmplam, .1f * alam);  // lambda >= .1*Lambda_1\n+  278: \n+  279:         }\n+  280: \n+  281:         return 0.0;\n+  282:     }\n+  283: \n   284: \n-  285:         return 0.0;\n-  286:     }\n+  285: \n+  286: \n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n    if (virtualFile != null) {\n      PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n      if (file != null) {\n        int targetOffset = target.getOffset();\n        for (int i = 0; i < 2; i++) {\n          Class<? extends PsiElement> clazz = DartComponentName.class;\n          if (i == 1) {\n            clazz = DartReferenceExpression.class;\n          }\n          PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n          if (elementAt != null) {\n            return elementAt;\n          }\n        }\n      }\n    }\n    return null;\n  }\n SourceCodeAfterRefactoring:\n@Nullable\n  private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n    String targetPath = target.getFile();\n    PsiFile file = findPsiFile(project, targetPath);\n    if (file != null) {\n      int targetOffset = target.getOffset();\n      for (int i = 0; i < 2; i++) {\n        Class<? extends PsiElement> clazz = DartComponentName.class;\n        if (i == 1) {\n          clazz = DartReferenceExpression.class;\n        }\n        PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n        if (elementAt != null) {\n          return elementAt;\n        }\n      }\n    }\n    return null;\n  }\n@Nullable\n  public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n    if (virtualFile != null) {\n      return PsiManager.getInstance(project).findFile(virtualFile);\n    }\n    return null;\n  }\n DiffSourceCode:\n   135:   @Nullable\n   136:   private static PsiElement getElementForNavigationTarget(Project project, PluginNavigationTarget target) {\n   137:     String targetPath = target.getFile();\n-  138:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(targetPath);\n-  139:     if (virtualFile != null) {\n-  140:       PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n-  141:       if (file != null) {\n-  142:         int targetOffset = target.getOffset();\n-  143:         for (int i = 0; i < 2; i++) {\n-  144:           Class<? extends PsiElement> clazz = DartComponentName.class;\n-  145:           if (i == 1) {\n-  146:             clazz = DartReferenceExpression.class;\n-  147:           }\n-  148:           PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n-  149:           if (elementAt != null) {\n-  150:             return elementAt;\n-  151:           }\n-  152:         }\n-  153:       }\n-  154:     }\n-  155:     return null;\n-  156:   }\n-  157: \n-  158:   @NotNull\n-  159:   private static List<PsiElement> toResult(@Nullable PsiElement element) {\n-  160:     if (element == null) {\n-  161:       return Collections.emptyList();\n-  162:     }\n+  138:     PsiFile file = findPsiFile(project, targetPath);\n+  139:     if (file != null) {\n+  140:       int targetOffset = target.getOffset();\n+  141:       for (int i = 0; i < 2; i++) {\n+  142:         Class<? extends PsiElement> clazz = DartComponentName.class;\n+  143:         if (i == 1) {\n+  144:           clazz = DartReferenceExpression.class;\n+  145:         }\n+  146:         PsiElement elementAt = PsiTreeUtil.findElementOfClassAtOffset(file, targetOffset, clazz, false);\n+  147:         if (elementAt != null) {\n+  148:           return elementAt;\n+  149:         }\n+  150:       }\n+  151:     }\n+  152:     return null;\n+  153:   }\n+  154: \n+  155:   @Nullable\n+  156:   public static PsiFile findPsiFile(@NotNull Project project, @NotNull String path) {\n+  157:     VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(path);\n+  158:     if (virtualFile != null) {\n+  159:       return PsiManager.getInstance(project).findFile(virtualFile);\n+  160:     }\n+  161:     return null;\n+  162:   }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n\t\tthis.source = source;\n\t\tthis.fexpr = fexpr;\n\t\tthis.args = args;\n\t\tthis.line = line;\n\t\tthis.column = column;\n\t\tthis.tailPosition = tailPosition;\n\n\t\tif(fexpr instanceof VarExpr)\n\t\t\t{\n\t\t\tVar fvar = ((VarExpr)fexpr).var;\n\t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n\t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n\t\t\t\t{\n\t\t\t\tthis.isProtocol = true;\n\t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n\t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n\t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n\t\t\t\tif(this.protocolOn != null)\n\t\t\t\t\t{\n\t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n                    Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n                    if (mmapVal == null) {\n                        throw new IllegalArgumentException(\n                              \"No method of interface: \" + protocolOn.getName() +\n                              \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n                              \" (The protocol method may have been defined before and removed.)\");\n                    }\n                    String mname = munge(mmapVal.sym.toString());\n \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n\t\t\t\t\tif(methods.size() != 1)\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n\t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n\t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (tag != null) {\n\t\t    this.tag = tag;\n\t\t} else if (fexpr instanceof VarExpr) {\n\t\t    Object arglists = RT.get(RT.meta(((VarExpr) fexpr).var), arglistsKey);\n\t\t    Object sigTag = null;\n\t\t    for(ISeq s = RT.seq(arglists); s != null; s = s.next()) {\n                APersistentVector sig = (APersistentVector) s.first();\n                int restOffset = sig.indexOf(_AMP_);\n                if (args.count() == sig.count() || (restOffset > -1 && args.count() >= restOffset)) {\n                    sigTag = tagOf(sig);\n                    break;\n                }\n            }\n\t\t    \n\t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n\t\t} else {\n\t\t    this.tag = null;\n\t\t}\n\t}\n SourceCodeAfterRefactoring:\npublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n\t\tthis.source = source;\n\t\tthis.fexpr = fexpr;\n\t\tthis.args = args;\n\t\tthis.line = line;\n\t\tthis.column = column;\n\t\tthis.tailPosition = tailPosition;\n\n\t\tif(fexpr instanceof VarExpr)\n\t\t\t{\n\t\t\tVar fvar = ((VarExpr)fexpr).var;\n\t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n\t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n\t\t\t\t{\n\t\t\t\tthis.isProtocol = true;\n\t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n\t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n\t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n\t\t\t\tif(this.protocolOn != null)\n\t\t\t\t\t{\n\t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n                    Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n                    if (mmapVal == null) {\n                        throw new IllegalArgumentException(\n                              \"No method of interface: \" + protocolOn.getName() +\n                              \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n                              \" (The protocol method may have been defined before and removed.)\");\n                    }\n                    String mname = munge(mmapVal.sym.toString());\n \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n\t\t\t\t\tif(methods.size() != 1)\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n\t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n\t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif (tag != null) {\n\t\t    this.tag = tag;\n\t\t} else if (fexpr instanceof VarExpr) {\n            Var v = ((VarExpr) fexpr).var;\n\t\t    Object arglists = RT.get(RT.meta(v), arglistsKey);\n\t\t    Object sigTag = sigTag(args.count(),v);\n\t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n\t\t} else {\n\t\t    this.tag = null;\n\t\t}\n\t}\nstatic Object sigTag(int argcount, Var v){\n        Object arglists = RT.get(RT.meta(v), arglistsKey);\n        Object sigTag = null;\n        for(ISeq s = RT.seq(arglists); s != null; s = s.next())\n            {\n            APersistentVector sig = (APersistentVector) s.first();\n            int restOffset = sig.indexOf(_AMP_);\n            if(argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))\n                return tagOf(sig);\n            }\n        return null;\n        }\n DiffSourceCode:\n- 3585: \tpublic Class protocolOn;\n- 3586: \tpublic java.lang.reflect.Method onMethod;\n- 3587: \tstatic Keyword onKey = Keyword.intern(\"on\");\n- 3588: \tstatic Keyword methodMapKey = Keyword.intern(\"method-map\");\n- 3589: \n- 3590: \tpublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n- 3591: \t\tthis.source = source;\n- 3592: \t\tthis.fexpr = fexpr;\n- 3593: \t\tthis.args = args;\n- 3594: \t\tthis.line = line;\n- 3595: \t\tthis.column = column;\n- 3596: \t\tthis.tailPosition = tailPosition;\n+ 3585:     static Object sigTag(int argcount, Var v){\n+ 3586:         Object arglists = RT.get(RT.meta(v), arglistsKey);\n+ 3587:         Object sigTag = null;\n+ 3588:         for(ISeq s = RT.seq(arglists); s != null; s = s.next())\n+ 3589:             {\n+ 3590:             APersistentVector sig = (APersistentVector) s.first();\n+ 3591:             int restOffset = sig.indexOf(_AMP_);\n+ 3592:             if(argcount == sig.count() || (restOffset > -1 && argcount >= restOffset))\n+ 3593:                 return tagOf(sig);\n+ 3594:             }\n+ 3595:         return null;\n+ 3596:         }\n  3597: \n- 3598: \t\tif(fexpr instanceof VarExpr)\n- 3599: \t\t\t{\n- 3600: \t\t\tVar fvar = ((VarExpr)fexpr).var;\n- 3601: \t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n- 3602: \t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n- 3603: \t\t\t\t{\n- 3604: \t\t\t\tthis.isProtocol = true;\n- 3605: \t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n- 3606: \t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n- 3607: \t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n- 3608: \t\t\t\tif(this.protocolOn != null)\n- 3609: \t\t\t\t\t{\n- 3610: \t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n- 3611:                     Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n- 3612:                     if (mmapVal == null) {\n- 3613:                         throw new IllegalArgumentException(\n- 3614:                               \"No method of interface: \" + protocolOn.getName() +\n- 3615:                               \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n- 3616:                               \" (The protocol method may have been defined before and removed.)\");\n- 3617:                     }\n- 3618:                     String mname = munge(mmapVal.sym.toString());\n- 3619:  \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n- 3620: \t\t\t\t\tif(methods.size() != 1)\n- 3621: \t\t\t\t\t\tthrow new IllegalArgumentException(\n- 3622: \t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n- 3623: \t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n- 3624: \t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n- 3625: \t\t\t\t\t}\n- 3626: \t\t\t\t}\n- 3627: \t\t\t}\n- 3628: \t\t\n- 3629: \t\tif (tag != null) {\n- 3630: \t\t    this.tag = tag;\n- 3631: \t\t} else if (fexpr instanceof VarExpr) {\n- 3632: \t\t    Object arglists = RT.get(RT.meta(((VarExpr) fexpr).var), arglistsKey);\n- 3633: \t\t    Object sigTag = null;\n- 3634: \t\t    for(ISeq s = RT.seq(arglists); s != null; s = s.next()) {\n- 3635:                 APersistentVector sig = (APersistentVector) s.first();\n- 3636:                 int restOffset = sig.indexOf(_AMP_);\n- 3637:                 if (args.count() == sig.count() || (restOffset > -1 && args.count() >= restOffset)) {\n- 3638:                     sigTag = tagOf(sig);\n- 3639:                     break;\n- 3640:                 }\n- 3641:             }\n- 3642: \t\t    \n+ 3598: \tpublic InvokeExpr(String source, int line, int column, Symbol tag, Expr fexpr, IPersistentVector args, boolean tailPosition) {\n+ 3599: \t\tthis.source = source;\n+ 3600: \t\tthis.fexpr = fexpr;\n+ 3601: \t\tthis.args = args;\n+ 3602: \t\tthis.line = line;\n+ 3603: \t\tthis.column = column;\n+ 3604: \t\tthis.tailPosition = tailPosition;\n+ 3605: \n+ 3606: \t\tif(fexpr instanceof VarExpr)\n+ 3607: \t\t\t{\n+ 3608: \t\t\tVar fvar = ((VarExpr)fexpr).var;\n+ 3609: \t\t\tVar pvar =  (Var)RT.get(fvar.meta(), protocolKey);\n+ 3610: \t\t\tif(pvar != null && PROTOCOL_CALLSITES.isBound())\n+ 3611: \t\t\t\t{\n+ 3612: \t\t\t\tthis.isProtocol = true;\n+ 3613: \t\t\t\tthis.siteIndex = registerProtocolCallsite(((VarExpr)fexpr).var);\n+ 3614: \t\t\t\tObject pon = RT.get(pvar.get(), onKey);\n+ 3615: \t\t\t\tthis.protocolOn = HostExpr.maybeClass(pon,false);\n+ 3616: \t\t\t\tif(this.protocolOn != null)\n+ 3617: \t\t\t\t\t{\n+ 3618: \t\t\t\t\tIPersistentMap mmap = (IPersistentMap) RT.get(pvar.get(), methodMapKey);\n+ 3619:                     Keyword mmapVal = (Keyword) mmap.valAt(Keyword.intern(fvar.sym));\n+ 3620:                     if (mmapVal == null) {\n+ 3621:                         throw new IllegalArgumentException(\n+ 3622:                               \"No method of interface: \" + protocolOn.getName() +\n+ 3623:                               \" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym +\n+ 3624:                               \" (The protocol method may have been defined before and removed.)\");\n+ 3625:                     }\n+ 3626:                     String mname = munge(mmapVal.sym.toString());\n+ 3627:  \t\t\t\t\tList methods = Reflector.getMethods(protocolOn, args.count() - 1, mname, false);\n+ 3628: \t\t\t\t\tif(methods.size() != 1)\n+ 3629: \t\t\t\t\t\tthrow new IllegalArgumentException(\n+ 3630: \t\t\t\t\t\t\t\t\"No single method: \" + mname + \" of interface: \" + protocolOn.getName() +\n+ 3631: \t\t\t\t\t\t\t\t\" found for function: \" + fvar.sym + \" of protocol: \" + pvar.sym);\n+ 3632: \t\t\t\t\tthis.onMethod = (java.lang.reflect.Method) methods.get(0);\n+ 3633: \t\t\t\t\t}\n+ 3634: \t\t\t\t}\n+ 3635: \t\t\t}\n+ 3636: \t\t\n+ 3637: \t\tif (tag != null) {\n+ 3638: \t\t    this.tag = tag;\n+ 3639: \t\t} else if (fexpr instanceof VarExpr) {\n+ 3640:             Var v = ((VarExpr) fexpr).var;\n+ 3641: \t\t    Object arglists = RT.get(RT.meta(v), arglistsKey);\n+ 3642: \t\t    Object sigTag = sigTag(args.count(),v);\n  3643: \t\t    this.tag = sigTag == null ? ((VarExpr) fexpr).tag : sigTag;\n  3644: \t\t} else {\n  3645: \t\t    this.tag = null;\n  3646: \t\t}\n  3647: \t}\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/osmandapp/Osmand.git",
        "branch": "master",
        "commitId": "e95aa8ab32a0334b9c941799060fd601297d05e4",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\t\tIconsCache iconsCache = getMyApplication().getIconsCache();\n\t\tif (selectionMode) {\n\t\t\tCheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n\t\t\tFavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tch.setChecked(!ch.isChecked());\n\t\t\tif (ch.isChecked()) {\n\t\t\t\tfavoritesSelected.add(model);\n\t\t\t} else {\n\t\t\t\tfavoritesSelected.remove(model);\n\t\t\t}\n\t\t\tupdateSelectionMode(actionMode);\n\t\t} else {\n\t\t\tfinal FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tfinal OsmandSettings settings = getMyApplication().getSettings();\n\t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, \n\t\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()), settings.getLastKnownMapZoom(),\n\t\t\t\t\tgetActivity(), true, false);\n\n\t\t\tMenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n\t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\teditPoint(getActivity(), point, new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tfavouritesAdapter.synchronizeGroups();\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\titem = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n\t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tdeletePoint(point);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toptionsMenu.show();\n\t\t}\n\t\treturn true;\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\npublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n    IconsCache iconsCache = getMyApplication().getIconsCache();\n    if (selectionMode) {\n        CheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n        FavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n        ch.setChecked(!ch.isChecked());\n        if (ch.isChecked()) {\n            favoritesSelected.add(model);\n        } else {\n            favoritesSelected.remove(model);\n        }\n        updateSelectionMode(actionMode);\n    } else {\n        final FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n        final OsmandSettings settings = getMyApplication().getSettings();\n        LatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n        final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n        DirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, \n                new PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()), settings.getLastKnownMapZoom(),\n                getActivity(), true, false);\n\n        MenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n                .setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));\n        item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                editPoint(getActivity(), point, new Runnable() {\n                    public void run() {\n                        favouritesAdapter.synchronizeGroups();\t\t\n                    }\n                });\n                return true;\n            }\n        });\n\n        item = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n                .setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));\n        item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                deletePoint(point);\n                return true;\n            }\n        });\n\n        optionsMenu.show();\n    }\n    return true;\n}\n```\n\n### Refactored Code:\n```java\n@Override\npublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n    if (selectionMode) {\n        handleSelectionMode(v, groupPosition, childPosition);\n    } else {\n        handleNormalClick(v, groupPosition, childPosition);\n    }\n    return true;\n}\n\nprivate void handleSelectionMode(View v, int groupPosition, int childPosition) {\n    CheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n    FavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n    ch.setChecked(!ch.isChecked());\n    if (ch.isChecked()) {\n        favoritesSelected.add(model);\n    } else {\n        favoritesSelected.remove(model);\n    }\n    updateSelectionMode(actionMode);\n}\n\nprivate void handleNormalClick(View v, int groupPosition, int childPosition) {\n    final FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n    final OsmandSettings settings = getMyApplication().getSettings();\n    LatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n    final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n    DirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, \n            new PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()), settings.getLastKnownMapZoom(),\n            getActivity(), true, false);\n\n    addEditMenuItem(optionsMenu, point);\n    addDeleteMenuItem(optionsMenu, point);\n    \n    optionsMenu.show();\n}\n\nprivate void addEditMenuItem(PopupMenu optionsMenu, final FavouritePoint point) {\n    MenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n            .setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_edit_dark));\n    item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            editPoint(getActivity(), point, new Runnable() {\n                public void run() {\n                    favouritesAdapter.synchronizeGroups();\t\t\n                }\n            });\n            return true;\n        }\n    });\n}\n\nprivate void addDeleteMenuItem(PopupMenu optionsMenu, final FavouritePoint point) {\n    MenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n            .setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_delete_dark));\n    item.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n        @Override\n        public boolean onMenuItemClick(MenuItem item) {\n            deletePoint(point);\n            return true;\n        }\n    });\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: The original method was broken down into smaller methods:\n   - `handleSelectionMode`: Handles the logic for when the selection mode is active.\n   - `handleNormalClick`: Handles the logic for when a normal click occurs.\n   - `addEditMenuItem`: Adds the edit menu item to the popup menu.\n   - `addDeleteMenuItem`: Adds the delete menu item to the popup menu.\n\n2. **Improved Readability**: Each method now has a single responsibility, making the code easier to read and maintain.\n\n3. **Functionality Unchanged**: The refactored code maintains the same functionality as the original code.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\t\tIconsCache iconsCache = getMyApplication().getIconsCache();\n\t\tif (selectionMode) {\n\t\t\tCheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n\t\t\tFavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tch.setChecked(!ch.isChecked());\n\t\t\tif (ch.isChecked()) {\n\t\t\t\tfavoritesSelected.add(model);\n\t\t\t} else {\n\t\t\t\tfavoritesSelected.remove(model);\n\t\t\t}\n\t\t\tupdateSelectionMode(actionMode);\n\t\t} else {\n\t\t\tfinal FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tshowItemPopupOptionsMenu(point, v);\n\t\t}\n\t\treturn true;\n\t}\npublic void showItemPopupOptionsMenu(final FavouritePoint point, final View view) {\n\t\tfinal OsmandSettings settings = getMyApplication().getSettings();\n\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), view);\n\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point,\n\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()),\n\t\t\t\tsettings.getLastKnownMapZoom(),\n\t\t\t\tgetActivity(), true, false);\n\n\t\tMenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n\t\t\t\t.setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_edit_dark));\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\teditPoint(getActivity(), point, new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tfavouritesAdapter.synchronizeGroups();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\titem = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n\t\t\t\t.setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_delete_dark));\n\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t@Override\n\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\tdeletePoint(point);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\toptionsMenu.show();\n\t}",
        "diffSourceCode": "   171: \t@Override\n   172: \tpublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n   173: \t\tIconsCache iconsCache = getMyApplication().getIconsCache();\n   174: \t\tif (selectionMode) {\n   175: \t\t\tCheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n   176: \t\t\tFavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n   177: \t\t\tch.setChecked(!ch.isChecked());\n   178: \t\t\tif (ch.isChecked()) {\n   179: \t\t\t\tfavoritesSelected.add(model);\n   180: \t\t\t} else {\n   181: \t\t\t\tfavoritesSelected.remove(model);\n   182: \t\t\t}\n   183: \t\t\tupdateSelectionMode(actionMode);\n   184: \t\t} else {\n   185: \t\t\tfinal FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n-  186: \t\t\tfinal OsmandSettings settings = getMyApplication().getSettings();\n-  187: \t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n-  188: \t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n-  189: \t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, \n-  190: \t\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()), settings.getLastKnownMapZoom(),\n-  191: \t\t\t\t\tgetActivity(), true, false);\n-  192: \n-  193: \t\t\tMenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n-  194: \t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));\n-  195: \t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n-  196: \t\t\t\t@Override\n-  197: \t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n-  198: \t\t\t\t\teditPoint(getActivity(), point, new Runnable() {\n-  199: \t\t\t\t\t\tpublic void run() {\n-  200: \t\t\t\t\t\t\tfavouritesAdapter.synchronizeGroups();\t\t\n-  201: \t\t\t\t\t\t}\n-  202: \t\t\t\t\t});\n-  203: \t\t\t\t\treturn true;\n-  204: \t\t\t\t}\n-  205: \t\t\t});\n-  206: \n-  207: \t\t\titem = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n-  208: \t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));\n-  209: \t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n-  210: \t\t\t\t@Override\n-  211: \t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n-  212: \t\t\t\t\tdeletePoint(point);\n-  213: \n-  214: \t\t\t\t\treturn true;\n-  215: \t\t\t\t}\n-  216: \t\t\t});\n-  217: \n-  218: \t\t\toptionsMenu.show();\n-  219: \t\t}\n-  220: \t\treturn true;\n-  221: \t}\n-  878: \t\t\t\t\t}\n-  879: \t\t\t\t}\n-  880: \t\t\t\tresults.values = filter;\n-  881: \t\t\t\tresults.count = filter.size();\n-  882: \t\t\t}\n-  883: \t\t\treturn results;\n-  884: \t\t}\n-  885: \n-  886: \t\t@Override\n-  887: \t\tprotected void publishResults(CharSequence constraint, FilterResults results) {\n-  888: \t\t\tsynchronized (favouritesAdapter) {\n-  889: \t\t\t\tfavouritesAdapter.setFilterResults((Set<?>) results.values);\n-  890: \t\t\t\tfavouritesAdapter.synchronizeGroups();\n-  891: \t\t\t}\n-  892: \t\t\tfavouritesAdapter.notifyDataSetChanged();\n-  893: \t\t\tif(constraint != null && constraint.length() > 1) {\n-  894: \t\t\t\tcollapseTrees(5);\n-  895: \t\t\t}\n-  896: \t\t}\n-  897: \t}\n-  898: }\n+  186: \t\t\tshowItemPopupOptionsMenu(point, v);\n+  187: \t\t}\n+  188: \t\treturn true;\n+  189: \t}\n+  190: \n+  191: \tpublic static boolean editPoint(Context ctx, final FavouritePoint point, final Runnable callback) {\n+  192: \t\tOsmandApplication app = (OsmandApplication) ctx.getApplicationContext();\n+  193: \t\tBuilder builder = new AlertDialog.Builder(ctx);\n+  194: \t\tbuilder.setTitle(R.string.favourites_context_menu_edit);\n+  195: \t\tfinal View v = LayoutInflater.from(ctx).inflate(R.layout.favorite_edit_dialog,\n+  196: \t\t\t\tnull, false);\n+  197: \t\tfinal AutoCompleteTextView cat = (AutoCompleteTextView) v.findViewById(R.id.Category);\n+  198: \t\tfinal EditText editText = (EditText) v.findViewById(R.id.Name);\n+  199: \t\tfinal EditText editDescr = (EditText) v.findViewById(R.id.descr);\n+  200: \t\tbuilder.setView(v);\n+  201: \t\teditText.setText(point.getName());\n+  202: \t\teditDescr.setText(point.getDescription());\n+  203: \t\tcat.setText(point.getCategory());\n+  204: \t\tcat.setThreshold(1);\n+  205: \t\tfinal FavouritesDbHelper helper = app.getFavorites();\n+  206: \t\tList<FavoriteGroup> gs = helper.getFavoriteGroups();\n+  207: \t\tString[] list = new String[gs.size()];\n+  208: \t\tfor(int i = 0; i < list.length; i++) {\n+  209: \t\t\tlist[i] =gs.get(i).name;\n+  210: \t\t}\n+  211: \t\tcat.setAdapter(new ArrayAdapter<String>(ctx, R.layout.list_textview, list));\n+  212: \t\tbuilder.setNegativeButton(R.string.shared_string_cancel, null);\n+  213: \t\tbuilder.setPositiveButton(R.string.shared_string_apply, new DialogInterface.OnClickListener() {\n+  214: \t\t\t@Override\n+  215: \t\t\tpublic void onClick(DialogInterface dialog, int which) {\n+  216: \t\t\t\tboolean edited = helper.editFavouriteName(point, editText.getText().toString().trim(), cat.getText()\n+  217: \t\t\t\t\t\t.toString(), editDescr.getText().toString());\n+  218: \t\t\t\tif (edited && callback != null) {\n+  219: \t\t\t\t\tcallback.run();\n+  220: \t\t\t\t\t\n+  221: \t\t\t\t}\n+  878: \tpublic void showItemPopupOptionsMenu(final FavouritePoint point, final View view) {\n+  879: \t\tfinal OsmandSettings settings = getMyApplication().getSettings();\n+  880: \t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n+  881: \t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), view);\n+  882: \t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point,\n+  883: \t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()),\n+  884: \t\t\t\tsettings.getLastKnownMapZoom(),\n+  885: \t\t\t\tgetActivity(), true, false);\n+  886: \n+  887: \t\tMenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n+  888: \t\t\t\t.setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_edit_dark));\n+  889: \t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n+  890: \t\t\t@Override\n+  891: \t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n+  892: \t\t\t\teditPoint(getActivity(), point, new Runnable() {\n+  893: \t\t\t\t\tpublic void run() {\n+  894: \t\t\t\t\t\tfavouritesAdapter.synchronizeGroups();\n+  895: \t\t\t\t\t}\n+  896: \t\t\t\t});\n+  897: \t\t\t\treturn true;\n+  898: \t\t\t}\n+  899: \t\t});\n+  900: \n+  901: \t\titem = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n+  902: \t\t\t\t.setIcon(getMyApplication().getIconsCache().getContentIcon(R.drawable.ic_action_delete_dark));\n+  903: \t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n+  904: \t\t\t@Override\n+  905: \t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n+  906: \t\t\t\tdeletePoint(point);\n+  907: \n+  908: \t\t\t\treturn true;\n+  909: \t\t\t}\n+  910: \t\t});\n+  911: \n+  912: \t\toptionsMenu.show();\n+  913: \t}\n",
        "uniqueId": "e95aa8ab32a0334b9c941799060fd601297d05e4_171_221_878_913_171_189",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n @Override\n    public void actionPerformed( ActionEvent e )\n    {\n        JFileChooser jFileChooser = new JFileChooser();\n        jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        jFileChooser.setDialogTitle( \"Select database\" );\n        jFileChooser.setDialogType( CUSTOM_DIALOG );\n\n        while ( true )\n        {\n            int choice = jFileChooser.showOpenDialog( frame );\n\n            if ( choice != APPROVE_OPTION )\n            {\n                return;\n            }\n\n            File selectedFile = jFileChooser.getSelectedFile();\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n                return;\n            }\n            catch ( UnsuitableDirectoryException error )\n            {\n                int result = showWrappedConfirmDialog(\n                        frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n                if ( result == CANCEL_OPTION )\n                {\n                    return;\n                }\n            }\n        }\n    }\n SourceCodeAfterRefactoring:\n@Override\n    public void actionPerformed( ActionEvent e )\n    {\n        File selectedFile = null;\n        boolean cancelled = false;\n        boolean validLocation = false;\n        String os = System.getProperty( \"os.name\" );\n\n        while ( !validLocation && !cancelled )\n        {\n            if ( os.toLowerCase().contains( \"mac\" ) )\n            {\n                selectedFile = macFileSelection();\n            }\n            else\n            {\n                selectedFile = fileSelection();\n            }\n\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n\n                validLocation = true;\n\n                FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n                fileWriter.write( selectedFile.getAbsolutePath() );\n                fileWriter.flush();\n                fileWriter.close();\n            }\n            catch ( UnsuitableDirectoryException ude )\n            {\n                int choice = showWrappedConfirmDialog(\n                        frame,\n                        ude.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n\n                if ( choice == CANCEL_OPTION )\n                {\n                    cancelled = true;\n                }\n            }\n            catch ( IOException ioe )\n            {\n                System.out.println( \"Error saving DB location\" );\n                System.out.println( ioe );\n            }\n        }\n    }\nprivate File fileSelection()\n    {\n        File selectedFile = null;\n\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        fileChooser.setDialogTitle( \"Select database\" );\n        fileChooser.setDialogType( CUSTOM_DIALOG );\n\n        int choice = fileChooser.showOpenDialog( frame );\n\n        if ( choice == APPROVE_OPTION )\n        {\n            selectedFile = fileChooser.getSelectedFile();\n        }\n\n        return selectedFile;\n    }\n DiffSourceCode:\n-   50:     @Override\n-   51:     public void actionPerformed( ActionEvent e )\n-   52:     {\n-   53:         JFileChooser jFileChooser = new JFileChooser();\n-   54:         jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n-   55:         jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n-   56:         jFileChooser.setDialogTitle( \"Select database\" );\n-   57:         jFileChooser.setDialogType( CUSTOM_DIALOG );\n-   58: \n-   59:         while ( true )\n-   60:         {\n-   61:             int choice = jFileChooser.showOpenDialog( frame );\n-   62: \n-   63:             if ( choice != APPROVE_OPTION )\n+   50:         this.model = model;\n+   51:     }\n+   52: \n+   53:     @Override\n+   54:     public void actionPerformed( ActionEvent e )\n+   55:     {\n+   56:         File selectedFile = null;\n+   57:         boolean cancelled = false;\n+   58:         boolean validLocation = false;\n+   59:         String os = System.getProperty( \"os.name\" );\n+   60: \n+   61:         while ( !validLocation && !cancelled )\n+   62:         {\n+   63:             if ( os.toLowerCase().contains( \"mac\" ) )\n    64:             {\n-   65:                 return;\n+   65:                 selectedFile = macFileSelection();\n    66:             }\n-   67: \n-   68:             File selectedFile = jFileChooser.getSelectedFile();\n-   69:             try\n-   70:             {\n-   71:                 model.setDatabaseDirectory( selectedFile );\n-   72:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n-   73:                 return;\n-   74:             }\n-   75:             catch ( UnsuitableDirectoryException error )\n-   76:             {\n-   77:                 int result = showWrappedConfirmDialog(\n-   78:                         frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n-   79:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n-   80:                 if ( result == CANCEL_OPTION )\n-   81:                 {\n-   82:                     return;\n-   83:                 }\n-   84:             }\n-   85:         }\n-   86:     }\n-   87: }\n+   67:             else\n+   68:             {\n+   69:                 selectedFile = fileSelection();\n+   70:             }\n+   71: \n+   72:             try\n+   73:             {\n+   74:                 model.setDatabaseDirectory( selectedFile );\n+   75:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n+   76: \n+   77:                 validLocation = true;\n+   78: \n+   79:                 FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n+   80:                 fileWriter.write( selectedFile.getAbsolutePath() );\n+   81:                 fileWriter.flush();\n+   82:                 fileWriter.close();\n+   83:             }\n+   84:             catch ( UnsuitableDirectoryException ude )\n+   85:             {\n+   86:                 int choice = showWrappedConfirmDialog(\n+   87:                         frame,\n+   88:                         ude.getMessage() + \"\\nPlease choose a different folder.\",\n+   89:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n+   90: \n+   91:                 if ( choice == CANCEL_OPTION )\n+   92:                 {\n+   93:                     cancelled = true;\n+   94:                 }\n+   95:             }\n+   96:             catch ( IOException ioe )\n+   97:             {\n+   98:                 System.out.println( \"Error saving DB location\" );\n+   99:                 System.out.println( ioe );\n+  100:             }\n+  101:         }\n+  102:     }\n+  104:     private File fileSelection()\n+  105:     {\n+  106:         File selectedFile = null;\n+  107: \n+  108:         JFileChooser fileChooser = new JFileChooser();\n+  109:         fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n+  110:         fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n+  111:         fileChooser.setDialogTitle( \"Select database\" );\n+  112:         fileChooser.setDialogType( CUSTOM_DIALOG );\n+  113: \n+  114:         int choice = fileChooser.showOpenDialog( frame );\n+  115: \n+  116:         if ( choice == APPROVE_OPTION )\n+  117:         {\n+  118:             selectedFile = fileChooser.getSelectedFile();\n+  119:         }\n+  120: \n+  121:         return selectedFile;\n+  122:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic int getItemViewType(int position) {\n\t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t} else {\n\t\t\treturn SENT;\n\t\t}\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic int getItemViewType(int position) {\n\t\treturn this.getItemViewType(getItem(position));\n\t}\npublic int getItemViewType(Message message) {\n\t\tif (message.getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t}\n\n\t\treturn SENT;\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\nprivate int getMessageTextColor(Message message) {\n\t\tint type = this.getItemViewType(message);\n\n\t\tif (type == SENT) {\n\t\t\treturn activity.getResources().getColor(R.color.black87);\n\t\t} else if (type == RECEIVED) {\n\t\t\treturn activity.getResources().getColor(R.color.white);\n\t\t}\n\n\t\treturn activity.getPrimaryTextColor();\n\t}\n DiffSourceCode:\n-   84: \t@Override\n-   85: \tpublic int getItemViewType(int position) {\n-   86: \t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n-   87: \t\t\treturn STATUS;\n-   88: \t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n-   89: \t\t\treturn RECEIVED;\n-   90: \t\t} else {\n-   91: \t\t\treturn SENT;\n-   92: \t\t}\n-   93: \t}\n-   94: \n-   95: \tprivate void displayStatus(ViewHolder viewHolder, Message message) {\n-   96: \t\tString filesize = null;\n-   97: \t\tString info = null;\n-   99: \t\tif (viewHolder.indicatorReceived != null) {\n-  100: \t\t\tviewHolder.indicatorReceived.setVisibility(View.GONE);\n-  101: \t\t}\n-  102: \t\tboolean multiReceived = message.getConversation().getMode() == Conversation.MODE_MULTI\n-  103: \t\t\t&& message.getMergedStatus() <= Message.STATUS_RECEIVED;\n-  104: \t\tif (message.getType() == Message.TYPE_IMAGE || message.getType() == Message.TYPE_FILE || message.getTransferable() != null) {\n-  105: \t\t\tFileParams params = message.getFileParams();\n-  106: \t\t\tif (params.size > (1.5 * 1024 * 1024)) {\n-  107: \t\t\t\tfilesize = params.size / (1024 * 1024)+ \" MiB\";\n-  108: \t\t\t} else if (params.size > 0) {\n-  109: \t\t\t\tfilesize = params.size / 1024 + \" KiB\";\n-  239: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n-  240: \t\tif (viewHolder.download_button != null) {\n-  241: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n-  242: \t\t}\n-  243: \t\tviewHolder.image.setVisibility(View.GONE);\n-  244: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n-  245: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n-  246: \t\tif (message.getBody() != null) {\n-  247: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n-  248: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n-  249: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n-  250: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n-  251: \t\t\twhile(i >= 0) {\n-  252: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n-  253: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  254: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n-  255: \t\t\t}\n-  256: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n-  257: \t\t\t\tif (message.hasMeCommand()) {\n-  258: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n-  259: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n-  260: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  261: \t\t\t\t\tviewHolder.messageBody.setText(span);\n-  262: \t\t\t\t} else {\n-  263: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n-  264: \t\t\t\t}\n-  265: \t\t\t} else {\n-  266: \t\t\t\tString privateMarker;\n-  267: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n-  268: \t\t\t\t\tprivateMarker = activity\n-  269: \t\t\t\t\t\t.getString(R.string.private_message);\n-  270: \t\t\t\t} else {\n-  271: \t\t\t\t\tfinal String to;\n-  272: \t\t\t\t\tif (message.getCounterpart() != null) {\n-  273: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n-  274: \t\t\t\t\t} else {\n-  275: \t\t\t\t\t\tto = \"\";\n-  276: \t\t\t\t\t}\n-  277: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n-  278: \t\t\t\t}\n-  279: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n-  280: \t\t\t\t\t\t+ formattedBody);\n-  281: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n-  282: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n-  283: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  284: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n-  285: \t\t\t\t\t\tprivateMarker.length(),\n-  286: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  287: \t\t\t\tif (message.hasMeCommand()) {\n-  288: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n-  289: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n-  290: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  291: \t\t\t\t}\n-  292: \t\t\t\tviewHolder.messageBody.setText(span);\n-  293: \t\t\t}\n-  294: \t\t} else {\n-  295: \t\t\tviewHolder.messageBody.setText(\"\");\n-  296: \t\t}\n-  297: \t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n-  298: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n-  299: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n-  300: \t}\n-  301: \n-  302: \tprivate void displayDownloadableMessage(ViewHolder viewHolder,\n-  303: \t\t\tfinal Message message, String text) {\n-  304: \t\tviewHolder.image.setVisibility(View.GONE);\n-  305: \t\tviewHolder.messageBody.setVisibility(View.GONE);\n-  306: \t\tviewHolder.download_button.setVisibility(View.VISIBLE);\n-  307: \t\tviewHolder.download_button.setText(text);\n-  308: \t\tviewHolder.download_button.setOnClickListener(new OnClickListener() {\n-  309: \n-  310: \t\t\t@Override\n-  311: \t\t\tpublic void onClick(View v) {\n-  312: \t\t\t\tstartDownloadable(message);\n-  313: \t\t\t}\n-  314: \t\t});\n-  315: \t\tviewHolder.download_button.setOnLongClickListener(openContextMenu);\n+   84: \tpublic int getItemViewType(Message message) {\n+   85: \t\tif (message.getType() == Message.TYPE_STATUS) {\n+   86: \t\t\treturn STATUS;\n+   87: \t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n+   88: \t\t\treturn RECEIVED;\n+   89: \t\t}\n+   90: \n+   91: \t\treturn SENT;\n+   92: \t}\n+   93: \n+   94: \t@Override\n+   95: \tpublic int getItemViewType(int position) {\n+   96: \t\treturn this.getItemViewType(getItem(position));\n+   97: \t}\n+   99: \tprivate int getMessageTextColor(Message message) {\n+  100: \t\tint type = this.getItemViewType(message);\n+  101: \n+  102: \t\tif (type == SENT) {\n+  103: \t\t\treturn activity.getResources().getColor(R.color.black87);\n+  104: \t\t} else if (type == RECEIVED) {\n+  105: \t\t\treturn activity.getResources().getColor(R.color.white);\n+  106: \t\t}\n+  107: \n+  108: \t\treturn activity.getPrimaryTextColor();\n+  109: \t}\n+  239: \t\tviewHolder.messageBody.setTextIsSelectable(false);\n+  240: \t}\n+  241: \n+  242: \tprivate void displayHeartMessage(final ViewHolder viewHolder, final String body) {\n+  243: \t\tif (viewHolder.download_button != null) {\n+  244: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  245: \t\t}\n+  246: \t\tviewHolder.image.setVisibility(View.GONE);\n+  247: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  248: \t\tviewHolder.messageBody.setIncludeFontPadding(false);\n+  249: \t\tSpannable span = new SpannableString(body);\n+  250: \t\tspan.setSpan(new RelativeSizeSpan(4.0f), 0, body.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  251: \t\tspan.setSpan(new ForegroundColorSpan(activity.getWarningTextColor()), 0, body.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  252: \t\tviewHolder.messageBody.setText(span);\n+  253: \t}\n+  254: \n+  255: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n+  256: \t\tif (viewHolder.download_button != null) {\n+  257: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  258: \t\t}\n+  259: \t\tviewHolder.image.setVisibility(View.GONE);\n+  260: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  261: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n+  262: \t\tif (message.getBody() != null) {\n+  263: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n+  264: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n+  265: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n+  266: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n+  267: \t\t\twhile(i >= 0) {\n+  268: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n+  269: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  270: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n+  271: \t\t\t}\n+  272: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n+  273: \t\t\t\tif (message.hasMeCommand()) {\n+  274: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n+  275: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n+  276: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  277: \t\t\t\t\tviewHolder.messageBody.setText(span);\n+  278: \t\t\t\t} else {\n+  279: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n+  280: \t\t\t\t}\n+  281: \t\t\t} else {\n+  282: \t\t\t\tString privateMarker;\n+  283: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n+  284: \t\t\t\t\tprivateMarker = activity\n+  285: \t\t\t\t\t\t.getString(R.string.private_message);\n+  286: \t\t\t\t} else {\n+  287: \t\t\t\t\tfinal String to;\n+  288: \t\t\t\t\tif (message.getCounterpart() != null) {\n+  289: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n+  290: \t\t\t\t\t} else {\n+  291: \t\t\t\t\t\tto = \"\";\n+  292: \t\t\t\t\t}\n+  293: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n+  294: \t\t\t\t}\n+  295: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n+  296: \t\t\t\t\t\t+ formattedBody);\n+  297: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n+  298: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n+  299: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  300: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n+  301: \t\t\t\t\t\tprivateMarker.length(),\n+  302: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  303: \t\t\t\tif (message.hasMeCommand()) {\n+  304: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n+  305: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n+  306: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  307: \t\t\t\t}\n+  308: \t\t\t\tviewHolder.messageBody.setText(span);\n+  309: \t\t\t}\n+  310: \t\t} else {\n+  311: \t\t\tviewHolder.messageBody.setText(\"\");\n+  312: \t\t}\n+  313: \t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n+  314: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n+  315: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n   316: \t}\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static synchronized List<MenuNode> topLevelNodes() {\n\t\tif (ourNodes == null) {\n\t\t\tourNodes = new ArrayList<MenuNode>();\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n\t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n\t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t}\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n\t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n\t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n\t\t\t}\n\t\t\tourNodes.add(orientations);\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n\t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n\t\t}\n\t\treturn ourNodes;\n\t}\n SourceCodeAfterRefactoring:\npublic static synchronized List<MenuNode> topLevelNodes() {\n\t\tfinal List<MenuNode> allNodes = allTopLevelNodes();\n\t\tfinal List<MenuNode> activeNodes = new ArrayList<MenuNode>(allNodes.size());\n\t\tfor (MenuNode node : allNodes) {\n\t\t\tif (nodeOption(code(node)).getValue()) {\n\t\t\t\tactiveNodes.add(node);\n\t\t\t}\n\t\t}\n\t\treturn activeNodes;\n\t}\nprivate static synchronized List<MenuNode> allTopLevelNodes() {\n\t\tif (ourNodes == null) {\n\t\t\tourNodes = new ArrayList<MenuNode>();\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n\t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n\t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t}\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n\t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n\t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n\t\t\t}\n\t\t\tourNodes.add(orientations);\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n\t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n\t\t}\n\t\treturn ourNodes;\n\t}\n DiffSourceCode:\n-   35: \tpublic static synchronized List<MenuNode> topLevelNodes() {\n-   36: \t\tif (ourNodes == null) {\n-   37: \t\t\tourNodes = new ArrayList<MenuNode>();\n-   38: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n-   39: \t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n-   40: \t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n-   41: \t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n-   42: \t\t\t}\n-   43: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n-   44: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n-   45: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n-   46: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n-   47: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n-   48: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n-   49: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n-   50: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n-   51: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n-   52: \t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n-   53: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n-   54: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n-   55: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n-   56: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n-   57: \t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n-   58: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n-   59: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n-   60: \t\t\t}\n-   61: \t\t\tourNodes.add(orientations);\n-   62: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n-   63: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n-   64: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n-   65: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n-   66: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n-   67: \t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n-   68: \t\t}\n-   69: \t\treturn ourNodes;\n-   70: \t}\n-   71: }\n+   35: \tprivate static final Map<String,ZLBooleanOption> ourNodeOptions =\n+   36: \t\tnew HashMap<String,ZLBooleanOption>();\n+   37: \n+   38: \tprivate static synchronized List<MenuNode> allTopLevelNodes() {\n+   39: \t\tif (ourNodes == null) {\n+   40: \t\t\tourNodes = new ArrayList<MenuNode>();\n+   41: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n+   42: \t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n+   43: \t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n+   44: \t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n+   45: \t\t\t}\n+   46: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n+   47: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n+   48: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n+   49: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n+   50: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n+   51: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n+   52: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n+   53: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n+   54: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n+   55: \t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n+   56: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n+   57: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n+   58: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n+   59: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n+   60: \t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n+   61: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n+   62: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n+   63: \t\t\t}\n+   64: \t\t\tourNodes.add(orientations);\n+   65: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n+   66: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n+   67: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n+   68: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n+   69: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n+   70: \t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n+   71: \t\t}\n+   72: \t\treturn ourNodes;\n+   73: \t}\n+   95: \tpublic static synchronized List<MenuNode> topLevelNodes() {\n+   96: \t\tfinal List<MenuNode> allNodes = allTopLevelNodes();\n+   97: \t\tfinal List<MenuNode> activeNodes = new ArrayList<MenuNode>(allNodes.size());\n+   98: \t\tfor (MenuNode node : allNodes) {\n+   99: \t\t\tif (nodeOption(code(node)).getValue()) {\n+  100: \t\t\t\tactiveNodes.add(node);\n+  101: \t\t\t}\n+  102: \t\t}\n+  103: \t\treturn activeNodes;\n+  104: \t}\n\n",
        "contextDescription": "PackageName: net.osmand.plus.activities\nClassName: net.osmand.plus.activities.FavoritesTreeFragment\nMethodName: net.osmand.plus.activities.FavoritesTreeFragment#onChildClick\n ClassSignature: public class FavoritesTreeFragment extends OsmandExpandableListFragment \nInvokedMethod: methodSignature: net.osmand.plus.activities.FavoritesListFragment.FavouritesAdapter#getName\n methodBody: public String getName(FavouritePoint model) {\nreturn model.getName();\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#deletePoint\n methodBody: private boolean deletePoint(final FavouritePoint point) {\nfinal Resources resources=this.getResources();\nBuilder builder=new AlertDialog.Builder(getActivity());\nbuilder.setMessage(getString(R.string.favourites_remove_dialog_msg,point.getName()));\nbuilder.setNegativeButton(R.string.shared_string_no,null);\nbuilder.setPositiveButton(R.string.shared_string_yes,new DialogInterface.OnClickListener(){\n  @Override public void onClick(  DialogInterface dialog,  int which){\n    boolean deleted=helper.deleteFavourite(point);\n    if (deleted) {\n      AccessibleToast.makeText(getActivity(),MessageFormat.format(resources.getString(R.string.favourites_remove_dialog_success),point.getName()),Toast.LENGTH_SHORT).show();\n      favouritesAdapter.synchronizeGroups();\n    }\n  }\n}\n);\nbuilder.create().show();\nreturn true;\n}\nmethodSignature: net.osmand.plus.activities.FavoritesListFragment#getMyApplication\n methodBody: public OsmandApplication getMyApplication() {\nreturn (OsmandApplication)getActivity().getApplication();\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#updateSelectionMode\n methodBody: private void updateSelectionMode(ActionMode m) {\nif(favoritesSelected.size() > 0){m.setTitle(favoritesSelected.size() + \" \" + getMyApplication().getString(R.string.shared_string_selected_lowercase));\n}{m.setTitle(\"\");\n}}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment.FavouritesAdapter#getChild\n methodBody: public FavouritePoint getChild(int groupPosition, int childPosition) {\nreturn favoriteGroups.get(groups.get(groupPosition)).get(childPosition);\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#editPoint\n methodBody: public static boolean editPoint(Context ctx, final FavouritePoint point, final Runnable callback) {\nOsmandApplication app=(OsmandApplication)ctx.getApplicationContext();\nBuilder builder=new AlertDialog.Builder(ctx);\nbuilder.setTitle(R.string.favourites_context_menu_edit);\nfinal View v=LayoutInflater.from(ctx).inflate(R.layout.favorite_edit_dialog,null,false);\nfinal AutoCompleteTextView cat=(AutoCompleteTextView)v.findViewById(R.id.Category);\nfinal EditText editText=(EditText)v.findViewById(R.id.Name);\nfinal EditText editDescr=(EditText)v.findViewById(R.id.descr);\nbuilder.setView(v);\neditText.setText(point.getName());\neditDescr.setText(point.getDescription());\ncat.setText(point.getCategory());\ncat.setThreshold(1);\nfinal FavouritesDbHelper helper=app.getFavorites();\nList<FavoriteGroup> gs=helper.getFavoriteGroups();\nString[] list=new String[gs.size()];\nfor(int i=0; i < list.length; i++){list[i]=gs.get(i).name;\n}cat.setAdapter(new ArrayAdapter<String>(ctx,R.layout.list_textview,list));\nbuilder.setNegativeButton(R.string.shared_string_cancel,null);\nbuilder.setPositiveButton(R.string.shared_string_apply,new DialogInterface.OnClickListener(){\n  @Override public void onClick(  DialogInterface dialog,  int which){\n    boolean edited=helper.editFavouriteName(point,editText.getText().toString().trim(),cat.getText().toString(),editDescr.getText().toString());\n    if (edited && callback != null) {\n      callback.run();\n    }\n  }\n}\n);\nbuilder.create().show();\neditText.requestFocus();\nreturn true;\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n@Override\n\tpublic boolean onChildClick(ExpandableListView parent, View v, int groupPosition, int childPosition, long id) {\n\t\tIconsCache iconsCache = getMyApplication().getIconsCache();\n\t\tif (selectionMode) {\n\t\t\tCheckBox ch = (CheckBox) v.findViewById(R.id.check_item);\n\t\t\tFavouritePoint model = favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tch.setChecked(!ch.isChecked());\n\t\t\tif (ch.isChecked()) {\n\t\t\t\tfavoritesSelected.add(model);\n\t\t\t} else {\n\t\t\t\tfavoritesSelected.remove(model);\n\t\t\t}\n\t\t\tupdateSelectionMode(actionMode);\n\t\t} else {\n\t\t\tfinal FavouritePoint point = (FavouritePoint) favouritesAdapter.getChild(groupPosition, childPosition);\n\t\t\tfinal OsmandSettings settings = getMyApplication().getSettings();\n\t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, \n\t\t\t\t\tnew PointDescription(PointDescription.POINT_TYPE_FAVORITE, point.getName()), settings.getLastKnownMapZoom(),\n\t\t\t\t\tgetActivity(), true, false);\n\n\t\t\tMenuItem item = optionsMenu.getMenu().add(R.string.favourites_context_menu_edit)\n\t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_edit_dark));\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\teditPoint(getActivity(), point, new Runnable() {\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tfavouritesAdapter.synchronizeGroups();\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\titem = optionsMenu.getMenu().add(R.string.favourites_context_menu_delete)\n\t\t\t\t\t.setIcon(iconsCache.getContentIcon(R.drawable.ic_action_delete_dark));\n\t\t\titem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean onMenuItemClick(MenuItem item) {\n\t\t\t\t\tdeletePoint(point);\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toptionsMenu.show();\n\t\t}\n\t\treturn true;\n\t}\n\nThe context of the source code is as follows:\nPackageName: net.osmand.plus.activities\nClassName: net.osmand.plus.activities.FavoritesTreeFragment\nMethodName: net.osmand.plus.activities.FavoritesTreeFragment#onChildClick\n ClassSignature: public class FavoritesTreeFragment extends OsmandExpandableListFragment \nInvokedMethod: methodSignature: net.osmand.plus.activities.FavoritesListFragment.FavouritesAdapter#getName\n methodBody: public String getName(FavouritePoint model) {\nreturn model.getName();\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#deletePoint\n methodBody: private boolean deletePoint(final FavouritePoint point) {\nfinal Resources resources=this.getResources();\nBuilder builder=new AlertDialog.Builder(getActivity());\nbuilder.setMessage(getString(R.string.favourites_remove_dialog_msg,point.getName()));\nbuilder.setNegativeButton(R.string.shared_string_no,null);\nbuilder.setPositiveButton(R.string.shared_string_yes,new DialogInterface.OnClickListener(){\n  @Override public void onClick(  DialogInterface dialog,  int which){\n    boolean deleted=helper.deleteFavourite(point);\n    if (deleted) {\n      AccessibleToast.makeText(getActivity(),MessageFormat.format(resources.getString(R.string.favourites_remove_dialog_success),point.getName()),Toast.LENGTH_SHORT).show();\n      favouritesAdapter.synchronizeGroups();\n    }\n  }\n}\n);\nbuilder.create().show();\nreturn true;\n}\nmethodSignature: net.osmand.plus.activities.FavoritesListFragment#getMyApplication\n methodBody: public OsmandApplication getMyApplication() {\nreturn (OsmandApplication)getActivity().getApplication();\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#updateSelectionMode\n methodBody: private void updateSelectionMode(ActionMode m) {\nif(favoritesSelected.size() > 0){m.setTitle(favoritesSelected.size() + \" \" + getMyApplication().getString(R.string.shared_string_selected_lowercase));\n}{m.setTitle(\"\");\n}}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment.FavouritesAdapter#getChild\n methodBody: public FavouritePoint getChild(int groupPosition, int childPosition) {\nreturn favoriteGroups.get(groups.get(groupPosition)).get(childPosition);\n}\nmethodSignature: net.osmand.plus.activities.FavoritesTreeFragment#editPoint\n methodBody: public static boolean editPoint(Context ctx, final FavouritePoint point, final Runnable callback) {\nOsmandApplication app=(OsmandApplication)ctx.getApplicationContext();\nBuilder builder=new AlertDialog.Builder(ctx);\nbuilder.setTitle(R.string.favourites_context_menu_edit);\nfinal View v=LayoutInflater.from(ctx).inflate(R.layout.favorite_edit_dialog,null,false);\nfinal AutoCompleteTextView cat=(AutoCompleteTextView)v.findViewById(R.id.Category);\nfinal EditText editText=(EditText)v.findViewById(R.id.Name);\nfinal EditText editDescr=(EditText)v.findViewById(R.id.descr);\nbuilder.setView(v);\neditText.setText(point.getName());\neditDescr.setText(point.getDescription());\ncat.setText(point.getCategory());\ncat.setThreshold(1);\nfinal FavouritesDbHelper helper=app.getFavorites();\nList<FavoriteGroup> gs=helper.getFavoriteGroups();\nString[] list=new String[gs.size()];\nfor(int i=0; i < list.length; i++){list[i]=gs.get(i).name;\n}cat.setAdapter(new ArrayAdapter<String>(ctx,R.layout.list_textview,list));\nbuilder.setNegativeButton(R.string.shared_string_cancel,null);\nbuilder.setPositiveButton(R.string.shared_string_apply,new DialogInterface.OnClickListener(){\n  @Override public void onClick(  DialogInterface dialog,  int which){\n    boolean edited=helper.editFavouriteName(point,editText.getText().toString().trim(),cat.getText().toString(),editDescr.getText().toString());\n    if (edited && callback != null) {\n      callback.run();\n    }\n  }\n}\n);\nbuilder.create().show();\neditText.requestFocus();\nreturn true;\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n @Override\n    public void actionPerformed( ActionEvent e )\n    {\n        JFileChooser jFileChooser = new JFileChooser();\n        jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        jFileChooser.setDialogTitle( \"Select database\" );\n        jFileChooser.setDialogType( CUSTOM_DIALOG );\n\n        while ( true )\n        {\n            int choice = jFileChooser.showOpenDialog( frame );\n\n            if ( choice != APPROVE_OPTION )\n            {\n                return;\n            }\n\n            File selectedFile = jFileChooser.getSelectedFile();\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n                return;\n            }\n            catch ( UnsuitableDirectoryException error )\n            {\n                int result = showWrappedConfirmDialog(\n                        frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n                if ( result == CANCEL_OPTION )\n                {\n                    return;\n                }\n            }\n        }\n    }\n SourceCodeAfterRefactoring:\n@Override\n    public void actionPerformed( ActionEvent e )\n    {\n        File selectedFile = null;\n        boolean cancelled = false;\n        boolean validLocation = false;\n        String os = System.getProperty( \"os.name\" );\n\n        while ( !validLocation && !cancelled )\n        {\n            if ( os.toLowerCase().contains( \"mac\" ) )\n            {\n                selectedFile = macFileSelection();\n            }\n            else\n            {\n                selectedFile = fileSelection();\n            }\n\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n\n                validLocation = true;\n\n                FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n                fileWriter.write( selectedFile.getAbsolutePath() );\n                fileWriter.flush();\n                fileWriter.close();\n            }\n            catch ( UnsuitableDirectoryException ude )\n            {\n                int choice = showWrappedConfirmDialog(\n                        frame,\n                        ude.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n\n                if ( choice == CANCEL_OPTION )\n                {\n                    cancelled = true;\n                }\n            }\n            catch ( IOException ioe )\n            {\n                System.out.println( \"Error saving DB location\" );\n                System.out.println( ioe );\n            }\n        }\n    }\nprivate File fileSelection()\n    {\n        File selectedFile = null;\n\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        fileChooser.setDialogTitle( \"Select database\" );\n        fileChooser.setDialogType( CUSTOM_DIALOG );\n\n        int choice = fileChooser.showOpenDialog( frame );\n\n        if ( choice == APPROVE_OPTION )\n        {\n            selectedFile = fileChooser.getSelectedFile();\n        }\n\n        return selectedFile;\n    }\n DiffSourceCode:\n-   50:     @Override\n-   51:     public void actionPerformed( ActionEvent e )\n-   52:     {\n-   53:         JFileChooser jFileChooser = new JFileChooser();\n-   54:         jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n-   55:         jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n-   56:         jFileChooser.setDialogTitle( \"Select database\" );\n-   57:         jFileChooser.setDialogType( CUSTOM_DIALOG );\n-   58: \n-   59:         while ( true )\n-   60:         {\n-   61:             int choice = jFileChooser.showOpenDialog( frame );\n-   62: \n-   63:             if ( choice != APPROVE_OPTION )\n+   50:         this.model = model;\n+   51:     }\n+   52: \n+   53:     @Override\n+   54:     public void actionPerformed( ActionEvent e )\n+   55:     {\n+   56:         File selectedFile = null;\n+   57:         boolean cancelled = false;\n+   58:         boolean validLocation = false;\n+   59:         String os = System.getProperty( \"os.name\" );\n+   60: \n+   61:         while ( !validLocation && !cancelled )\n+   62:         {\n+   63:             if ( os.toLowerCase().contains( \"mac\" ) )\n    64:             {\n-   65:                 return;\n+   65:                 selectedFile = macFileSelection();\n    66:             }\n-   67: \n-   68:             File selectedFile = jFileChooser.getSelectedFile();\n-   69:             try\n-   70:             {\n-   71:                 model.setDatabaseDirectory( selectedFile );\n-   72:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n-   73:                 return;\n-   74:             }\n-   75:             catch ( UnsuitableDirectoryException error )\n-   76:             {\n-   77:                 int result = showWrappedConfirmDialog(\n-   78:                         frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n-   79:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n-   80:                 if ( result == CANCEL_OPTION )\n-   81:                 {\n-   82:                     return;\n-   83:                 }\n-   84:             }\n-   85:         }\n-   86:     }\n-   87: }\n+   67:             else\n+   68:             {\n+   69:                 selectedFile = fileSelection();\n+   70:             }\n+   71: \n+   72:             try\n+   73:             {\n+   74:                 model.setDatabaseDirectory( selectedFile );\n+   75:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n+   76: \n+   77:                 validLocation = true;\n+   78: \n+   79:                 FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n+   80:                 fileWriter.write( selectedFile.getAbsolutePath() );\n+   81:                 fileWriter.flush();\n+   82:                 fileWriter.close();\n+   83:             }\n+   84:             catch ( UnsuitableDirectoryException ude )\n+   85:             {\n+   86:                 int choice = showWrappedConfirmDialog(\n+   87:                         frame,\n+   88:                         ude.getMessage() + \"\\nPlease choose a different folder.\",\n+   89:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n+   90: \n+   91:                 if ( choice == CANCEL_OPTION )\n+   92:                 {\n+   93:                     cancelled = true;\n+   94:                 }\n+   95:             }\n+   96:             catch ( IOException ioe )\n+   97:             {\n+   98:                 System.out.println( \"Error saving DB location\" );\n+   99:                 System.out.println( ioe );\n+  100:             }\n+  101:         }\n+  102:     }\n+  104:     private File fileSelection()\n+  105:     {\n+  106:         File selectedFile = null;\n+  107: \n+  108:         JFileChooser fileChooser = new JFileChooser();\n+  109:         fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n+  110:         fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n+  111:         fileChooser.setDialogTitle( \"Select database\" );\n+  112:         fileChooser.setDialogType( CUSTOM_DIALOG );\n+  113: \n+  114:         int choice = fileChooser.showOpenDialog( frame );\n+  115: \n+  116:         if ( choice == APPROVE_OPTION )\n+  117:         {\n+  118:             selectedFile = fileChooser.getSelectedFile();\n+  119:         }\n+  120: \n+  121:         return selectedFile;\n+  122:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic int getItemViewType(int position) {\n\t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t} else {\n\t\t\treturn SENT;\n\t\t}\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic int getItemViewType(int position) {\n\t\treturn this.getItemViewType(getItem(position));\n\t}\npublic int getItemViewType(Message message) {\n\t\tif (message.getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t}\n\n\t\treturn SENT;\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\nprivate int getMessageTextColor(Message message) {\n\t\tint type = this.getItemViewType(message);\n\n\t\tif (type == SENT) {\n\t\t\treturn activity.getResources().getColor(R.color.black87);\n\t\t} else if (type == RECEIVED) {\n\t\t\treturn activity.getResources().getColor(R.color.white);\n\t\t}\n\n\t\treturn activity.getPrimaryTextColor();\n\t}\n DiffSourceCode:\n-   84: \t@Override\n-   85: \tpublic int getItemViewType(int position) {\n-   86: \t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n-   87: \t\t\treturn STATUS;\n-   88: \t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n-   89: \t\t\treturn RECEIVED;\n-   90: \t\t} else {\n-   91: \t\t\treturn SENT;\n-   92: \t\t}\n-   93: \t}\n-   94: \n-   95: \tprivate void displayStatus(ViewHolder viewHolder, Message message) {\n-   96: \t\tString filesize = null;\n-   97: \t\tString info = null;\n-   99: \t\tif (viewHolder.indicatorReceived != null) {\n-  100: \t\t\tviewHolder.indicatorReceived.setVisibility(View.GONE);\n-  101: \t\t}\n-  102: \t\tboolean multiReceived = message.getConversation().getMode() == Conversation.MODE_MULTI\n-  103: \t\t\t&& message.getMergedStatus() <= Message.STATUS_RECEIVED;\n-  104: \t\tif (message.getType() == Message.TYPE_IMAGE || message.getType() == Message.TYPE_FILE || message.getTransferable() != null) {\n-  105: \t\t\tFileParams params = message.getFileParams();\n-  106: \t\t\tif (params.size > (1.5 * 1024 * 1024)) {\n-  107: \t\t\t\tfilesize = params.size / (1024 * 1024)+ \" MiB\";\n-  108: \t\t\t} else if (params.size > 0) {\n-  109: \t\t\t\tfilesize = params.size / 1024 + \" KiB\";\n-  239: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n-  240: \t\tif (viewHolder.download_button != null) {\n-  241: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n-  242: \t\t}\n-  243: \t\tviewHolder.image.setVisibility(View.GONE);\n-  244: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n-  245: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n-  246: \t\tif (message.getBody() != null) {\n-  247: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n-  248: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n-  249: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n-  250: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n-  251: \t\t\twhile(i >= 0) {\n-  252: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n-  253: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  254: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n-  255: \t\t\t}\n-  256: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n-  257: \t\t\t\tif (message.hasMeCommand()) {\n-  258: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n-  259: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n-  260: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  261: \t\t\t\t\tviewHolder.messageBody.setText(span);\n-  262: \t\t\t\t} else {\n-  263: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n-  264: \t\t\t\t}\n-  265: \t\t\t} else {\n-  266: \t\t\t\tString privateMarker;\n-  267: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n-  268: \t\t\t\t\tprivateMarker = activity\n-  269: \t\t\t\t\t\t.getString(R.string.private_message);\n-  270: \t\t\t\t} else {\n-  271: \t\t\t\t\tfinal String to;\n-  272: \t\t\t\t\tif (message.getCounterpart() != null) {\n-  273: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n-  274: \t\t\t\t\t} else {\n-  275: \t\t\t\t\t\tto = \"\";\n-  276: \t\t\t\t\t}\n-  277: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n-  278: \t\t\t\t}\n-  279: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n-  280: \t\t\t\t\t\t+ formattedBody);\n-  281: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n-  282: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n-  283: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  284: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n-  285: \t\t\t\t\t\tprivateMarker.length(),\n-  286: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  287: \t\t\t\tif (message.hasMeCommand()) {\n-  288: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n-  289: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n-  290: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  291: \t\t\t\t}\n-  292: \t\t\t\tviewHolder.messageBody.setText(span);\n-  293: \t\t\t}\n-  294: \t\t} else {\n-  295: \t\t\tviewHolder.messageBody.setText(\"\");\n-  296: \t\t}\n-  297: \t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n-  298: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n-  299: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n-  300: \t}\n-  301: \n-  302: \tprivate void displayDownloadableMessage(ViewHolder viewHolder,\n-  303: \t\t\tfinal Message message, String text) {\n-  304: \t\tviewHolder.image.setVisibility(View.GONE);\n-  305: \t\tviewHolder.messageBody.setVisibility(View.GONE);\n-  306: \t\tviewHolder.download_button.setVisibility(View.VISIBLE);\n-  307: \t\tviewHolder.download_button.setText(text);\n-  308: \t\tviewHolder.download_button.setOnClickListener(new OnClickListener() {\n-  309: \n-  310: \t\t\t@Override\n-  311: \t\t\tpublic void onClick(View v) {\n-  312: \t\t\t\tstartDownloadable(message);\n-  313: \t\t\t}\n-  314: \t\t});\n-  315: \t\tviewHolder.download_button.setOnLongClickListener(openContextMenu);\n+   84: \tpublic int getItemViewType(Message message) {\n+   85: \t\tif (message.getType() == Message.TYPE_STATUS) {\n+   86: \t\t\treturn STATUS;\n+   87: \t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n+   88: \t\t\treturn RECEIVED;\n+   89: \t\t}\n+   90: \n+   91: \t\treturn SENT;\n+   92: \t}\n+   93: \n+   94: \t@Override\n+   95: \tpublic int getItemViewType(int position) {\n+   96: \t\treturn this.getItemViewType(getItem(position));\n+   97: \t}\n+   99: \tprivate int getMessageTextColor(Message message) {\n+  100: \t\tint type = this.getItemViewType(message);\n+  101: \n+  102: \t\tif (type == SENT) {\n+  103: \t\t\treturn activity.getResources().getColor(R.color.black87);\n+  104: \t\t} else if (type == RECEIVED) {\n+  105: \t\t\treturn activity.getResources().getColor(R.color.white);\n+  106: \t\t}\n+  107: \n+  108: \t\treturn activity.getPrimaryTextColor();\n+  109: \t}\n+  239: \t\tviewHolder.messageBody.setTextIsSelectable(false);\n+  240: \t}\n+  241: \n+  242: \tprivate void displayHeartMessage(final ViewHolder viewHolder, final String body) {\n+  243: \t\tif (viewHolder.download_button != null) {\n+  244: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  245: \t\t}\n+  246: \t\tviewHolder.image.setVisibility(View.GONE);\n+  247: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  248: \t\tviewHolder.messageBody.setIncludeFontPadding(false);\n+  249: \t\tSpannable span = new SpannableString(body);\n+  250: \t\tspan.setSpan(new RelativeSizeSpan(4.0f), 0, body.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  251: \t\tspan.setSpan(new ForegroundColorSpan(activity.getWarningTextColor()), 0, body.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  252: \t\tviewHolder.messageBody.setText(span);\n+  253: \t}\n+  254: \n+  255: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n+  256: \t\tif (viewHolder.download_button != null) {\n+  257: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  258: \t\t}\n+  259: \t\tviewHolder.image.setVisibility(View.GONE);\n+  260: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  261: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n+  262: \t\tif (message.getBody() != null) {\n+  263: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n+  264: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n+  265: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n+  266: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n+  267: \t\t\twhile(i >= 0) {\n+  268: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n+  269: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  270: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n+  271: \t\t\t}\n+  272: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n+  273: \t\t\t\tif (message.hasMeCommand()) {\n+  274: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n+  275: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n+  276: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  277: \t\t\t\t\tviewHolder.messageBody.setText(span);\n+  278: \t\t\t\t} else {\n+  279: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n+  280: \t\t\t\t}\n+  281: \t\t\t} else {\n+  282: \t\t\t\tString privateMarker;\n+  283: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n+  284: \t\t\t\t\tprivateMarker = activity\n+  285: \t\t\t\t\t\t.getString(R.string.private_message);\n+  286: \t\t\t\t} else {\n+  287: \t\t\t\t\tfinal String to;\n+  288: \t\t\t\t\tif (message.getCounterpart() != null) {\n+  289: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n+  290: \t\t\t\t\t} else {\n+  291: \t\t\t\t\t\tto = \"\";\n+  292: \t\t\t\t\t}\n+  293: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n+  294: \t\t\t\t}\n+  295: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n+  296: \t\t\t\t\t\t+ formattedBody);\n+  297: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n+  298: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n+  299: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  300: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n+  301: \t\t\t\t\t\tprivateMarker.length(),\n+  302: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  303: \t\t\t\tif (message.hasMeCommand()) {\n+  304: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n+  305: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n+  306: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  307: \t\t\t\t}\n+  308: \t\t\t\tviewHolder.messageBody.setText(span);\n+  309: \t\t\t}\n+  310: \t\t} else {\n+  311: \t\t\tviewHolder.messageBody.setText(\"\");\n+  312: \t\t}\n+  313: \t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n+  314: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n+  315: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n   316: \t}\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n public static synchronized List<MenuNode> topLevelNodes() {\n\t\tif (ourNodes == null) {\n\t\t\tourNodes = new ArrayList<MenuNode>();\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n\t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n\t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t}\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n\t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n\t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n\t\t\t}\n\t\t\tourNodes.add(orientations);\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n\t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n\t\t}\n\t\treturn ourNodes;\n\t}\n SourceCodeAfterRefactoring:\npublic static synchronized List<MenuNode> topLevelNodes() {\n\t\tfinal List<MenuNode> allNodes = allTopLevelNodes();\n\t\tfinal List<MenuNode> activeNodes = new ArrayList<MenuNode>(allNodes.size());\n\t\tfor (MenuNode node : allNodes) {\n\t\t\tif (nodeOption(code(node)).getValue()) {\n\t\t\t\tactiveNodes.add(node);\n\t\t\t}\n\t\t}\n\t\treturn activeNodes;\n\t}\nprivate static synchronized List<MenuNode> allTopLevelNodes() {\n\t\tif (ourNodes == null) {\n\t\t\tourNodes = new ArrayList<MenuNode>();\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n\t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n\t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n\t\t\t}\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n\t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n\t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n\t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n\t\t\t}\n\t\t\tourNodes.add(orientations);\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n\t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n\t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n\t\t}\n\t\treturn ourNodes;\n\t}\n DiffSourceCode:\n-   35: \tpublic static synchronized List<MenuNode> topLevelNodes() {\n-   36: \t\tif (ourNodes == null) {\n-   37: \t\t\tourNodes = new ArrayList<MenuNode>();\n-   38: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n-   39: \t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n-   40: \t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n-   41: \t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n-   42: \t\t\t}\n-   43: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n-   44: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n-   45: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n-   46: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n-   47: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n-   48: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n-   49: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n-   50: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n-   51: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n-   52: \t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n-   53: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n-   54: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n-   55: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n-   56: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n-   57: \t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n-   58: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n-   59: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n-   60: \t\t\t}\n-   61: \t\t\tourNodes.add(orientations);\n-   62: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n-   63: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n-   64: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n-   65: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n-   66: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n-   67: \t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n-   68: \t\t}\n-   69: \t\treturn ourNodes;\n-   70: \t}\n-   71: }\n+   35: \tprivate static final Map<String,ZLBooleanOption> ourNodeOptions =\n+   36: \t\tnew HashMap<String,ZLBooleanOption>();\n+   37: \n+   38: \tprivate static synchronized List<MenuNode> allTopLevelNodes() {\n+   39: \t\tif (ourNodes == null) {\n+   40: \t\t\tourNodes = new ArrayList<MenuNode>();\n+   41: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library));\n+   42: \t\t\tif (DeviceType.Instance() == DeviceType.YOTA_PHONE) {\n+   43: \t\t\t\tourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_BACK_SCREEN, R.drawable.ic_menu_p2b));\n+   44: \t\t\t\t//ourNodes.add(new MenuNode.Item(ActionCode.YOTA_SWITCH_TO_FRONT_SCREEN, R.drawable.ic_menu_p2b));\n+   45: \t\t\t}\n+   46: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary));\n+   47: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_TOC, R.drawable.ic_menu_toc));\n+   48: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks));\n+   49: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night));\n+   50: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day));\n+   51: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SEARCH, R.drawable.ic_menu_search));\n+   52: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHARE_BOOK));\n+   53: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_PREFERENCES));\n+   54: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.SHOW_BOOK_INFO));\n+   55: \t\t\tfinal MenuNode.Submenu orientations = new MenuNode.Submenu(\"screenOrientation\");\n+   56: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SYSTEM));\n+   57: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_SENSOR));\n+   58: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_PORTRAIT));\n+   59: \t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_LANDSCAPE));\n+   60: \t\t\tif (ZLibrary.Instance().supportsAllOrientations()) {\n+   61: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_PORTRAIT));\n+   62: \t\t\t\torientations.Children.add(new MenuNode.Item(ActionCode.SET_SCREEN_ORIENTATION_REVERSE_LANDSCAPE));\n+   63: \t\t\t}\n+   64: \t\t\tourNodes.add(orientations);\n+   65: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INCREASE_FONT));\n+   66: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.DECREASE_FONT));\n+   67: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.INSTALL_PLUGINS));\n+   68: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_WEB_HELP));\n+   69: \t\t\tourNodes.add(new MenuNode.Item(ActionCode.OPEN_START_SCREEN));\n+   70: \t\t\tourNodes = Collections.unmodifiableList(ourNodes);\n+   71: \t\t}\n+   72: \t\treturn ourNodes;\n+   73: \t}\n+   95: \tpublic static synchronized List<MenuNode> topLevelNodes() {\n+   96: \t\tfinal List<MenuNode> allNodes = allTopLevelNodes();\n+   97: \t\tfinal List<MenuNode> activeNodes = new ArrayList<MenuNode>(allNodes.size());\n+   98: \t\tfor (MenuNode node : allNodes) {\n+   99: \t\t\tif (nodeOption(code(node)).getValue()) {\n+  100: \t\t\t\tactiveNodes.add(node);\n+  101: \t\t\t}\n+  102: \t\t}\n+  103: \t\treturn activeNodes;\n+  104: \t}\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/osmandapp/Osmand.git",
        "branch": "master",
        "commitId": "e95aa8ab32a0334b9c941799060fd601297d05e4",
        "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onListItemClick(ListView l, View v, int position, long id) {\n\n\t\tif (!isSelectFavoriteMode()) {\n\t\t\tFavouritePoint point = favouritesAdapter.getItem(position);\n\t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, point.getPointDescription(), settings.getLastKnownMapZoom(),\n\t\t\t\t\tgetActivity(), true, false);\n\t\t\toptionsMenu.show();\n\t\t} else {\n\t\t\tIntent intent = getActivity().getIntent();\n\t\t\tintent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n\t\t\tgetActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n\t\t\tgetActivity().finish();\n\t\t}\n\t}",
        "refactoredCode": "### Original Code:\n```java\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n\n    if (!isSelectFavoriteMode()) {\n        FavouritePoint point = favouritesAdapter.getItem(position);\n        LatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n        final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n        DirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, point.getPointDescription(), settings.getLastKnownMapZoom(),\n                getActivity(), true, false);\n        optionsMenu.show();\n    } else {\n        Intent intent = getActivity().getIntent();\n        intent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n        getActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n        getActivity().finish();\n    }\n}\n```\n\n### Refactored Code:\n```java\n@Override\npublic void onListItemClick(ListView l, View v, int position, long id) {\n    if (!isSelectFavoriteMode()) {\n        showPopupMenu(v, position);\n    } else {\n        selectFavoritePoint(position);\n    }\n}\n\nprivate void showPopupMenu(View v, int position) {\n    FavouritePoint point = favouritesAdapter.getItem(position);\n    LatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n    final PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n    DirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, point.getPointDescription(), settings.getLastKnownMapZoom(),\n            getActivity(), true, false);\n    optionsMenu.show();\n}\n\nprivate void selectFavoritePoint(int position) {\n    Intent intent = getActivity().getIntent();\n    intent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n    getActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n    getActivity().finish();\n}\n```\n\n### Explanation of Changes:\n1. **Method Extraction**: The original method `onListItemClick` was split into two new methods: `showPopupMenu` and `selectFavoritePoint`. Each of these methods encapsulates a specific responsibility:\n   - `showPopupMenu`: Handles the logic for displaying the popup menu when not in favorite selection mode.\n   - `selectFavoritePoint`: Handles the logic for selecting a favorite point when in favorite selection mode.\n\n2. **Improved Readability**: The refactored code is more readable and easier to understand at a glance. The main method (`onListItemClick`) now clearly indicates the two distinct paths of execution based on the mode.\n\n3. **Maintained Functionality**: The functionality of the original method remains unchanged, ensuring that the refactoring does not introduce any bugs or alter the behavior of the application.",
        "sourceCodeAfterRefactoring": "@Override\n\tpublic void onListItemClick(ListView l, View v, int position, long id) {\n\n\t\tif (!isSelectFavoriteMode()) {\n\t\t\tFavouritePoint point = favouritesAdapter.getItem(position);\n\t\t\tshowItemPopupOptionsMenu(point, getActivity(), v);\n\t\t} else {\n\t\t\tIntent intent = getActivity().getIntent();\n\t\t\tintent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n\t\t\tgetActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n\t\t\tgetActivity().finish();\n\t\t}\n\t}\npublic static void showItemPopupOptionsMenu(FavouritePoint point, Activity activity, View view) {\n\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\tfinal PopupMenu optionsMenu = new PopupMenu(activity, view);\n\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location,\n\t\t\t\tpoint, point.getPointDescription(),\n\t\t\t\t((OsmandApplication) activity.getApplication()).getSettings().getLastKnownMapZoom(),\n\t\t\t\tactivity, true, false);\n\t\toptionsMenu.show();\n\t}",
        "diffSourceCode": "-  130: \n-  131: \t@Override\n-  132: \tpublic void onListItemClick(ListView l, View v, int position, long id) {\n-  133: \n-  134: \t\tif (!isSelectFavoriteMode()) {\n-  135: \t\t\tFavouritePoint point = favouritesAdapter.getItem(position);\n-  136: \t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n-  137: \t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n-  138: \t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, point.getPointDescription(), settings.getLastKnownMapZoom(),\n-  139: \t\t\t\t\tgetActivity(), true, false);\n-  140: \t\t\toptionsMenu.show();\n-  141: \t\t} else {\n-  142: \t\t\tIntent intent = getActivity().getIntent();\n-  143: \t\t\tintent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n-  144: \t\t\tgetActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n-  145: \t\t\tgetActivity().finish();\n-  146: \t\t}\n-  147: \t}\n+  130: \t@Override\n+  131: \tpublic void onListItemClick(ListView l, View v, int position, long id) {\n+  132: \n+  133: \t\tif (!isSelectFavoriteMode()) {\n+  134: \t\t\tFavouritePoint point = favouritesAdapter.getItem(position);\n+  135: \t\t\tshowItemPopupOptionsMenu(point, getActivity(), v);\n+  136: \t\t} else {\n+  137: \t\t\tIntent intent = getActivity().getIntent();\n+  138: \t\t\tintent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n+  139: \t\t\tgetActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n+  140: \t\t\tgetActivity().finish();\n+  141: \t\t}\n+  142: \t}\n+  143: \n+  144: \tpublic static class FavouritesAdapter extends ArrayAdapter<FavouritePoint> {\n+  145: \t\tprivate Activity activity;\n+  146: \t\tprivate LatLon location;\n+  147: \t\tprivate OsmandApplication app;\n+  256: \tpublic static void showItemPopupOptionsMenu(FavouritePoint point, Activity activity, View view) {\n+  257: \t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n+  258: \t\tfinal PopupMenu optionsMenu = new PopupMenu(activity, view);\n+  259: \t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location,\n+  260: \t\t\t\tpoint, point.getPointDescription(),\n+  261: \t\t\t\t((OsmandApplication) activity.getApplication()).getSettings().getLastKnownMapZoom(),\n+  262: \t\t\t\tactivity, true, false);\n+  263: \t\toptionsMenu.show();\n+  264: \t}\n",
        "uniqueId": "e95aa8ab32a0334b9c941799060fd601297d05e4_131_147_256_264_130_142",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Handles all actions with this intent\n     */\n    private void handleActions(Bundle savedInstanceState, Intent intent) {\n        String action = intent.getAction();\n        String type = intent.getType();\n        Uri uri = intent.getData();\n\n        if (Intent.ACTION_SEND.equals(action) && type != null) {\n            // When sending to Keychain Decrypt via share menu\n            // Binary via content provider (could also be files)\n            // override uri to get stream from send\n            uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);\n            action = ACTION_DECRYPT_DATA;\n        } else if (Intent.ACTION_VIEW.equals(action)) {\n            // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n\n            // override action\n            action = ACTION_DECRYPT_DATA;\n        }\n\n        // No need to initialize fragments if we are being restored\n        if (savedInstanceState != null) {\n            return;\n        }\n\n        // Definitely need a data uri with the decrypt_data intent\n        if (ACTION_DECRYPT_DATA.equals(action) && uri == null) {\n            Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n            setResult(Activity.RESULT_CANCELED);\n            finish();\n        }\n\n        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(uri, showOpenDialog);\n\n        // Add the fragment to the 'fragment_container' FrameLayout\n        // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n        getSupportFragmentManager().beginTransaction()\n                .replace(R.id.decrypt_files_fragment_container, frag)\n                .commit();\n\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Handles all actions with this intent\n     */\n    private void handleActions(Bundle savedInstanceState, Intent intent) {\n\n        // No need to initialize fragments if we are just being restored\n        if (savedInstanceState != null) {\n            return;\n        }\n\n        ArrayList<Uri> uris = new ArrayList<>();\n\n        String action = intent.getAction();\n\n        switch (action) {\n            case Intent.ACTION_SEND: {\n                // When sending to Keychain Decrypt via share menu\n                // Binary via content provider (could also be files)\n                // override uri to get stream from send\n                action = ACTION_DECRYPT_DATA;\n                uris.add(intent.<Uri>getParcelableExtra(Intent.EXTRA_STREAM));\n                break;\n            }\n\n            case Intent.ACTION_SEND_MULTIPLE: {\n                action = ACTION_DECRYPT_DATA;\n                uris.addAll(intent.<Uri>getParcelableArrayListExtra(Intent.EXTRA_STREAM));\n                break;\n            }\n\n            case Intent.ACTION_VIEW:\n                // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n                action = ACTION_DECRYPT_DATA;\n\n                // fallthrough\n            default:\n                uris.add(intent.getData());\n\n        }\n\n        if (ACTION_DECRYPT_DATA.equals(action)) {\n            // Definitely need a data uri with the decrypt_data intent\n            if (uris.isEmpty()) {\n                Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n                setResult(Activity.RESULT_CANCELED);\n                finish();\n            }\n            displayListFragment(uris);\n            return;\n        }\n\n        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n        displayInputFragment(showOpenDialog);\n\n    }\npublic void displayInputFragment(boolean showOpenDialog) {\n        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(showOpenDialog);\n\n        // Add the fragment to the 'fragment_container' FrameLayout\n        // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n        getSupportFragmentManager().beginTransaction()\n                .replace(R.id.decrypt_files_fragment_container, frag)\n                .commit();\n    }\n DiffSourceCode:\n-   64:     /**\n-   65:      * Handles all actions with this intent\n-   66:      */\n-   67:     private void handleActions(Bundle savedInstanceState, Intent intent) {\n-   68:         String action = intent.getAction();\n-   69:         String type = intent.getType();\n-   70:         Uri uri = intent.getData();\n-   71: \n-   72:         if (Intent.ACTION_SEND.equals(action) && type != null) {\n-   73:             // When sending to Keychain Decrypt via share menu\n-   74:             // Binary via content provider (could also be files)\n-   75:             // override uri to get stream from send\n-   76:             uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);\n-   77:             action = ACTION_DECRYPT_DATA;\n-   78:         } else if (Intent.ACTION_VIEW.equals(action)) {\n-   79:             // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n-   80: \n-   81:             // override action\n-   82:             action = ACTION_DECRYPT_DATA;\n-   83:         }\n-   84: \n-   85:         // No need to initialize fragments if we are being restored\n-   86:         if (savedInstanceState != null) {\n-   87:             return;\n-   88:         }\n+   64:     }\n+   65: \n+   66:     /**\n+   67:      * Handles all actions with this intent\n+   68:      */\n+   69:     private void handleActions(Bundle savedInstanceState, Intent intent) {\n+   70: \n+   71:         // No need to initialize fragments if we are just being restored\n+   72:         if (savedInstanceState != null) {\n+   73:             return;\n+   74:         }\n+   75: \n+   76:         ArrayList<Uri> uris = new ArrayList<>();\n+   77: \n+   78:         String action = intent.getAction();\n+   79: \n+   80:         switch (action) {\n+   81:             case Intent.ACTION_SEND: {\n+   82:                 // When sending to Keychain Decrypt via share menu\n+   83:                 // Binary via content provider (could also be files)\n+   84:                 // override uri to get stream from send\n+   85:                 action = ACTION_DECRYPT_DATA;\n+   86:                 uris.add(intent.<Uri>getParcelableExtra(Intent.EXTRA_STREAM));\n+   87:                 break;\n+   88:             }\n    89: \n-   90:         // Definitely need a data uri with the decrypt_data intent\n-   91:         if (ACTION_DECRYPT_DATA.equals(action) && uri == null) {\n-   92:             Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n-   93:             setResult(Activity.RESULT_CANCELED);\n-   94:             finish();\n-   95:         }\n-   96: \n-   97:         boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n-   98:         DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(uri, showOpenDialog);\n+   90:             case Intent.ACTION_SEND_MULTIPLE: {\n+   91:                 action = ACTION_DECRYPT_DATA;\n+   92:                 uris.addAll(intent.<Uri>getParcelableArrayListExtra(Intent.EXTRA_STREAM));\n+   93:                 break;\n+   94:             }\n+   95: \n+   96:             case Intent.ACTION_VIEW:\n+   97:                 // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n+   98:                 action = ACTION_DECRYPT_DATA;\n    99: \n-  100:         // Add the fragment to the 'fragment_container' FrameLayout\n-  101:         // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n-  102:         getSupportFragmentManager().beginTransaction()\n-  103:                 .replace(R.id.decrypt_files_fragment_container, frag)\n-  104:                 .commit();\n+  100:                 // fallthrough\n+  101:             default:\n+  102:                 uris.add(intent.getData());\n+  103: \n+  104:         }\n   105: \n-  106:     }\n-  107: \n-  108:     public void displayListFragment(Uri inputUri) {\n-  109: \n-  110:         ArrayList<Uri> uris = new ArrayList<>();\n-  111:         uris.add(inputUri);\n-  112:         DecryptFilesListFragment frag = DecryptFilesListFragment.newInstance(uris);\n-  113: \n-  114:         getSupportFragmentManager().beginTransaction()\n-  115:                 .replace(R.id.decrypt_files_fragment_container, frag)\n-  116:                 .addToBackStack(\"list\")\n-  117:                 .commit();\n-  118: \n-  119:     }\n-  120: \n+  106:         if (ACTION_DECRYPT_DATA.equals(action)) {\n+  107:             // Definitely need a data uri with the decrypt_data intent\n+  108:             if (uris.isEmpty()) {\n+  109:                 Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n+  110:                 setResult(Activity.RESULT_CANCELED);\n+  111:                 finish();\n+  112:             }\n+  113:             displayListFragment(uris);\n+  114:             return;\n+  115:         }\n+  116: \n+  117:         boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n+  118:         displayInputFragment(showOpenDialog);\n+  119: \n+  120:     }\n+  122:     public void displayInputFragment(boolean showOpenDialog) {\n+  123:         DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(showOpenDialog);\n+  124: \n+  125:         // Add the fragment to the 'fragment_container' FrameLayout\n+  126:         // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n+  127:         getSupportFragmentManager().beginTransaction()\n+  128:                 .replace(R.id.decrypt_files_fragment_container, frag)\n+  129:                 .commit();\n+  130:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Override\n    public void actionPerformed( ActionEvent e )\n    {\n        JFileChooser jFileChooser = new JFileChooser();\n        jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        jFileChooser.setDialogTitle( \"Select database\" );\n        jFileChooser.setDialogType( CUSTOM_DIALOG );\n\n        while ( true )\n        {\n            int choice = jFileChooser.showOpenDialog( frame );\n\n            if ( choice != APPROVE_OPTION )\n            {\n                return;\n            }\n\n            File selectedFile = jFileChooser.getSelectedFile();\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n                return;\n            }\n            catch ( UnsuitableDirectoryException error )\n            {\n                int result = showWrappedConfirmDialog(\n                        frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n                if ( result == CANCEL_OPTION )\n                {\n                    return;\n                }\n            }\n        }\n    }\n SourceCodeAfterRefactoring:\n@Override\n    public void actionPerformed( ActionEvent e )\n    {\n        File selectedFile = null;\n        boolean cancelled = false;\n        boolean validLocation = false;\n        String os = System.getProperty( \"os.name\" );\n\n        while ( !validLocation && !cancelled )\n        {\n            if ( os.toLowerCase().contains( \"mac\" ) )\n            {\n                selectedFile = macFileSelection();\n            }\n            else\n            {\n                selectedFile = fileSelection();\n            }\n\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n\n                validLocation = true;\n\n                FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n                fileWriter.write( selectedFile.getAbsolutePath() );\n                fileWriter.flush();\n                fileWriter.close();\n            }\n            catch ( UnsuitableDirectoryException ude )\n            {\n                int choice = showWrappedConfirmDialog(\n                        frame,\n                        ude.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n\n                if ( choice == CANCEL_OPTION )\n                {\n                    cancelled = true;\n                }\n            }\n            catch ( IOException ioe )\n            {\n                System.out.println( \"Error saving DB location\" );\n                System.out.println( ioe );\n            }\n        }\n    }\nprivate File fileSelection()\n    {\n        File selectedFile = null;\n\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        fileChooser.setDialogTitle( \"Select database\" );\n        fileChooser.setDialogType( CUSTOM_DIALOG );\n\n        int choice = fileChooser.showOpenDialog( frame );\n\n        if ( choice == APPROVE_OPTION )\n        {\n            selectedFile = fileChooser.getSelectedFile();\n        }\n\n        return selectedFile;\n    }\n DiffSourceCode:\n-   50:     @Override\n-   51:     public void actionPerformed( ActionEvent e )\n-   52:     {\n-   53:         JFileChooser jFileChooser = new JFileChooser();\n-   54:         jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n-   55:         jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n-   56:         jFileChooser.setDialogTitle( \"Select database\" );\n-   57:         jFileChooser.setDialogType( CUSTOM_DIALOG );\n-   58: \n-   59:         while ( true )\n-   60:         {\n-   61:             int choice = jFileChooser.showOpenDialog( frame );\n-   62: \n-   63:             if ( choice != APPROVE_OPTION )\n+   50:         this.model = model;\n+   51:     }\n+   52: \n+   53:     @Override\n+   54:     public void actionPerformed( ActionEvent e )\n+   55:     {\n+   56:         File selectedFile = null;\n+   57:         boolean cancelled = false;\n+   58:         boolean validLocation = false;\n+   59:         String os = System.getProperty( \"os.name\" );\n+   60: \n+   61:         while ( !validLocation && !cancelled )\n+   62:         {\n+   63:             if ( os.toLowerCase().contains( \"mac\" ) )\n    64:             {\n-   65:                 return;\n+   65:                 selectedFile = macFileSelection();\n    66:             }\n-   67: \n-   68:             File selectedFile = jFileChooser.getSelectedFile();\n-   69:             try\n-   70:             {\n-   71:                 model.setDatabaseDirectory( selectedFile );\n-   72:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n-   73:                 return;\n-   74:             }\n-   75:             catch ( UnsuitableDirectoryException error )\n-   76:             {\n-   77:                 int result = showWrappedConfirmDialog(\n-   78:                         frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n-   79:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n-   80:                 if ( result == CANCEL_OPTION )\n-   81:                 {\n-   82:                     return;\n-   83:                 }\n-   84:             }\n-   85:         }\n-   86:     }\n-   87: }\n+   67:             else\n+   68:             {\n+   69:                 selectedFile = fileSelection();\n+   70:             }\n+   71: \n+   72:             try\n+   73:             {\n+   74:                 model.setDatabaseDirectory( selectedFile );\n+   75:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n+   76: \n+   77:                 validLocation = true;\n+   78: \n+   79:                 FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n+   80:                 fileWriter.write( selectedFile.getAbsolutePath() );\n+   81:                 fileWriter.flush();\n+   82:                 fileWriter.close();\n+   83:             }\n+   84:             catch ( UnsuitableDirectoryException ude )\n+   85:             {\n+   86:                 int choice = showWrappedConfirmDialog(\n+   87:                         frame,\n+   88:                         ude.getMessage() + \"\\nPlease choose a different folder.\",\n+   89:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n+   90: \n+   91:                 if ( choice == CANCEL_OPTION )\n+   92:                 {\n+   93:                     cancelled = true;\n+   94:                 }\n+   95:             }\n+   96:             catch ( IOException ioe )\n+   97:             {\n+   98:                 System.out.println( \"Error saving DB location\" );\n+   99:                 System.out.println( ioe );\n+  100:             }\n+  101:         }\n+  102:     }\n+  104:     private File fileSelection()\n+  105:     {\n+  106:         File selectedFile = null;\n+  107: \n+  108:         JFileChooser fileChooser = new JFileChooser();\n+  109:         fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n+  110:         fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n+  111:         fileChooser.setDialogTitle( \"Select database\" );\n+  112:         fileChooser.setDialogType( CUSTOM_DIALOG );\n+  113: \n+  114:         int choice = fileChooser.showOpenDialog( frame );\n+  115: \n+  116:         if ( choice == APPROVE_OPTION )\n+  117:         {\n+  118:             selectedFile = fileChooser.getSelectedFile();\n+  119:         }\n+  120: \n+  121:         return selectedFile;\n+  122:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic int getItemViewType(int position) {\n\t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t} else {\n\t\t\treturn SENT;\n\t\t}\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic int getItemViewType(int position) {\n\t\treturn this.getItemViewType(getItem(position));\n\t}\npublic int getItemViewType(Message message) {\n\t\tif (message.getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t}\n\n\t\treturn SENT;\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\nprivate int getMessageTextColor(Message message) {\n\t\tint type = this.getItemViewType(message);\n\n\t\tif (type == SENT) {\n\t\t\treturn activity.getResources().getColor(R.color.black87);\n\t\t} else if (type == RECEIVED) {\n\t\t\treturn activity.getResources().getColor(R.color.white);\n\t\t}\n\n\t\treturn activity.getPrimaryTextColor();\n\t}\n DiffSourceCode:\n-   84: \t@Override\n-   85: \tpublic int getItemViewType(int position) {\n-   86: \t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n-   87: \t\t\treturn STATUS;\n-   88: \t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n-   89: \t\t\treturn RECEIVED;\n-   90: \t\t} else {\n-   91: \t\t\treturn SENT;\n-   92: \t\t}\n-   93: \t}\n-   94: \n-   95: \tprivate void displayStatus(ViewHolder viewHolder, Message message) {\n-   96: \t\tString filesize = null;\n-   97: \t\tString info = null;\n-   99: \t\tif (viewHolder.indicatorReceived != null) {\n-  100: \t\t\tviewHolder.indicatorReceived.setVisibility(View.GONE);\n-  101: \t\t}\n-  102: \t\tboolean multiReceived = message.getConversation().getMode() == Conversation.MODE_MULTI\n-  103: \t\t\t&& message.getMergedStatus() <= Message.STATUS_RECEIVED;\n-  104: \t\tif (message.getType() == Message.TYPE_IMAGE || message.getType() == Message.TYPE_FILE || message.getTransferable() != null) {\n-  105: \t\t\tFileParams params = message.getFileParams();\n-  106: \t\t\tif (params.size > (1.5 * 1024 * 1024)) {\n-  107: \t\t\t\tfilesize = params.size / (1024 * 1024)+ \" MiB\";\n-  108: \t\t\t} else if (params.size > 0) {\n-  109: \t\t\t\tfilesize = params.size / 1024 + \" KiB\";\n-  239: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n-  240: \t\tif (viewHolder.download_button != null) {\n-  241: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n-  242: \t\t}\n-  243: \t\tviewHolder.image.setVisibility(View.GONE);\n-  244: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n-  245: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n-  246: \t\tif (message.getBody() != null) {\n-  247: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n-  248: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n-  249: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n-  250: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n-  251: \t\t\twhile(i >= 0) {\n-  252: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n-  253: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  254: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n-  255: \t\t\t}\n-  256: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n-  257: \t\t\t\tif (message.hasMeCommand()) {\n-  258: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n-  259: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n-  260: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  261: \t\t\t\t\tviewHolder.messageBody.setText(span);\n-  262: \t\t\t\t} else {\n-  263: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n-  264: \t\t\t\t}\n-  265: \t\t\t} else {\n-  266: \t\t\t\tString privateMarker;\n-  267: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n-  268: \t\t\t\t\tprivateMarker = activity\n-  269: \t\t\t\t\t\t.getString(R.string.private_message);\n-  270: \t\t\t\t} else {\n-  271: \t\t\t\t\tfinal String to;\n-  272: \t\t\t\t\tif (message.getCounterpart() != null) {\n-  273: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n-  274: \t\t\t\t\t} else {\n-  275: \t\t\t\t\t\tto = \"\";\n-  276: \t\t\t\t\t}\n-  277: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n-  278: \t\t\t\t}\n-  279: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n-  280: \t\t\t\t\t\t+ formattedBody);\n-  281: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n-  282: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n-  283: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  284: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n-  285: \t\t\t\t\t\tprivateMarker.length(),\n-  286: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  287: \t\t\t\tif (message.hasMeCommand()) {\n-  288: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n-  289: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n-  290: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  291: \t\t\t\t}\n-  292: \t\t\t\tviewHolder.messageBody.setText(span);\n-  293: \t\t\t}\n-  294: \t\t} else {\n-  295: \t\t\tviewHolder.messageBody.setText(\"\");\n-  296: \t\t}\n-  297: \t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n-  298: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n-  299: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n-  300: \t}\n-  301: \n-  302: \tprivate void displayDownloadableMessage(ViewHolder viewHolder,\n-  303: \t\t\tfinal Message message, String text) {\n-  304: \t\tviewHolder.image.setVisibility(View.GONE);\n-  305: \t\tviewHolder.messageBody.setVisibility(View.GONE);\n-  306: \t\tviewHolder.download_button.setVisibility(View.VISIBLE);\n-  307: \t\tviewHolder.download_button.setText(text);\n-  308: \t\tviewHolder.download_button.setOnClickListener(new OnClickListener() {\n-  309: \n-  310: \t\t\t@Override\n-  311: \t\t\tpublic void onClick(View v) {\n-  312: \t\t\t\tstartDownloadable(message);\n-  313: \t\t\t}\n-  314: \t\t});\n-  315: \t\tviewHolder.download_button.setOnLongClickListener(openContextMenu);\n+   84: \tpublic int getItemViewType(Message message) {\n+   85: \t\tif (message.getType() == Message.TYPE_STATUS) {\n+   86: \t\t\treturn STATUS;\n+   87: \t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n+   88: \t\t\treturn RECEIVED;\n+   89: \t\t}\n+   90: \n+   91: \t\treturn SENT;\n+   92: \t}\n+   93: \n+   94: \t@Override\n+   95: \tpublic int getItemViewType(int position) {\n+   96: \t\treturn this.getItemViewType(getItem(position));\n+   97: \t}\n+   99: \tprivate int getMessageTextColor(Message message) {\n+  100: \t\tint type = this.getItemViewType(message);\n+  101: \n+  102: \t\tif (type == SENT) {\n+  103: \t\t\treturn activity.getResources().getColor(R.color.black87);\n+  104: \t\t} else if (type == RECEIVED) {\n+  105: \t\t\treturn activity.getResources().getColor(R.color.white);\n+  106: \t\t}\n+  107: \n+  108: \t\treturn activity.getPrimaryTextColor();\n+  109: \t}\n+  239: \t\tviewHolder.messageBody.setTextIsSelectable(false);\n+  240: \t}\n+  241: \n+  242: \tprivate void displayHeartMessage(final ViewHolder viewHolder, final String body) {\n+  243: \t\tif (viewHolder.download_button != null) {\n+  244: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  245: \t\t}\n+  246: \t\tviewHolder.image.setVisibility(View.GONE);\n+  247: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  248: \t\tviewHolder.messageBody.setIncludeFontPadding(false);\n+  249: \t\tSpannable span = new SpannableString(body);\n+  250: \t\tspan.setSpan(new RelativeSizeSpan(4.0f), 0, body.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  251: \t\tspan.setSpan(new ForegroundColorSpan(activity.getWarningTextColor()), 0, body.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  252: \t\tviewHolder.messageBody.setText(span);\n+  253: \t}\n+  254: \n+  255: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n+  256: \t\tif (viewHolder.download_button != null) {\n+  257: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  258: \t\t}\n+  259: \t\tviewHolder.image.setVisibility(View.GONE);\n+  260: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  261: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n+  262: \t\tif (message.getBody() != null) {\n+  263: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n+  264: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n+  265: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n+  266: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n+  267: \t\t\twhile(i >= 0) {\n+  268: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n+  269: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  270: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n+  271: \t\t\t}\n+  272: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n+  273: \t\t\t\tif (message.hasMeCommand()) {\n+  274: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n+  275: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n+  276: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  277: \t\t\t\t\tviewHolder.messageBody.setText(span);\n+  278: \t\t\t\t} else {\n+  279: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n+  280: \t\t\t\t}\n+  281: \t\t\t} else {\n+  282: \t\t\t\tString privateMarker;\n+  283: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n+  284: \t\t\t\t\tprivateMarker = activity\n+  285: \t\t\t\t\t\t.getString(R.string.private_message);\n+  286: \t\t\t\t} else {\n+  287: \t\t\t\t\tfinal String to;\n+  288: \t\t\t\t\tif (message.getCounterpart() != null) {\n+  289: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n+  290: \t\t\t\t\t} else {\n+  291: \t\t\t\t\t\tto = \"\";\n+  292: \t\t\t\t\t}\n+  293: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n+  294: \t\t\t\t}\n+  295: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n+  296: \t\t\t\t\t\t+ formattedBody);\n+  297: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n+  298: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n+  299: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  300: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n+  301: \t\t\t\t\t\tprivateMarker.length(),\n+  302: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  303: \t\t\t\tif (message.hasMeCommand()) {\n+  304: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n+  305: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n+  306: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  307: \t\t\t\t}\n+  308: \t\t\t\tviewHolder.messageBody.setText(span);\n+  309: \t\t\t}\n+  310: \t\t} else {\n+  311: \t\t\tviewHolder.messageBody.setText(\"\");\n+  312: \t\t}\n+  313: \t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n+  314: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n+  315: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n   316: \t}\n\n",
        "contextDescription": "PackageName: net.osmand.plus.activities\nClassName: net.osmand.plus.activities.FavoritesListFragment\nMethodName: net.osmand.plus.activities.FavoritesListFragment#onListItemClick\n ClassSignature: public class FavoritesListFragment extends OsmAndListFragment implements SearchActivityChild, OsmAndCompassListener \nInvokedMethod: methodSignature: net.osmand.plus.activities.FavoritesListFragment#isSelectFavoriteMode\n methodBody: public boolean isSelectFavoriteMode() {\nreturn selectFavoriteMode;\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n@Override\n\tpublic void onListItemClick(ListView l, View v, int position, long id) {\n\n\t\tif (!isSelectFavoriteMode()) {\n\t\t\tFavouritePoint point = favouritesAdapter.getItem(position);\n\t\t\tLatLon location = new LatLon(point.getLatitude(), point.getLongitude());\n\t\t\tfinal PopupMenu optionsMenu = new PopupMenu(getActivity(), v);\n\t\t\tDirectionsDialogs.createDirectionActionsPopUpMenu(optionsMenu, location, point, point.getPointDescription(), settings.getLastKnownMapZoom(),\n\t\t\t\t\tgetActivity(), true, false);\n\t\t\toptionsMenu.show();\n\t\t} else {\n\t\t\tIntent intent = getActivity().getIntent();\n\t\t\tintent.putExtra(SELECT_FAVORITE_POINT_INTENT_KEY, favouritesAdapter.getItem(position));\n\t\t\tgetActivity().setResult(SELECT_FAVORITE_POINT_RESULT_OK, intent);\n\t\t\tgetActivity().finish();\n\t\t}\n\t}\n\nThe context of the source code is as follows:\nPackageName: net.osmand.plus.activities\nClassName: net.osmand.plus.activities.FavoritesListFragment\nMethodName: net.osmand.plus.activities.FavoritesListFragment#onListItemClick\n ClassSignature: public class FavoritesListFragment extends OsmAndListFragment implements SearchActivityChild, OsmAndCompassListener \nInvokedMethod: methodSignature: net.osmand.plus.activities.FavoritesListFragment#isSelectFavoriteMode\n methodBody: public boolean isSelectFavoriteMode() {\nreturn selectFavoriteMode;\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n /**\n     * Handles all actions with this intent\n     */\n    private void handleActions(Bundle savedInstanceState, Intent intent) {\n        String action = intent.getAction();\n        String type = intent.getType();\n        Uri uri = intent.getData();\n\n        if (Intent.ACTION_SEND.equals(action) && type != null) {\n            // When sending to Keychain Decrypt via share menu\n            // Binary via content provider (could also be files)\n            // override uri to get stream from send\n            uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);\n            action = ACTION_DECRYPT_DATA;\n        } else if (Intent.ACTION_VIEW.equals(action)) {\n            // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n\n            // override action\n            action = ACTION_DECRYPT_DATA;\n        }\n\n        // No need to initialize fragments if we are being restored\n        if (savedInstanceState != null) {\n            return;\n        }\n\n        // Definitely need a data uri with the decrypt_data intent\n        if (ACTION_DECRYPT_DATA.equals(action) && uri == null) {\n            Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n            setResult(Activity.RESULT_CANCELED);\n            finish();\n        }\n\n        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(uri, showOpenDialog);\n\n        // Add the fragment to the 'fragment_container' FrameLayout\n        // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n        getSupportFragmentManager().beginTransaction()\n                .replace(R.id.decrypt_files_fragment_container, frag)\n                .commit();\n\n    }\n SourceCodeAfterRefactoring:\n/**\n     * Handles all actions with this intent\n     */\n    private void handleActions(Bundle savedInstanceState, Intent intent) {\n\n        // No need to initialize fragments if we are just being restored\n        if (savedInstanceState != null) {\n            return;\n        }\n\n        ArrayList<Uri> uris = new ArrayList<>();\n\n        String action = intent.getAction();\n\n        switch (action) {\n            case Intent.ACTION_SEND: {\n                // When sending to Keychain Decrypt via share menu\n                // Binary via content provider (could also be files)\n                // override uri to get stream from send\n                action = ACTION_DECRYPT_DATA;\n                uris.add(intent.<Uri>getParcelableExtra(Intent.EXTRA_STREAM));\n                break;\n            }\n\n            case Intent.ACTION_SEND_MULTIPLE: {\n                action = ACTION_DECRYPT_DATA;\n                uris.addAll(intent.<Uri>getParcelableArrayListExtra(Intent.EXTRA_STREAM));\n                break;\n            }\n\n            case Intent.ACTION_VIEW:\n                // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n                action = ACTION_DECRYPT_DATA;\n\n                // fallthrough\n            default:\n                uris.add(intent.getData());\n\n        }\n\n        if (ACTION_DECRYPT_DATA.equals(action)) {\n            // Definitely need a data uri with the decrypt_data intent\n            if (uris.isEmpty()) {\n                Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n                setResult(Activity.RESULT_CANCELED);\n                finish();\n            }\n            displayListFragment(uris);\n            return;\n        }\n\n        boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n        displayInputFragment(showOpenDialog);\n\n    }\npublic void displayInputFragment(boolean showOpenDialog) {\n        DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(showOpenDialog);\n\n        // Add the fragment to the 'fragment_container' FrameLayout\n        // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n        getSupportFragmentManager().beginTransaction()\n                .replace(R.id.decrypt_files_fragment_container, frag)\n                .commit();\n    }\n DiffSourceCode:\n-   64:     /**\n-   65:      * Handles all actions with this intent\n-   66:      */\n-   67:     private void handleActions(Bundle savedInstanceState, Intent intent) {\n-   68:         String action = intent.getAction();\n-   69:         String type = intent.getType();\n-   70:         Uri uri = intent.getData();\n-   71: \n-   72:         if (Intent.ACTION_SEND.equals(action) && type != null) {\n-   73:             // When sending to Keychain Decrypt via share menu\n-   74:             // Binary via content provider (could also be files)\n-   75:             // override uri to get stream from send\n-   76:             uri = intent.getParcelableExtra(Intent.EXTRA_STREAM);\n-   77:             action = ACTION_DECRYPT_DATA;\n-   78:         } else if (Intent.ACTION_VIEW.equals(action)) {\n-   79:             // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n-   80: \n-   81:             // override action\n-   82:             action = ACTION_DECRYPT_DATA;\n-   83:         }\n-   84: \n-   85:         // No need to initialize fragments if we are being restored\n-   86:         if (savedInstanceState != null) {\n-   87:             return;\n-   88:         }\n+   64:     }\n+   65: \n+   66:     /**\n+   67:      * Handles all actions with this intent\n+   68:      */\n+   69:     private void handleActions(Bundle savedInstanceState, Intent intent) {\n+   70: \n+   71:         // No need to initialize fragments if we are just being restored\n+   72:         if (savedInstanceState != null) {\n+   73:             return;\n+   74:         }\n+   75: \n+   76:         ArrayList<Uri> uris = new ArrayList<>();\n+   77: \n+   78:         String action = intent.getAction();\n+   79: \n+   80:         switch (action) {\n+   81:             case Intent.ACTION_SEND: {\n+   82:                 // When sending to Keychain Decrypt via share menu\n+   83:                 // Binary via content provider (could also be files)\n+   84:                 // override uri to get stream from send\n+   85:                 action = ACTION_DECRYPT_DATA;\n+   86:                 uris.add(intent.<Uri>getParcelableExtra(Intent.EXTRA_STREAM));\n+   87:                 break;\n+   88:             }\n    89: \n-   90:         // Definitely need a data uri with the decrypt_data intent\n-   91:         if (ACTION_DECRYPT_DATA.equals(action) && uri == null) {\n-   92:             Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n-   93:             setResult(Activity.RESULT_CANCELED);\n-   94:             finish();\n-   95:         }\n-   96: \n-   97:         boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n-   98:         DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(uri, showOpenDialog);\n+   90:             case Intent.ACTION_SEND_MULTIPLE: {\n+   91:                 action = ACTION_DECRYPT_DATA;\n+   92:                 uris.addAll(intent.<Uri>getParcelableArrayListExtra(Intent.EXTRA_STREAM));\n+   93:                 break;\n+   94:             }\n+   95: \n+   96:             case Intent.ACTION_VIEW:\n+   97:                 // Android's Action when opening file associated to Keychain (see AndroidManifest.xml)\n+   98:                 action = ACTION_DECRYPT_DATA;\n    99: \n-  100:         // Add the fragment to the 'fragment_container' FrameLayout\n-  101:         // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n-  102:         getSupportFragmentManager().beginTransaction()\n-  103:                 .replace(R.id.decrypt_files_fragment_container, frag)\n-  104:                 .commit();\n+  100:                 // fallthrough\n+  101:             default:\n+  102:                 uris.add(intent.getData());\n+  103: \n+  104:         }\n   105: \n-  106:     }\n-  107: \n-  108:     public void displayListFragment(Uri inputUri) {\n-  109: \n-  110:         ArrayList<Uri> uris = new ArrayList<>();\n-  111:         uris.add(inputUri);\n-  112:         DecryptFilesListFragment frag = DecryptFilesListFragment.newInstance(uris);\n-  113: \n-  114:         getSupportFragmentManager().beginTransaction()\n-  115:                 .replace(R.id.decrypt_files_fragment_container, frag)\n-  116:                 .addToBackStack(\"list\")\n-  117:                 .commit();\n-  118: \n-  119:     }\n-  120: \n+  106:         if (ACTION_DECRYPT_DATA.equals(action)) {\n+  107:             // Definitely need a data uri with the decrypt_data intent\n+  108:             if (uris.isEmpty()) {\n+  109:                 Toast.makeText(this, \"No data to decrypt!\", Toast.LENGTH_LONG).show();\n+  110:                 setResult(Activity.RESULT_CANCELED);\n+  111:                 finish();\n+  112:             }\n+  113:             displayListFragment(uris);\n+  114:             return;\n+  115:         }\n+  116: \n+  117:         boolean showOpenDialog = ACTION_DECRYPT_DATA_OPEN.equals(action);\n+  118:         displayInputFragment(showOpenDialog);\n+  119: \n+  120:     }\n+  122:     public void displayInputFragment(boolean showOpenDialog) {\n+  123:         DecryptFilesInputFragment frag = DecryptFilesInputFragment.newInstance(showOpenDialog);\n+  124: \n+  125:         // Add the fragment to the 'fragment_container' FrameLayout\n+  126:         // NOTE: We use commitAllowingStateLoss() to prevent weird crashes!\n+  127:         getSupportFragmentManager().beginTransaction()\n+  128:                 .replace(R.id.decrypt_files_fragment_container, frag)\n+  129:                 .commit();\n+  130:     }\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n @Override\n    public void actionPerformed( ActionEvent e )\n    {\n        JFileChooser jFileChooser = new JFileChooser();\n        jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        jFileChooser.setDialogTitle( \"Select database\" );\n        jFileChooser.setDialogType( CUSTOM_DIALOG );\n\n        while ( true )\n        {\n            int choice = jFileChooser.showOpenDialog( frame );\n\n            if ( choice != APPROVE_OPTION )\n            {\n                return;\n            }\n\n            File selectedFile = jFileChooser.getSelectedFile();\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n                return;\n            }\n            catch ( UnsuitableDirectoryException error )\n            {\n                int result = showWrappedConfirmDialog(\n                        frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n                if ( result == CANCEL_OPTION )\n                {\n                    return;\n                }\n            }\n        }\n    }\n SourceCodeAfterRefactoring:\n@Override\n    public void actionPerformed( ActionEvent e )\n    {\n        File selectedFile = null;\n        boolean cancelled = false;\n        boolean validLocation = false;\n        String os = System.getProperty( \"os.name\" );\n\n        while ( !validLocation && !cancelled )\n        {\n            if ( os.toLowerCase().contains( \"mac\" ) )\n            {\n                selectedFile = macFileSelection();\n            }\n            else\n            {\n                selectedFile = fileSelection();\n            }\n\n            try\n            {\n                model.setDatabaseDirectory( selectedFile );\n                directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n\n                validLocation = true;\n\n                FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n                fileWriter.write( selectedFile.getAbsolutePath() );\n                fileWriter.flush();\n                fileWriter.close();\n            }\n            catch ( UnsuitableDirectoryException ude )\n            {\n                int choice = showWrappedConfirmDialog(\n                        frame,\n                        ude.getMessage() + \"\\nPlease choose a different folder.\",\n                        \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n\n                if ( choice == CANCEL_OPTION )\n                {\n                    cancelled = true;\n                }\n            }\n            catch ( IOException ioe )\n            {\n                System.out.println( \"Error saving DB location\" );\n                System.out.println( ioe );\n            }\n        }\n    }\nprivate File fileSelection()\n    {\n        File selectedFile = null;\n\n        JFileChooser fileChooser = new JFileChooser();\n        fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n        fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n        fileChooser.setDialogTitle( \"Select database\" );\n        fileChooser.setDialogType( CUSTOM_DIALOG );\n\n        int choice = fileChooser.showOpenDialog( frame );\n\n        if ( choice == APPROVE_OPTION )\n        {\n            selectedFile = fileChooser.getSelectedFile();\n        }\n\n        return selectedFile;\n    }\n DiffSourceCode:\n-   50:     @Override\n-   51:     public void actionPerformed( ActionEvent e )\n-   52:     {\n-   53:         JFileChooser jFileChooser = new JFileChooser();\n-   54:         jFileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n-   55:         jFileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n-   56:         jFileChooser.setDialogTitle( \"Select database\" );\n-   57:         jFileChooser.setDialogType( CUSTOM_DIALOG );\n-   58: \n-   59:         while ( true )\n-   60:         {\n-   61:             int choice = jFileChooser.showOpenDialog( frame );\n-   62: \n-   63:             if ( choice != APPROVE_OPTION )\n+   50:         this.model = model;\n+   51:     }\n+   52: \n+   53:     @Override\n+   54:     public void actionPerformed( ActionEvent e )\n+   55:     {\n+   56:         File selectedFile = null;\n+   57:         boolean cancelled = false;\n+   58:         boolean validLocation = false;\n+   59:         String os = System.getProperty( \"os.name\" );\n+   60: \n+   61:         while ( !validLocation && !cancelled )\n+   62:         {\n+   63:             if ( os.toLowerCase().contains( \"mac\" ) )\n    64:             {\n-   65:                 return;\n+   65:                 selectedFile = macFileSelection();\n    66:             }\n-   67: \n-   68:             File selectedFile = jFileChooser.getSelectedFile();\n-   69:             try\n-   70:             {\n-   71:                 model.setDatabaseDirectory( selectedFile );\n-   72:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n-   73:                 return;\n-   74:             }\n-   75:             catch ( UnsuitableDirectoryException error )\n-   76:             {\n-   77:                 int result = showWrappedConfirmDialog(\n-   78:                         frame, error.getMessage() + \"\\nPlease choose a different folder.\",\n-   79:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n-   80:                 if ( result == CANCEL_OPTION )\n-   81:                 {\n-   82:                     return;\n-   83:                 }\n-   84:             }\n-   85:         }\n-   86:     }\n-   87: }\n+   67:             else\n+   68:             {\n+   69:                 selectedFile = fileSelection();\n+   70:             }\n+   71: \n+   72:             try\n+   73:             {\n+   74:                 model.setDatabaseDirectory( selectedFile );\n+   75:                 directoryDisplay.setText( model.getDatabaseDirectory().getAbsolutePath() );\n+   76: \n+   77:                 validLocation = true;\n+   78: \n+   79:                 FileWriter fileWriter = new FileWriter( new File( \".dblocation\" ) );\n+   80:                 fileWriter.write( selectedFile.getAbsolutePath() );\n+   81:                 fileWriter.flush();\n+   82:                 fileWriter.close();\n+   83:             }\n+   84:             catch ( UnsuitableDirectoryException ude )\n+   85:             {\n+   86:                 int choice = showWrappedConfirmDialog(\n+   87:                         frame,\n+   88:                         ude.getMessage() + \"\\nPlease choose a different folder.\",\n+   89:                         \"Invalid folder selected\", OK_CANCEL_OPTION, ERROR_MESSAGE );\n+   90: \n+   91:                 if ( choice == CANCEL_OPTION )\n+   92:                 {\n+   93:                     cancelled = true;\n+   94:                 }\n+   95:             }\n+   96:             catch ( IOException ioe )\n+   97:             {\n+   98:                 System.out.println( \"Error saving DB location\" );\n+   99:                 System.out.println( ioe );\n+  100:             }\n+  101:         }\n+  102:     }\n+  104:     private File fileSelection()\n+  105:     {\n+  106:         File selectedFile = null;\n+  107: \n+  108:         JFileChooser fileChooser = new JFileChooser();\n+  109:         fileChooser.setFileSelectionMode( DIRECTORIES_ONLY );\n+  110:         fileChooser.setCurrentDirectory( new File( directoryDisplay.getText() ) );\n+  111:         fileChooser.setDialogTitle( \"Select database\" );\n+  112:         fileChooser.setDialogType( CUSTOM_DIALOG );\n+  113: \n+  114:         int choice = fileChooser.showOpenDialog( frame );\n+  115: \n+  116:         if ( choice == APPROVE_OPTION )\n+  117:         {\n+  118:             selectedFile = fileChooser.getSelectedFile();\n+  119:         }\n+  120: \n+  121:         return selectedFile;\n+  122:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n @Override\n\tpublic int getItemViewType(int position) {\n\t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t} else {\n\t\t\treturn SENT;\n\t\t}\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\n SourceCodeAfterRefactoring:\n@Override\n\tpublic int getItemViewType(int position) {\n\t\treturn this.getItemViewType(getItem(position));\n\t}\npublic int getItemViewType(Message message) {\n\t\tif (message.getType() == Message.TYPE_STATUS) {\n\t\t\treturn STATUS;\n\t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\treturn RECEIVED;\n\t\t}\n\n\t\treturn SENT;\n\t}\nprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n\t\tif (viewHolder.download_button != null) {\n\t\t\tviewHolder.download_button.setVisibility(View.GONE);\n\t\t}\n\t\tviewHolder.image.setVisibility(View.GONE);\n\t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n\t\tviewHolder.messageBody.setIncludeFontPadding(true);\n\t\tif (message.getBody() != null) {\n\t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n\t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n\t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n\t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n\t\t\twhile(i >= 0) {\n\t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n\t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n\t\t\t}\n\t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t\t} else {\n\t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString privateMarker;\n\t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n\t\t\t\t\tprivateMarker = activity\n\t\t\t\t\t\t.getString(R.string.private_message);\n\t\t\t\t} else {\n\t\t\t\t\tfinal String to;\n\t\t\t\t\tif (message.getCounterpart() != null) {\n\t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n\t\t\t\t}\n\t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n\t\t\t\t\t\t+ formattedBody);\n\t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n\t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n\t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n\t\t\t\t\t\tprivateMarker.length(),\n\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\tif (message.hasMeCommand()) {\n\t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n\t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n\t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n\t\t\t\t}\n\t\t\t\tviewHolder.messageBody.setText(span);\n\t\t\t}\n\t\t} else {\n\t\t\tviewHolder.messageBody.setText(\"\");\n\t\t}\n\t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n\t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n\t\tviewHolder.messageBody.setTextIsSelectable(true);\n\t}\nprivate int getMessageTextColor(Message message) {\n\t\tint type = this.getItemViewType(message);\n\n\t\tif (type == SENT) {\n\t\t\treturn activity.getResources().getColor(R.color.black87);\n\t\t} else if (type == RECEIVED) {\n\t\t\treturn activity.getResources().getColor(R.color.white);\n\t\t}\n\n\t\treturn activity.getPrimaryTextColor();\n\t}\n DiffSourceCode:\n-   84: \t@Override\n-   85: \tpublic int getItemViewType(int position) {\n-   86: \t\tif (getItem(position).getType() == Message.TYPE_STATUS) {\n-   87: \t\t\treturn STATUS;\n-   88: \t\t} else if (getItem(position).getStatus() <= Message.STATUS_RECEIVED) {\n-   89: \t\t\treturn RECEIVED;\n-   90: \t\t} else {\n-   91: \t\t\treturn SENT;\n-   92: \t\t}\n-   93: \t}\n-   94: \n-   95: \tprivate void displayStatus(ViewHolder viewHolder, Message message) {\n-   96: \t\tString filesize = null;\n-   97: \t\tString info = null;\n-   99: \t\tif (viewHolder.indicatorReceived != null) {\n-  100: \t\t\tviewHolder.indicatorReceived.setVisibility(View.GONE);\n-  101: \t\t}\n-  102: \t\tboolean multiReceived = message.getConversation().getMode() == Conversation.MODE_MULTI\n-  103: \t\t\t&& message.getMergedStatus() <= Message.STATUS_RECEIVED;\n-  104: \t\tif (message.getType() == Message.TYPE_IMAGE || message.getType() == Message.TYPE_FILE || message.getTransferable() != null) {\n-  105: \t\t\tFileParams params = message.getFileParams();\n-  106: \t\t\tif (params.size > (1.5 * 1024 * 1024)) {\n-  107: \t\t\t\tfilesize = params.size / (1024 * 1024)+ \" MiB\";\n-  108: \t\t\t} else if (params.size > 0) {\n-  109: \t\t\t\tfilesize = params.size / 1024 + \" KiB\";\n-  239: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n-  240: \t\tif (viewHolder.download_button != null) {\n-  241: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n-  242: \t\t}\n-  243: \t\tviewHolder.image.setVisibility(View.GONE);\n-  244: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n-  245: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n-  246: \t\tif (message.getBody() != null) {\n-  247: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n-  248: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n-  249: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n-  250: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n-  251: \t\t\twhile(i >= 0) {\n-  252: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n-  253: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  254: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n-  255: \t\t\t}\n-  256: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n-  257: \t\t\t\tif (message.hasMeCommand()) {\n-  258: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n-  259: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n-  260: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  261: \t\t\t\t\tviewHolder.messageBody.setText(span);\n-  262: \t\t\t\t} else {\n-  263: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n-  264: \t\t\t\t}\n-  265: \t\t\t} else {\n-  266: \t\t\t\tString privateMarker;\n-  267: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n-  268: \t\t\t\t\tprivateMarker = activity\n-  269: \t\t\t\t\t\t.getString(R.string.private_message);\n-  270: \t\t\t\t} else {\n-  271: \t\t\t\t\tfinal String to;\n-  272: \t\t\t\t\tif (message.getCounterpart() != null) {\n-  273: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n-  274: \t\t\t\t\t} else {\n-  275: \t\t\t\t\t\tto = \"\";\n-  276: \t\t\t\t\t}\n-  277: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n-  278: \t\t\t\t}\n-  279: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n-  280: \t\t\t\t\t\t+ formattedBody);\n-  281: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n-  282: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n-  283: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  284: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n-  285: \t\t\t\t\t\tprivateMarker.length(),\n-  286: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  287: \t\t\t\tif (message.hasMeCommand()) {\n-  288: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n-  289: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n-  290: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n-  291: \t\t\t\t}\n-  292: \t\t\t\tviewHolder.messageBody.setText(span);\n-  293: \t\t\t}\n-  294: \t\t} else {\n-  295: \t\t\tviewHolder.messageBody.setText(\"\");\n-  296: \t\t}\n-  297: \t\tviewHolder.messageBody.setTextColor(activity.getPrimaryTextColor());\n-  298: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n-  299: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n-  300: \t}\n-  301: \n-  302: \tprivate void displayDownloadableMessage(ViewHolder viewHolder,\n-  303: \t\t\tfinal Message message, String text) {\n-  304: \t\tviewHolder.image.setVisibility(View.GONE);\n-  305: \t\tviewHolder.messageBody.setVisibility(View.GONE);\n-  306: \t\tviewHolder.download_button.setVisibility(View.VISIBLE);\n-  307: \t\tviewHolder.download_button.setText(text);\n-  308: \t\tviewHolder.download_button.setOnClickListener(new OnClickListener() {\n-  309: \n-  310: \t\t\t@Override\n-  311: \t\t\tpublic void onClick(View v) {\n-  312: \t\t\t\tstartDownloadable(message);\n-  313: \t\t\t}\n-  314: \t\t});\n-  315: \t\tviewHolder.download_button.setOnLongClickListener(openContextMenu);\n+   84: \tpublic int getItemViewType(Message message) {\n+   85: \t\tif (message.getType() == Message.TYPE_STATUS) {\n+   86: \t\t\treturn STATUS;\n+   87: \t\t} else if (message.getStatus() <= Message.STATUS_RECEIVED) {\n+   88: \t\t\treturn RECEIVED;\n+   89: \t\t}\n+   90: \n+   91: \t\treturn SENT;\n+   92: \t}\n+   93: \n+   94: \t@Override\n+   95: \tpublic int getItemViewType(int position) {\n+   96: \t\treturn this.getItemViewType(getItem(position));\n+   97: \t}\n+   99: \tprivate int getMessageTextColor(Message message) {\n+  100: \t\tint type = this.getItemViewType(message);\n+  101: \n+  102: \t\tif (type == SENT) {\n+  103: \t\t\treturn activity.getResources().getColor(R.color.black87);\n+  104: \t\t} else if (type == RECEIVED) {\n+  105: \t\t\treturn activity.getResources().getColor(R.color.white);\n+  106: \t\t}\n+  107: \n+  108: \t\treturn activity.getPrimaryTextColor();\n+  109: \t}\n+  239: \t\tviewHolder.messageBody.setTextIsSelectable(false);\n+  240: \t}\n+  241: \n+  242: \tprivate void displayHeartMessage(final ViewHolder viewHolder, final String body) {\n+  243: \t\tif (viewHolder.download_button != null) {\n+  244: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  245: \t\t}\n+  246: \t\tviewHolder.image.setVisibility(View.GONE);\n+  247: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  248: \t\tviewHolder.messageBody.setIncludeFontPadding(false);\n+  249: \t\tSpannable span = new SpannableString(body);\n+  250: \t\tspan.setSpan(new RelativeSizeSpan(4.0f), 0, body.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  251: \t\tspan.setSpan(new ForegroundColorSpan(activity.getWarningTextColor()), 0, body.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  252: \t\tviewHolder.messageBody.setText(span);\n+  253: \t}\n+  254: \n+  255: \tprivate void displayTextMessage(final ViewHolder viewHolder, final Message message) {\n+  256: \t\tif (viewHolder.download_button != null) {\n+  257: \t\t\tviewHolder.download_button.setVisibility(View.GONE);\n+  258: \t\t}\n+  259: \t\tviewHolder.image.setVisibility(View.GONE);\n+  260: \t\tviewHolder.messageBody.setVisibility(View.VISIBLE);\n+  261: \t\tviewHolder.messageBody.setIncludeFontPadding(true);\n+  262: \t\tif (message.getBody() != null) {\n+  263: \t\t\tfinal String nick = UIHelper.getMessageDisplayName(message);\n+  264: \t\t\tfinal String body = message.getMergedBody().replaceAll(\"^\" + Message.ME_COMMAND,nick + \" \");\n+  265: \t\t\tfinal SpannableString formattedBody = new SpannableString(body);\n+  266: \t\t\tint i = body.indexOf(Message.MERGE_SEPARATOR);\n+  267: \t\t\twhile(i >= 0) {\n+  268: \t\t\t\tfinal int end = i + Message.MERGE_SEPARATOR.length();\n+  269: \t\t\t\tformattedBody.setSpan(new RelativeSizeSpan(0.3f),i,end,Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  270: \t\t\t\ti = body.indexOf(Message.MERGE_SEPARATOR,end);\n+  271: \t\t\t}\n+  272: \t\t\tif (message.getType() != Message.TYPE_PRIVATE) {\n+  273: \t\t\t\tif (message.hasMeCommand()) {\n+  274: \t\t\t\t\tfinal Spannable span = new SpannableString(formattedBody);\n+  275: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), 0, nick.length(),\n+  276: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  277: \t\t\t\t\tviewHolder.messageBody.setText(span);\n+  278: \t\t\t\t} else {\n+  279: \t\t\t\t\tviewHolder.messageBody.setText(formattedBody);\n+  280: \t\t\t\t}\n+  281: \t\t\t} else {\n+  282: \t\t\t\tString privateMarker;\n+  283: \t\t\t\tif (message.getStatus() <= Message.STATUS_RECEIVED) {\n+  284: \t\t\t\t\tprivateMarker = activity\n+  285: \t\t\t\t\t\t.getString(R.string.private_message);\n+  286: \t\t\t\t} else {\n+  287: \t\t\t\t\tfinal String to;\n+  288: \t\t\t\t\tif (message.getCounterpart() != null) {\n+  289: \t\t\t\t\t\tto = message.getCounterpart().getResourcepart();\n+  290: \t\t\t\t\t} else {\n+  291: \t\t\t\t\t\tto = \"\";\n+  292: \t\t\t\t\t}\n+  293: \t\t\t\t\tprivateMarker = activity.getString(R.string.private_message_to, to);\n+  294: \t\t\t\t}\n+  295: \t\t\t\tfinal Spannable span = new SpannableString(privateMarker + \" \"\n+  296: \t\t\t\t\t\t+ formattedBody);\n+  297: \t\t\t\tspan.setSpan(new ForegroundColorSpan(activity\n+  298: \t\t\t\t\t\t\t.getSecondaryTextColor()), 0, privateMarker\n+  299: \t\t\t\t\t\t.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  300: \t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD), 0,\n+  301: \t\t\t\t\t\tprivateMarker.length(),\n+  302: \t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  303: \t\t\t\tif (message.hasMeCommand()) {\n+  304: \t\t\t\t\tspan.setSpan(new StyleSpan(Typeface.BOLD_ITALIC), privateMarker.length() + 1,\n+  305: \t\t\t\t\t\t\tprivateMarker.length() + 1 + nick.length(),\n+  306: \t\t\t\t\t\t\tSpannable.SPAN_EXCLUSIVE_EXCLUSIVE);\n+  307: \t\t\t\t}\n+  308: \t\t\t\tviewHolder.messageBody.setText(span);\n+  309: \t\t\t}\n+  310: \t\t} else {\n+  311: \t\t\tviewHolder.messageBody.setText(\"\");\n+  312: \t\t}\n+  313: \t\tviewHolder.messageBody.setTextColor(this.getMessageTextColor(message));\n+  314: \t\tviewHolder.messageBody.setTypeface(null, Typeface.NORMAL);\n+  315: \t\tviewHolder.messageBody.setTextIsSelectable(true);\n   316: \t}\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    },
    {
        "url": "https://github.com/mongodb/morphia.git",
        "branch": "master",
        "commitId": "70a25d4afdc435e9cad4460b2a20b7aabdd21e35",
        "sourceCodeBeforeRefactoring": "@Test\n    public void testBasicMapping() throws Exception {\n        final DBCollection hotels = getDb().getCollection(\"hotels\");\n        final DBCollection agencies = getDb().getCollection(\"agencies\");\n\n        getMorphia().map(Hotel.class);\n        getMorphia().map(TravelAgency.class);\n\n        final Hotel borg = new Hotel();\n        borg.setName(\"Hotel Borg\");\n        borg.setStars(4);\n        borg.setTakesCreditCards(true);\n        borg.setStartDate(new Date());\n        borg.setType(Hotel.Type.LEISURE);\n        borg.getTags().add(\"Swimming pool\");\n        borg.getTags().add(\"Room service\");\n        borg.setTemp(\"A temporary transient value\");\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n\n        final Address address = new Address();\n        address.setStreet(\"Posthusstraeti 11\");\n        address.setPostCode(\"101\");\n        borg.setAddress(address);\n\n        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n        assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n\n\n        hotels.save(hotelDbObj);\n\n        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n\n        assertEquals(borg.getName(), borgLoaded.getName());\n        assertEquals(borg.getStars(), borgLoaded.getStars());\n        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n        assertEquals(borg.getType(), borgLoaded.getType());\n        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n        assertEquals(borg.getTags(), borgLoaded.getTags());\n        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n        assertNull(borgLoaded.getTemp());\n        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n        assertNotNull(borgLoaded.getId());\n\n        final TravelAgency agency = new TravelAgency();\n        agency.setName(\"Lastminute.com\");\n        agency.getHotels().add(borgLoaded);\n\n        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n        agencies.save(agencyDbObj);\n\n        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),\n                                                                    new DefaultEntityCache());\n\n        assertEquals(agency.getName(), agencyLoaded.getName());\n        assertEquals(1, agency.getHotels().size());\n        assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n\n        // try clearing values\n        borgLoaded.setAddress(null);\n        borgLoaded.getPhoneNumbers().clear();\n        borgLoaded.setName(null);\n\n        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n        hotels.save(hotelDbObj);\n\n        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n\n        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n        assertNull(borgLoaded.getAddress());\n        assertEquals(0, borgLoaded.getPhoneNumbers().size());\n        assertNull(borgLoaded.getName());\n    }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testBasicMapping() throws Exception {\n    final DBCollection hotels = getDb().getCollection(\"hotels\");\n    final DBCollection agencies = getDb().getCollection(\"agencies\");\n\n    getMorphia().map(Hotel.class);\n    getMorphia().map(TravelAgency.class);\n\n    final Hotel borg = new Hotel();\n    borg.setName(\"Hotel Borg\");\n    borg.setStars(4);\n    borg.setTakesCreditCards(true);\n    borg.setStartDate(new Date());\n    borg.setType(Hotel.Type.LEISURE);\n    borg.getTags().add(\"Swimming pool\");\n    borg.getTags().add(\"Room service\");\n    borg.setTemp(\"A temporary transient value\");\n    borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n    borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n\n    final Address address = new Address();\n    address.setStreet(\"Posthusstraeti 11\");\n    address.setPostCode(\"101\");\n    borg.setAddress(address);\n\n    BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n    assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n\n    hotels.save(hotelDbObj);\n\n    Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n\n    assertEquals(borg.getName(), borgLoaded.getName());\n    assertEquals(borg.getStars(), borgLoaded.getStars());\n    assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n    assertEquals(borg.getType(), borgLoaded.getType());\n    assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n    assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n    assertEquals(borg.getTags(), borgLoaded.getTags());\n    assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n    assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n    assertNull(borgLoaded.getTemp());\n    assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n    assertNotNull(borgLoaded.getId());\n\n    final TravelAgency agency = new TravelAgency();\n    agency.setName(\"Lastminute.com\");\n    agency.getHotels().add(borgLoaded);\n\n    final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n    agencies.save(agencyDbObj);\n\n    final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n                                                                agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n                                                                                                   agencyDbObj.get(Mapper.ID_KEY))),\n                                                                new DefaultEntityCache());\n\n    assertEquals(agency.getName(), agencyLoaded.getName());\n    assertEquals(1, agency.getHotels().size());\n    assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n\n    // try clearing values\n    borgLoaded.setAddress(null);\n    borgLoaded.getPhoneNumbers().clear();\n    borgLoaded.setName(null);\n\n    hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n    hotels.save(hotelDbObj);\n\n    hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n\n    borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n    assertNull(borgLoaded.getAddress());\n    assertEquals(0, borgLoaded.getPhoneNumbers().size());\n    assertNull(borgLoaded.getName());\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testBasicMapping() throws Exception {\n    final DBCollection hotels = getDb().getCollection(\"hotels\");\n    final DBCollection agencies = getDb().getCollection(\"agencies\");\n\n    mapEntities();\n\n    Hotel borg = createHotel();\n    BasicDBObject hotelDbObj = saveHotel(hotels, borg);\n\n    Hotel borgLoaded = loadHotel(hotels, hotelDbObj);\n    assertHotelProperties(borg, borgLoaded);\n\n    TravelAgency agency = createTravelAgency(borgLoaded);\n    saveTravelAgency(agencies, agency);\n\n    TravelAgency agencyLoaded = loadTravelAgency(agencies, agency);\n    assertTravelAgencyProperties(agency, agencyLoaded);\n\n    clearHotelValues(borgLoaded);\n    hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n    hotels.save(hotelDbObj);\n\n    borgLoaded = loadHotel(hotels, hotelDbObj);\n    assertClearedHotelProperties(borgLoaded);\n}\n\nprivate void mapEntities() {\n    getMorphia().map(Hotel.class);\n    getMorphia().map(TravelAgency.class);\n}\n\nprivate Hotel createHotel() {\n    Hotel borg = new Hotel();\n    borg.setName(\"Hotel Borg\");\n    borg.setStars(4);\n    borg.setTakesCreditCards(true);\n    borg.setStartDate(new Date());\n    borg.setType(Hotel.Type.LEISURE);\n    borg.getTags().add(\"Swimming pool\");\n    borg.getTags().add(\"Room service\");\n    borg.setTemp(\"A temporary transient value\");\n    borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n    borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n\n    Address address = new Address();\n    address.setStreet(\"Posthusstraeti 11\");\n    address.setPostCode(\"101\");\n    borg.setAddress(address);\n    return borg;\n}\n\nprivate BasicDBObject saveHotel(DBCollection hotels, Hotel borg) {\n    BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n    assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n    hotels.save(hotelDbObj);\n    return hotelDbObj;\n}\n\nprivate Hotel loadHotel(DBCollection hotels, BasicDBObject hotelDbObj) {\n    return getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n}\n\nprivate void assertHotelProperties(Hotel expected, Hotel actual) {\n    assertEquals(expected.getName(), actual.getName());\n    assertEquals(expected.getStars(), actual.getStars());\n    assertEquals(expected.getStartDate(), actual.getStartDate());\n    assertEquals(expected.getType(), actual.getType());\n    assertEquals(expected.getAddress().getStreet(), actual.getAddress().getStreet());\n    assertEquals(expected.getTags().size(), actual.getTags().size());\n    assertEquals(expected.getTags(), actual.getTags());\n    assertEquals(expected.getPhoneNumbers().size(), actual.getPhoneNumbers().size());\n    assertEquals(expected.getPhoneNumbers().get(1), actual.getPhoneNumbers().get(1));\n    assertNull(actual.getTemp());\n    assertTrue(actual.getPhoneNumbers() instanceof Vector);\n    assertNotNull(actual.getId());\n}\n\nprivate TravelAgency createTravelAgency(Hotel borgLoaded) {\n    TravelAgency agency = new TravelAgency();\n    agency.setName(\"Lastminute.com\");\n    agency.getHotels().add(borgLoaded);\n    return agency;\n}\n\nprivate void saveTravelAgency(DBCollection agencies, TravelAgency agency) {\n    BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n    agencies.save(agencyDbObj);\n}\n\nprivate TravelAgency loadTravelAgency(DBCollection agencies, TravelAgency agency) {\n    return getMorphia().fromDBObject(TravelAgency.class,\n                                      agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n                                                                         agency.getId())),\n                                      new DefaultEntityCache());\n}\n\nprivate void assertTravelAgencyProperties(TravelAgency expected, TravelAgency actual) {\n    assertEquals(expected.getName(), actual.getName());\n    assertEquals(1, expected.getHotels().size());\n    assertEquals(expected.getHotels().get(0).getName(), expected.getHotels().get(0).getName());\n}\n\nprivate void clearHotelValues(Hotel borgLoaded) {\n    borgLoaded.setAddress(null);\n    borgLoaded.getPhoneNumbers().clear();\n    borgLoaded.setName(null);\n}\n\nprivate void assertClearedHotelProperties(Hotel borgLoaded) {\n    assertNull(borgLoaded.getAddress());\n    assertEquals(0, borgLoaded.getPhoneNumbers().size());\n    assertNull(borgLoaded.getName());\n}\n```",
        "sourceCodeAfterRefactoring": "@Test\n    public void testBasicMapping() throws Exception {\n        performBasicMappingTest();\n        assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().isEmpty());\n    }\nprivate void performBasicMappingTest() {\n        final DBCollection hotels = getDb().getCollection(\"hotels\");\n        final DBCollection agencies = getDb().getCollection(\"agencies\");\n\n        getMorphia().map(Hotel.class);\n        getMorphia().map(TravelAgency.class);\n\n        final Hotel borg = new Hotel();\n        borg.setName(\"Hotel Borg\");\n        borg.setStars(4);\n        borg.setTakesCreditCards(true);\n        borg.setStartDate(new Date());\n        borg.setType(Hotel.Type.LEISURE);\n        borg.getTags().add(\"Swimming pool\");\n        borg.getTags().add(\"Room service\");\n        borg.setTemp(\"A temporary transient value\");\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n\n        final Address address = new Address();\n        address.setStreet(\"Posthusstraeti 11\");\n        address.setPostCode(\"101\");\n        borg.setAddress(address);\n\n        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n        assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n\n\n        hotels.save(hotelDbObj);\n\n        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n\n        assertEquals(borg.getName(), borgLoaded.getName());\n        assertEquals(borg.getStars(), borgLoaded.getStars());\n        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n        assertEquals(borg.getType(), borgLoaded.getType());\n        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n        assertEquals(borg.getTags(), borgLoaded.getTags());\n        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n        assertNull(borgLoaded.getTemp());\n        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n        assertNotNull(borgLoaded.getId());\n\n        final TravelAgency agency = new TravelAgency();\n        agency.setName(\"Lastminute.com\");\n        agency.getHotels().add(borgLoaded);\n\n        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n        agencies.save(agencyDbObj);\n\n        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),\n                                                                    new DefaultEntityCache());\n\n        assertEquals(agency.getName(), agencyLoaded.getName());\n        assertEquals(1, agency.getHotels().size());\n        assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n\n        // try clearing values\n        borgLoaded.setAddress(null);\n        borgLoaded.getPhoneNumbers().clear();\n        borgLoaded.setName(null);\n\n        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n        hotels.save(hotelDbObj);\n\n        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n\n        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n        assertNull(borgLoaded.getAddress());\n        assertEquals(0, borgLoaded.getPhoneNumbers().size());\n        assertNull(borgLoaded.getName());\n    }",
        "diffSourceCode": "-  795:     @Test\n-  796:     public void testBasicMapping() throws Exception {\n-  797:         final DBCollection hotels = getDb().getCollection(\"hotels\");\n-  798:         final DBCollection agencies = getDb().getCollection(\"agencies\");\n-  799: \n-  800:         getMorphia().map(Hotel.class);\n-  801:         getMorphia().map(TravelAgency.class);\n-  802: \n-  803:         final Hotel borg = new Hotel();\n-  804:         borg.setName(\"Hotel Borg\");\n-  805:         borg.setStars(4);\n-  806:         borg.setTakesCreditCards(true);\n-  807:         borg.setStartDate(new Date());\n-  808:         borg.setType(Hotel.Type.LEISURE);\n-  809:         borg.getTags().add(\"Swimming pool\");\n-  810:         borg.getTags().add(\"Room service\");\n-  811:         borg.setTemp(\"A temporary transient value\");\n-  812:         borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n-  813:         borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n-  814: \n-  815:         final Address address = new Address();\n-  816:         address.setStreet(\"Posthusstraeti 11\");\n-  817:         address.setPostCode(\"101\");\n-  818:         borg.setAddress(address);\n-  819: \n-  820:         BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n-  821:         assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n-  822: \n-  823: \n-  824:         hotels.save(hotelDbObj);\n-  825: \n-  826:         Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n-  827: \n-  828:         assertEquals(borg.getName(), borgLoaded.getName());\n-  829:         assertEquals(borg.getStars(), borgLoaded.getStars());\n-  830:         assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n-  831:         assertEquals(borg.getType(), borgLoaded.getType());\n-  832:         assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n-  833:         assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n-  834:         assertEquals(borg.getTags(), borgLoaded.getTags());\n-  835:         assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n-  836:         assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n-  837:         assertNull(borgLoaded.getTemp());\n-  838:         assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n-  839:         assertNotNull(borgLoaded.getId());\n+  795: \n+  796:     @Test\n+  797:     public void testBasicMapping() throws Exception {\n+  798:         performBasicMappingTest();\n+  799:         assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().isEmpty());\n+  800:     }\n+  801: \n+  802:     @Test\n+  803:     public void testBasicMappingWithCachedClasses() throws Exception {\n+  804:         getMorphia().getMapper().getOptions().setCacheClassLookups(true);\n+  805:         try {\n+  806:             performBasicMappingTest();\n+  807:             assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().containsKey(Hotel.class.getName()));\n+  808:             assertTrue(((DefaultCreator)getMorphia().getMapper().getOptions().getObjectFactory()).getClassNameCache().containsKey(TravelAgency.class.getName()));\n+  809:         } finally {\n+  810:             getMorphia().getMapper().getOptions().setCacheClassLookups(false);\n+  811:         }\n+  812:     }\n+  813: \n+  814:     private void performBasicMappingTest() {\n+  815:         final DBCollection hotels = getDb().getCollection(\"hotels\");\n+  816:         final DBCollection agencies = getDb().getCollection(\"agencies\");\n+  817: \n+  818:         getMorphia().map(Hotel.class);\n+  819:         getMorphia().map(TravelAgency.class);\n+  820: \n+  821:         final Hotel borg = new Hotel();\n+  822:         borg.setName(\"Hotel Borg\");\n+  823:         borg.setStars(4);\n+  824:         borg.setTakesCreditCards(true);\n+  825:         borg.setStartDate(new Date());\n+  826:         borg.setType(Hotel.Type.LEISURE);\n+  827:         borg.getTags().add(\"Swimming pool\");\n+  828:         borg.getTags().add(\"Room service\");\n+  829:         borg.setTemp(\"A temporary transient value\");\n+  830:         borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n+  831:         borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n+  832: \n+  833:         final Address address = new Address();\n+  834:         address.setStreet(\"Posthusstraeti 11\");\n+  835:         address.setPostCode(\"101\");\n+  836:         borg.setAddress(address);\n+  837: \n+  838:         BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n+  839:         assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n   840: \n-  841:         final TravelAgency agency = new TravelAgency();\n-  842:         agency.setName(\"Lastminute.com\");\n-  843:         agency.getHotels().add(borgLoaded);\n-  844: \n-  845:         final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n-  846:         agencies.save(agencyDbObj);\n-  847: \n-  848:         final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n-  849:                                                                     agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n-  850:                                                                                                        agencyDbObj.get(Mapper.ID_KEY))),\n-  851:                                                                     new DefaultEntityCache());\n-  852: \n-  853:         assertEquals(agency.getName(), agencyLoaded.getName());\n-  854:         assertEquals(1, agency.getHotels().size());\n-  855:         assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n-  856: \n-  857:         // try clearing values\n-  858:         borgLoaded.setAddress(null);\n-  859:         borgLoaded.getPhoneNumbers().clear();\n-  860:         borgLoaded.setName(null);\n-  861: \n-  862:         hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n-  863:         hotels.save(hotelDbObj);\n-  864: \n-  865:         hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n-  866: \n-  867:         borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n-  868:         assertNull(borgLoaded.getAddress());\n-  869:         assertEquals(0, borgLoaded.getPhoneNumbers().size());\n-  870:         assertNull(borgLoaded.getName());\n-  871:     }\n-  872: \n-  873:     @Test\n-  874:     public void testMaps() throws Exception {\n-  875:         final DBCollection articles = getDb().getCollection(\"articles\");\n-  876:         getMorphia().map(Article.class).map(Translation.class).map(Circle.class);\n-  877: \n-  878:         final Article related = new Article();\n-  879:         final BasicDBObject relatedDbObj = (BasicDBObject) getMorphia().toDBObject(related);\n-  880:         articles.save(relatedDbObj);\n-  881: \n-  882:         final Article relatedLoaded = getMorphia().fromDBObject(Article.class,\n-  883:                                                                 articles.findOne(new BasicDBObject(Mapper.ID_KEY,\n-  884:                                                                                                    relatedDbObj.get(Mapper.ID_KEY))),\n-  885:                                                                 new DefaultEntityCache());\n-  886: \n-  887:         final Article article = new Article();\n-  888:         article.setTranslation(\"en\", new Translation(\"Hello World\", \"Just a test\"));\n-  889:         article.setTranslation(\"is\", new Translation(\"Hall\u00f3 heimur\", \"Bara a\u00f0 pr\u00f3fa\"));\n+  841: \n+  842:         hotels.save(hotelDbObj);\n+  843: \n+  844:         Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n+  845: \n+  846:         assertEquals(borg.getName(), borgLoaded.getName());\n+  847:         assertEquals(borg.getStars(), borgLoaded.getStars());\n+  848:         assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n+  849:         assertEquals(borg.getType(), borgLoaded.getType());\n+  850:         assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n+  851:         assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n+  852:         assertEquals(borg.getTags(), borgLoaded.getTags());\n+  853:         assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n+  854:         assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n+  855:         assertNull(borgLoaded.getTemp());\n+  856:         assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n+  857:         assertNotNull(borgLoaded.getId());\n+  858: \n+  859:         final TravelAgency agency = new TravelAgency();\n+  860:         agency.setName(\"Lastminute.com\");\n+  861:         agency.getHotels().add(borgLoaded);\n+  862: \n+  863:         final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n+  864:         agencies.save(agencyDbObj);\n+  865: \n+  866:         final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n+  867:                                                                     agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n+  868:                                                                                                        agencyDbObj.get(Mapper.ID_KEY))),\n+  869:                                                                     new DefaultEntityCache());\n+  870: \n+  871:         assertEquals(agency.getName(), agencyLoaded.getName());\n+  872:         assertEquals(1, agency.getHotels().size());\n+  873:         assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n+  874: \n+  875:         // try clearing values\n+  876:         borgLoaded.setAddress(null);\n+  877:         borgLoaded.getPhoneNumbers().clear();\n+  878:         borgLoaded.setName(null);\n+  879: \n+  880:         hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n+  881:         hotels.save(hotelDbObj);\n+  882: \n+  883:         hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n+  884: \n+  885:         borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n+  886:         assertNull(borgLoaded.getAddress());\n+  887:         assertEquals(0, borgLoaded.getPhoneNumbers().size());\n+  888:         assertNull(borgLoaded.getName());\n+  889:     }\n",
        "uniqueId": "70a25d4afdc435e9cad4460b2a20b7aabdd21e35_795_871_814_889_796_800",
        "historicalRefactorings": "Example 1:\n SourceCodeBeforeRefactoring:\n public void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n\n    Collections.sort(rules, new CategoryComparator());\n\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    // JPanel\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n    treeModel.addTreeModelListener(new TreeModelListener() {\n\n      @Override\n      public void treeNodesChanged(TreeModelEvent e) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n        int index = e.getChildIndices()[0];\n        node = (DefaultMutableTreeNode) node.getChildAt(index);\n        if (node instanceof RuleNode) {\n          RuleNode o = (RuleNode) node;\n          if (o.getRule().isDefaultOff()) {\n            if (o.isEnabled()) {\n              config.getEnabledRuleIds().add(o.getRule().getId());\n            } else {\n              config.getEnabledRuleIds().remove(o.getRule().getId());\n            }\n          } else {\n            if (o.isEnabled()) {\n              config.getDisabledRuleIds().remove(o.getRule().getId());\n            } else {\n              config.getDisabledRuleIds().add(o.getRule().getId());\n            }\n          }\n        }\n        if (node instanceof CategoryNode) {\n          CategoryNode o = (CategoryNode) node;\n          if (o.isEnabled()) {\n            config.getDisabledCategoryNames().remove(o.getCategory().getName());\n          } else {\n            config.getDisabledCategoryNames().add(o.getCategory().getName());\n          }\n        }\n      }\n\n      @Override\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeStructureChanged(TreeModelEvent e) {\n      }\n    });\n    configTree = new JTree(treeModel);\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(\n      ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n\n    MouseAdapter ma = new MouseAdapter() {\n      private void handlePopupEvent(MouseEvent e) {\n        final JTree tree = (JTree) e.getSource();\n\n        TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n        if (path == null) {\n          return;\n        }\n\n        DefaultMutableTreeNode node\n                = (DefaultMutableTreeNode) path.getLastPathComponent();\n\n        TreePath[] paths = tree.getSelectionPaths();\n\n        boolean isSelected = false;\n        if (paths != null) {\n          for (TreePath selectionPath : paths) {\n            if (selectionPath.equals(path)) {\n              isSelected = true;\n            }\n          }\n        }\n        if (!isSelected) {\n          tree.setSelectionPath(path);\n        }\n        if (node.isLeaf()) {\n          JPopupMenu popup = new JPopupMenu();\n          final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n          aboutRuleMenuItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {\n              RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n              Rule rule = node.getRule();\n              Language lang = config.getLanguage();\n              if(lang == null) {\n                lang = Languages.getLanguageForLocale(Locale.getDefault());\n              }\n              Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n                      rule.getDescription(), rule, messages,\n                      lang.getShortNameWithCountryAndVariant());\n            }\n          });\n          popup.add(aboutRuleMenuItem);\n          popup.show(tree, e.getX(), e.getY());\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n    };\n    configTree.addMouseListener(ma);\n    final JPanel treeButtonPanel = new JPanel();\n    cons = new GridBagConstraints();\n    cons.gridx = 0;\n    cons.gridy = 0;\n    final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n    treeButtonPanel.add(expandAllButton, cons);\n    expandAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n          TreeNode n = (TreeNode) cat.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.expandPath(child);\n        }\n      }\n    });\n\n    cons.gridx = 1;\n    cons.gridy = 0;\n    final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n    treeButtonPanel.add(collapseAllButton, cons);\n    collapseAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n          TreeNode n = (TreeNode) categ.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.collapsePath(child);\n        }\n      }\n    });\n\n    final JPanel motherTonguePanel = new JPanel();\n    motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n    motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n    if (config.getMotherTongue() != null) {\n      motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n    }\n    motherTongueBox.addItemListener(new ItemListener() {\n\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        if (e.getStateChange() == ItemEvent.SELECTED) {\n          Language motherTongue;\n          if (motherTongueBox.getSelectedItem() instanceof String) {\n            motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n          } else {\n            motherTongue = (Language) motherTongueBox.getSelectedItem();\n          }\n          config.setMotherTongue(motherTongue);\n        }\n      }\n    });\n    motherTonguePanel.add(motherTongueBox, cons);\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setSelected(config.getRunServer());\n      portPanel.add(serverCheckbox, cons);\n      serverCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n          serverPortField.setEnabled(serverCheckbox.isSelected());\n          serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n        }\n      });\n      serverCheckbox.addItemListener(new ItemListener() {\n\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setRunServer(serverCheckbox.isSelected());\n        }\n      });\n\n      serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n      serverPortField.setEnabled(serverCheckbox.isSelected());\n      serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n      serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n      cons.gridx = 1;\n      portPanel.add(serverPortField, cons);\n      serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n          try {\n            int serverPort = Integer.parseInt(serverPortField.getText());\n            if (serverPort > -1 && serverPort < MAX_PORT) {\n              serverPortField.setForeground(null);\n              config.setServerPort(serverPort);\n            } else {\n              serverPortField.setForeground(Color.RED);\n            }\n          } catch (NumberFormatException ex) {\n            serverPortField.setForeground(Color.RED);\n          }\n        }\n      });\n\n      cons.gridx = 0;\n      cons.gridy = 10;      \n      serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n          .getString(\"useGUIConfig\")));\n      serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n      serverSettingsCheckbox.setEnabled(config.getRunServer());\n      serverSettingsCheckbox.addItemListener(new ItemListener() {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n        }\n      });\n      portPanel.add(serverSettingsCheckbox, cons);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(treeButtonPanel, cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(motherTonguePanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\n SourceCodeAfterRefactoring:\npublic void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    Collections.sort(rules, new CategoryComparator());\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    configTree = new JTree(getTreeModel(rootNode));\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n    configTree.addMouseListener(getMouseAdapter());\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      createNonOfficeElements(cons, portPanel);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(getTreeButtonPanel(), cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(getMotherTonguePanel(cons), cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\nprivate void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n    serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setSelected(config.getRunServer());\n    portPanel.add(serverCheckbox, cons);\n    serverCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n        serverPortField.setEnabled(serverCheckbox.isSelected());\n        serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n      }\n    });\n    serverCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setRunServer(serverCheckbox.isSelected());\n      }\n    });\n\n    serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n    serverPortField.setEnabled(serverCheckbox.isSelected());\n    serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n    serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n    cons.gridx = 1;\n    portPanel.add(serverPortField, cons);\n    serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void changedUpdate(DocumentEvent e) {\n        try {\n          int serverPort = Integer.parseInt(serverPortField.getText());\n          if (serverPort > -1 && serverPort < MAX_PORT) {\n            serverPortField.setForeground(null);\n            config.setServerPort(serverPort);\n          } else {\n            serverPortField.setForeground(Color.RED);\n          }\n        } catch (NumberFormatException ex) {\n          serverPortField.setForeground(Color.RED);\n        }\n      }\n    });\n\n    cons.gridx = 0;\n    cons.gridy = 10;\n    serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n    serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n    serverSettingsCheckbox.setEnabled(config.getRunServer());\n    serverSettingsCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n      }\n    });\n    portPanel.add(serverSettingsCheckbox, cons);\n  }\n DiffSourceCode:\n-  117:   public void show(List<Rule> rules) {\n-  118:     if (original != null) {\n-  119:       config.restoreState(original);\n-  120:     }\n-  121:     dialog = new JDialog(owner, true);\n-  122:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n-  123: \n-  124:     Collections.sort(rules, new CategoryComparator());\n-  125: \n-  126:     // close dialog when user presses Escape key:\n-  127:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n-  128:     final ActionListener actionListener = new ActionListener() {\n-  129:       @Override\n-  130:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n-  131:         dialog.setVisible(false);\n-  132:       }\n-  133:     };\n-  134:     final JRootPane rootPane = dialog.getRootPane();\n-  135:     rootPane.registerKeyboardAction(actionListener, stroke,\n-  136:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n-  137: \n-  138:     // JPanel\n-  139:     final JPanel checkBoxPanel = new JPanel();\n-  140:     checkBoxPanel.setLayout(new GridBagLayout());\n-  141:     GridBagConstraints cons = new GridBagConstraints();\n-  142:     cons.anchor = GridBagConstraints.NORTHWEST;\n-  143:     cons.gridx = 0;\n-  144:     cons.weightx = 1.0;\n-  145:     cons.weighty = 1.0;\n-  146:     cons.fill = GridBagConstraints.BOTH;\n-  147:     DefaultMutableTreeNode rootNode = createTree(rules);\n-  148:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n-  149:     treeModel.addTreeModelListener(new TreeModelListener() {\n-  150: \n-  151:       @Override\n-  152:       public void treeNodesChanged(TreeModelEvent e) {\n-  153:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n-  154:         int index = e.getChildIndices()[0];\n-  155:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n-  156:         if (node instanceof RuleNode) {\n-  157:           RuleNode o = (RuleNode) node;\n-  158:           if (o.getRule().isDefaultOff()) {\n-  159:             if (o.isEnabled()) {\n-  160:               config.getEnabledRuleIds().add(o.getRule().getId());\n-  161:             } else {\n-  162:               config.getEnabledRuleIds().remove(o.getRule().getId());\n-  163:             }\n-  164:           } else {\n-  165:             if (o.isEnabled()) {\n-  166:               config.getDisabledRuleIds().remove(o.getRule().getId());\n-  167:             } else {\n-  168:               config.getDisabledRuleIds().add(o.getRule().getId());\n-  169:             }\n-  170:           }\n-  171:         }\n-  172:         if (node instanceof CategoryNode) {\n-  173:           CategoryNode o = (CategoryNode) node;\n-  174:           if (o.isEnabled()) {\n-  175:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n-  176:           } else {\n-  177:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n-  178:           }\n-  179:         }\n-  180:       }\n-  181: \n-  182:       @Override\n-  183:       public void treeNodesInserted(TreeModelEvent e) {\n-  184:       }\n-  185: \n-  186:       @Override\n-  187:       public void treeNodesRemoved(TreeModelEvent e) {\n-  188:       }\n-  189: \n-  190:       @Override\n-  191:       public void treeStructureChanged(TreeModelEvent e) {\n-  192:       }\n-  193:     });\n-  194:     configTree = new JTree(treeModel);\n-  195: \n-  196:     Language lang = config.getLanguage();\n-  197:     if (lang == null) {\n-  198:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  199:     }\n-  200:     configTree.applyComponentOrientation(\n-  201:       ComponentOrientation.getOrientation(lang.getLocale()));\n-  202: \n-  203:     configTree.setRootVisible(false);\n-  204:     configTree.setEditable(false);\n-  205:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n-  206:     TreeListener.install(configTree);\n-  207:     checkBoxPanel.add(configTree, cons);\n-  208: \n-  209:     MouseAdapter ma = new MouseAdapter() {\n-  210:       private void handlePopupEvent(MouseEvent e) {\n-  211:         final JTree tree = (JTree) e.getSource();\n-  212: \n-  213:         TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n-  214:         if (path == null) {\n-  215:           return;\n-  216:         }\n-  217: \n-  218:         DefaultMutableTreeNode node\n-  219:                 = (DefaultMutableTreeNode) path.getLastPathComponent();\n-  220: \n-  221:         TreePath[] paths = tree.getSelectionPaths();\n-  222: \n-  223:         boolean isSelected = false;\n-  224:         if (paths != null) {\n-  225:           for (TreePath selectionPath : paths) {\n-  226:             if (selectionPath.equals(path)) {\n-  227:               isSelected = true;\n-  228:             }\n-  229:           }\n-  230:         }\n-  231:         if (!isSelected) {\n-  232:           tree.setSelectionPath(path);\n-  233:         }\n-  234:         if (node.isLeaf()) {\n-  235:           JPopupMenu popup = new JPopupMenu();\n-  236:           final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n-  237:           aboutRuleMenuItem.addActionListener(new ActionListener() {\n-  238:             @Override\n-  239:             public void actionPerformed(ActionEvent actionEvent) {\n-  240:               RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n-  241:               Rule rule = node.getRule();\n-  242:               Language lang = config.getLanguage();\n-  243:               if(lang == null) {\n-  244:                 lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  245:               }\n-  246:               Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n-  247:                       rule.getDescription(), rule, messages,\n-  248:                       lang.getShortNameWithCountryAndVariant());\n-  249:             }\n-  250:           });\n-  251:           popup.add(aboutRuleMenuItem);\n-  252:           popup.show(tree, e.getX(), e.getY());\n-  253:         }\n-  254:       }\n-  255: \n-  256:       @Override\n-  257:       public void mousePressed(MouseEvent e) {\n-  258:         if (e.isPopupTrigger()) {\n-  259:           handlePopupEvent(e);\n-  260:         }\n-  261:       }\n-  262: \n-  263:       @Override\n-  264:       public void mouseReleased(MouseEvent e) {\n-  265:         if (e.isPopupTrigger()) {\n-  266:           handlePopupEvent(e);\n-  267:         }\n-  268:       }\n-  269:     };\n-  270:     configTree.addMouseListener(ma);\n-  271:     final JPanel treeButtonPanel = new JPanel();\n-  272:     cons = new GridBagConstraints();\n-  273:     cons.gridx = 0;\n-  274:     cons.gridy = 0;\n-  275:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n-  276:     treeButtonPanel.add(expandAllButton, cons);\n-  277:     expandAllButton.addActionListener(new ActionListener() {\n-  278: \n-  279:       @Override\n-  280:       public void actionPerformed(ActionEvent e) {\n-  281:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  282:         TreePath parent = new TreePath(root);\n-  283:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n-  284:           TreeNode n = (TreeNode) cat.nextElement();\n-  285:           TreePath child = parent.pathByAddingChild(n);\n-  286:           configTree.expandPath(child);\n-  287:         }\n-  288:       }\n-  289:     });\n-  290: \n-  291:     cons.gridx = 1;\n-  292:     cons.gridy = 0;\n-  293:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n-  294:     treeButtonPanel.add(collapseAllButton, cons);\n-  295:     collapseAllButton.addActionListener(new ActionListener() {\n-  296: \n-  297:       @Override\n-  298:       public void actionPerformed(ActionEvent e) {\n-  299:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  300:         TreePath parent = new TreePath(root);\n-  301:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n-  302:           TreeNode n = (TreeNode) categ.nextElement();\n-  303:           TreePath child = parent.pathByAddingChild(n);\n-  304:           configTree.collapsePath(child);\n-  305:         }\n-  306:       }\n-  307:     });\n-  308: \n-  309:     final JPanel motherTonguePanel = new JPanel();\n-  310:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n-  311:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n-  312:     if (config.getMotherTongue() != null) {\n-  313:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n-  314:     }\n-  315:     motherTongueBox.addItemListener(new ItemListener() {\n-  316: \n-  317:       @Override\n-  318:       public void itemStateChanged(ItemEvent e) {\n-  319:         if (e.getStateChange() == ItemEvent.SELECTED) {\n-  320:           Language motherTongue;\n-  321:           if (motherTongueBox.getSelectedItem() instanceof String) {\n-  322:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  117: \n+  118:   public void show(List<Rule> rules) {\n+  119:     if (original != null) {\n+  120:       config.restoreState(original);\n+  121:     }\n+  122:     dialog = new JDialog(owner, true);\n+  123:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n+  124:     // close dialog when user presses Escape key:\n+  125:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n+  126:     final ActionListener actionListener = new ActionListener() {\n+  127:       @Override\n+  128:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n+  129:         dialog.setVisible(false);\n+  130:       }\n+  131:     };\n+  132:     final JRootPane rootPane = dialog.getRootPane();\n+  133:     rootPane.registerKeyboardAction(actionListener, stroke,\n+  134:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n+  135: \n+  136:     final JPanel checkBoxPanel = new JPanel();\n+  137:     checkBoxPanel.setLayout(new GridBagLayout());\n+  138:     GridBagConstraints cons = new GridBagConstraints();\n+  139:     cons.anchor = GridBagConstraints.NORTHWEST;\n+  140:     cons.gridx = 0;\n+  141:     cons.weightx = 1.0;\n+  142:     cons.weighty = 1.0;\n+  143:     cons.fill = GridBagConstraints.BOTH;\n+  144:     Collections.sort(rules, new CategoryComparator());\n+  145:     DefaultMutableTreeNode rootNode = createTree(rules);\n+  146:     configTree = new JTree(getTreeModel(rootNode));\n+  147: \n+  148:     Language lang = config.getLanguage();\n+  149:     if (lang == null) {\n+  150:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  151:     }\n+  152:     configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n+  153: \n+  154:     configTree.setRootVisible(false);\n+  155:     configTree.setEditable(false);\n+  156:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n+  157:     TreeListener.install(configTree);\n+  158:     checkBoxPanel.add(configTree, cons);\n+  159:     configTree.addMouseListener(getMouseAdapter());\n+  160:     \n+  161:     final JPanel portPanel = new JPanel();\n+  162:     portPanel.setLayout(new GridBagLayout());\n+  163:     cons = new GridBagConstraints();\n+  164:     cons.insets = new Insets(0, 4, 0, 0);\n+  165:     cons.gridx = 0;\n+  166:     cons.gridy = 0;\n+  167:     cons.anchor = GridBagConstraints.WEST;\n+  168:     cons.fill = GridBagConstraints.NONE;\n+  169:     cons.weightx = 0.0f;\n+  170:     if (!insideOffice) {\n+  171:       createNonOfficeElements(cons, portPanel);\n+  172:     }\n+  173: \n+  174:     final JPanel buttonPanel = new JPanel();\n+  175:     buttonPanel.setLayout(new GridBagLayout());\n+  176:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n+  177:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n+  178:     okButton.addActionListener(this);\n+  179:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n+  180:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n+  181:     cancelButton.addActionListener(this);\n+  182:     cons = new GridBagConstraints();\n+  183:     cons.insets = new Insets(0, 4, 0, 0);\n+  184:     buttonPanel.add(okButton, cons);\n+  185:     buttonPanel.add(cancelButton, cons);\n+  186: \n+  187:     final Container contentPane = dialog.getContentPane();\n+  188:     contentPane.setLayout(new GridBagLayout());\n+  189:     cons = new GridBagConstraints();\n+  190:     cons.insets = new Insets(4, 4, 4, 4);\n+  191:     cons.gridx = 0;\n+  192:     cons.gridy = 0;\n+  193:     cons.weightx = 10.0f;\n+  194:     cons.weighty = 10.0f;\n+  195:     cons.fill = GridBagConstraints.BOTH;\n+  196:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n+  197: \n+  198:     cons.gridx = 0;\n+  199:     cons.gridy++;\n+  200:     cons.fill = GridBagConstraints.NONE;\n+  201:     cons.anchor = GridBagConstraints.LINE_END;\n+  202:     contentPane.add(getTreeButtonPanel(), cons);\n+  203:     \n+  204:     cons.gridy++;\n+  205:     cons.anchor = GridBagConstraints.WEST;\n+  206:     contentPane.add(getMotherTonguePanel(cons), cons);\n+  207: \n+  208:     cons.gridy++;\n+  209:     cons.anchor = GridBagConstraints.WEST;\n+  210:     contentPane.add(portPanel, cons);\n+  211: \n+  212:     cons.gridy++;\n+  213:     cons.anchor = GridBagConstraints.EAST;\n+  214:     contentPane.add(buttonPanel, cons);\n+  215: \n+  216:     dialog.pack();\n+  217:     dialog.setSize(500, 500);\n+  218:     // center on screen:\n+  219:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+  220:     final Dimension frameSize = dialog.getSize();\n+  221:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n+  222:         screenSize.height / 2 - frameSize.height / 2);\n+  223:     dialog.setLocationByPlatform(true);\n+  224:     dialog.setVisible(true);\n+  225:   }\n+  226: \n+  227:   private void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n+  228:     serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n+  229:     serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n+  230:     serverCheckbox.setSelected(config.getRunServer());\n+  231:     portPanel.add(serverCheckbox, cons);\n+  232:     serverCheckbox.addActionListener(new ActionListener() {\n+  233:       @Override\n+  234:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n+  235:         serverPortField.setEnabled(serverCheckbox.isSelected());\n+  236:         serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n+  237:       }\n+  238:     });\n+  239:     serverCheckbox.addItemListener(new ItemListener() {\n+  240:       @Override\n+  241:       public void itemStateChanged(ItemEvent e) {\n+  242:         config.setRunServer(serverCheckbox.isSelected());\n+  243:       }\n+  244:     });\n+  245: \n+  246:     serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n+  247:     serverPortField.setEnabled(serverCheckbox.isSelected());\n+  248:     serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n+  249:     serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n+  250:     cons.gridx = 1;\n+  251:     portPanel.add(serverPortField, cons);\n+  252:     serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n+  253: \n+  254:       @Override\n+  255:       public void insertUpdate(DocumentEvent e) {\n+  256:         changedUpdate(e);\n+  257:       }\n+  258: \n+  259:       @Override\n+  260:       public void removeUpdate(DocumentEvent e) {\n+  261:         changedUpdate(e);\n+  262:       }\n+  263: \n+  264:       @Override\n+  265:       public void changedUpdate(DocumentEvent e) {\n+  266:         try {\n+  267:           int serverPort = Integer.parseInt(serverPortField.getText());\n+  268:           if (serverPort > -1 && serverPort < MAX_PORT) {\n+  269:             serverPortField.setForeground(null);\n+  270:             config.setServerPort(serverPort);\n+  271:           } else {\n+  272:             serverPortField.setForeground(Color.RED);\n+  273:           }\n+  274:         } catch (NumberFormatException ex) {\n+  275:           serverPortField.setForeground(Color.RED);\n+  276:         }\n+  277:       }\n+  278:     });\n+  279: \n+  280:     cons.gridx = 0;\n+  281:     cons.gridy = 10;\n+  282:     serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n+  283:     serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n+  284:     serverSettingsCheckbox.setEnabled(config.getRunServer());\n+  285:     serverSettingsCheckbox.addItemListener(new ItemListener() {\n+  286:       @Override\n+  287:       public void itemStateChanged(ItemEvent e) {\n+  288:         config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n+  289:       }\n+  290:     });\n+  291:     portPanel.add(serverSettingsCheckbox, cons);\n+  292:   }\n+  293: \n+  294:   @NotNull\n+  295:   private DefaultTreeModel getTreeModel(DefaultMutableTreeNode rootNode) {\n+  296:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n+  297:     treeModel.addTreeModelListener(new TreeModelListener() {\n+  298:       @Override\n+  299:       public void treeNodesChanged(TreeModelEvent e) {\n+  300:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n+  301:         int index = e.getChildIndices()[0];\n+  302:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n+  303:         if (node instanceof RuleNode) {\n+  304:           RuleNode o = (RuleNode) node;\n+  305:           if (o.getRule().isDefaultOff()) {\n+  306:             if (o.isEnabled()) {\n+  307:               config.getEnabledRuleIds().add(o.getRule().getId());\n+  308:             } else {\n+  309:               config.getEnabledRuleIds().remove(o.getRule().getId());\n+  310:             }\n+  311:           } else {\n+  312:             if (o.isEnabled()) {\n+  313:               config.getDisabledRuleIds().remove(o.getRule().getId());\n+  314:             } else {\n+  315:               config.getDisabledRuleIds().add(o.getRule().getId());\n+  316:             }\n+  317:           }\n+  318:         }\n+  319:         if (node instanceof CategoryNode) {\n+  320:           CategoryNode o = (CategoryNode) node;\n+  321:           if (o.isEnabled()) {\n+  322:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n   323:           } else {\n-  324:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  324:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n   325:           }\n-  326:           config.setMotherTongue(motherTongue);\n-  327:         }\n-  328:       }\n-  329:     });\n-  330:     motherTonguePanel.add(motherTongueBox, cons);\n-  331:     \n-  332:     final JPanel portPanel = new JPanel();\n-  333:     portPanel.setLayout(new GridBagLayout());\n-  334:     cons = new GridBagConstraints();\n-  335:     cons.insets = new Insets(0, 4, 0, 0);\n-  336:     cons.gridx = 0;\n-  337:     cons.gridy = 0;\n-  338:     cons.anchor = GridBagConstraints.WEST;\n-  339:     cons.fill = GridBagConstraints.NONE;\n-  340:     cons.weightx = 0.0f;\n-  341:     if (!insideOffice) {\n-  342:       serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n-  343:       serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n-  344:       serverCheckbox.setSelected(config.getRunServer());\n-  345:       portPanel.add(serverCheckbox, cons);\n-  346:       serverCheckbox.addActionListener(new ActionListener() {\n-  347:         @Override\n-  348:         public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n-  349:           serverPortField.setEnabled(serverCheckbox.isSelected());\n-  350:           serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n-  351:         }\n-  352:       });\n-  353:       serverCheckbox.addItemListener(new ItemListener() {\n-  354: \n-  355:         @Override\n-  356:         public void itemStateChanged(ItemEvent e) {\n-  357:           config.setRunServer(serverCheckbox.isSelected());\n-  358:         }\n-  359:       });\n-  360: \n-  361:       serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n-  362:       serverPortField.setEnabled(serverCheckbox.isSelected());\n-  363:       serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n-  364:       serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n-  365:       cons.gridx = 1;\n-  366:       portPanel.add(serverPortField, cons);\n-  367:       serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n-  368: \n-  369:         @Override\n-  370:         public void insertUpdate(DocumentEvent e) {\n-  371:           changedUpdate(e);\n-  372:         }\n-  373: \n-  374:         @Override\n-  375:         public void removeUpdate(DocumentEvent e) {\n-  376:           changedUpdate(e);\n-  377:         }\n-  378: \n-  379:         @Override\n-  380:         public void changedUpdate(DocumentEvent e) {\n-  381:           try {\n-  382:             int serverPort = Integer.parseInt(serverPortField.getText());\n-  383:             if (serverPort > -1 && serverPort < MAX_PORT) {\n-  384:               serverPortField.setForeground(null);\n-  385:               config.setServerPort(serverPort);\n-  386:             } else {\n-  387:               serverPortField.setForeground(Color.RED);\n-  388:             }\n-  389:           } catch (NumberFormatException ex) {\n-  390:             serverPortField.setForeground(Color.RED);\n-  391:           }\n-  392:         }\n-  393:       });\n-  394: \n-  395:       cons.gridx = 0;\n-  396:       cons.gridy = 10;      \n-  397:       serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n-  398:           .getString(\"useGUIConfig\")));\n-  399:       serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n-  400:       serverSettingsCheckbox.setEnabled(config.getRunServer());\n-  401:       serverSettingsCheckbox.addItemListener(new ItemListener() {\n-  402:         @Override\n-  403:         public void itemStateChanged(ItemEvent e) {\n-  404:           config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n-  405:         }\n-  406:       });\n-  407:       portPanel.add(serverSettingsCheckbox, cons);\n-  408:     }\n+  326:         }\n+  327:       }\n+  328:       @Override\n+  329:       public void treeNodesInserted(TreeModelEvent e) {}\n+  330:       @Override\n+  331:       public void treeNodesRemoved(TreeModelEvent e) {}\n+  332:       @Override\n+  333:       public void treeStructureChanged(TreeModelEvent e) {}\n+  334:     });\n+  335:     return treeModel;\n+  336:   }\n+  337: \n+  338:   @NotNull\n+  339:   private MouseAdapter getMouseAdapter() {\n+  340:     return new MouseAdapter() {\n+  341:         private void handlePopupEvent(MouseEvent e) {\n+  342:           final JTree tree = (JTree) e.getSource();\n+  343:           TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n+  344:           if (path == null) {\n+  345:             return;\n+  346:           }\n+  347:           DefaultMutableTreeNode node\n+  348:                   = (DefaultMutableTreeNode) path.getLastPathComponent();\n+  349:           TreePath[] paths = tree.getSelectionPaths();\n+  350:           boolean isSelected = false;\n+  351:           if (paths != null) {\n+  352:             for (TreePath selectionPath : paths) {\n+  353:               if (selectionPath.equals(path)) {\n+  354:                 isSelected = true;\n+  355:               }\n+  356:             }\n+  357:           }\n+  358:           if (!isSelected) {\n+  359:             tree.setSelectionPath(path);\n+  360:           }\n+  361:           if (node.isLeaf()) {\n+  362:             JPopupMenu popup = new JPopupMenu();\n+  363:             final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n+  364:             aboutRuleMenuItem.addActionListener(new ActionListener() {\n+  365:               @Override\n+  366:               public void actionPerformed(ActionEvent actionEvent) {\n+  367:                 RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n+  368:                 Rule rule = node.getRule();\n+  369:                 Language lang = config.getLanguage();\n+  370:                 if(lang == null) {\n+  371:                   lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  372:                 }\n+  373:                 Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n+  374:                         rule.getDescription(), rule, messages,\n+  375:                         lang.getShortNameWithCountryAndVariant());\n+  376:               }\n+  377:             });\n+  378:             popup.add(aboutRuleMenuItem);\n+  379:             popup.show(tree, e.getX(), e.getY());\n+  380:           }\n+  381:         }\n+  382:   \n+  383:         @Override\n+  384:         public void mousePressed(MouseEvent e) {\n+  385:           if (e.isPopupTrigger()) {\n+  386:             handlePopupEvent(e);\n+  387:           }\n+  388:         }\n+  389:   \n+  390:         @Override\n+  391:         public void mouseReleased(MouseEvent e) {\n+  392:           if (e.isPopupTrigger()) {\n+  393:             handlePopupEvent(e);\n+  394:           }\n+  395:         }\n+  396:       };\n+  397:   }\n+  398: \n+  399:   @NotNull\n+  400:   private JPanel getTreeButtonPanel() {\n+  401:     GridBagConstraints cons;\n+  402:     final JPanel treeButtonPanel = new JPanel();\n+  403:     cons = new GridBagConstraints();\n+  404:     cons.gridx = 0;\n+  405:     cons.gridy = 0;\n+  406:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n+  407:     treeButtonPanel.add(expandAllButton, cons);\n+  408:     expandAllButton.addActionListener(new ActionListener() {\n   409: \n-  410:     final JPanel buttonPanel = new JPanel();\n-  411:     buttonPanel.setLayout(new GridBagLayout());\n-  412:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n-  413:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n-  414:     okButton.addActionListener(this);\n-  415:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n-  416:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n-  417:     cancelButton.addActionListener(this);\n-  418:     cons = new GridBagConstraints();\n-  419:     cons.insets = new Insets(0, 4, 0, 0);\n-  420:     buttonPanel.add(okButton, cons);\n-  421:     buttonPanel.add(cancelButton, cons);\n-  422: \n-  423:     final Container contentPane = dialog.getContentPane();\n-  424:     contentPane.setLayout(new GridBagLayout());\n-  425:     cons = new GridBagConstraints();\n-  426:     cons.insets = new Insets(4, 4, 4, 4);\n-  427:     cons.gridx = 0;\n-  428:     cons.gridy = 0;\n-  429:     cons.weightx = 10.0f;\n-  430:     cons.weighty = 10.0f;\n-  431:     cons.fill = GridBagConstraints.BOTH;\n-  432:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n-  433: \n-  434:     cons.gridx = 0;\n-  435:     cons.gridy++;\n-  436:     cons.fill = GridBagConstraints.NONE;\n-  437:     cons.anchor = GridBagConstraints.LINE_END;\n-  438:     contentPane.add(treeButtonPanel, cons);\n-  439:     \n-  440:     cons.gridy++;\n-  441:     cons.anchor = GridBagConstraints.WEST;\n-  442:     contentPane.add(motherTonguePanel, cons);\n-  443: \n-  444:     cons.gridy++;\n-  445:     cons.anchor = GridBagConstraints.WEST;\n-  446:     contentPane.add(portPanel, cons);\n-  447: \n-  448:     cons.gridy++;\n-  449:     cons.anchor = GridBagConstraints.EAST;\n-  450:     contentPane.add(buttonPanel, cons);\n+  410:       @Override\n+  411:       public void actionPerformed(ActionEvent e) {\n+  412:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  413:         TreePath parent = new TreePath(root);\n+  414:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n+  415:           TreeNode n = (TreeNode) cat.nextElement();\n+  416:           TreePath child = parent.pathByAddingChild(n);\n+  417:           configTree.expandPath(child);\n+  418:         }\n+  419:       }\n+  420:     });\n+  421: \n+  422:     cons.gridx = 1;\n+  423:     cons.gridy = 0;\n+  424:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n+  425:     treeButtonPanel.add(collapseAllButton, cons);\n+  426:     collapseAllButton.addActionListener(new ActionListener() {\n+  427: \n+  428:       @Override\n+  429:       public void actionPerformed(ActionEvent e) {\n+  430:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  431:         TreePath parent = new TreePath(root);\n+  432:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n+  433:           TreeNode n = (TreeNode) categ.nextElement();\n+  434:           TreePath child = parent.pathByAddingChild(n);\n+  435:           configTree.collapsePath(child);\n+  436:         }\n+  437:       }\n+  438:     });\n+  439:     return treeButtonPanel;\n+  440:   }\n+  441: \n+  442:   @NotNull\n+  443:   private JPanel getMotherTonguePanel(GridBagConstraints cons) {\n+  444:     final JPanel motherTonguePanel = new JPanel();\n+  445:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n+  446:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n+  447:     if (config.getMotherTongue() != null) {\n+  448:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n+  449:     }\n+  450:     motherTongueBox.addItemListener(new ItemListener() {\n   451: \n-  452:     dialog.pack();\n-  453:     dialog.setSize(500, 500);\n-  454:     // center on screen:\n-  455:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-  456:     final Dimension frameSize = dialog.getSize();\n-  457:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n-  458:         screenSize.height / 2 - frameSize.height / 2);\n-  459:     dialog.setLocationByPlatform(true);\n-  460:     dialog.setVisible(true);\n-  461:   }\n+  452:       @Override\n+  453:       public void itemStateChanged(ItemEvent e) {\n+  454:         if (e.getStateChange() == ItemEvent.SELECTED) {\n+  455:           Language motherTongue;\n+  456:           if (motherTongueBox.getSelectedItem() instanceof String) {\n+  457:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  458:           } else {\n+  459:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  460:           }\n+  461:           config.setMotherTongue(motherTongue);\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientInSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new ClientOutSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientOutSelector\",\n                Logger.getLogger(ClientOutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketOptions = networkConfig.getSocketOptions();\n        ClientExtension clientExtension = client.getClientExtension();\n        socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n    }\n@Override\n    public synchronized void start() {\n        if (alive) {\n            return;\n        }\n        alive = true;\n        inSelector.start();\n        outSelector.start();\n        HeartBeat heartBeat = new HeartBeat();\n        executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n    }\n@Override\n    public synchronized void shutdown() {\n        if (!alive) {\n            return;\n        }\n        alive = false;\n        for (ClientConnection connection : connections.values()) {\n            connection.close();\n        }\n        inSelector.shutdown();\n        outSelector.shutdown();\n        connectionLockMap.clear();\n        connectionListeners.clear();\n        heartbeatListeners.clear();\n    }\n SourceCodeAfterRefactoring:\npublic ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n\n        initializeSelectors(client);\n\n        socketOptions = networkConfig.getSocketOptions();\n        ClientExtension clientExtension = client.getClientExtension();\n        socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n    }\nprotected void initializeSelectors(HazelcastClientInstanceImpl client) {\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientInSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new ClientOutSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientOutSelector\",\n                Logger.getLogger(ClientOutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n    }\n@Override\n    public synchronized void start() {\n        if (alive) {\n            return;\n        }\n        alive = true;\n        startSelectors();\n        HeartBeat heartBeat = new HeartBeat();\n        executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n    }\nprotected void startSelectors() {\n        inSelector.start();\n        outSelector.start();\n    }\n@Override\n    public synchronized void shutdown() {\n        if (!alive) {\n            return;\n        }\n        alive = false;\n        for (ClientConnection connection : connections.values()) {\n            connection.close();\n        }\n        shutdownSelectors();\n        connectionLockMap.clear();\n        connectionListeners.clear();\n        heartbeatListeners.clear();\n    }\nprotected void shutdownSelectors() {\n        inSelector.shutdown();\n        outSelector.shutdown();\n    }\n DiffSourceCode:\n   102:     public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n   103:                                        AddressTranslator addressTranslator) {\n   104:         this.client = client;\n   105:         this.addressTranslator = addressTranslator;\n   106:         final ClientConfig config = client.getClientConfig();\n   107:         final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n   108: \n   109:         final int connTimeout = networkConfig.getConnectionTimeout();\n   110:         connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n   111: \n   112:         final ClientProperties clientProperties = client.getClientProperties();\n   113:         int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n   114:         this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n   115: \n   116:         int interval = clientProperties.getHeartbeatInterval().getInteger();\n   117:         heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n   118: \n   119:         executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n   120: \n-  121:         inSelector = new InSelectorImpl(\n-  122:                 client.getThreadGroup(),\n-  123:                 client.getName() + \".ClientInSelector\",\n-  124:                 Logger.getLogger(InSelectorImpl.class),\n-  125:                 OUT_OF_MEMORY_HANDLER);\n-  126:         outSelector = new ClientOutSelectorImpl(\n-  127:                 client.getThreadGroup(),\n-  128:                 client.getName() + \".ClientOutSelector\",\n-  129:                 Logger.getLogger(ClientOutSelectorImpl.class),\n-  130:                 OUT_OF_MEMORY_HANDLER);\n-  131: \n-  132:         socketOptions = networkConfig.getSocketOptions();\n-  133:         ClientExtension clientExtension = client.getClientExtension();\n-  134:         socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n-  135:         socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n-  136:     }\n-  137: \n-  138: \n-  139:     private SocketInterceptor initSocketInterceptor(SocketInterceptorConfig sic) {\n-  140:         if (sic != null && sic.isEnabled()) {\n-  152:     @Override\n-  153:     public synchronized void start() {\n-  154:         if (alive) {\n-  155:             return;\n-  156:         }\n-  157:         alive = true;\n-  158:         inSelector.start();\n-  159:         outSelector.start();\n-  160:         HeartBeat heartBeat = new HeartBeat();\n-  161:         executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n-  162:     }\n-  163: \n-  164:     @Override\n-  165:     public synchronized void shutdown() {\n-  166:         if (!alive) {\n-  167:             return;\n-  168:         }\n-  169:         alive = false;\n-  170:         for (ClientConnection connection : connections.values()) {\n-  171:             connection.close();\n-  172:         }\n-  173:         inSelector.shutdown();\n-  174:         outSelector.shutdown();\n-  175:         connectionLockMap.clear();\n-  176:         connectionListeners.clear();\n-  177:         heartbeatListeners.clear();\n-  178:     }\n-  179: \n-  180:     public ClientConnection getConnection(Address target) {\n-  181:         return connections.get(target);\n-  182:     }\n-  183: \n-  184:     public ClientConnection getOrConnect(Address target, Authenticator authenticator) throws IOException {\n-  185:         Address address = addressTranslator.translate(target);\n-  187:         if (address == null) {\n-  188:             throw new IOException(\"Address is required!\");\n-  189:         }\n-  190: \n+  121:         initializeSelectors(client);\n+  122: \n+  123:         socketOptions = networkConfig.getSocketOptions();\n+  124:         ClientExtension clientExtension = client.getClientExtension();\n+  125:         socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n+  126:         socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n+  127:     }\n+  128: \n+  129:     protected void initializeSelectors(HazelcastClientInstanceImpl client) {\n+  130:         inSelector = new InSelectorImpl(\n+  131:                 client.getThreadGroup(),\n+  132:                 client.getName() + \".ClientInSelector\",\n+  133:                 Logger.getLogger(InSelectorImpl.class),\n+  134:                 OUT_OF_MEMORY_HANDLER);\n+  135:         outSelector = new ClientOutSelectorImpl(\n+  136:                 client.getThreadGroup(),\n+  137:                 client.getName() + \".ClientOutSelector\",\n+  138:                 Logger.getLogger(ClientOutSelectorImpl.class),\n+  139:                 OUT_OF_MEMORY_HANDLER);\n+  140:     }\n+  152:     public boolean isAlive() {\n+  153:         return alive;\n+  154:     }\n+  155: \n+  156:     @Override\n+  157:     public synchronized void start() {\n+  158:         if (alive) {\n+  159:             return;\n+  160:         }\n+  161:         alive = true;\n+  162:         startSelectors();\n+  163:         HeartBeat heartBeat = new HeartBeat();\n+  164:         executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n+  165:     }\n+  166: \n+  167:     protected void startSelectors() {\n+  168:         inSelector.start();\n+  169:         outSelector.start();\n+  170:     }\n+  171: \n+  172:     @Override\n+  173:     public synchronized void shutdown() {\n+  174:         if (!alive) {\n+  175:             return;\n+  176:         }\n+  177:         alive = false;\n+  178:         for (ClientConnection connection : connections.values()) {\n+  179:             connection.close();\n+  180:         }\n+  181:         shutdownSelectors();\n+  182:         connectionLockMap.clear();\n+  183:         connectionListeners.clear();\n+  184:         heartbeatListeners.clear();\n+  185:     }\n+  187:     protected void shutdownSelectors() {\n+  188:         inSelector.shutdown();\n+  189:         outSelector.shutdown();\n+  190:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n @Test\n    public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertFalse( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( A );\n            tx.success();\n        }\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"A\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( B );\n            tx.success();\n        }\n        // and rotating the log (which implies flushing)\n        checkPoint( db );\n        // and creating another node after it\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( C );\n            tx.success();\n        }\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n            // in the stats\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"B\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n\n        // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n        final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n        assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n\n        final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n        int labelId = holder.getIdByName( C.name() );\n        assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n\n        db.shutdown();\n    }\n SourceCodeAfterRefactoring:\n@Test\n    public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertFalse( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n    }\nprivate CountsTracker createCountsTracker(PageCache pageCache)\n    {\n        return new CountsTracker( NullLogProvider.getInstance(), fs, pageCache, emptyConfig,\n                new File( dir.getPath(), COUNTS_STORE_BASE ) );\n    }\n@Test\n    public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( A );\n            tx.success();\n        }\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"A\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( B );\n            tx.success();\n        }\n        // and rotating the log (which implies flushing)\n        checkPoint( db );\n        // and creating another node after it\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( C );\n            tx.success();\n        }\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n            // in the stats\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"B\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n\n        // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n        final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n        assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n\n        final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n        int labelId = holder.getIdByName( C.name() );\n        assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n\n        db.shutdown();\n    }\n DiffSourceCode:\n-   62:     @Test\n-   63:     public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n-   64:     {\n-   65:         // GIVEN\n-   66:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-   67: \n-   68:         // WHEN\n-   69:         db.shutdown();\n-   70: \n-   71:         // THEN\n-   72:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-   73:         assertFalse( fs.fileExists( betaStoreFile() ) );\n-   74: \n-   75:         try ( Lifespan life = new Lifespan() )\n-   76:         {\n-   77:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-   78:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n+   62: {\n+   63:     @Test\n+   64:     public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n+   65:     {\n+   66:         // GIVEN\n+   67:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+   68: \n+   69:         // WHEN\n+   70:         db.shutdown();\n+   71: \n+   72:         // THEN\n+   73:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+   74:         assertFalse( fs.fileExists( betaStoreFile() ) );\n+   75: \n+   76:         try ( Lifespan life = new Lifespan() )\n+   77:         {\n+   78:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n    79:             assertEquals( BASE_TX_ID, store.txId() );\n    80:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n    81:             assertEquals( 0, store.totalEntriesStored() );\n    82:             assertEquals( 0, allRecords( store ).size() );\n    83:         }\n    84: \n    85:         try ( Lifespan life = new Lifespan() )\n    86:         {\n-   87:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-   88:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-   89:             assertEquals( BASE_TX_ID, store.txId() );\n-   90:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-   91:             assertEquals( 0, store.totalEntriesStored() );\n-   92:             assertEquals( 0, allRecords( store ).size() );\n-   93:         }\n-   94:     }\n-   95: \n-   96:     @Test\n-   97:     public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n-   98:     {\n-   99:         // GIVEN\n-  100:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-  101:         try ( Transaction tx = db.beginTx() )\n-  102:         {\n-  103:             db.createNode( A );\n-  104:             tx.success();\n-  105:         }\n-  106: \n-  107:         // WHEN\n-  108:         db.shutdown();\n-  109: \n-  110:         // THEN\n-  111:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-  112:         assertTrue( fs.fileExists( betaStoreFile() ) );\n-  113: \n-  114:         try ( Lifespan life = new Lifespan() )\n-  115:         {\n-  116:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-  117:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-  118:             // a transaction for creating the label and a transaction for the node\n-  119:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n-  120:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-  121:             // one for all nodes and one for the created \"A\" label\n-  122:             assertEquals( 1 + 1, store.totalEntriesStored() );\n-  123:             assertEquals( 1 + 1, allRecords( store ).size() );\n-  124:         }\n-  125:     }\n-  126: \n-  127:     @Test\n-  128:     public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n-  129:     {\n-  130:         // GIVEN\n-  131:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-  132: \n-  133:         // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n-  134:         try ( Transaction tx = db.beginTx() )\n-  135:         {\n-  136:             db.createNode( B );\n-  137:             tx.success();\n-  138:         }\n-  139:         // and rotating the log (which implies flushing)\n-  140:         checkPoint( db );\n-  141:         // and creating another node after it\n-  142:         try ( Transaction tx = db.beginTx() )\n-  143:         {\n-  144:             db.createNode( C );\n-  145:             tx.success();\n-  146:         }\n-  147: \n-  148:         // THEN\n-  149:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-  150:         assertTrue( fs.fileExists( betaStoreFile() ) );\n-  151: \n-  152:         final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n-  153:         try ( Lifespan life = new Lifespan() )\n-  154:         {\n-  155:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-  156:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-  157:             // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n-  158:             // in the stats\n-  159:             // a transaction for creating the label and a transaction for the node\n-  160:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n-  161:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-  162:             // one for all nodes and one for the created \"B\" label\n-  163:             assertEquals( 1 + 1, store.totalEntriesStored() );\n-  164:             assertEquals( 1 + 1, allRecords( store ).size() );\n-  165:         }\n-  166: \n-  167:         // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n-  168:         final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n-  169:         assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n-  170: \n-  171:         final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n-  172:         int labelId = holder.getIdByName( C.name() );\n-  173:         assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n+   87:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+   88:             assertEquals( BASE_TX_ID, store.txId() );\n+   89:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+   90:             assertEquals( 0, store.totalEntriesStored() );\n+   91:             assertEquals( 0, allRecords( store ).size() );\n+   92:         }\n+   93:     }\n+   94: \n+   95:     @Test\n+   96:     public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n+   97:     {\n+   98:         // GIVEN\n+   99:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+  100:         try ( Transaction tx = db.beginTx() )\n+  101:         {\n+  102:             db.createNode( A );\n+  103:             tx.success();\n+  104:         }\n+  105: \n+  106:         // WHEN\n+  107:         db.shutdown();\n+  108: \n+  109:         // THEN\n+  110:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+  111:         assertTrue( fs.fileExists( betaStoreFile() ) );\n+  112: \n+  113:         try ( Lifespan life = new Lifespan() )\n+  114:         {\n+  115:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+  116:             // a transaction for creating the label and a transaction for the node\n+  117:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n+  118:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+  119:             // one for all nodes and one for the created \"A\" label\n+  120:             assertEquals( 1 + 1, store.totalEntriesStored() );\n+  121:             assertEquals( 1 + 1, allRecords( store ).size() );\n+  122:         }\n+  123:     }\n+  124: \n+  125:     @Test\n+  126:     public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n+  127:     {\n+  128:         // GIVEN\n+  129:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+  130: \n+  131:         // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n+  132:         try ( Transaction tx = db.beginTx() )\n+  133:         {\n+  134:             db.createNode( B );\n+  135:             tx.success();\n+  136:         }\n+  137:         // and rotating the log (which implies flushing)\n+  138:         checkPoint( db );\n+  139:         // and creating another node after it\n+  140:         try ( Transaction tx = db.beginTx() )\n+  141:         {\n+  142:             db.createNode( C );\n+  143:             tx.success();\n+  144:         }\n+  145: \n+  146:         // THEN\n+  147:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+  148:         assertTrue( fs.fileExists( betaStoreFile() ) );\n+  149: \n+  150:         final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n+  151:         try ( Lifespan life = new Lifespan() )\n+  152:         {\n+  153:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+  154:             // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n+  155:             // in the stats\n+  156:             // a transaction for creating the label and a transaction for the node\n+  157:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n+  158:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+  159:             // one for all nodes and one for the created \"B\" label\n+  160:             assertEquals( 1 + 1, store.totalEntriesStored() );\n+  161:             assertEquals( 1 + 1, allRecords( store ).size() );\n+  162:         }\n+  163: \n+  164:         // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n+  165:         final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n+  166:         assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n+  167: \n+  168:         final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n+  169:         int labelId = holder.getIdByName( C.name() );\n+  170:         assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n+  171: \n+  172:         db.shutdown();\n+  173:     }\n   174: \n-  175:         db.shutdown();\n-  176:     }\n-  177: \n-  178:     private void checkPoint( GraphDatabaseAPI db ) throws IOException\n-  179:     {\n+  175:     private CountsTracker createCountsTracker(PageCache pageCache)\n+  176:     {\n+  177:         return new CountsTracker( NullLogProvider.getInstance(), fs, pageCache, emptyConfig,\n+  178:                 new File( dir.getPath(), COUNTS_STORE_BASE ) );\n+  179:     }\n\n",
        "contextDescription": "PackageName: org.mongodb.morphia\nClassName: org.mongodb.morphia.TestMapping\nMethodName: org.mongodb.morphia.TestMapping#testBasicMapping\n ClassSignature: public class TestMapping extends TestBase \nInvokedMethod: methodSignature: org.mongodb.morphia.TestMapping.BaseEntity#getId\n methodBody: public String getId() {\nreturn id.toString();\n}",
        "prompt": "Task: You are an expert software engineer. You are given a large or complex method that contains multiple responsibilities. The objective is to refactor this method by extracting smaller, cohesive methods that represent distinct tasks. This refactoring will improve code readability, maintainability, and modularity.\n\nUse a Chain-of-Thought approach to refactor the code:\n1. Analyze the provided method to identify logical code blocks that can be grouped into smaller, independent methods. Each block should perform a specific, well-defined task.\n2. Reference historical refactorings: We have provided examples of code before and after method extraction refactoring, as well as the extracted methods between them. Use these historical examples as a reference when performing method extraction in the current code. This will help you maintain consistency in naming conventions, method structure, and overall refactoring approach.\n3. Create new methods for the identified blocks, ensuring each new method has a meaningful name that describes its functionality. Pass any necessary arguments from the original method.\n4. Replace the original code blocks in the provided method with calls to the newly created methods. Ensure the original method now acts as a higher-level orchestrator.\n5. Ensure code correctness by keeping the functionality unchanged, and that the refactored method still performs as intended.\n\nThe source code provided for refactoring is as follows:\n@Test\n    public void testBasicMapping() throws Exception {\n        final DBCollection hotels = getDb().getCollection(\"hotels\");\n        final DBCollection agencies = getDb().getCollection(\"agencies\");\n\n        getMorphia().map(Hotel.class);\n        getMorphia().map(TravelAgency.class);\n\n        final Hotel borg = new Hotel();\n        borg.setName(\"Hotel Borg\");\n        borg.setStars(4);\n        borg.setTakesCreditCards(true);\n        borg.setStartDate(new Date());\n        borg.setType(Hotel.Type.LEISURE);\n        borg.getTags().add(\"Swimming pool\");\n        borg.getTags().add(\"Room service\");\n        borg.setTemp(\"A temporary transient value\");\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152233, PhoneNumber.Type.PHONE));\n        borg.getPhoneNumbers().add(new PhoneNumber(354, 5152244, PhoneNumber.Type.FAX));\n\n        final Address address = new Address();\n        address.setStreet(\"Posthusstraeti 11\");\n        address.setPostCode(\"101\");\n        borg.setAddress(address);\n\n        BasicDBObject hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borg);\n        assertTrue(!(((DBObject) ((List) hotelDbObj.get(\"phoneNumbers\")).get(0)).containsField(Mapper.CLASS_NAME_FIELDNAME)));\n\n\n        hotels.save(hotelDbObj);\n\n        Hotel borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n\n        assertEquals(borg.getName(), borgLoaded.getName());\n        assertEquals(borg.getStars(), borgLoaded.getStars());\n        assertEquals(borg.getStartDate(), borgLoaded.getStartDate());\n        assertEquals(borg.getType(), borgLoaded.getType());\n        assertEquals(borg.getAddress().getStreet(), borgLoaded.getAddress().getStreet());\n        assertEquals(borg.getTags().size(), borgLoaded.getTags().size());\n        assertEquals(borg.getTags(), borgLoaded.getTags());\n        assertEquals(borg.getPhoneNumbers().size(), borgLoaded.getPhoneNumbers().size());\n        assertEquals(borg.getPhoneNumbers().get(1), borgLoaded.getPhoneNumbers().get(1));\n        assertNull(borgLoaded.getTemp());\n        assertTrue(borgLoaded.getPhoneNumbers() instanceof Vector);\n        assertNotNull(borgLoaded.getId());\n\n        final TravelAgency agency = new TravelAgency();\n        agency.setName(\"Lastminute.com\");\n        agency.getHotels().add(borgLoaded);\n\n        final BasicDBObject agencyDbObj = (BasicDBObject) getMorphia().toDBObject(agency);\n        agencies.save(agencyDbObj);\n\n        final TravelAgency agencyLoaded = getMorphia().fromDBObject(TravelAgency.class,\n                                                                    agencies.findOne(new BasicDBObject(Mapper.ID_KEY,\n                                                                                                       agencyDbObj.get(Mapper.ID_KEY))),\n                                                                    new DefaultEntityCache());\n\n        assertEquals(agency.getName(), agencyLoaded.getName());\n        assertEquals(1, agency.getHotels().size());\n        assertEquals(agency.getHotels().get(0).getName(), borg.getName());\n\n        // try clearing values\n        borgLoaded.setAddress(null);\n        borgLoaded.getPhoneNumbers().clear();\n        borgLoaded.setName(null);\n\n        hotelDbObj = (BasicDBObject) getMorphia().toDBObject(borgLoaded);\n        hotels.save(hotelDbObj);\n\n        hotelDbObj = (BasicDBObject) hotels.findOne(new BasicDBObject(Mapper.ID_KEY, hotelDbObj.get(Mapper.ID_KEY)));\n\n        borgLoaded = getMorphia().fromDBObject(Hotel.class, hotelDbObj, new DefaultEntityCache());\n        assertNull(borgLoaded.getAddress());\n        assertEquals(0, borgLoaded.getPhoneNumbers().size());\n        assertNull(borgLoaded.getName());\n    }\n\nThe context of the source code is as follows:\nPackageName: org.mongodb.morphia\nClassName: org.mongodb.morphia.TestMapping\nMethodName: org.mongodb.morphia.TestMapping#testBasicMapping\n ClassSignature: public class TestMapping extends TestBase \nInvokedMethod: methodSignature: org.mongodb.morphia.TestMapping.BaseEntity#getId\n methodBody: public String getId() {\nreturn id.toString();\n}\n\nExample of Historical Refactorings:\nExample 1:\n SourceCodeBeforeRefactoring:\n public void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n\n    Collections.sort(rules, new CategoryComparator());\n\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    // JPanel\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n    treeModel.addTreeModelListener(new TreeModelListener() {\n\n      @Override\n      public void treeNodesChanged(TreeModelEvent e) {\n        DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n        int index = e.getChildIndices()[0];\n        node = (DefaultMutableTreeNode) node.getChildAt(index);\n        if (node instanceof RuleNode) {\n          RuleNode o = (RuleNode) node;\n          if (o.getRule().isDefaultOff()) {\n            if (o.isEnabled()) {\n              config.getEnabledRuleIds().add(o.getRule().getId());\n            } else {\n              config.getEnabledRuleIds().remove(o.getRule().getId());\n            }\n          } else {\n            if (o.isEnabled()) {\n              config.getDisabledRuleIds().remove(o.getRule().getId());\n            } else {\n              config.getDisabledRuleIds().add(o.getRule().getId());\n            }\n          }\n        }\n        if (node instanceof CategoryNode) {\n          CategoryNode o = (CategoryNode) node;\n          if (o.isEnabled()) {\n            config.getDisabledCategoryNames().remove(o.getCategory().getName());\n          } else {\n            config.getDisabledCategoryNames().add(o.getCategory().getName());\n          }\n        }\n      }\n\n      @Override\n      public void treeNodesInserted(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeNodesRemoved(TreeModelEvent e) {\n      }\n\n      @Override\n      public void treeStructureChanged(TreeModelEvent e) {\n      }\n    });\n    configTree = new JTree(treeModel);\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(\n      ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n\n    MouseAdapter ma = new MouseAdapter() {\n      private void handlePopupEvent(MouseEvent e) {\n        final JTree tree = (JTree) e.getSource();\n\n        TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n        if (path == null) {\n          return;\n        }\n\n        DefaultMutableTreeNode node\n                = (DefaultMutableTreeNode) path.getLastPathComponent();\n\n        TreePath[] paths = tree.getSelectionPaths();\n\n        boolean isSelected = false;\n        if (paths != null) {\n          for (TreePath selectionPath : paths) {\n            if (selectionPath.equals(path)) {\n              isSelected = true;\n            }\n          }\n        }\n        if (!isSelected) {\n          tree.setSelectionPath(path);\n        }\n        if (node.isLeaf()) {\n          JPopupMenu popup = new JPopupMenu();\n          final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n          aboutRuleMenuItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {\n              RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n              Rule rule = node.getRule();\n              Language lang = config.getLanguage();\n              if(lang == null) {\n                lang = Languages.getLanguageForLocale(Locale.getDefault());\n              }\n              Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n                      rule.getDescription(), rule, messages,\n                      lang.getShortNameWithCountryAndVariant());\n            }\n          });\n          popup.add(aboutRuleMenuItem);\n          popup.show(tree, e.getX(), e.getY());\n        }\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n        if (e.isPopupTrigger()) {\n          handlePopupEvent(e);\n        }\n      }\n    };\n    configTree.addMouseListener(ma);\n    final JPanel treeButtonPanel = new JPanel();\n    cons = new GridBagConstraints();\n    cons.gridx = 0;\n    cons.gridy = 0;\n    final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n    treeButtonPanel.add(expandAllButton, cons);\n    expandAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n          TreeNode n = (TreeNode) cat.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.expandPath(child);\n        }\n      }\n    });\n\n    cons.gridx = 1;\n    cons.gridy = 0;\n    final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n    treeButtonPanel.add(collapseAllButton, cons);\n    collapseAllButton.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        TreeNode root = (TreeNode) configTree.getModel().getRoot();\n        TreePath parent = new TreePath(root);\n        for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n          TreeNode n = (TreeNode) categ.nextElement();\n          TreePath child = parent.pathByAddingChild(n);\n          configTree.collapsePath(child);\n        }\n      }\n    });\n\n    final JPanel motherTonguePanel = new JPanel();\n    motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n    motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n    if (config.getMotherTongue() != null) {\n      motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n    }\n    motherTongueBox.addItemListener(new ItemListener() {\n\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        if (e.getStateChange() == ItemEvent.SELECTED) {\n          Language motherTongue;\n          if (motherTongueBox.getSelectedItem() instanceof String) {\n            motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n          } else {\n            motherTongue = (Language) motherTongueBox.getSelectedItem();\n          }\n          config.setMotherTongue(motherTongue);\n        }\n      }\n    });\n    motherTonguePanel.add(motherTongueBox, cons);\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n      serverCheckbox.setSelected(config.getRunServer());\n      portPanel.add(serverCheckbox, cons);\n      serverCheckbox.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n          serverPortField.setEnabled(serverCheckbox.isSelected());\n          serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n        }\n      });\n      serverCheckbox.addItemListener(new ItemListener() {\n\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setRunServer(serverCheckbox.isSelected());\n        }\n      });\n\n      serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n      serverPortField.setEnabled(serverCheckbox.isSelected());\n      serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n      serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n      cons.gridx = 1;\n      portPanel.add(serverPortField, cons);\n      serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n          changedUpdate(e);\n        }\n\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n          try {\n            int serverPort = Integer.parseInt(serverPortField.getText());\n            if (serverPort > -1 && serverPort < MAX_PORT) {\n              serverPortField.setForeground(null);\n              config.setServerPort(serverPort);\n            } else {\n              serverPortField.setForeground(Color.RED);\n            }\n          } catch (NumberFormatException ex) {\n            serverPortField.setForeground(Color.RED);\n          }\n        }\n      });\n\n      cons.gridx = 0;\n      cons.gridy = 10;      \n      serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n          .getString(\"useGUIConfig\")));\n      serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n      serverSettingsCheckbox.setEnabled(config.getRunServer());\n      serverSettingsCheckbox.addItemListener(new ItemListener() {\n        @Override\n        public void itemStateChanged(ItemEvent e) {\n          config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n        }\n      });\n      portPanel.add(serverSettingsCheckbox, cons);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(treeButtonPanel, cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(motherTonguePanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\n SourceCodeAfterRefactoring:\npublic void show(List<Rule> rules) {\n    if (original != null) {\n      config.restoreState(original);\n    }\n    dialog = new JDialog(owner, true);\n    dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n    // close dialog when user presses Escape key:\n    final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n    final ActionListener actionListener = new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n        dialog.setVisible(false);\n      }\n    };\n    final JRootPane rootPane = dialog.getRootPane();\n    rootPane.registerKeyboardAction(actionListener, stroke,\n        JComponent.WHEN_IN_FOCUSED_WINDOW);\n\n    final JPanel checkBoxPanel = new JPanel();\n    checkBoxPanel.setLayout(new GridBagLayout());\n    GridBagConstraints cons = new GridBagConstraints();\n    cons.anchor = GridBagConstraints.NORTHWEST;\n    cons.gridx = 0;\n    cons.weightx = 1.0;\n    cons.weighty = 1.0;\n    cons.fill = GridBagConstraints.BOTH;\n    Collections.sort(rules, new CategoryComparator());\n    DefaultMutableTreeNode rootNode = createTree(rules);\n    configTree = new JTree(getTreeModel(rootNode));\n\n    Language lang = config.getLanguage();\n    if (lang == null) {\n      lang = Languages.getLanguageForLocale(Locale.getDefault());\n    }\n    configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n\n    configTree.setRootVisible(false);\n    configTree.setEditable(false);\n    configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n    TreeListener.install(configTree);\n    checkBoxPanel.add(configTree, cons);\n    configTree.addMouseListener(getMouseAdapter());\n    \n    final JPanel portPanel = new JPanel();\n    portPanel.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.anchor = GridBagConstraints.WEST;\n    cons.fill = GridBagConstraints.NONE;\n    cons.weightx = 0.0f;\n    if (!insideOffice) {\n      createNonOfficeElements(cons, portPanel);\n    }\n\n    final JPanel buttonPanel = new JPanel();\n    buttonPanel.setLayout(new GridBagLayout());\n    okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n    okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n    okButton.addActionListener(this);\n    cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n    cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n    cancelButton.addActionListener(this);\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(0, 4, 0, 0);\n    buttonPanel.add(okButton, cons);\n    buttonPanel.add(cancelButton, cons);\n\n    final Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new GridBagLayout());\n    cons = new GridBagConstraints();\n    cons.insets = new Insets(4, 4, 4, 4);\n    cons.gridx = 0;\n    cons.gridy = 0;\n    cons.weightx = 10.0f;\n    cons.weighty = 10.0f;\n    cons.fill = GridBagConstraints.BOTH;\n    contentPane.add(new JScrollPane(checkBoxPanel), cons);\n\n    cons.gridx = 0;\n    cons.gridy++;\n    cons.fill = GridBagConstraints.NONE;\n    cons.anchor = GridBagConstraints.LINE_END;\n    contentPane.add(getTreeButtonPanel(), cons);\n    \n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(getMotherTonguePanel(cons), cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.WEST;\n    contentPane.add(portPanel, cons);\n\n    cons.gridy++;\n    cons.anchor = GridBagConstraints.EAST;\n    contentPane.add(buttonPanel, cons);\n\n    dialog.pack();\n    dialog.setSize(500, 500);\n    // center on screen:\n    final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n    final Dimension frameSize = dialog.getSize();\n    dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n        screenSize.height / 2 - frameSize.height / 2);\n    dialog.setLocationByPlatform(true);\n    dialog.setVisible(true);\n  }\nprivate void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n    serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n    serverCheckbox.setSelected(config.getRunServer());\n    portPanel.add(serverCheckbox, cons);\n    serverCheckbox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n        serverPortField.setEnabled(serverCheckbox.isSelected());\n        serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n      }\n    });\n    serverCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setRunServer(serverCheckbox.isSelected());\n      }\n    });\n\n    serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n    serverPortField.setEnabled(serverCheckbox.isSelected());\n    serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n    serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n    cons.gridx = 1;\n    portPanel.add(serverPortField, cons);\n    serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        changedUpdate(e);\n      }\n\n      @Override\n      public void changedUpdate(DocumentEvent e) {\n        try {\n          int serverPort = Integer.parseInt(serverPortField.getText());\n          if (serverPort > -1 && serverPort < MAX_PORT) {\n            serverPortField.setForeground(null);\n            config.setServerPort(serverPort);\n          } else {\n            serverPortField.setForeground(Color.RED);\n          }\n        } catch (NumberFormatException ex) {\n          serverPortField.setForeground(Color.RED);\n        }\n      }\n    });\n\n    cons.gridx = 0;\n    cons.gridy = 10;\n    serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n    serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n    serverSettingsCheckbox.setEnabled(config.getRunServer());\n    serverSettingsCheckbox.addItemListener(new ItemListener() {\n      @Override\n      public void itemStateChanged(ItemEvent e) {\n        config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n      }\n    });\n    portPanel.add(serverSettingsCheckbox, cons);\n  }\n DiffSourceCode:\n-  117:   public void show(List<Rule> rules) {\n-  118:     if (original != null) {\n-  119:       config.restoreState(original);\n-  120:     }\n-  121:     dialog = new JDialog(owner, true);\n-  122:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n-  123: \n-  124:     Collections.sort(rules, new CategoryComparator());\n-  125: \n-  126:     // close dialog when user presses Escape key:\n-  127:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n-  128:     final ActionListener actionListener = new ActionListener() {\n-  129:       @Override\n-  130:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n-  131:         dialog.setVisible(false);\n-  132:       }\n-  133:     };\n-  134:     final JRootPane rootPane = dialog.getRootPane();\n-  135:     rootPane.registerKeyboardAction(actionListener, stroke,\n-  136:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n-  137: \n-  138:     // JPanel\n-  139:     final JPanel checkBoxPanel = new JPanel();\n-  140:     checkBoxPanel.setLayout(new GridBagLayout());\n-  141:     GridBagConstraints cons = new GridBagConstraints();\n-  142:     cons.anchor = GridBagConstraints.NORTHWEST;\n-  143:     cons.gridx = 0;\n-  144:     cons.weightx = 1.0;\n-  145:     cons.weighty = 1.0;\n-  146:     cons.fill = GridBagConstraints.BOTH;\n-  147:     DefaultMutableTreeNode rootNode = createTree(rules);\n-  148:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n-  149:     treeModel.addTreeModelListener(new TreeModelListener() {\n-  150: \n-  151:       @Override\n-  152:       public void treeNodesChanged(TreeModelEvent e) {\n-  153:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n-  154:         int index = e.getChildIndices()[0];\n-  155:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n-  156:         if (node instanceof RuleNode) {\n-  157:           RuleNode o = (RuleNode) node;\n-  158:           if (o.getRule().isDefaultOff()) {\n-  159:             if (o.isEnabled()) {\n-  160:               config.getEnabledRuleIds().add(o.getRule().getId());\n-  161:             } else {\n-  162:               config.getEnabledRuleIds().remove(o.getRule().getId());\n-  163:             }\n-  164:           } else {\n-  165:             if (o.isEnabled()) {\n-  166:               config.getDisabledRuleIds().remove(o.getRule().getId());\n-  167:             } else {\n-  168:               config.getDisabledRuleIds().add(o.getRule().getId());\n-  169:             }\n-  170:           }\n-  171:         }\n-  172:         if (node instanceof CategoryNode) {\n-  173:           CategoryNode o = (CategoryNode) node;\n-  174:           if (o.isEnabled()) {\n-  175:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n-  176:           } else {\n-  177:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n-  178:           }\n-  179:         }\n-  180:       }\n-  181: \n-  182:       @Override\n-  183:       public void treeNodesInserted(TreeModelEvent e) {\n-  184:       }\n-  185: \n-  186:       @Override\n-  187:       public void treeNodesRemoved(TreeModelEvent e) {\n-  188:       }\n-  189: \n-  190:       @Override\n-  191:       public void treeStructureChanged(TreeModelEvent e) {\n-  192:       }\n-  193:     });\n-  194:     configTree = new JTree(treeModel);\n-  195: \n-  196:     Language lang = config.getLanguage();\n-  197:     if (lang == null) {\n-  198:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  199:     }\n-  200:     configTree.applyComponentOrientation(\n-  201:       ComponentOrientation.getOrientation(lang.getLocale()));\n-  202: \n-  203:     configTree.setRootVisible(false);\n-  204:     configTree.setEditable(false);\n-  205:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n-  206:     TreeListener.install(configTree);\n-  207:     checkBoxPanel.add(configTree, cons);\n-  208: \n-  209:     MouseAdapter ma = new MouseAdapter() {\n-  210:       private void handlePopupEvent(MouseEvent e) {\n-  211:         final JTree tree = (JTree) e.getSource();\n-  212: \n-  213:         TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n-  214:         if (path == null) {\n-  215:           return;\n-  216:         }\n-  217: \n-  218:         DefaultMutableTreeNode node\n-  219:                 = (DefaultMutableTreeNode) path.getLastPathComponent();\n-  220: \n-  221:         TreePath[] paths = tree.getSelectionPaths();\n-  222: \n-  223:         boolean isSelected = false;\n-  224:         if (paths != null) {\n-  225:           for (TreePath selectionPath : paths) {\n-  226:             if (selectionPath.equals(path)) {\n-  227:               isSelected = true;\n-  228:             }\n-  229:           }\n-  230:         }\n-  231:         if (!isSelected) {\n-  232:           tree.setSelectionPath(path);\n-  233:         }\n-  234:         if (node.isLeaf()) {\n-  235:           JPopupMenu popup = new JPopupMenu();\n-  236:           final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n-  237:           aboutRuleMenuItem.addActionListener(new ActionListener() {\n-  238:             @Override\n-  239:             public void actionPerformed(ActionEvent actionEvent) {\n-  240:               RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n-  241:               Rule rule = node.getRule();\n-  242:               Language lang = config.getLanguage();\n-  243:               if(lang == null) {\n-  244:                 lang = Languages.getLanguageForLocale(Locale.getDefault());\n-  245:               }\n-  246:               Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n-  247:                       rule.getDescription(), rule, messages,\n-  248:                       lang.getShortNameWithCountryAndVariant());\n-  249:             }\n-  250:           });\n-  251:           popup.add(aboutRuleMenuItem);\n-  252:           popup.show(tree, e.getX(), e.getY());\n-  253:         }\n-  254:       }\n-  255: \n-  256:       @Override\n-  257:       public void mousePressed(MouseEvent e) {\n-  258:         if (e.isPopupTrigger()) {\n-  259:           handlePopupEvent(e);\n-  260:         }\n-  261:       }\n-  262: \n-  263:       @Override\n-  264:       public void mouseReleased(MouseEvent e) {\n-  265:         if (e.isPopupTrigger()) {\n-  266:           handlePopupEvent(e);\n-  267:         }\n-  268:       }\n-  269:     };\n-  270:     configTree.addMouseListener(ma);\n-  271:     final JPanel treeButtonPanel = new JPanel();\n-  272:     cons = new GridBagConstraints();\n-  273:     cons.gridx = 0;\n-  274:     cons.gridy = 0;\n-  275:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n-  276:     treeButtonPanel.add(expandAllButton, cons);\n-  277:     expandAllButton.addActionListener(new ActionListener() {\n-  278: \n-  279:       @Override\n-  280:       public void actionPerformed(ActionEvent e) {\n-  281:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  282:         TreePath parent = new TreePath(root);\n-  283:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n-  284:           TreeNode n = (TreeNode) cat.nextElement();\n-  285:           TreePath child = parent.pathByAddingChild(n);\n-  286:           configTree.expandPath(child);\n-  287:         }\n-  288:       }\n-  289:     });\n-  290: \n-  291:     cons.gridx = 1;\n-  292:     cons.gridy = 0;\n-  293:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n-  294:     treeButtonPanel.add(collapseAllButton, cons);\n-  295:     collapseAllButton.addActionListener(new ActionListener() {\n-  296: \n-  297:       @Override\n-  298:       public void actionPerformed(ActionEvent e) {\n-  299:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n-  300:         TreePath parent = new TreePath(root);\n-  301:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n-  302:           TreeNode n = (TreeNode) categ.nextElement();\n-  303:           TreePath child = parent.pathByAddingChild(n);\n-  304:           configTree.collapsePath(child);\n-  305:         }\n-  306:       }\n-  307:     });\n-  308: \n-  309:     final JPanel motherTonguePanel = new JPanel();\n-  310:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n-  311:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n-  312:     if (config.getMotherTongue() != null) {\n-  313:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n-  314:     }\n-  315:     motherTongueBox.addItemListener(new ItemListener() {\n-  316: \n-  317:       @Override\n-  318:       public void itemStateChanged(ItemEvent e) {\n-  319:         if (e.getStateChange() == ItemEvent.SELECTED) {\n-  320:           Language motherTongue;\n-  321:           if (motherTongueBox.getSelectedItem() instanceof String) {\n-  322:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  117: \n+  118:   public void show(List<Rule> rules) {\n+  119:     if (original != null) {\n+  120:       config.restoreState(original);\n+  121:     }\n+  122:     dialog = new JDialog(owner, true);\n+  123:     dialog.setTitle(messages.getString(\"guiConfigWindowTitle\"));\n+  124:     // close dialog when user presses Escape key:\n+  125:     final KeyStroke stroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0);\n+  126:     final ActionListener actionListener = new ActionListener() {\n+  127:       @Override\n+  128:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent actionEvent) {\n+  129:         dialog.setVisible(false);\n+  130:       }\n+  131:     };\n+  132:     final JRootPane rootPane = dialog.getRootPane();\n+  133:     rootPane.registerKeyboardAction(actionListener, stroke,\n+  134:         JComponent.WHEN_IN_FOCUSED_WINDOW);\n+  135: \n+  136:     final JPanel checkBoxPanel = new JPanel();\n+  137:     checkBoxPanel.setLayout(new GridBagLayout());\n+  138:     GridBagConstraints cons = new GridBagConstraints();\n+  139:     cons.anchor = GridBagConstraints.NORTHWEST;\n+  140:     cons.gridx = 0;\n+  141:     cons.weightx = 1.0;\n+  142:     cons.weighty = 1.0;\n+  143:     cons.fill = GridBagConstraints.BOTH;\n+  144:     Collections.sort(rules, new CategoryComparator());\n+  145:     DefaultMutableTreeNode rootNode = createTree(rules);\n+  146:     configTree = new JTree(getTreeModel(rootNode));\n+  147: \n+  148:     Language lang = config.getLanguage();\n+  149:     if (lang == null) {\n+  150:       lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  151:     }\n+  152:     configTree.applyComponentOrientation(ComponentOrientation.getOrientation(lang.getLocale()));\n+  153: \n+  154:     configTree.setRootVisible(false);\n+  155:     configTree.setEditable(false);\n+  156:     configTree.setCellRenderer(new CheckBoxTreeCellRenderer());\n+  157:     TreeListener.install(configTree);\n+  158:     checkBoxPanel.add(configTree, cons);\n+  159:     configTree.addMouseListener(getMouseAdapter());\n+  160:     \n+  161:     final JPanel portPanel = new JPanel();\n+  162:     portPanel.setLayout(new GridBagLayout());\n+  163:     cons = new GridBagConstraints();\n+  164:     cons.insets = new Insets(0, 4, 0, 0);\n+  165:     cons.gridx = 0;\n+  166:     cons.gridy = 0;\n+  167:     cons.anchor = GridBagConstraints.WEST;\n+  168:     cons.fill = GridBagConstraints.NONE;\n+  169:     cons.weightx = 0.0f;\n+  170:     if (!insideOffice) {\n+  171:       createNonOfficeElements(cons, portPanel);\n+  172:     }\n+  173: \n+  174:     final JPanel buttonPanel = new JPanel();\n+  175:     buttonPanel.setLayout(new GridBagLayout());\n+  176:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n+  177:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n+  178:     okButton.addActionListener(this);\n+  179:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n+  180:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n+  181:     cancelButton.addActionListener(this);\n+  182:     cons = new GridBagConstraints();\n+  183:     cons.insets = new Insets(0, 4, 0, 0);\n+  184:     buttonPanel.add(okButton, cons);\n+  185:     buttonPanel.add(cancelButton, cons);\n+  186: \n+  187:     final Container contentPane = dialog.getContentPane();\n+  188:     contentPane.setLayout(new GridBagLayout());\n+  189:     cons = new GridBagConstraints();\n+  190:     cons.insets = new Insets(4, 4, 4, 4);\n+  191:     cons.gridx = 0;\n+  192:     cons.gridy = 0;\n+  193:     cons.weightx = 10.0f;\n+  194:     cons.weighty = 10.0f;\n+  195:     cons.fill = GridBagConstraints.BOTH;\n+  196:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n+  197: \n+  198:     cons.gridx = 0;\n+  199:     cons.gridy++;\n+  200:     cons.fill = GridBagConstraints.NONE;\n+  201:     cons.anchor = GridBagConstraints.LINE_END;\n+  202:     contentPane.add(getTreeButtonPanel(), cons);\n+  203:     \n+  204:     cons.gridy++;\n+  205:     cons.anchor = GridBagConstraints.WEST;\n+  206:     contentPane.add(getMotherTonguePanel(cons), cons);\n+  207: \n+  208:     cons.gridy++;\n+  209:     cons.anchor = GridBagConstraints.WEST;\n+  210:     contentPane.add(portPanel, cons);\n+  211: \n+  212:     cons.gridy++;\n+  213:     cons.anchor = GridBagConstraints.EAST;\n+  214:     contentPane.add(buttonPanel, cons);\n+  215: \n+  216:     dialog.pack();\n+  217:     dialog.setSize(500, 500);\n+  218:     // center on screen:\n+  219:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+  220:     final Dimension frameSize = dialog.getSize();\n+  221:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n+  222:         screenSize.height / 2 - frameSize.height / 2);\n+  223:     dialog.setLocationByPlatform(true);\n+  224:     dialog.setVisible(true);\n+  225:   }\n+  226: \n+  227:   private void createNonOfficeElements(GridBagConstraints cons, JPanel portPanel) {\n+  228:     serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n+  229:     serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n+  230:     serverCheckbox.setSelected(config.getRunServer());\n+  231:     portPanel.add(serverCheckbox, cons);\n+  232:     serverCheckbox.addActionListener(new ActionListener() {\n+  233:       @Override\n+  234:       public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n+  235:         serverPortField.setEnabled(serverCheckbox.isSelected());\n+  236:         serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n+  237:       }\n+  238:     });\n+  239:     serverCheckbox.addItemListener(new ItemListener() {\n+  240:       @Override\n+  241:       public void itemStateChanged(ItemEvent e) {\n+  242:         config.setRunServer(serverCheckbox.isSelected());\n+  243:       }\n+  244:     });\n+  245: \n+  246:     serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n+  247:     serverPortField.setEnabled(serverCheckbox.isSelected());\n+  248:     serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n+  249:     serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n+  250:     cons.gridx = 1;\n+  251:     portPanel.add(serverPortField, cons);\n+  252:     serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n+  253: \n+  254:       @Override\n+  255:       public void insertUpdate(DocumentEvent e) {\n+  256:         changedUpdate(e);\n+  257:       }\n+  258: \n+  259:       @Override\n+  260:       public void removeUpdate(DocumentEvent e) {\n+  261:         changedUpdate(e);\n+  262:       }\n+  263: \n+  264:       @Override\n+  265:       public void changedUpdate(DocumentEvent e) {\n+  266:         try {\n+  267:           int serverPort = Integer.parseInt(serverPortField.getText());\n+  268:           if (serverPort > -1 && serverPort < MAX_PORT) {\n+  269:             serverPortField.setForeground(null);\n+  270:             config.setServerPort(serverPort);\n+  271:           } else {\n+  272:             serverPortField.setForeground(Color.RED);\n+  273:           }\n+  274:         } catch (NumberFormatException ex) {\n+  275:           serverPortField.setForeground(Color.RED);\n+  276:         }\n+  277:       }\n+  278:     });\n+  279: \n+  280:     cons.gridx = 0;\n+  281:     cons.gridy = 10;\n+  282:     serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"useGUIConfig\")));\n+  283:     serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n+  284:     serverSettingsCheckbox.setEnabled(config.getRunServer());\n+  285:     serverSettingsCheckbox.addItemListener(new ItemListener() {\n+  286:       @Override\n+  287:       public void itemStateChanged(ItemEvent e) {\n+  288:         config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n+  289:       }\n+  290:     });\n+  291:     portPanel.add(serverSettingsCheckbox, cons);\n+  292:   }\n+  293: \n+  294:   @NotNull\n+  295:   private DefaultTreeModel getTreeModel(DefaultMutableTreeNode rootNode) {\n+  296:     DefaultTreeModel treeModel = new DefaultTreeModel(rootNode);\n+  297:     treeModel.addTreeModelListener(new TreeModelListener() {\n+  298:       @Override\n+  299:       public void treeNodesChanged(TreeModelEvent e) {\n+  300:         DefaultMutableTreeNode node = (DefaultMutableTreeNode) e.getTreePath().getLastPathComponent();\n+  301:         int index = e.getChildIndices()[0];\n+  302:         node = (DefaultMutableTreeNode) node.getChildAt(index);\n+  303:         if (node instanceof RuleNode) {\n+  304:           RuleNode o = (RuleNode) node;\n+  305:           if (o.getRule().isDefaultOff()) {\n+  306:             if (o.isEnabled()) {\n+  307:               config.getEnabledRuleIds().add(o.getRule().getId());\n+  308:             } else {\n+  309:               config.getEnabledRuleIds().remove(o.getRule().getId());\n+  310:             }\n+  311:           } else {\n+  312:             if (o.isEnabled()) {\n+  313:               config.getDisabledRuleIds().remove(o.getRule().getId());\n+  314:             } else {\n+  315:               config.getDisabledRuleIds().add(o.getRule().getId());\n+  316:             }\n+  317:           }\n+  318:         }\n+  319:         if (node instanceof CategoryNode) {\n+  320:           CategoryNode o = (CategoryNode) node;\n+  321:           if (o.isEnabled()) {\n+  322:             config.getDisabledCategoryNames().remove(o.getCategory().getName());\n   323:           } else {\n-  324:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  324:             config.getDisabledCategoryNames().add(o.getCategory().getName());\n   325:           }\n-  326:           config.setMotherTongue(motherTongue);\n-  327:         }\n-  328:       }\n-  329:     });\n-  330:     motherTonguePanel.add(motherTongueBox, cons);\n-  331:     \n-  332:     final JPanel portPanel = new JPanel();\n-  333:     portPanel.setLayout(new GridBagLayout());\n-  334:     cons = new GridBagConstraints();\n-  335:     cons.insets = new Insets(0, 4, 0, 0);\n-  336:     cons.gridx = 0;\n-  337:     cons.gridy = 0;\n-  338:     cons.anchor = GridBagConstraints.WEST;\n-  339:     cons.fill = GridBagConstraints.NONE;\n-  340:     cons.weightx = 0.0f;\n-  341:     if (!insideOffice) {\n-  342:       serverCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"guiRunOnPort\")));\n-  343:       serverCheckbox.setMnemonic(Tools.getMnemonic(messages.getString(\"guiRunOnPort\")));\n-  344:       serverCheckbox.setSelected(config.getRunServer());\n-  345:       portPanel.add(serverCheckbox, cons);\n-  346:       serverCheckbox.addActionListener(new ActionListener() {\n-  347:         @Override\n-  348:         public void actionPerformed(@SuppressWarnings(\"unused\") ActionEvent e) {\n-  349:           serverPortField.setEnabled(serverCheckbox.isSelected());\n-  350:           serverSettingsCheckbox.setEnabled(serverCheckbox.isSelected());\n-  351:         }\n-  352:       });\n-  353:       serverCheckbox.addItemListener(new ItemListener() {\n-  354: \n-  355:         @Override\n-  356:         public void itemStateChanged(ItemEvent e) {\n-  357:           config.setRunServer(serverCheckbox.isSelected());\n-  358:         }\n-  359:       });\n-  360: \n-  361:       serverPortField = new JTextField(Integer.toString(config.getServerPort()));\n-  362:       serverPortField.setEnabled(serverCheckbox.isSelected());\n-  363:       serverSettingsCheckbox = new JCheckBox(Tools.getLabel(messages.getString(\"useGUIConfig\")));\n-  364:       serverPortField.setMinimumSize(new Dimension(100, 25));  // without this the box is just a few pixels small, but why?\n-  365:       cons.gridx = 1;\n-  366:       portPanel.add(serverPortField, cons);\n-  367:       serverPortField.getDocument().addDocumentListener(new DocumentListener() {\n-  368: \n-  369:         @Override\n-  370:         public void insertUpdate(DocumentEvent e) {\n-  371:           changedUpdate(e);\n-  372:         }\n-  373: \n-  374:         @Override\n-  375:         public void removeUpdate(DocumentEvent e) {\n-  376:           changedUpdate(e);\n-  377:         }\n-  378: \n-  379:         @Override\n-  380:         public void changedUpdate(DocumentEvent e) {\n-  381:           try {\n-  382:             int serverPort = Integer.parseInt(serverPortField.getText());\n-  383:             if (serverPort > -1 && serverPort < MAX_PORT) {\n-  384:               serverPortField.setForeground(null);\n-  385:               config.setServerPort(serverPort);\n-  386:             } else {\n-  387:               serverPortField.setForeground(Color.RED);\n-  388:             }\n-  389:           } catch (NumberFormatException ex) {\n-  390:             serverPortField.setForeground(Color.RED);\n-  391:           }\n-  392:         }\n-  393:       });\n-  394: \n-  395:       cons.gridx = 0;\n-  396:       cons.gridy = 10;      \n-  397:       serverSettingsCheckbox.setMnemonic(Tools.getMnemonic(messages\n-  398:           .getString(\"useGUIConfig\")));\n-  399:       serverSettingsCheckbox.setSelected(config.getUseGUIConfig());\n-  400:       serverSettingsCheckbox.setEnabled(config.getRunServer());\n-  401:       serverSettingsCheckbox.addItemListener(new ItemListener() {\n-  402:         @Override\n-  403:         public void itemStateChanged(ItemEvent e) {\n-  404:           config.setUseGUIConfig(serverSettingsCheckbox.isSelected());\n-  405:         }\n-  406:       });\n-  407:       portPanel.add(serverSettingsCheckbox, cons);\n-  408:     }\n+  326:         }\n+  327:       }\n+  328:       @Override\n+  329:       public void treeNodesInserted(TreeModelEvent e) {}\n+  330:       @Override\n+  331:       public void treeNodesRemoved(TreeModelEvent e) {}\n+  332:       @Override\n+  333:       public void treeStructureChanged(TreeModelEvent e) {}\n+  334:     });\n+  335:     return treeModel;\n+  336:   }\n+  337: \n+  338:   @NotNull\n+  339:   private MouseAdapter getMouseAdapter() {\n+  340:     return new MouseAdapter() {\n+  341:         private void handlePopupEvent(MouseEvent e) {\n+  342:           final JTree tree = (JTree) e.getSource();\n+  343:           TreePath path = tree.getPathForLocation(e.getX(), e.getY());\n+  344:           if (path == null) {\n+  345:             return;\n+  346:           }\n+  347:           DefaultMutableTreeNode node\n+  348:                   = (DefaultMutableTreeNode) path.getLastPathComponent();\n+  349:           TreePath[] paths = tree.getSelectionPaths();\n+  350:           boolean isSelected = false;\n+  351:           if (paths != null) {\n+  352:             for (TreePath selectionPath : paths) {\n+  353:               if (selectionPath.equals(path)) {\n+  354:                 isSelected = true;\n+  355:               }\n+  356:             }\n+  357:           }\n+  358:           if (!isSelected) {\n+  359:             tree.setSelectionPath(path);\n+  360:           }\n+  361:           if (node.isLeaf()) {\n+  362:             JPopupMenu popup = new JPopupMenu();\n+  363:             final JMenuItem aboutRuleMenuItem = new JMenuItem(messages.getString(\"guiAboutRuleMenu\"));\n+  364:             aboutRuleMenuItem.addActionListener(new ActionListener() {\n+  365:               @Override\n+  366:               public void actionPerformed(ActionEvent actionEvent) {\n+  367:                 RuleNode node = (RuleNode) tree.getSelectionPath().getLastPathComponent();\n+  368:                 Rule rule = node.getRule();\n+  369:                 Language lang = config.getLanguage();\n+  370:                 if(lang == null) {\n+  371:                   lang = Languages.getLanguageForLocale(Locale.getDefault());\n+  372:                 }\n+  373:                 Tools.showRuleInfoDialog(tree, messages.getString(\"guiAboutRuleTitle\"),\n+  374:                         rule.getDescription(), rule, messages,\n+  375:                         lang.getShortNameWithCountryAndVariant());\n+  376:               }\n+  377:             });\n+  378:             popup.add(aboutRuleMenuItem);\n+  379:             popup.show(tree, e.getX(), e.getY());\n+  380:           }\n+  381:         }\n+  382:   \n+  383:         @Override\n+  384:         public void mousePressed(MouseEvent e) {\n+  385:           if (e.isPopupTrigger()) {\n+  386:             handlePopupEvent(e);\n+  387:           }\n+  388:         }\n+  389:   \n+  390:         @Override\n+  391:         public void mouseReleased(MouseEvent e) {\n+  392:           if (e.isPopupTrigger()) {\n+  393:             handlePopupEvent(e);\n+  394:           }\n+  395:         }\n+  396:       };\n+  397:   }\n+  398: \n+  399:   @NotNull\n+  400:   private JPanel getTreeButtonPanel() {\n+  401:     GridBagConstraints cons;\n+  402:     final JPanel treeButtonPanel = new JPanel();\n+  403:     cons = new GridBagConstraints();\n+  404:     cons.gridx = 0;\n+  405:     cons.gridy = 0;\n+  406:     final JButton expandAllButton = new JButton(messages.getString(\"guiExpandAll\"));\n+  407:     treeButtonPanel.add(expandAllButton, cons);\n+  408:     expandAllButton.addActionListener(new ActionListener() {\n   409: \n-  410:     final JPanel buttonPanel = new JPanel();\n-  411:     buttonPanel.setLayout(new GridBagLayout());\n-  412:     okButton = new JButton(Tools.getLabel(messages.getString(\"guiOKButton\")));\n-  413:     okButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiOKButton\")));\n-  414:     okButton.addActionListener(this);\n-  415:     cancelButton = new JButton(Tools.getLabel(messages.getString(\"guiCancelButton\")));\n-  416:     cancelButton.setMnemonic(Tools.getMnemonic(messages.getString(\"guiCancelButton\")));\n-  417:     cancelButton.addActionListener(this);\n-  418:     cons = new GridBagConstraints();\n-  419:     cons.insets = new Insets(0, 4, 0, 0);\n-  420:     buttonPanel.add(okButton, cons);\n-  421:     buttonPanel.add(cancelButton, cons);\n-  422: \n-  423:     final Container contentPane = dialog.getContentPane();\n-  424:     contentPane.setLayout(new GridBagLayout());\n-  425:     cons = new GridBagConstraints();\n-  426:     cons.insets = new Insets(4, 4, 4, 4);\n-  427:     cons.gridx = 0;\n-  428:     cons.gridy = 0;\n-  429:     cons.weightx = 10.0f;\n-  430:     cons.weighty = 10.0f;\n-  431:     cons.fill = GridBagConstraints.BOTH;\n-  432:     contentPane.add(new JScrollPane(checkBoxPanel), cons);\n-  433: \n-  434:     cons.gridx = 0;\n-  435:     cons.gridy++;\n-  436:     cons.fill = GridBagConstraints.NONE;\n-  437:     cons.anchor = GridBagConstraints.LINE_END;\n-  438:     contentPane.add(treeButtonPanel, cons);\n-  439:     \n-  440:     cons.gridy++;\n-  441:     cons.anchor = GridBagConstraints.WEST;\n-  442:     contentPane.add(motherTonguePanel, cons);\n-  443: \n-  444:     cons.gridy++;\n-  445:     cons.anchor = GridBagConstraints.WEST;\n-  446:     contentPane.add(portPanel, cons);\n-  447: \n-  448:     cons.gridy++;\n-  449:     cons.anchor = GridBagConstraints.EAST;\n-  450:     contentPane.add(buttonPanel, cons);\n+  410:       @Override\n+  411:       public void actionPerformed(ActionEvent e) {\n+  412:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  413:         TreePath parent = new TreePath(root);\n+  414:         for (Enumeration cat = root.children(); cat.hasMoreElements();) {\n+  415:           TreeNode n = (TreeNode) cat.nextElement();\n+  416:           TreePath child = parent.pathByAddingChild(n);\n+  417:           configTree.expandPath(child);\n+  418:         }\n+  419:       }\n+  420:     });\n+  421: \n+  422:     cons.gridx = 1;\n+  423:     cons.gridy = 0;\n+  424:     final JButton collapseAllButton = new JButton(messages.getString(\"guiCollapseAll\"));\n+  425:     treeButtonPanel.add(collapseAllButton, cons);\n+  426:     collapseAllButton.addActionListener(new ActionListener() {\n+  427: \n+  428:       @Override\n+  429:       public void actionPerformed(ActionEvent e) {\n+  430:         TreeNode root = (TreeNode) configTree.getModel().getRoot();\n+  431:         TreePath parent = new TreePath(root);\n+  432:         for (Enumeration categ = root.children(); categ.hasMoreElements();) {\n+  433:           TreeNode n = (TreeNode) categ.nextElement();\n+  434:           TreePath child = parent.pathByAddingChild(n);\n+  435:           configTree.collapsePath(child);\n+  436:         }\n+  437:       }\n+  438:     });\n+  439:     return treeButtonPanel;\n+  440:   }\n+  441: \n+  442:   @NotNull\n+  443:   private JPanel getMotherTonguePanel(GridBagConstraints cons) {\n+  444:     final JPanel motherTonguePanel = new JPanel();\n+  445:     motherTonguePanel.add(new JLabel(messages.getString(\"guiMotherTongue\")), cons);\n+  446:     motherTongueBox = new JComboBox<>(getPossibleMotherTongues());\n+  447:     if (config.getMotherTongue() != null) {\n+  448:       motherTongueBox.setSelectedItem(config.getMotherTongue().getTranslatedName(messages));\n+  449:     }\n+  450:     motherTongueBox.addItemListener(new ItemListener() {\n   451: \n-  452:     dialog.pack();\n-  453:     dialog.setSize(500, 500);\n-  454:     // center on screen:\n-  455:     final Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n-  456:     final Dimension frameSize = dialog.getSize();\n-  457:     dialog.setLocation(screenSize.width / 2 - frameSize.width / 2,\n-  458:         screenSize.height / 2 - frameSize.height / 2);\n-  459:     dialog.setLocationByPlatform(true);\n-  460:     dialog.setVisible(true);\n-  461:   }\n+  452:       @Override\n+  453:       public void itemStateChanged(ItemEvent e) {\n+  454:         if (e.getStateChange() == ItemEvent.SELECTED) {\n+  455:           Language motherTongue;\n+  456:           if (motherTongueBox.getSelectedItem() instanceof String) {\n+  457:             motherTongue = getLanguageForLocalizedName(motherTongueBox.getSelectedItem().toString());\n+  458:           } else {\n+  459:             motherTongue = (Language) motherTongueBox.getSelectedItem();\n+  460:           }\n+  461:           config.setMotherTongue(motherTongue);\n\n\nExample 2:\n SourceCodeBeforeRefactoring:\n public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientInSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new ClientOutSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientOutSelector\",\n                Logger.getLogger(ClientOutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n\n        socketOptions = networkConfig.getSocketOptions();\n        ClientExtension clientExtension = client.getClientExtension();\n        socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n    }\n@Override\n    public synchronized void start() {\n        if (alive) {\n            return;\n        }\n        alive = true;\n        inSelector.start();\n        outSelector.start();\n        HeartBeat heartBeat = new HeartBeat();\n        executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n    }\n@Override\n    public synchronized void shutdown() {\n        if (!alive) {\n            return;\n        }\n        alive = false;\n        for (ClientConnection connection : connections.values()) {\n            connection.close();\n        }\n        inSelector.shutdown();\n        outSelector.shutdown();\n        connectionLockMap.clear();\n        connectionListeners.clear();\n        heartbeatListeners.clear();\n    }\n SourceCodeAfterRefactoring:\npublic ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n                                       AddressTranslator addressTranslator) {\n        this.client = client;\n        this.addressTranslator = addressTranslator;\n        final ClientConfig config = client.getClientConfig();\n        final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n\n        final int connTimeout = networkConfig.getConnectionTimeout();\n        connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n\n        final ClientProperties clientProperties = client.getClientProperties();\n        int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n        this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n\n        int interval = clientProperties.getHeartbeatInterval().getInteger();\n        heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n\n        executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n\n        initializeSelectors(client);\n\n        socketOptions = networkConfig.getSocketOptions();\n        ClientExtension clientExtension = client.getClientExtension();\n        socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n        socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n    }\nprotected void initializeSelectors(HazelcastClientInstanceImpl client) {\n        inSelector = new InSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientInSelector\",\n                Logger.getLogger(InSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n        outSelector = new ClientOutSelectorImpl(\n                client.getThreadGroup(),\n                client.getName() + \".ClientOutSelector\",\n                Logger.getLogger(ClientOutSelectorImpl.class),\n                OUT_OF_MEMORY_HANDLER);\n    }\n@Override\n    public synchronized void start() {\n        if (alive) {\n            return;\n        }\n        alive = true;\n        startSelectors();\n        HeartBeat heartBeat = new HeartBeat();\n        executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n    }\nprotected void startSelectors() {\n        inSelector.start();\n        outSelector.start();\n    }\n@Override\n    public synchronized void shutdown() {\n        if (!alive) {\n            return;\n        }\n        alive = false;\n        for (ClientConnection connection : connections.values()) {\n            connection.close();\n        }\n        shutdownSelectors();\n        connectionLockMap.clear();\n        connectionListeners.clear();\n        heartbeatListeners.clear();\n    }\nprotected void shutdownSelectors() {\n        inSelector.shutdown();\n        outSelector.shutdown();\n    }\n DiffSourceCode:\n   102:     public ClientConnectionManagerImpl(HazelcastClientInstanceImpl client,\n   103:                                        AddressTranslator addressTranslator) {\n   104:         this.client = client;\n   105:         this.addressTranslator = addressTranslator;\n   106:         final ClientConfig config = client.getClientConfig();\n   107:         final ClientNetworkConfig networkConfig = config.getNetworkConfig();\n   108: \n   109:         final int connTimeout = networkConfig.getConnectionTimeout();\n   110:         connectionTimeout = connTimeout == 0 ? Integer.MAX_VALUE : connTimeout;\n   111: \n   112:         final ClientProperties clientProperties = client.getClientProperties();\n   113:         int timeout = clientProperties.getHeartbeatTimeout().getInteger();\n   114:         this.heartBeatTimeout = timeout > 0 ? timeout : Integer.parseInt(PROP_HEARTBEAT_TIMEOUT_DEFAULT);\n   115: \n   116:         int interval = clientProperties.getHeartbeatInterval().getInteger();\n   117:         heartBeatInterval = interval > 0 ? interval : Integer.parseInt(PROP_HEARTBEAT_INTERVAL_DEFAULT);\n   118: \n   119:         executionService = (ClientExecutionServiceImpl) client.getClientExecutionService();\n   120: \n-  121:         inSelector = new InSelectorImpl(\n-  122:                 client.getThreadGroup(),\n-  123:                 client.getName() + \".ClientInSelector\",\n-  124:                 Logger.getLogger(InSelectorImpl.class),\n-  125:                 OUT_OF_MEMORY_HANDLER);\n-  126:         outSelector = new ClientOutSelectorImpl(\n-  127:                 client.getThreadGroup(),\n-  128:                 client.getName() + \".ClientOutSelector\",\n-  129:                 Logger.getLogger(ClientOutSelectorImpl.class),\n-  130:                 OUT_OF_MEMORY_HANDLER);\n-  131: \n-  132:         socketOptions = networkConfig.getSocketOptions();\n-  133:         ClientExtension clientExtension = client.getClientExtension();\n-  134:         socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n-  135:         socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n-  136:     }\n-  137: \n-  138: \n-  139:     private SocketInterceptor initSocketInterceptor(SocketInterceptorConfig sic) {\n-  140:         if (sic != null && sic.isEnabled()) {\n-  152:     @Override\n-  153:     public synchronized void start() {\n-  154:         if (alive) {\n-  155:             return;\n-  156:         }\n-  157:         alive = true;\n-  158:         inSelector.start();\n-  159:         outSelector.start();\n-  160:         HeartBeat heartBeat = new HeartBeat();\n-  161:         executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n-  162:     }\n-  163: \n-  164:     @Override\n-  165:     public synchronized void shutdown() {\n-  166:         if (!alive) {\n-  167:             return;\n-  168:         }\n-  169:         alive = false;\n-  170:         for (ClientConnection connection : connections.values()) {\n-  171:             connection.close();\n-  172:         }\n-  173:         inSelector.shutdown();\n-  174:         outSelector.shutdown();\n-  175:         connectionLockMap.clear();\n-  176:         connectionListeners.clear();\n-  177:         heartbeatListeners.clear();\n-  178:     }\n-  179: \n-  180:     public ClientConnection getConnection(Address target) {\n-  181:         return connections.get(target);\n-  182:     }\n-  183: \n-  184:     public ClientConnection getOrConnect(Address target, Authenticator authenticator) throws IOException {\n-  185:         Address address = addressTranslator.translate(target);\n-  187:         if (address == null) {\n-  188:             throw new IOException(\"Address is required!\");\n-  189:         }\n-  190: \n+  121:         initializeSelectors(client);\n+  122: \n+  123:         socketOptions = networkConfig.getSocketOptions();\n+  124:         ClientExtension clientExtension = client.getClientExtension();\n+  125:         socketChannelWrapperFactory = clientExtension.createSocketChannelWrapperFactory();\n+  126:         socketInterceptor = initSocketInterceptor(networkConfig.getSocketInterceptorConfig());\n+  127:     }\n+  128: \n+  129:     protected void initializeSelectors(HazelcastClientInstanceImpl client) {\n+  130:         inSelector = new InSelectorImpl(\n+  131:                 client.getThreadGroup(),\n+  132:                 client.getName() + \".ClientInSelector\",\n+  133:                 Logger.getLogger(InSelectorImpl.class),\n+  134:                 OUT_OF_MEMORY_HANDLER);\n+  135:         outSelector = new ClientOutSelectorImpl(\n+  136:                 client.getThreadGroup(),\n+  137:                 client.getName() + \".ClientOutSelector\",\n+  138:                 Logger.getLogger(ClientOutSelectorImpl.class),\n+  139:                 OUT_OF_MEMORY_HANDLER);\n+  140:     }\n+  152:     public boolean isAlive() {\n+  153:         return alive;\n+  154:     }\n+  155: \n+  156:     @Override\n+  157:     public synchronized void start() {\n+  158:         if (alive) {\n+  159:             return;\n+  160:         }\n+  161:         alive = true;\n+  162:         startSelectors();\n+  163:         HeartBeat heartBeat = new HeartBeat();\n+  164:         executionService.scheduleWithFixedDelay(heartBeat, heartBeatInterval, heartBeatInterval, TimeUnit.MILLISECONDS);\n+  165:     }\n+  166: \n+  167:     protected void startSelectors() {\n+  168:         inSelector.start();\n+  169:         outSelector.start();\n+  170:     }\n+  171: \n+  172:     @Override\n+  173:     public synchronized void shutdown() {\n+  174:         if (!alive) {\n+  175:             return;\n+  176:         }\n+  177:         alive = false;\n+  178:         for (ClientConnection connection : connections.values()) {\n+  179:             connection.close();\n+  180:         }\n+  181:         shutdownSelectors();\n+  182:         connectionLockMap.clear();\n+  183:         connectionListeners.clear();\n+  184:         heartbeatListeners.clear();\n+  185:     }\n+  187:     protected void shutdownSelectors() {\n+  188:         inSelector.shutdown();\n+  189:         outSelector.shutdown();\n+  190:     }\n\n\nExample 3:\n SourceCodeBeforeRefactoring:\n @Test\n    public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertFalse( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( A );\n            tx.success();\n        }\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"A\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( B );\n            tx.success();\n        }\n        // and rotating the log (which implies flushing)\n        checkPoint( db );\n        // and creating another node after it\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( C );\n            tx.success();\n        }\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n                                                           new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n            // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n            // in the stats\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"B\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n\n        // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n        final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n        assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n\n        final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n        int labelId = holder.getIdByName( C.name() );\n        assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n\n        db.shutdown();\n    }\n SourceCodeAfterRefactoring:\n@Test\n    public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertFalse( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            assertEquals( BASE_TX_ID, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            assertEquals( 0, store.totalEntriesStored() );\n            assertEquals( 0, allRecords( store ).size() );\n        }\n    }\nprivate CountsTracker createCountsTracker(PageCache pageCache)\n    {\n        return new CountsTracker( NullLogProvider.getInstance(), fs, pageCache, emptyConfig,\n                new File( dir.getPath(), COUNTS_STORE_BASE ) );\n    }\n@Test\n    public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( A );\n            tx.success();\n        }\n\n        // WHEN\n        db.shutdown();\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"A\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n    }\n@Test\n    public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n    {\n        // GIVEN\n        GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n\n        // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( B );\n            tx.success();\n        }\n        // and rotating the log (which implies flushing)\n        checkPoint( db );\n        // and creating another node after it\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode( C );\n            tx.success();\n        }\n\n        // THEN\n        assertTrue( fs.fileExists( alphaStoreFile() ) );\n        assertTrue( fs.fileExists( betaStoreFile() ) );\n\n        final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n        try ( Lifespan life = new Lifespan() )\n        {\n            CountsTracker store = life.add( createCountsTracker( pageCache ) );\n            // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n            // in the stats\n            // a transaction for creating the label and a transaction for the node\n            assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n            assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n            // one for all nodes and one for the created \"B\" label\n            assertEquals( 1 + 1, store.totalEntriesStored() );\n            assertEquals( 1 + 1, allRecords( store ).size() );\n        }\n\n        // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n        final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n        assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n\n        final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n        int labelId = holder.getIdByName( C.name() );\n        assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n\n        db.shutdown();\n    }\n DiffSourceCode:\n-   62:     @Test\n-   63:     public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n-   64:     {\n-   65:         // GIVEN\n-   66:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-   67: \n-   68:         // WHEN\n-   69:         db.shutdown();\n-   70: \n-   71:         // THEN\n-   72:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-   73:         assertFalse( fs.fileExists( betaStoreFile() ) );\n-   74: \n-   75:         try ( Lifespan life = new Lifespan() )\n-   76:         {\n-   77:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-   78:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n+   62: {\n+   63:     @Test\n+   64:     public void shouldCreateEmptyCountsTrackerStoreWhenCreatingDatabase() throws IOException\n+   65:     {\n+   66:         // GIVEN\n+   67:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+   68: \n+   69:         // WHEN\n+   70:         db.shutdown();\n+   71: \n+   72:         // THEN\n+   73:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+   74:         assertFalse( fs.fileExists( betaStoreFile() ) );\n+   75: \n+   76:         try ( Lifespan life = new Lifespan() )\n+   77:         {\n+   78:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n    79:             assertEquals( BASE_TX_ID, store.txId() );\n    80:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n    81:             assertEquals( 0, store.totalEntriesStored() );\n    82:             assertEquals( 0, allRecords( store ).size() );\n    83:         }\n    84: \n    85:         try ( Lifespan life = new Lifespan() )\n    86:         {\n-   87:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-   88:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-   89:             assertEquals( BASE_TX_ID, store.txId() );\n-   90:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-   91:             assertEquals( 0, store.totalEntriesStored() );\n-   92:             assertEquals( 0, allRecords( store ).size() );\n-   93:         }\n-   94:     }\n-   95: \n-   96:     @Test\n-   97:     public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n-   98:     {\n-   99:         // GIVEN\n-  100:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-  101:         try ( Transaction tx = db.beginTx() )\n-  102:         {\n-  103:             db.createNode( A );\n-  104:             tx.success();\n-  105:         }\n-  106: \n-  107:         // WHEN\n-  108:         db.shutdown();\n-  109: \n-  110:         // THEN\n-  111:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-  112:         assertTrue( fs.fileExists( betaStoreFile() ) );\n-  113: \n-  114:         try ( Lifespan life = new Lifespan() )\n-  115:         {\n-  116:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-  117:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-  118:             // a transaction for creating the label and a transaction for the node\n-  119:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n-  120:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-  121:             // one for all nodes and one for the created \"A\" label\n-  122:             assertEquals( 1 + 1, store.totalEntriesStored() );\n-  123:             assertEquals( 1 + 1, allRecords( store ).size() );\n-  124:         }\n-  125:     }\n-  126: \n-  127:     @Test\n-  128:     public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n-  129:     {\n-  130:         // GIVEN\n-  131:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n-  132: \n-  133:         // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n-  134:         try ( Transaction tx = db.beginTx() )\n-  135:         {\n-  136:             db.createNode( B );\n-  137:             tx.success();\n-  138:         }\n-  139:         // and rotating the log (which implies flushing)\n-  140:         checkPoint( db );\n-  141:         // and creating another node after it\n-  142:         try ( Transaction tx = db.beginTx() )\n-  143:         {\n-  144:             db.createNode( C );\n-  145:             tx.success();\n-  146:         }\n-  147: \n-  148:         // THEN\n-  149:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n-  150:         assertTrue( fs.fileExists( betaStoreFile() ) );\n-  151: \n-  152:         final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n-  153:         try ( Lifespan life = new Lifespan() )\n-  154:         {\n-  155:             CountsTracker store = life.add( new CountsTracker( NullLogProvider.getInstance(), fs, pageCache,\n-  156:                                                            new File( dir.getPath(), COUNTS_STORE_BASE ) ) );\n-  157:             // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n-  158:             // in the stats\n-  159:             // a transaction for creating the label and a transaction for the node\n-  160:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n-  161:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n-  162:             // one for all nodes and one for the created \"B\" label\n-  163:             assertEquals( 1 + 1, store.totalEntriesStored() );\n-  164:             assertEquals( 1 + 1, allRecords( store ).size() );\n-  165:         }\n-  166: \n-  167:         // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n-  168:         final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n-  169:         assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n-  170: \n-  171:         final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n-  172:         int labelId = holder.getIdByName( C.name() );\n-  173:         assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n+   87:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+   88:             assertEquals( BASE_TX_ID, store.txId() );\n+   89:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+   90:             assertEquals( 0, store.totalEntriesStored() );\n+   91:             assertEquals( 0, allRecords( store ).size() );\n+   92:         }\n+   93:     }\n+   94: \n+   95:     @Test\n+   96:     public void shouldRotateCountsStoreWhenClosingTheDatabase() throws IOException\n+   97:     {\n+   98:         // GIVEN\n+   99:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+  100:         try ( Transaction tx = db.beginTx() )\n+  101:         {\n+  102:             db.createNode( A );\n+  103:             tx.success();\n+  104:         }\n+  105: \n+  106:         // WHEN\n+  107:         db.shutdown();\n+  108: \n+  109:         // THEN\n+  110:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+  111:         assertTrue( fs.fileExists( betaStoreFile() ) );\n+  112: \n+  113:         try ( Lifespan life = new Lifespan() )\n+  114:         {\n+  115:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+  116:             // a transaction for creating the label and a transaction for the node\n+  117:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n+  118:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+  119:             // one for all nodes and one for the created \"A\" label\n+  120:             assertEquals( 1 + 1, store.totalEntriesStored() );\n+  121:             assertEquals( 1 + 1, allRecords( store ).size() );\n+  122:         }\n+  123:     }\n+  124: \n+  125:     @Test\n+  126:     public void shouldRotateCountsStoreWhenRotatingLog() throws IOException\n+  127:     {\n+  128:         // GIVEN\n+  129:         GraphDatabaseAPI db = (GraphDatabaseAPI) dbBuilder.newGraphDatabase();\n+  130: \n+  131:         // WHEN doing a transaction (actually two, the label-mini-tx also counts)\n+  132:         try ( Transaction tx = db.beginTx() )\n+  133:         {\n+  134:             db.createNode( B );\n+  135:             tx.success();\n+  136:         }\n+  137:         // and rotating the log (which implies flushing)\n+  138:         checkPoint( db );\n+  139:         // and creating another node after it\n+  140:         try ( Transaction tx = db.beginTx() )\n+  141:         {\n+  142:             db.createNode( C );\n+  143:             tx.success();\n+  144:         }\n+  145: \n+  146:         // THEN\n+  147:         assertTrue( fs.fileExists( alphaStoreFile() ) );\n+  148:         assertTrue( fs.fileExists( betaStoreFile() ) );\n+  149: \n+  150:         final PageCache pageCache = db.getDependencyResolver().resolveDependency( PageCache.class );\n+  151:         try ( Lifespan life = new Lifespan() )\n+  152:         {\n+  153:             CountsTracker store = life.add( createCountsTracker( pageCache ) );\n+  154:             // NOTE since the rotation happens before the second transaction is committed we do not see those changes\n+  155:             // in the stats\n+  156:             // a transaction for creating the label and a transaction for the node\n+  157:             assertEquals( BASE_TX_ID + 1 + 1, store.txId() );\n+  158:             assertEquals( INITIAL_MINOR_VERSION, store.minorVersion() );\n+  159:             // one for all nodes and one for the created \"B\" label\n+  160:             assertEquals( 1 + 1, store.totalEntriesStored() );\n+  161:             assertEquals( 1 + 1, allRecords( store ).size() );\n+  162:         }\n+  163: \n+  164:         // on the other hand the tracker should read the correct value by merging data on disk and data in memory\n+  165:         final CountsTracker tracker = db.getDependencyResolver().resolveDependency( NeoStore.class ).getCounts();\n+  166:         assertEquals( 1 + 1, tracker.nodeCount( -1, newDoubleLongRegister() ).readSecond() );\n+  167: \n+  168:         final LabelTokenHolder holder = db.getDependencyResolver().resolveDependency( LabelTokenHolder.class );\n+  169:         int labelId = holder.getIdByName( C.name() );\n+  170:         assertEquals( 1, tracker.nodeCount( labelId, newDoubleLongRegister() ).readSecond() );\n+  171: \n+  172:         db.shutdown();\n+  173:     }\n   174: \n-  175:         db.shutdown();\n-  176:     }\n-  177: \n-  178:     private void checkPoint( GraphDatabaseAPI db ) throws IOException\n-  179:     {\n+  175:     private CountsTracker createCountsTracker(PageCache pageCache)\n+  176:     {\n+  177:         return new CountsTracker( NullLogProvider.getInstance(), fs, pageCache, emptyConfig,\n+  178:                 new File( dir.getPath(), COUNTS_STORE_BASE ) );\n+  179:     }\n\nOutput Requirements:\nThe refactored method should call smaller, extracted methods.\nEach extracted method should represent a clear, single responsibility.\nThe extracted methods and refactored code should follow the structure of the historical refactorings provided.\nThe original functionality must remain unchanged.\nIf no refactoring is necessary, respond with \"No need to refactor.\"\nIf refactoring is performed, output the original code and the refactored code in the following format:\n### Original Code:\n```java\n// Original code goes here\n```\n### Refactored Code:\n```java\n// Refactored code goes here\n```\n\n\n"
    }
]
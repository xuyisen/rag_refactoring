[
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\n}\n\n@Test\npublic void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n}\n\n@Test\npublic void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n}\n\n@Test\npublic void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testExcludeInnerClassObject() {\n    assertExclusion(innerClass, true, true);\n}\n\n@Test\npublic void testExcludeInnerClassField() throws Exception {\n    assertExclusion(getClass().getField(\"innerClass\"), true, true);\n}\n\n@Test\npublic void testIncludeStaticNestedClassObject() {\n    assertExclusion(staticNestedClass, true, false);\n}\n\n@Test\npublic void testIncludeStaticNestedClassField() throws Exception {\n    assertExclusion(getClass().getField(\"staticNestedClass\"), true, false);\n}\n\nprivate void assertExclusion(Object target, boolean flag, boolean expected) {\n    Class<?> clazz = target instanceof Class ? (Class<?>) target : target.getClass();\n    assertThat(excluder.excludeClass(clazz, flag)).isEqualTo(expected);\n}\n\nprivate void assertExclusion(Field field, boolean flag, boolean expected) {\n    assertThat(excluder.excludeField(field, flag)).isEqualTo(expected);\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Common Logic**: The logic for asserting exclusion was duplicated across the test methods. I created a private method `assertExclusion` to handle both class and field exclusions, reducing redundancy.\n2. **Improved Readability**: The refactored code is more concise and easier to read, as it abstracts the common functionality into helper methods. This makes it clear what the tests are asserting without repeating the exclusion logic.\n3. **Parameterization**: The `assertExclusion` method takes parameters to handle both class and field checks, making it versatile and reducing the number of lines in the test methods.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertExcludesClass(clazz);\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertIncludesClass(clazz);\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertIncludesField(f);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertExcludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_39_40_43_55_59",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nAfter Refactoring:\nprivate void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}\n\nExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}\nExample 2:\n Before Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}\n\nAfter Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn rules(target);\n\t}\n\nExtractedCodeFragments:\n/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of MethodRules that should be applied when executing this\n\t *         test\n\t * @deprecated {@link MethodRule} is a deprecated interface. Port to\n\t *             {@link TestRule} and\n\t *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}\n\t */\n\t@Deprecated\n\tprotected List<org.junit.rules.MethodRule> rules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target, Rule.class,\n\t\t\t\torg.junit.rules.MethodRule.class);\n\t}\nExample 3:\n Before Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (org.junit.rules.MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\nAfter Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\tfor (org.junit.rules.MethodRule each : getMethodRules(target))\n\t\t\tif (! testRules.contains(each))\n\t\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\nExtractedCodeFragments:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    \n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\n}\n\n@Test\npublic void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n}\n\n@Test\npublic void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testSameVersion() throws Exception {\n    assertExclusionForVersion(VERSION, false, true, false);\n}\n\n@Test\npublic void testNewerVersion() throws Exception {\n    assertExclusionForVersion(VERSION + 5, false, true, true);\n}\n\n@Test\npublic void testOlderVersion() throws Exception {\n    assertExclusionForVersion(VERSION - 5, true, false, true);\n}\n\nprivate void assertExclusionForVersion(int version, boolean expectedSince, boolean expectedUntil, boolean expectedBoth) throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(version);\n    \n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isEqualTo(expectedSince);\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isEqualTo(expectedSince);\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isEqualTo(expectedUntil);\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isEqualTo(expectedUntil);\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isEqualTo(expectedBoth);\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isEqualTo(expectedBoth);\n}\n```\n\n### Explanation of Refactoring:\n- The repeated logic in the test methods was extracted into a single method `assertExclusionForVersion`, which takes the version and expected results as parameters. This reduces code duplication and improves readability.\n- The assertions are now more concise and easier to maintain, as any changes to the exclusion logic only need to be made in one place.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    \n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassBoth.class);\n    assertIncludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertExcludesClass(excluder, MockClassSince.class);\n    assertExcludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassUntil.class);\n    assertIncludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertIncludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_47_36_39_56_68",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (org.junit.rules.MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\nAfter Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\tfor (org.junit.rules.MethodRule each : getMethodRules(target))\n\t\t\tif (! testRules.contains(each))\n\t\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}\n\nExtractedCodeFragments:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}\nExample 2:\n Before Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}\n\nAfter Refactoring:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn rules(target);\n\t}\n\nExtractedCodeFragments:\n/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of MethodRules that should be applied when executing this\n\t *         test\n\t * @deprecated {@link MethodRule} is a deprecated interface. Port to\n\t *             {@link TestRule} and\n\t *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}\n\t */\n\t@Deprecated\n\tprotected List<org.junit.rules.MethodRule> rules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target, Rule.class,\n\t\t\t\torg.junit.rules.MethodRule.class);\n\t}\nExample 3:\n Before Refactoring:\n@Test\n    public void getDescriptionWithAnnotation() {\n        JUnit38ClassRunner runner = new JUnit38ClassRunner(JUnit3ClassWithAnnotatedMethod.class);\n        Description d = runner.getDescription();\n        assertEquals(2, d.testCount());\n        for (Description methodDesc : d.getChildren()) {\n            if (methodDesc.getMethodName().equals(\"testAnnotated\")) {\n                assertNotNull(methodDesc.getAnnotation(MyAnnotation.class));\n            } else {\n                assertNull(methodDesc.getAnnotation(MyAnnotation.class));\n            }\n        }\n    }\n\nAfter Refactoring:\n@Test\n    public void getDescriptionWithAnnotation() {\n        JUnit38ClassRunner runner = new JUnit38ClassRunner(JUnit3ClassWithAnnotatedMethod.class);\n        assertAnnotationFiltering(runner);\n    }\n\nExtractedCodeFragments:\nprivate void assertAnnotationFiltering(JUnit38ClassRunner runner) {\n        Description d = runner.getDescription();\n        assertEquals(2, d.testCount());\n        for (Description methodDesc : d.getChildren()) {\n            if (methodDesc.getMethodName().equals(\"testAnnotated\")) {\n                assertNotNull(methodDesc.getAnnotation(MyAnnotation.class));\n            } else {\n                assertNull(methodDesc.getAnnotation(MyAnnotation.class));\n            }\n        }\n    }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testNeverSkipClasses() {\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\n}\n\n@Test\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n}\n\n@Test\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n}\n\n@Test\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n}\n\n@Test\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testNeverSkipClasses() {\n    assertExclusion(MockObject.class, false);\n}\n\n@Test\npublic void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertFieldExclusion(f, true);\n    assertFieldExclusion(f, false);\n}\n\n@Test\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertFieldExclusion(f, true);\n    assertFieldExclusion(f, false);\n}\n\n@Test\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertFieldExclusion(f, false);\n}\n\n@Test\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFieldExclusion(f, false);\n}\n\nprivate void assertExclusion(Class<?> clazz, boolean expected) {\n    assertThat(excluder.excludeClass(clazz, true)).isEqualTo(expected);\n    assertThat(excluder.excludeClass(clazz, false)).isEqualTo(expected);\n}\n\nprivate void assertFieldExclusion(Field field, boolean expected) throws Exception {\n    assertThat(excluder.excludeField(field, true)).isEqualTo(expected);\n    assertThat(excluder.excludeField(field, false)).isEqualTo(expected);\n}\n```\n\n### Explanation of Refactoring:\n1. **Extracted Methods**: Created `assertExclusion` and `assertFieldExclusion` methods to reduce redundancy in the test cases. This improves readability and maintainability.\n2. **Simplified Assertions**: The assertions are now more concise, making it easier to understand the intent of each test case.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertIncludesClass(MockObject.class);\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertIncludesField(f);\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertIncludesField(f);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
        "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_34_38_34_37_49_52",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n@Override\n    public Object createTest() throws Exception {\n        if (fieldsAreAnnotated()) {\n            return createTestUsingFieldInjection();\n        } else {\n            return createTestUsingConstructorInjection();\n        }\n    }\n\nAfter Refactoring:\n@Override\n    public Object createTest() throws Exception {\n        InjectionType injectionType = getInjectionType();\n        switch (injectionType) {\n            case CONSTRUCTOR:\n                return createTestUsingConstructorInjection();\n            case FIELD:\n                return createTestUsingFieldInjection();\n            default:\n                throw new IllegalStateException(\"The injection type \"\n                        + injectionType + \" is not supported.\");\n        }\n    }\n\nExtractedCodeFragments:\nprivate InjectionType getInjectionType() {\n        if (fieldsAreAnnotated()) {\n            return InjectionType.FIELD;\n        } else {\n            return InjectionType.CONSTRUCTOR;\n        }\n    }\nExample 2:\n Before Refactoring:\n@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tObject testClassInstance = null;\n\t\t\tList<FrameworkField> fields = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (!fields.isEmpty()) {\n\t\t\t\tif (fields.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+fields.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\t\ttestClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\t\tfor (FrameworkField f : fields) {\n\t\t\t\t\tField field = f.getField();\n\t\t\t\t\tParameter annot = field.getAnnotation(Parameter.class);\n\t\t\t\t\tint index = annot.value();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttestClassInstance = getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}\n\nAfter Refactoring:\n@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tif (fieldsAreAnnotated()) {\n\t\t\t\treturn createTestUsingFieldInjection();\n\t\t\t} else {\n\t\t\t\treturn createTestUsingConstructorInjection();\n\t\t\t}\n\t\t}\n\nExtractedCodeFragments:\nprivate Object createTestUsingFieldInjection() throws Exception {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n\t\t\tif (annotatedFieldsByParameter.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @Parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+annotatedFieldsByParameter.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\tObject testClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\tfor (FrameworkField each : annotatedFieldsByParameter) {\n\t\t\t\tField field = each.getField();\n\t\t\t\tParameter annotation = field.getAnnotation(Parameter.class);\n\t\t\t\tint index = annotation.value();\n\t\t\t\ttry {\n\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}\nExample 3:\n Before Refactoring:\n@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tObject testClassInstance = null;\n\t\t\tList<FrameworkField> fields = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (!fields.isEmpty()) {\n\t\t\t\tif (fields.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+fields.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\t\ttestClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\t\tfor (FrameworkField f : fields) {\n\t\t\t\t\tField field = f.getField();\n\t\t\t\t\tParameter annot = field.getAnnotation(Parameter.class);\n\t\t\t\t\tint index = annot.value();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttestClassInstance = getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}\n\nAfter Refactoring:\n@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tif (fieldsAreAnnotated()) {\n\t\t\t\treturn createTestUsingFieldInjection();\n\t\t\t} else {\n\t\t\t\treturn createTestUsingConstructorInjection();\n\t\t\t}\n\t\t}\n\nExtractedCodeFragments:\nprivate boolean fieldsAreAnnotated() {\n\t\treturn !getAnnotatedFieldsByParameter().isEmpty();\n\t}"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "08174e201980698a89f5f5996e10617d89ff09e1",
        "url": "https://github.com/google/gson/commit/08174e201980698a89f5f5996e10617d89ff09e1",
        "sourceCodeBeforeRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
        "refactoredCode": "### Original Code:\n```java\n@Test\npublic void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n\n@Test\npublic void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n}\n```\n\n### Refactored Code:\n```java\n@Test\npublic void testNonFiniteFloats() throws IOException {\n    testNonFiniteValue(Float.NaN);\n    testNonFiniteValue(Float.NEGATIVE_INFINITY);\n    testNonFiniteValue(Float.POSITIVE_INFINITY);\n}\n\n@Test\npublic void testNonFiniteFloatsWhenStrict() throws IOException {\n    testNonFiniteValueStrict(Float.NaN);\n    testNonFiniteValueStrict(Float.NEGATIVE_INFINITY);\n    testNonFiniteValueStrict(Float.POSITIVE_INFINITY);\n}\n\n@Test\npublic void testNonFiniteDoubles() throws IOException {\n    testNonFiniteValue(Double.NaN);\n    testNonFiniteValue(Double.NEGATIVE_INFINITY);\n    testNonFiniteValue(Double.POSITIVE_INFINITY);\n}\n\n@Test\npublic void testNonFiniteDoublesWhenStrict() throws IOException {\n    testNonFiniteValueStrict(Double.NaN);\n    testNonFiniteValueStrict(Double.NEGATIVE_INFINITY);\n    testNonFiniteValueStrict(Double.POSITIVE_INFINITY);\n}\n\n@Test\npublic void testNonFiniteNumbers() throws IOException {\n    testNonFiniteValue(Double.valueOf(Double.NaN));\n    testNonFiniteValue(Double.valueOf(Double.NEGATIVE_INFINITY));\n    testNonFiniteValue(Double.valueOf(Double.POSITIVE_INFINITY));\n    testNonFiniteValue(new LazilyParsedNumber(\"Infinity\"));\n}\n\n@Test\npublic void testNonFiniteNumbersWhenStrict() throws IOException {\n    testNonFiniteValueStrict(Double.valueOf(Double.NaN));\n    testNonFiniteValueStrict(Double.valueOf(Double.NEGATIVE_INFINITY));\n    testNonFiniteValueStrict(Double.valueOf(Double.POSITIVE_INFINITY));\n    testNonFiniteValueStrict(new LazilyParsedNumber(\"Infinity\"));\n}\n\nprivate void testNonFiniteValue(Number value) throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected = assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(value));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was \" + value);\n}\n\nprivate void testNonFiniteValueStrict(Number value) throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected = assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(value));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was \" + value);\n}\n```\n\n### Summary of Changes:\n- Extracted common logic into two helper methods: `testNonFiniteValue` and `testNonFiniteValueStrict` to reduce code duplication.\n- Each test now simply calls these methods with the appropriate values, improving readability and maintainability.",
        "sourceCodeAfterRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
        "uniqueId": "08174e201980698a89f5f5996e10617d89ff09e1_289_312_289_309_311_316",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nAfter Refactoring:\n\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }\n\nExtractedCodeFragments:\nstatic private boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }\nExample 2:\n Before Refactoring:\n@Test\n    public void arraysDifferAtElement0nullMessage() {\n        try {\n            assertArrayEquals((new Object[]{true}), (new Object[]{false}));\n        } catch (AssertionError exception) {\n            assertEquals(\"arrays first differed at element [0]; expected:<true> but was:<false>\", exception\n                    .getMessage());\n        }\n    }\n\nAfter Refactoring:\n@Test\n    public void arraysDifferAtElement0nullMessage() {\n        assertArrayEqualsFailure(\n                new Object[]{true},\n                new Object[]{false},\n                \"arrays first differed at element [0]; expected:<true> but was:<false>\"\n        );\n    }\n\nExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }\nExample 3:\n Before Refactoring:\n@Test\n    public void arraysDifferentLengthDifferingAtStartMessage() {\n        try {\n            assertArrayEquals(\"not equal\", (new Object[]{true}), (new Object[]{false, true}));\n        } catch (AssertionError exception) {\n            assertEquals(\"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n        }\n    }\n\nAfter Refactoring:\n@Test\n    public void arraysDifferentLengthDifferingAtStartMessage() {\n        assertArrayEqualsFailure(\n                \"not equal\",\n                new Object[]{true},\n                new Object[]{false, true},\n                \"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [0]; expected:<true> but was:<false>\");\n    }\n\nExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "66847264765180c849f945ca13704aa0eae79c58",
        "url": "https://github.com/google/gson/commit/66847264765180c849f945ca13704aa0eae79c58",
        "sourceCodeBeforeRefactoring": "\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n  }",
        "refactoredCode": "### Original Code:\n```java\n@CanIgnoreReturnValue\npublic GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n}\n```\n\n### Refactored Code:\n```java\n@CanIgnoreReturnValue\npublic GsonBuilder setDateFormat(int style) {\n    resetDatePattern();\n    this.dateStyle = style;\n    return this;\n}\n\nprivate void resetDatePattern() {\n    this.datePattern = null;\n}\n```\n\n### Explanation:\nIn the refactored code, I extracted the logic that resets the `datePattern` into a separate method called `resetDatePattern()`. This improves readability by clearly indicating the purpose of that line of code and adheres to the Single Responsibility Principle, making it easier to maintain and understand.",
        "sourceCodeAfterRefactoring": "\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = checkDateFormatStyle(style);\n    this.datePattern = null;\n    return this;\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static int checkDateFormatStyle(int style) {\n    \n    if (style < 0 || style > 3) {\n      throw new IllegalArgumentException(\"Invalid style: \" + style);\n    }\n    return style;\n  }",
        "uniqueId": "66847264765180c849f945ca13704aa0eae79c58_614_633_616_622_624_644",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 2:\n Before Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nAfter Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }\n\nExtractedCodeFragments:\nprivate boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\nExample 3:\n Before Refactoring:\npublic FailOnTimeout(Statement originalStatement, long timeout) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n    }\n\nAfter Refactoring:\npublic FailOnTimeout(Statement originalStatement, long timeout) {\n        this(originalStatement, timeout, TimeUnit.MILLISECONDS);\n    }\n\nExtractedCodeFragments:\npublic FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n    }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
        "url": "https://github.com/google/gson/commit/6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
        "sourceCodeBeforeRefactoring": "\n  private Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n  }",
        "refactoredCode": "### Original Code:\n```java\nprivate Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n}\n```\n\n### Refactored Code:\n```java\nprivate Object writeReplace() throws ObjectStreamException {\n    return createBigDecimal(value);\n}\n\nprivate BigDecimal createBigDecimal(Object value) {\n    return new BigDecimal(value);\n}\n```\n\nIn this refactoring, I extracted the creation of the `BigDecimal` into a separate method called `createBigDecimal`. This improves readability by giving a clear purpose to the method and allows for easier testing or modification of the `BigDecimal` creation logic in the future.",
        "sourceCodeAfterRefactoring": "\n  private Object writeReplace() throws ObjectStreamException {\n    return asBigDecimal();\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate BigDecimal asBigDecimal() {\n    return NumberLimits.parseBigDecimal(value);\n  }",
        "uniqueId": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc_75_82_38_40_79_86",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprotected PrintStream writer() {\n\t\treturn fWriter;\n\t}\n\nAfter Refactoring:\n\n\tprotected PrintStream writer() {\n\t\treturn getWriter();\n\t}\n\nExtractedCodeFragments:\nprotected PrintStream getWriter() {\n\t\treturn fWriter;\n\t}\nExample 2:\n Before Refactoring:\nprivate void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        new ObjectOutputStream(byteArrayOutputStream).writeObject(result);\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertNotNull(fromStream);\n    }\n\nAfter Refactoring:\nprivate void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        new ObjectOutputStream(byteArrayOutputStream).writeObject(result);\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertSerializedCorrectly(result, fromStream);\n\n        InputStream resource = getClass().getResourceAsStream(getName());\n        assertNotNull(\"Could not read resource \" + getName(), resource);\n        objectInputStream = new ObjectInputStream(resource);\n        fromStream = (Result) objectInputStream.readObject();\n        \n        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);\n    }\n\nExtractedCodeFragments:\nprivate void assertSerializedCorrectly(Result result, Result fromStream) {\n        assertNotNull(fromStream);\n\n        // Exceptions don't implement equals() so we need to compare field by field\n        assertEquals(\"failureCount\", result.getFailureCount(), fromStream.getFailureCount());\n        assertEquals(\"ignoreCount\", result.getIgnoreCount(), fromStream.getIgnoreCount());\n        assertEquals(\"runTime\", result.getRunTime(), fromStream.getRunTime());\n        assertEquals(\"failures\", result.getFailures().size(), fromStream.getFailures().size());\n        int index = 0;\n        for (Failure failure : result.getFailures()) {\n            Failure failureFromStream = fromStream.getFailures().get(index);\n            String messagePrefix = String.format(\"failures[%d]\", index++);\n            assertEquals(messagePrefix + \".description\",\n                    failure.getDescription(), failureFromStream.getDescription());\n            Throwable exception = failure.getException();\n            Throwable exceptionFromStream = failureFromStream.getException();\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getClass(), exceptionFromStream.getClass());\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getMessage(), exceptionFromStream.getMessage());\n        }\n    }\nExample 3:\n Before Refactoring:\n\n\tpublic TestRunner(PrintStream writer) {\n\t\tif (writer == null)\n\t\t\tthrow new IllegalArgumentException(\"Writer can't be null\");\n\t\tfPrinter= new ResultPrinter(writer);\n\t}\n\nAfter Refactoring:\n\n\tpublic TestRunner(PrintStream writer) {\n\t\tthis(new ResultPrinter(writer));\n\t}\n\nExtractedCodeFragments:\n/**\n\t * Constructs a TestRunner using the given ResultPrinter all the output\n\t */\n\tpublic TestRunner(ResultPrinter printer) {\n\t\tfPrinter= printer;\n\t}"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "e7cf5c458374e5fc69dbdce6de5cb2c881521135",
        "url": "https://github.com/google/gson/commit/e7cf5c458374e5fc69dbdce6de5cb2c881521135",
        "sourceCodeBeforeRefactoring": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      \n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        \n        \n        Method accessor = null;\n        if (isRecord) {\n          \n          \n          \n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            \n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            \n            \n            \n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        \n        \n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, accessor, name,\n              TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n              + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n              + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n              + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }",
        "refactoredCode": "### Original Code:\n```java\nprivate Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n\n        Method accessor = null;\n        if (isRecord) {\n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; \n          BoundField boundField = createBoundField(context, field, accessor, name,\n              TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n              + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n              + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n              + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n}\n```\n\n### Refactored Code:\n```java\nprivate Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n        return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n        Field[] fields = raw.getDeclaredFields();\n        handleReflectionAccessFilter(originalRaw, raw, fields);\n\n        for (Field field : fields) {\n            boolean serialize = includeField(field, true);\n            boolean deserialize = includeField(field, false);\n            if (!serialize && !deserialize) {\n                continue;\n            }\n\n            Method accessor = null;\n            if (isRecord) {\n                accessor = handleRecordField(field, blockInaccessible, deserialize);\n                if (accessor == null) {\n                    deserialize = false;\n                }\n            }\n\n            if (!blockInaccessible && accessor == null) {\n                ReflectionHelper.makeAccessible(field);\n            }\n            Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n            List<String> fieldNames = getFieldNames(field);\n            BoundField previous = processFieldNames(context, field, accessor, fieldNames, serialize, deserialize, blockInaccessible, result);\n            checkForDuplicateFields(originalRaw, previous, field);\n        }\n        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n        raw = type.getRawType();\n    }\n    return result;\n}\n\nprivate void handleReflectionAccessFilter(Class<?> originalRaw, Class<?> raw, Field[] fields) {\n    if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n            throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n                + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n                + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n    }\n}\n\nprivate Method handleRecordField(Field field, boolean blockInaccessible, boolean deserialize) {\n    if (Modifier.isStatic(field.getModifiers())) {\n        return null;\n    } else {\n        Method accessor = ReflectionHelper.getAccessor(raw, field);\n        if (!blockInaccessible) {\n            ReflectionHelper.makeAccessible(accessor);\n        }\n        validateSerializedName(field, accessor);\n        return accessor;\n    }\n}\n\nprivate void validateSerializedName(Field field, Method accessor) {\n    if (accessor.getAnnotation(SerializedName.class) != null\n        && field.getAnnotation(SerializedName.class) == null) {\n        String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n        throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n    }\n}\n\nprivate BoundField processFieldNames(Gson context, Field field, Method accessor, List<String> fieldNames,\n                                      boolean serialize, boolean deserialize, boolean blockInaccessible,\n                                      Map<String, BoundField> result) {\n    BoundField previous = null;\n    for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n        String name = fieldNames.get(i);\n        if (i != 0) serialize = false; \n        BoundField boundField = createBoundField(context, field, accessor, name,\n            TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n        BoundField replaced = result.put(name, boundField);\n        if (previous == null) previous = replaced;\n    }\n    return previous;\n}\n\nprivate void checkForDuplicateFields(Class<?> originalRaw, BoundField previous, Field field) {\n    if (previous != null) {\n        throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n            + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n            + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n            + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n    }\n}\n```\n\n### Summary of Changes:\n1. **Extracted Methods**: Created helper methods to handle specific tasks, such as `handleReflectionAccessFilter`, `handleRecordField`, `validateSerializedName`, `processFieldNames`, and `checkForDuplicateFields`. This reduces the complexity of the main method and improves readability.\n2. **Improved Readability**: The refactored code is structured in a way that each method has a single responsibility, making it easier to understand the flow of logic.\n3. **Consistent Formatting**: Ensured consistent formatting and indentation for better readability.",
        "sourceCodeAfterRefactoring": "private FieldsData getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\n    if (raw.isInterface()) {\n      return FieldsData.EMPTY;\n    }\n\n    Map<String, BoundField> deserializedFields = new LinkedHashMap<>();\n    \n    Map<String, BoundField> serializedFields = new LinkedHashMap<>();\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      \n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        \n        \n        Method accessor = null;\n        if (isRecord) {\n          \n          \n          \n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            \n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            \n            \n            \n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        \n        \n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        String serializedName = fieldNames.get(0);\n        BoundField boundField = createBoundField(context, field, accessor, serializedName,\n            TypeToken.get(fieldType), serialize, blockInaccessible);\n\n        if (deserialize) {\n          for (String name : fieldNames) {\n            BoundField replaced = deserializedFields.put(name, boundField);\n\n            if (replaced != null) {\n              throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\n            }\n          }\n        }\n\n        if (serialize) {\n          BoundField replaced = serializedFields.put(serializedName, boundField);\n          if (replaced != null) {\n            throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\n          }\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate static IllegalArgumentException createDuplicateFieldException(Class<?> declaringType, String duplicateName, Field field1, Field field2) {\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName()\n        + \" declares multiple JSON fields named '\" + duplicateName + \"'; conflict is caused\"\n        + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2)\n        + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n  }",
        "uniqueId": "e7cf5c458374e5fc69dbdce6de5cb2c881521135_236_318_247_252_254_344",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\npublic ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\nAfter Refactoring:\n@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (final Method method : fClass.getMethods()) {\n\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\tlist.add(new MethodParameterValue(method));\n\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\ttry {\n\t\t\t\t\taddArrayValues(list, method.invoke(null));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\nExtractedCodeFragments:\nprivate Object getStaticFieldValue(final Field field) {\n\t\ttry {\n\t\t\treturn field.get(null);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t}\n\t}\nExample 2:\n Before Refactoring:\npublic static ParameterSupplier fieldParameterSupplier(final Class<?> targetClass) {\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t};\n\t}\n\nAfter Refactoring:\npublic ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\nExtractedCodeFragments:\npublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\ttry {\n\t\t\t\treturn fMethod.invoke(fTest);\nExample 3:\n Before Refactoring:\npublic static ParameterSupplier fieldParameterSupplier(final Class<?> targetClass) {\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t};\n\t}\n\nAfter Refactoring:\npublic ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\nExtractedCodeFragments:\nthrow new RuntimeException(\n\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t} catch (IllegalAccessException e) {"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
        "url": "https://github.com/google/gson/commit/7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
        "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\") \n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
        "refactoredCode": "### Original Code:\n```java\n@SuppressWarnings(\"unchecked\") \n@Override\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n        return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}\n\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n        typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n        typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n        JsonSerializer<?> serializer = instance instanceof JsonSerializer\n            ? (JsonSerializer<?>) instance\n            : null;\n        JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n            ? (JsonDeserializer<?>) instance\n            : null;\n\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n        typeAdapter = tempAdapter;\n\n        nullSafe = false;\n    } else {\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n            + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n            + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n            + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n        typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n}\n```\n\n### Refactored Code:\n```java\n@SuppressWarnings(\"unchecked\") \n@Override\npublic <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    JsonAdapter annotation = getJsonAdapterAnnotation(targetType);\n    if (annotation == null) {\n        return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}\n\nprivate <T> JsonAdapter getJsonAdapterAnnotation(TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    return rawType.getAnnotation(JsonAdapter.class);\n}\n\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    \n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n    TypeAdapter<?> typeAdapter = createTypeAdapter(instance, gson, type, annotation.nullSafe());\n    \n    return typeAdapter;\n}\n\nprivate TypeAdapter<?> createTypeAdapter(Object instance, Gson gson, TypeToken<?> type, boolean nullSafe) {\n    if (instance instanceof TypeAdapter) {\n        return (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n        return ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n        return createTreeTypeAdapter(instance, gson, type, nullSafe);\n    } else {\n        throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n            + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n            + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n            + \" JsonSerializer or JsonDeserializer.\");\n    }\n}\n\nprivate TypeAdapter<?> createTreeTypeAdapter(Object instance, Gson gson, TypeToken<?> type, boolean nullSafe) {\n    JsonSerializer<?> serializer = instance instanceof JsonSerializer ? (JsonSerializer<?>) instance : null;\n    JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer ? (JsonDeserializer<?>) instance : null;\n\n    TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n    return nullSafe ? tempAdapter.nullSafe() : tempAdapter;\n}\n```\n\n### Summary of Changes:\n1. **Extracted Method for Annotation Retrieval**: Created a separate method `getJsonAdapterAnnotation` to improve clarity and reduce complexity in the `create` method.\n2. **Extracted Type Adapter Creation Logic**: Moved the logic for creating the type adapter into a new method `createTypeAdapter` to encapsulate the logic and improve readability.\n3. **Extracted Tree Type Adapter Creation Logic**: Created a method `createTreeTypeAdapter` to handle the creation of `TreeTypeAdapter`, further simplifying the `getTypeAdapter` method.\n4. **Improved Variable Naming**: Enhanced clarity by using descriptive method names and reducing the number of inline checks. \n\nThese changes enhance the readability and maintainability of the code while preserving its original functionality.",
        "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\") \n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = getAnnotation(rawType);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation, boolean isClassAnnotation) {\n    Object instance = createAdapter(constructorConstructor, annotation.value());\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      TypeAdapterFactory factory = (TypeAdapterFactory) instance;\n\n      if (isClassAnnotation) {\n        factory = putFactoryAndGetCurrent(type.getRawType(), factory);\n      }\n\n      typeAdapter = factory.create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      \n      \n      TypeAdapterFactory skipPast;\n      if (isClassAnnotation) {\n        skipPast = TREE_TYPE_CLASS_DUMMY_FACTORY;\n      } else {\n        skipPast = TREE_TYPE_FIELD_DUMMY_FACTORY;\n      }\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\nprivate JsonAdapter getAnnotation(Class<?> rawType) {\n    return rawType.getAnnotation(JsonAdapter.class);\n  }\nExtractedCodeFragments:\nprivate static Object createAdapter(ConstructorConstructor constructorConstructor, Class<?> adapterClass) {\n    \n    \n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\n  }",
        "uniqueId": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956_41_50_73_75_77_86",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\nprivate void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if (returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) {\n                try {\n                    addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }\n\nAfter Refactoring:\nprivate void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if ((returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) ||\n                    Iterable.class.isAssignableFrom(returnType)) {\n                try {\n                    addDataPointsValues(returnType, sig, dataPointsMethod.getName(), list, \n                            dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate void addDataPointsValues(Class<?> type, ParameterSignature sig, String name, \n            List<PotentialAssignment> list, Object value) {\n        if (type.isArray()) {\n            addArrayValues(sig, name, list, value);\n        }\n        else if (Iterable.class.isAssignableFrom(type)) {\n            addIterableValues(sig, name, list, (Iterable<?>) value);\n        }\n    }\nExample 2:\n Before Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nAfter Refactoring:\nprivate void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }\n\nExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }\nExample 3:\n Before Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nAfter Refactoring:\nprivate boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }\n\nExtractedCodeFragments:\nprivate boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }"
    },
    {
        "repository": "https://github.com/google/gson.git",
        "sha1": "b3dce2dc17086c72bd1f8ccf508874849f9631bb",
        "url": "https://github.com/google/gson/commit/b3dce2dc17086c72bd1f8ccf508874849f9631bb",
        "sourceCodeBeforeRefactoring": "\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }",
        "refactoredCode": "### Original Code:\n```java\npublic final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n}\n```\n\n### Refactored Code:\n```java\npublic final void setLenientMode(boolean isLenient) {\n    this.lenient = isLenient;\n}\n```\n\n### Explanation:\n- The method name `setLenient` was changed to `setLenientMode` to provide clearer context about what the method is doing.\n- The parameter name `lenient` was changed to `isLenient` to improve readability and indicate that it is a boolean flag. \n\nThis refactoring enhances the clarity of the code without changing its functionality.",
        "sourceCodeAfterRefactoring": "\n  @Deprecated\n  @SuppressWarnings(\"InlineMeSuggester\") \n  public final void setLenient(boolean lenient) {\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\n  }",
        "diffSourceCode": "ExtractedCodeFragments:\n\n  public final void setStrictness(Strictness strictness) {\n    this.strictness = Objects.requireNonNull(strictness);\n  }",
        "uniqueId": "b3dce2dc17086c72bd1f8ccf508874849f9631bb_270_282_298_320_271_287",
        "historicalRefactorings": "Example 1:\n Before Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (expected.getClass().isArray() && actual.getClass().isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nAfter Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nExtractedCodeFragments:\nprivate static boolean isArray(Object expected) {\n\t\treturn expected != null && expected.getClass().isArray();\n\t}\nExample 2:\n Before Refactoring:\nprotected TestResult doRun(Test suite, boolean wait) {\n\t\tTestResult result= createTestResult();\n\t\tresult.addListener(this);\n\t\tlong startTime= System.currentTimeMillis();\n\t\tsuite.run(result);\n\t\tlong endTime= System.currentTimeMillis();\n\t\tlong runTime= endTime-startTime;\n\t\twriter().println();\n\t\twriter().println(\"Time: \"+elapsedTimeAsString(runTime));\n\t\tprint(result);\n\n\t\twriter().println();\n\n\t\tif (wait) {\n\t\t\twriter().println(\"<RETURN> to continue\");\n\t\t\ttry {\n\t\t\t\tSystem.in.read();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\nAfter Refactoring:\npublic TestResult doRun(Test suite, boolean wait) {\n\t\tTestResult result= createTestResult();\n\t\tresult.addListener(this);\n\t\tlong startTime= System.currentTimeMillis();\n\t\tsuite.run(result);\n\t\tlong endTime= System.currentTimeMillis();\n\t\tlong runTime= endTime-startTime;\n\t\twriter().println();\n\t\twriter().println(\"Time: \"+elapsedTimeAsString(runTime));\n\t\tprint(result);\n\n\t\twriter().println();\n\n\t\tpause(wait);\n\t\treturn result;\n\t}\n\nExtractedCodeFragments:\nprotected void pause(boolean wait) {\n\t\tif (wait) {\n\t\t\twriter().println(\"<RETURN> to continue\");\n\t\t\ttry {\n\t\t\t\tSystem.in.read();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t}\n\t\t}\n\t}\nExample 3:\n Before Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header= message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\"\n\t\t\t\t\t+ expectedsLength + \" actual.length=\" + actualsLength);\n\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nAfter Refactoring:\n\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header= message == null ? \"\" : message + \": \";\n\t\tint expectedsLength= assertArraysAreSameLength(expecteds, actuals,\n\t\t\t\theader);\n\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\t\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}\n\nExtractedCodeFragments:\npublic static int assertArraysAreSameLength(Object expecteds,\n\t\t\tObject actuals, String header) {\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\"\n\t\t\t\t\t+ expectedsLength + \" actual.length=\" + actualsLength);\n\t\treturn expectedsLength;\n\t}"
    }
]
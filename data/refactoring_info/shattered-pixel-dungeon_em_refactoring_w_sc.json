{
  "commits": [
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndEnergizeItem(Item item, WndBag owner) {\n\t\tsuper(item);\n\n\t\tthis.owner = owner;\n\n\t\tfloat pos = height;\n\n\t\tif (item.quantity() == 1) {\n\n\t\t\tRedButton btnEnergize = new RedButton( Messages.get(this, \"energize\", item.energyVal()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergize( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize );\n\n\t\t\tpos = btnEnergize.bottom();\n\n\t\t} else {\n\n\t\t\tint energyAll = item.energyVal();\n\t\t\tRedButton btnEnergize1 = new RedButton( Messages.get(this, \"energize_1\", energyAll / item.quantity()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeOne( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize1.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize1 );\n\t\t\tRedButton btnEnergizeAll = new RedButton( Messages.get(this, \"energize_all\", energyAll ) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergize( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergizeAll.setRect( 0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT );\n\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergizeAll );\n\n\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t}\n\n\t\tresize( width, (int)pos );\n\n\t}",
          "sourceCodeAfterRefactoring": "public WndEnergizeItem(Item item, WndBag owner) {\n\t\tsuper(item);\n\n\t\tthis.owner = owner;\n\n\t\tfloat pos = height;\n\n\t\tif (item.quantity() == 1) {\n\n\t\t\tRedButton btnEnergize = new RedButton( Messages.get(this, \"energize\", item.energyVal()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeAll( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize );\n\n\t\t\tpos = btnEnergize.bottom();\n\n\t\t} else {\n\n\t\t\tint energyAll = item.energyVal();\n\t\t\tRedButton btnEnergize1 = new RedButton( Messages.get(this, \"energize_1\", energyAll / item.quantity()) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeOne( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergize1.setRect( 0, pos + GAP, width, BTN_HEIGHT );\n\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergize1 );\n\t\t\tRedButton btnEnergizeAll = new RedButton( Messages.get(this, \"energize_all\", energyAll ) ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tenergizeAll( item );\n\t\t\t\t\thide();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtnEnergizeAll.setRect( 0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT );\n\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\tadd( btnEnergizeAll );\n\n\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t}\n\n\t\tresize( width, (int)pos );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void energizeAll(Item item ) {\n\n\t\tif (item.isEquipped( Dungeon.hero ) && !((EquipableItem)item).doUnequip( Dungeon.hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( Dungeon.hero.belongings.backpack );\n\t\tenergize(item);\n\t}",
          "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_44_96_110_117_45_97"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void energizeOne( Item item ) {\n\n\t\tif (item.quantity() <= 1) {\n\t\t\tenergize( item );\n\t\t} else {\n\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\titem = item.detach( hero.belongings.backpack );\n\n\t\t\tif (ShatteredPixelDungeon.scene() instanceof AlchemyScene){\n\n\t\t\t\tDungeon.energy += item.energyVal();\n\t\t\t\t((AlchemyScene) ShatteredPixelDungeon.scene()).createEnergy();\n\n\t\t\t} else {\n\n\t\t\t\t//selling items in the sell interface doesn't spend time\n\t\t\t\thero.spend(-hero.cooldown());\n\n\t\t\t\tnew EnergyCrystal(item.energyVal()).doPickUp(hero);\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void energizeOne( Item item ) {\n\n\t\tif (item.quantity() <= 1) {\n\t\t\tenergizeAll( item );\n\t\t} else {\n\t\t\tenergize(item.detach( Dungeon.hero.belongings.backpack ));\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void energizeAll(Item item ) {\n\n\t\tif (item.isEquipped( Dungeon.hero ) && !((EquipableItem)item).doUnequip( Dungeon.hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( Dungeon.hero.belongings.backpack );\n\t\tenergize(item);\n\t}",
          "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_133_156_110_117_119_126"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\n\t\t\tthis.owner = owner;\n\n\t\t\tfloat pos = height;\n\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\n\t\t\t\t\tpos = btnSell.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\n\t\t\t\t\tpos = btnSellAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\n\t\t\t\t\tpos = btnEnergize.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energize(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\n\n\t\t\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresize( width, (int)pos );\n\n\t\t}",
          "sourceCodeAfterRefactoring": "public WndAlchemizeItem(Item item, WndBag owner) {\n\t\t\tsuper(item);\n\n\t\t\tthis.owner = owner;\n\n\t\t\tfloat pos = height;\n\n\t\t\tif (Shopkeeper.canSell(item)) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnSell = new RedButton(Messages.get(this, \"sell\", item.value())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell);\n\n\t\t\t\t\tpos = btnSell.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint priceAll = item.value();\n\t\t\t\t\tRedButton btnSell1 = new RedButton(Messages.get(this, \"sell_1\", priceAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sellOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSell1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSell1.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSell1);\n\t\t\t\t\tRedButton btnSellAll = new RedButton(Messages.get(this, \"sell_all\", priceAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndTradeItem.sell(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnSellAll.setRect(0, btnSell1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnSellAll.icon(new ItemSprite(ItemSpriteSheet.GOLD));\n\t\t\t\t\tadd(btnSellAll);\n\n\t\t\t\t\tpos = btnSellAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (item.energyVal() > 0) {\n\t\t\t\tif (item.quantity() == 1) {\n\n\t\t\t\t\tRedButton btnEnergize = new RedButton(Messages.get(this, \"energize\", item.energyVal())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeAll(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize);\n\n\t\t\t\t\tpos = btnEnergize.bottom();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tint energyAll = item.energyVal();\n\t\t\t\t\tRedButton btnEnergize1 = new RedButton(Messages.get(this, \"energize_1\", energyAll / item.quantity())) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeOne(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergize1.setRect(0, pos + GAP, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergize1.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergize1);\n\t\t\t\t\tRedButton btnEnergizeAll = new RedButton(Messages.get(this, \"energize_all\", energyAll)) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tWndEnergizeItem.energizeAll(item);\n\t\t\t\t\t\t\thide();\n\t\t\t\t\t\t\tconsumeAlchemize();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnEnergizeAll.setRect(0, btnEnergize1.bottom() + 1, width, BTN_HEIGHT);\n\t\t\t\t\tbtnEnergizeAll.icon(new ItemSprite(ItemSpriteSheet.ENERGY));\n\t\t\t\t\tadd(btnEnergizeAll);\n\n\t\t\t\t\tpos = btnEnergizeAll.bottom();\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresize( width, (int)pos );\n\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static WndBag.ItemSelector itemSelector = new WndBag.ItemSelector() {\n\t\t@Override\n\t\tpublic String textPrompt() {\n\t\t\treturn Messages.get(Alchemize.class, \"prompt\");\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean itemSelectable(Item item) {",
          "uniqueId": "47fd533ca2ed99b219c8ffe6b37b241c6bd7aaff_141_246_110_117_141_246"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "92905ae81c0eb272c9a62d5f6914bda253fc571d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/92905ae81c0eb272c9a62d5f6914bda253fc571d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tString loadingAsset;\n\t\tint loadingDepth;\n\t\tfadeTime = NORM_FADE;\n\n\t\tlong seed = Dungeon.seed;\n\t\tswitch (mode){\n\t\t\tdefault:\n\t\t\t\tloadingDepth = Dungeon.depth;\n\t\t\t\tbreak;\n\t\t\tcase CONTINUE:\n\t\t\t\tloadingDepth = GamesInProgress.check(GamesInProgress.curSlot).depth;\n\t\t\t\tseed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n\t\t\t\tbreak;\n\t\t\tcase DESCEND:\n\t\t\t\tif (Dungeon.hero == null){\n\t\t\t\t\tloadingDepth = 1;\n\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t} else {\n\t\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\t\telse                        loadingDepth = Dungeon.depth+1;\n\t\t\t\t\tif (Statistics.deepestFloor >= loadingDepth) {\n\t\t\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\t\t} else if (loadingDepth == 6 || loadingDepth == 11\n\t\t\t\t\t\t\t|| loadingDepth == 16 || loadingDepth == 21) {\n\t\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FALL:\n\t\t\t\tloadingDepth = Dungeon.depth+1;\n\t\t\t\tbreak;\n\t\t\tcase ASCEND:\n\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\telse                        loadingDepth = Dungeon.depth-1;\n\t\t\t\tbreak;\n\t\t\tcase RETURN:\n\t\t\t\tloadingDepth = returnDepth;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//flush the texture cache whenever moving between regions, helps reduce memory load\n\t\tint region = (int)Math.ceil(loadingDepth / 5f);\n\t\tif (region != lastRegion){\n\t\t\tTextureCache.clear();\n\t\t\tlastRegion = region;\n\t\t}\n\n\t\tint loadingCenter = 400;\n\n\t\t//for portrait users, each run the splashes change what details they focus on\n\t\t//TOD should these be uniform, or should some be more common?\n\t\tRandom.pushGenerator(seed+lastRegion);\n\t\t\tswitch (lastRegion){\n\t\t\t\tcase 1:\n\t\t\t\t\tloadingAsset = Assets.Splashes.SEWERS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 180; break; //focus on rats and left side\n\t\t\t\t\t\tcase 1: loadingCenter = 485; break; //focus on center pipe and door\n\t\t\t\t\t\tcase 2: loadingCenter = 700; break; //focus on right pipe\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingAsset = Assets.Splashes.PRISON;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 190; break; //focus on left skeleton\n\t\t\t\t\t\tcase 1: loadingCenter = 402; break; //focus on center arch\n\t\t\t\t\t\tcase 2: loadingCenter = 650; break; //focus on right stairs\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CAVES;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 120; break; //focus on far-left mining machinery\n\t\t\t\t\t\tcase 1: loadingCenter = 340; break; //focus on center gnoll groups\n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; //focus on right gnoll\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CITY;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 275; break; //focus on left bookcases\n\t\t\t\t\t\tcase 1: loadingCenter = 460; break; //focus on center pathway\n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; //focus on right bookcases\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: default:\n\t\t\t\t\tloadingAsset = Assets.Splashes.HALLS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 145; break; //focus on left arches\n\t\t\t\t\t\tcase 1: loadingCenter = 400; break; //focus on ripper demon\n\t\t\t\t\t\tcase 2: loadingCenter = 615; break; //focus on right arches\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tRandom.popGenerator();\n\t\t\n\t\tif (DeviceCompat.isDebug()){\n\t\t\tfadeTime = 0f;\n\t\t}\n\n\t\tImage background = new Image(loadingAsset);\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tif (Camera.main.width >= background.width()){\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\t} else {\n\t\t\tbackground.x = Camera.main.width/2f - loadingCenter*background.scale.x;\n\t\t\tbackground.x = GameMath.gate(Camera.main.width - background.width(), background.x, 0);\n\t\t}\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tImage fadeLeft, fadeRight;\n\t\tfadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n\t\tfadeLeft.x = background.x-2;\n\t\tfadeLeft.scale.set(3, background.height());\n\t\tfadeLeft.visible = background.x > 0;\n\t\tadd(fadeLeft);\n\n\t\tfadeRight = new Image(fadeLeft);\n\t\tfadeRight.x = background.x + background.width() + 2;\n\t\tfadeRight.y = background.y + background.height();\n\t\tfadeRight.angle = 180;\n\t\tfadeRight.visible = fadeLeft.visible;\n\t\tadd(fadeRight);\n\n\t\tImage im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tif (lastRegion == 6)                aa = 1;\n\t\t\t\telse if (phase == Phase.FADE_IN)    aa = Math.max( 0, 2*(timeLeft - (fadeTime - 0.333f)));\n\t\t\t\telse if (phase == Phase.FADE_OUT)   aa = Math.max( 0, 2*(0.333f - timeLeft));\n\t\t\t\telse                                aa = 0;\n\t\t\t}\n\t\t};\n\t\tim.angle = 90;\n\t\tim.x = Camera.main.width;\n\t\tim.scale.x = Camera.main.height/5f;\n\t\tim.scale.y = Camera.main.width;\n\t\tadd(im);\n\n\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\n\t\tmessage = PixelScene.renderTextBlock( text, 9 );\n\t\tmessage.setPos(\n\t\t\t\t(Camera.main.width - message.width() - 8),\n\t\t\t\t(Camera.main.height - message.height() - 6)\n\t\t);\n\t\talign(message);\n\t\tadd( message );\n\n\t\tphase = Phase.FADE_IN;\n\t\ttimeLeft = fadeTime;\n\t\t\n\t\tif (thread == null) {\n\t\t\tthread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tActor.fixTime();\n\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase DESCEND:\n\t\t\t\t\t\t\t\tdescend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASCEND:\n\t\t\t\t\t\t\t\tascend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\t\trestore();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESURRECT:\n\t\t\t\t\t\t\t\tresurrect();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RETURN:\n\t\t\t\t\t\t\t\treturnTo();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FALL:\n\t\t\t\t\t\t\t\tfall();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESET:\n\t\t\t\t\t\t\t\treset();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (thread) {\n\t\t\t\t\t\tif (phase == Phase.STATIC && error == null) {\n\t\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthread.start();\n\t\t}\n\t\twaitingTime = 0f;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tString loadingAsset;\n\t\tint loadingDepth;\n\t\tfadeTime = NORM_FADE;\n\n\t\tlong seed = Dungeon.seed;\n\t\tswitch (mode){\n\t\t\tdefault:\n\t\t\t\tloadingDepth = Dungeon.depth;\n\t\t\t\tbreak;\n\t\t\tcase CONTINUE:\n\t\t\t\tloadingDepth = GamesInProgress.check(GamesInProgress.curSlot).depth;\n\t\t\t\tseed = GamesInProgress.check(GamesInProgress.curSlot).seed;\n\t\t\t\tbreak;\n\t\t\tcase DESCEND:\n\t\t\t\tif (Dungeon.hero == null){\n\t\t\t\t\tloadingDepth = 1;\n\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t} else {\n\t\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\t\telse                        loadingDepth = Dungeon.depth+1;\n\t\t\t\t\tif (Statistics.deepestFloor >= loadingDepth) {\n\t\t\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\t\t} else if (loadingDepth == 6 || loadingDepth == 11\n\t\t\t\t\t\t\t|| loadingDepth == 16 || loadingDepth == 21) {\n\t\t\t\t\t\tfadeTime = SLOW_FADE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase FALL:\n\t\t\t\tloadingDepth = Dungeon.depth+1;\n\t\t\t\tbreak;\n\t\t\tcase ASCEND:\n\t\t\t\tfadeTime = FAST_FADE;\n\t\t\t\tif (curTransition != null)  loadingDepth = curTransition.destDepth;\n\t\t\t\telse                        loadingDepth = Dungeon.depth-1;\n\t\t\t\tbreak;\n\t\t\tcase RETURN:\n\t\t\t\tloadingDepth = returnDepth;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t//flush the texture cache whenever moving between regions, helps reduce memory load\n\t\tint region = (int)Math.ceil(loadingDepth / 5f);\n\t\tif (region != lastRegion){\n\t\t\tTextureCache.clear();\n\t\t\tlastRegion = region;\n\t\t}\n\n\t\tint loadingCenter = 400;\n\n\t\t//for portrait users, each run the splashes change what details they focus on\n\t\t//TOD should these be uniform, or should some be more common?\n\t\tRandom.pushGenerator(seed+lastRegion);\n\t\t\tswitch (lastRegion){\n\t\t\t\tcase 1:\n\t\t\t\t\tloadingAsset = Assets.Splashes.SEWERS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 180; break; //focus on rats and left side\n\t\t\t\t\t\tcase 1: loadingCenter = 485; break; //focus on center pipe and door\n\t\t\t\t\t\tcase 2: loadingCenter = 700; break; //focus on right pipe\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingAsset = Assets.Splashes.PRISON;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 190; break; //focus on left skeleton\n\t\t\t\t\t\tcase 1: loadingCenter = 402; break; //focus on center arch\n\t\t\t\t\t\tcase 2: loadingCenter = 650; break; //focus on right stairs\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CAVES;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 120; break; //focus on far-left mining machinery\n\t\t\t\t\t\tcase 1: loadingCenter = 340; break; //focus on center gnoll groups\n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; //focus on right gnoll\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tloadingAsset = Assets.Splashes.CITY;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 275; break; //focus on left bookcases\n\t\t\t\t\t\tcase 1: loadingCenter = 460; break; //focus on center pathway\n\t\t\t\t\t\tcase 2: loadingCenter = 625; break; //focus on right bookcases\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5: default:\n\t\t\t\t\tloadingAsset = Assets.Splashes.HALLS;\n\t\t\t\t\tswitch (Random.Int(3)){\n\t\t\t\t\t\tcase 0: loadingCenter = 145; break; //focus on left arches\n\t\t\t\t\t\tcase 1: loadingCenter = 400; break; //focus on ripper demon\n\t\t\t\t\t\tcase 2: loadingCenter = 615; break; //focus on right arches\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tRandom.popGenerator();\n\t\t\n\t\tif (DeviceCompat.isDebug()){\n\t\t\tfadeTime = 1f;\n\t\t}\n\n\t\tImage background = new Image(loadingAsset);\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tif (Camera.main.width >= background.width()){\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\t} else {\n\t\t\tbackground.x = Camera.main.width/2f - loadingCenter*background.scale.x;\n\t\t\tbackground.x = GameMath.gate(Camera.main.width - background.width(), background.x, 0);\n\t\t}\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tImage fadeLeft, fadeRight;\n\t\tfadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0xFF000000, 0x00000000));\n\t\tfadeLeft.x = background.x-2;\n\t\tfadeLeft.scale.set(3, background.height());\n\t\tfadeLeft.visible = background.x > 0;\n\t\tadd(fadeLeft);\n\n\t\tfadeRight = new Image(fadeLeft);\n\t\tfadeRight.x = background.x + background.width() + 2;\n\t\tfadeRight.y = background.y + background.height();\n\t\tfadeRight.angle = 180;\n\t\tfadeRight.visible = fadeLeft.visible;\n\t\tadd(fadeRight);\n\n\t\tImage im = new Image(TextureCache.createGradient(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xFF000000)){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tif (lastRegion == 6)                aa = 1;\n\t\t\t\telse if (phase == Phase.FADE_IN)    aa = Math.max( 0, 2*(timeLeft - (fadeTime - 0.333f)));\n\t\t\t\telse if (phase == Phase.FADE_OUT)   aa = Math.max( 0, 2*(0.333f - timeLeft));\n\t\t\t\telse                                aa = 0;\n\t\t\t}\n\t\t};\n\t\tim.angle = 90;\n\t\tim.x = Camera.main.width;\n\t\tim.scale.x = Camera.main.height/5f;\n\t\tim.scale.y = Camera.main.width;\n\t\tadd(im);\n\n\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\n\t\tloadingText = PixelScene.renderTextBlock( text, 9 );\n\t\tloadingText.setPos(\n\t\t\t\t(Camera.main.width - loadingText.width() - 8),\n\t\t\t\t(Camera.main.height - loadingText.height() - 6)\n\t\t);\n\t\talign(loadingText);\n\t\tadd(loadingText);\n\n\t\t//TODo this is functional and doesn't look awful, but there's still improving to be done here\n\t\tif (mode == Mode.DESCEND){\n\t\t\tif (Dungeon.hero == null || (loadingDepth > Statistics.deepestFloor && loadingDepth % 5 == 1)){\n\t\t\t\t\tstoryMessage = PixelScene.renderTextBlock(Document.INTROS.pageBody(region), 6);\n\t\t\t\t\tstoryMessage.maxWidth( PixelScene.landscape() ? 180 : 125);\n\t\t\t\t\tstoryMessage.setPos((Camera.main.width-storyMessage.width())/2f, (Camera.main.height-storyMessage.height())/2f);\n\n\t\t\t\t\tstoryBG = new ShadowBox();\n\t\t\t\t\tstoryBG.boxRect(storyMessage.left()-10, storyMessage.top()-10, storyMessage.width()+20, storyMessage.height()+20);\n\t\t\t\t\tstoryBG.alpha(0.75f);\n\t\t\t\t\tadd(storyBG);\n\t\t\t\t\tadd(storyMessage);\n\n\t\t\t\t\tbtnContinue = new StyledButton(Chrome.Type.TOAST_TR, \"Continue\", 9){\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\t\ttimeLeft = fadeTime;\n\n\t\t\t\t\t\t\tbtnContinue.enable(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbtnContinue.icon(Icons.STAIRS.get());\n\t\t\t\t\tbtnContinue.setSize(btnContinue.reqWidth()+10, 22);\n\t\t\t\t\tbtnContinue.enable(false);\n\n\t\t\t\t\tbtnContinue.setPos((Camera.main.width - btnContinue.width())/2f, storyMessage.bottom()+10);\n\t\t\t\t\tadd(btnContinue);\n\t\t\t}\n\t\t}\n\n\t\tphase = Phase.FADE_IN;\n\t\ttimeLeft = fadeTime;\n\t\t\n\t\tif (thread == null) {\n\t\t\tthread = new Thread() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tActor.fixTime();\n\n\t\t\t\t\t\tswitch (mode) {\n\t\t\t\t\t\t\tcase DESCEND:\n\t\t\t\t\t\t\t\tdescend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASCEND:\n\t\t\t\t\t\t\t\tascend();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase CONTINUE:\n\t\t\t\t\t\t\t\trestore();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESURRECT:\n\t\t\t\t\t\t\t\tresurrect();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RETURN:\n\t\t\t\t\t\t\t\treturnTo();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FALL:\n\t\t\t\t\t\t\t\tfall();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase RESET:\n\t\t\t\t\t\t\t\treset();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tsynchronized (thread) {\n\t\t\t\t\t\tif (phase == Phase.STATIC && error == null) {\n\t\t\t\t\t\t\tafterLoading();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthread.start();\n\t\t}\n\t\twaitingTime = 0f;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void afterLoading(){\n\t\tif (btnContinue != null){\n\t\t\tbtnContinue.enable(true);\n\t\t} else {\n\t\t\tphase = Phase.FADE_OUT;\n\t\t\ttimeLeft = fadeTime;\n\t\t}\n\n\t}",
          "uniqueId": "92905ae81c0eb272c9a62d5f6914bda253fc571d_97_308_444_452_106_347"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\n\t\twaitingTime += Game.elapsed;\n\n\t\tif (mode != Mode.FALL && dots != Math.ceil(waitingTime / ((2*fadeTime)/3f))) {\n\t\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\tdots = (int)Math.ceil(waitingTime / ((2*fadeTime)/3f))%3;\n\t\t\tswitch (dots){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tmessage.text(text + \".\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmessage.text(text + \"..\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tmessage.text(text + \"...\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch (phase) {\n\t\t\n\t\tcase FADE_IN:\n\t\t\tmessage.alpha( Math.max(0, fadeTime - (timeLeft-0.333f)));\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tsynchronized (thread) {\n\t\t\t\t\tif (!thread.isAlive() && error == null) {\n\t\t\t\t\t\tphase = Phase.FADE_OUT;\n\t\t\t\t\t\ttimeLeft = fadeTime;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphase = Phase.STATIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FADE_OUT:\n\t\t\tmessage.alpha( Math.min(1, timeLeft+0.333f) );\n\t\t\t\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tGame.switchScene( GameScene.class );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase STATIC:\n\t\t\tif (error != null) {\n\t\t\t\tString errorMsg;\n\t\t\t\tif (error instanceof FileNotFoundException)     errorMsg = Messages.get(this, \"file_not_found\");\n\t\t\t\telse if (error instanceof IOException)          errorMsg = Messages.get(this, \"io_error\");\n\t\t\t\telse if (error.getMessage() != null &&\n\t\t\t\t\t\terror.getMessage().equals(\"old save\")) errorMsg = Messages.get(this, \"io_error\");\n\n\t\t\t\telse throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n\n\t\t\t\tadd( new WndError( errorMsg ) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\tGame.switchScene( StartScene.class );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t} else if (thread != null && (int)waitingTime == 10){\n\t\t\t\twaitingTime = 11f;\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (StackTraceElement t : thread.getStackTrace()){\n\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\ts += t.toString();\n\t\t\t\t}\n\t\t\t\t//we care about reporting game logic exceptions, not slow IO\n\t\t\t\tif (!s.contains(\"FileUtils.bundleToFile\")){\n\t\t\t\t\tShatteredPixelDungeon.reportException(\n\t\t\t\t\t\t\tnew RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n\t\t\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n\t\t\t\t\t\t\t\t\ts));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == Mode.FALL) {\n\t\t\tmessage.setPos(\n\t\t\t\t\t(Camera.main.width - message.width() - 4) + Random.NormalFloat(-1, 1),\n\t\t\t\t\t(Camera.main.height - message.height() - 6) + Random.NormalFloat(-1, 1)\n\t\t\t);\n\t\t\talign(message);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\n\t\twaitingTime += Game.elapsed;\n\n\t\tif (mode != Mode.FALL && dots != Math.ceil(waitingTime / ((2*fadeTime)/3f))) {\n\t\t\tString text = Messages.get(Mode.class, mode.name());\n\t\t\tdots = (int)Math.ceil(waitingTime / ((2*fadeTime)/3f))%3;\n\t\t\tswitch (dots){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tloadingText.text(text + \".\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tloadingText.text(text + \"..\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0:\n\t\t\t\t\tloadingText.text(text + \"...\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch (phase) {\n\t\t\n\t\tcase FADE_IN:\n\t\t\tloadingText.alpha( Math.max(0, fadeTime - (timeLeft-0.333f)));\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tsynchronized (thread) {\n\t\t\t\t\tif (!thread.isAlive() && error == null) {\n\t\t\t\t\t\tafterLoading();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tphase = Phase.STATIC;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase FADE_OUT:\n\t\t\tloadingText.alpha( Math.min(1, timeLeft+0.333f) );\n\t\t\t\n\t\t\tif ((timeLeft -= Game.elapsed) <= 0) {\n\t\t\t\tGame.switchScene( GameScene.class );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase STATIC:\n\t\t\tif (error != null) {\n\t\t\t\tString errorMsg;\n\t\t\t\tif (error instanceof FileNotFoundException)     errorMsg = Messages.get(this, \"file_not_found\");\n\t\t\t\telse if (error instanceof IOException)          errorMsg = Messages.get(this, \"io_error\");\n\t\t\t\telse if (error.getMessage() != null &&\n\t\t\t\t\t\terror.getMessage().equals(\"old save\")) errorMsg = Messages.get(this, \"io_error\");\n\n\t\t\t\telse throw new RuntimeException(\"fatal error occurred while moving between floors. \" +\n\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth, error);\n\n\t\t\t\tadd( new WndError( errorMsg ) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\tGame.switchScene( StartScene.class );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\tthread = null;\n\t\t\t\terror = null;\n\t\t\t} else if (thread != null && (int)waitingTime == 10){\n\t\t\t\twaitingTime = 11f;\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (StackTraceElement t : thread.getStackTrace()){\n\t\t\t\t\ts += \"\\n\";\n\t\t\t\t\ts += t.toString();\n\t\t\t\t}\n\t\t\t\t//we care about reporting game logic exceptions, not slow IO\n\t\t\t\tif (!s.contains(\"FileUtils.bundleToFile\")){\n\t\t\t\t\tShatteredPixelDungeon.reportException(\n\t\t\t\t\t\t\tnew RuntimeException(\"waited more than 10 seconds on levelgen. \" +\n\t\t\t\t\t\t\t\t\t\"Seed:\" + Dungeon.seed + \" depth:\" + Dungeon.depth + \" trace:\" +\n\t\t\t\t\t\t\t\t\ts));\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mode == Mode.FALL) {\n\t\t\tloadingText.setPos(\n\t\t\t\t\t(Camera.main.width - loadingText.width() - 4) + Random.NormalFloat(-1, 1),\n\t\t\t\t\t(Camera.main.height - loadingText.height() - 6) + Random.NormalFloat(-1, 1)\n\t\t\t);\n\t\t\talign(loadingText);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void afterLoading(){\n\t\tif (btnContinue != null){\n\t\t\tbtnContinue.enable(true);\n\t\t} else {\n\t\t\tphase = Phase.FADE_OUT;\n\t\t\ttimeLeft = fadeTime;\n\t\t}\n\n\t}",
          "uniqueId": "92905ae81c0eb272c9a62d5f6914bda253fc571d_312_404_444_452_351_442"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "fe66e03e74ddc86c62a2ba58c43466fc3996d8ff",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fe66e03e74ddc86c62a2ba58c43466fc3996d8ff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void blast(int pos) {\n\t\t\tGroup parent = Dungeon.hero.sprite.parent;\n\t\t\tBlastWave b = (BlastWave) parent.recycle(BlastWave.class);\n\t\t\tparent.bringToFront(b);\n\t\t\tb.reset(pos);\n\t\t}",
          "sourceCodeAfterRefactoring": "public static void blast(int pos) {\n\t\t\tblast(pos, 3);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void blast(int pos, float radius) {\n\t\t\tGroup parent = Dungeon.hero.sprite.parent;\n\t\t\tBlastWave b = (BlastWave) parent.recycle(BlastWave.class);\n\t\t\tparent.bringToFront(b);\n\t\t\tb.reset(pos, radius);\n\t\t}",
          "uniqueId": "fe66e03e74ddc86c62a2ba58c43466fc3996d8ff_279_284_285_290_281_283"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "70df007bcf55364711b9682f0e975e5bcfabd0cd",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/70df007bcf55364711b9682f0e975e5bcfabd0cd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int spawnImages( Hero hero, int nImages ){\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\tif (Actor.findChar( p ) == null && Dungeon.level.passable[p]) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint spawned = 0;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( hero );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t\tspawned++;\n\t\t}\n\t\t\n\t\treturn spawned;\n\t}",
          "sourceCodeAfterRefactoring": "public static int spawnImages( Hero hero, int nImages ){\n\t\treturn spawnImages( hero, hero.pos, nImages);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int spawnImages( Hero hero, int pos, int nImages ){\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS9.length; i++) {\n\t\t\tint p = pos + PathFinder.NEIGHBOURS9[i];\n\t\t\tif (Actor.findChar( p ) == null && Dungeon.level.passable[p]) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint spawned = 0;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( hero );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t\tspawned++;\n\t\t}\n\t\t\n\t\treturn spawned;\n\t}",
          "uniqueId": "70df007bcf55364711b9682f0e975e5bcfabd0cd_63_89_67_93_62_64"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static boolean rareEffect(final Item origin, final Char user, final int targetPos){\n\t\tboolean positiveOnly = user == Dungeon.hero && Random.Float() < WondrousResin.positiveCurseEffectChance();\n\t\tswitch(Random.Int(4)){\n\n\t\t\t//sheep transformation\n\t\t\tcase 0: default:\n\n\t\t\t\tChar ch = Actor.findChar( targetPos );\n\t\t\t\tif (ch != null && !(ch instanceof Hero)\n\t\t\t\t\t\t//ignores bosses, questgivers, rat king, etc.\n\t\t\t\t\t\t&& !ch.properties().contains(Char.Property.BOSS)\n\t\t\t\t\t\t&& !ch.properties().contains(Char.Property.MINIBOSS)\n\t\t\t\t\t\t&& !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL)){\n\t\t\t\t\tSheep sheep = new Sheep();\n\t\t\t\t\tsheep.lifespan = 10;\n\t\t\t\t\tsheep.pos = ch.pos;\n\t\t\t\t\tch.destroy();\n\t\t\t\t\tch.sprite.killAndErase();\n\t\t\t\t\tDungeon.level.mobs.remove(ch);\n\t\t\t\t\tTargetHealthIndicator.instance.target(null);\n\t\t\t\t\tGameScene.add(sheep);\n\t\t\t\t\tCellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.PUFF);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.SHEEP);\n\t\t\t\t\tDungeon.level.occupyCell(sheep);\n\t\t\t\t} else {\n\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t//curses!\n\t\t\t//or hexes target if positive only\n\t\t\tcase 1:\n\t\t\t\tif (positiveOnly){\n\t\t\t\t\tch = Actor.findChar( targetPos );\n\t\t\t\t\tif (ch != null){\n\t\t\t\t\t\tBuff.affect(ch, Hex.class, Hex.DURATION);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tif (user instanceof Hero) {\n\t\t\t\t\tCursingTrap.curse( (Hero) user );\n\t\t\t\t} else {\n\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t//inter-level teleportation\n\t\t\t//of scroll of teleportation if positive only, or inter-floor teleport disallowed\n\t\t\tcase 2:\n\t\t\t\tif (!positiveOnly && Dungeon.depth > 1 && Dungeon.interfloorTeleportAllowed() && user == Dungeon.hero) {\n\n\t\t\t\t\t//each depth has 1 more weight than the previous depth.\n\t\t\t\t\tfloat[] depths = new float[Dungeon.depth-1];\n\t\t\t\t\tfor (int i = 1; i < Dungeon.depth; i++) depths[i-1] = i;\n\t\t\t\t\tint depth = 1+Random.chances(depths);\n\n\t\t\t\t\tLevel.beforeTransition();\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.RETURN;\n\t\t\t\t\tInterlevelScene.returnDepth = depth;\n\t\t\t\t\tInterlevelScene.returnBranch = 0;\n\t\t\t\t\tInterlevelScene.returnPos = -1;\n\t\t\t\t\tGame.switchScene(InterlevelScene.class);\n\n\t\t\t\t} else {\n\t\t\t\t\tScrollOfTeleportation.teleportChar(user);\n\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t//summon monsters\n\t\t\t//or mirror images if positive only\n\t\t\tcase 3:\n\t\t\t\tif (positiveOnly && user == Dungeon.hero){\n\t\t\t\t\tScrollOfMirrorImage.spawnImages(Dungeon.hero, 2);\n\t\t\t\t} else {\n\t\t\t\t\tnew SummoningTrap().set(targetPos).activate();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean effect(Item origin, Char user, Ballistica bolt, boolean positiveOnly) {\n\t\t\tif (valid(origin, user, bolt, positiveOnly)){\n\t\t\t\tChar ch = Actor.findChar( bolt.collisionPos );\n\t\t\t\tSheep sheep = new Sheep();\n\t\t\t\tsheep.lifespan = 10;\n\t\t\t\tsheep.pos = ch.pos;\n\t\t\t\tch.destroy();\n\t\t\t\tch.sprite.killAndErase();\n\t\t\t\tDungeon.level.mobs.remove(ch);\n\t\t\t\tTargetHealthIndicator.instance.target(null);\n\t\t\t\tGameScene.add(sheep);\n\t\t\t\tCellEmitter.get(sheep.pos).burst(Speck.factory(Speck.WOOL), 4);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.PUFF);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.SHEEP);\n\t\t\t\tDungeon.level.occupyCell(sheep);\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tpublic boolean valid(Item origin, Char user, Ballistica bolt, boolean positiveOnly) {\n\t\t\tChar ch = Actor.findChar( bolt.collisionPos );\n\t\t\tif (ch != null && !(ch instanceof Hero)\n\t\t\t\t\t//ignores bosses, questgivers, rat king, etc.\n\t\t\t\t\t&& !ch.properties().contains(Char.Property.BOSS)\n\t\t\t\t\t&& !ch.properties().contains(Char.Property.MINIBOSS)\n\t\t\t\t\t&& !(ch instanceof NPC && ch.alignment == Char.Alignment.NEUTRAL)){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}",
          "uniqueId": "70df007bcf55364711b9682f0e975e5bcfabd0cd_275_355_418_430_432_452"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "543bc3f587038ae4de4a9612f59a9a1d912be727",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/543bc3f587038ae4de4a9612f59a9a1d912be727",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass ) {\n\t\tif ((!Dungeon.level.solid[pos] || Dungeon.level.passable[pos]) && Actor.findChar( pos ) == null) {\n\n\t\t\tWraith w;\n\t\t\t//if no wraith type is specified, 1/100 chance for exotic, otherwise normal\n\t\t\tif (wraithClass == null){\n\t\t\t\tfloat altChance = 1/100f * RatSkull.exoticChanceMultiplier();\n\t\t\t\tif (Random.Float() < altChance){\n\t\t\t\t\tw = new TormentedSpirit();\n\t\t\t\t} else {\n\t\t\t\t\tw = new Wraith();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw = Reflection.newInstance(wraithClass);\n\t\t\t}\n\t\t\tw.adjustStats( Dungeon.scalingDepth() );\n\t\t\tw.pos = pos;\n\t\t\tw.state = w.HUNTING;\n\t\t\tGameScene.add( w, SPAWN_DELAY );\n\t\t\tDungeon.level.occupyCell(w);\n\n\t\t\tw.sprite.alpha( 0 );\n\t\t\tw.sprite.parent.add( new AlphaTweener( w.sprite, 1, 0.5f ) );\n\n\t\t\tif (w instanceof TormentedSpirit){\n\t\t\t\tw.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n\t\t\t} else {\n\t\t\t\tw.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n\t\t\t}\n\n\t\t\treturn w;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass ) {\n\t\treturn spawnAt( pos, wraithClass, true );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static Wraith spawnAt( int pos, Class<? extends Wraith> wraithClass, boolean allowAdjacent ) {\n\n\t\t//if the position itself is blocked, try to place in an adjacent cell if allowed\n\t\tif (Dungeon.level.solid[pos] || Actor.findChar( pos ) != null){\n\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\n\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\tif (!Dungeon.level.solid[pos+i] && Actor.findChar( pos+i ) == null){\n\t\t\t\t\tcandidates.add(pos+i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (allowAdjacent && !candidates.isEmpty()){\n\t\t\t\tpos = Random.element(candidates);\n\t\t\t} else {\n\t\t\t\tpos = -1;\n\t\t\t}\n\n\t\t}\n\n\t\tif (pos != -1) {\n\n\t\t\tWraith w;\n\t\t\t//if no wraith type is specified, 1/100 chance for exotic, otherwise normal\n\t\t\tif (wraithClass == null){\n\t\t\t\tfloat altChance = 1/100f * RatSkull.exoticChanceMultiplier();\n\t\t\t\tif (Random.Float() < altChance){\n\t\t\t\t\tw = new TormentedSpirit();\n\t\t\t\t} else {\n\t\t\t\t\tw = new Wraith();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tw = Reflection.newInstance(wraithClass);\n\t\t\t}\n\t\t\tw.adjustStats( Dungeon.scalingDepth() );\n\t\t\tw.pos = pos;\n\t\t\tw.state = w.HUNTING;\n\t\t\tGameScene.add( w, SPAWN_DELAY );\n\t\t\tDungeon.level.occupyCell(w);\n\n\t\t\tw.sprite.alpha( 0 );\n\t\t\tw.sprite.parent.add( new AlphaTweener( w.sprite, 1, 0.5f ) );\n\n\t\t\tif (w instanceof TormentedSpirit){\n\t\t\t\tw.sprite.emitter().burst(ChallengeParticle.FACTORY, 10);\n\t\t\t} else {\n\t\t\t\tw.sprite.emitter().burst(ShadowParticle.CURSE, 5);\n\t\t\t}\n\n\t\t\treturn w;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "543bc3f587038ae4de4a9612f59a9a1d912be727_114_148_120_173_116_118"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tfloat spawnMulti = enemySpawnMultiplier();\n\t\tif (spawnMulti > 1f) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn spawnMulti;\n\t\t\t} else {\n\t\t\t\treturn 1f;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static float enemySpawnMultiplierDaytime( int level ){\n\t\tif (level == -1){\n\t\t\treturn 1f;\n\t\t} else {\n\t\t\treturn 0.95f - 0.05f*level;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static float enemySpawnMultiplierDaytime( int level ){\n\t\tif (level == -1){\n\t\t\treturn 1f;\n\t\t} else {\n\t\t\treturn 0.95f - 0.05f*level;\n\t\t}\n\t}",
          "uniqueId": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea_55_71_80_86_80_86"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tfloat spawnMulti = enemySpawnMultiplier();\n\t\tif (spawnMulti > 1f) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 21 || cal.get(Calendar.HOUR_OF_DAY) <= 6) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn spawnMulti;\n\t\t\t} else {\n\t\t\t\treturn 1f;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static float spawnMultiplierAtCurrentTime(){\n\t\tif (trinketLevel(DimensionalSundial.class) != -1) {\n\t\t\tCalendar cal = GregorianCalendar.getInstance();\n\t\t\tif (cal.get(Calendar.HOUR_OF_DAY) >= 20 || cal.get(Calendar.HOUR_OF_DAY) <= 7) {\n\t\t\t\tif (!sundialWarned){\n\t\t\t\t\tGLog.w(Messages.get(DimensionalSundial.class, \"warning\"));\n\t\t\t\t\tsundialWarned = true;\n\t\t\t\t}\n\t\t\t\treturn enemySpawnMultiplierNighttime();\n\t\t\t} else {\n\t\t\t\treturn enemySpawnMultiplierDaytime();\n\t\t\t}\n\t\t} else {\n\t\t\treturn 1f;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static float enemySpawnMultiplierDaytime(){\n\t\treturn enemySpawnMultiplierDaytime(trinketLevel(DimensionalSundial.class));\n\t}",
          "uniqueId": "e4d08e9ca0f0b1fbed75b0d44db1ac0317ca1bea_55_71_76_78_59_74"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4071a47a5612e5cc0744f1dbcafe7c335603bdc8",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4071a47a5612e5cc0744f1dbcafe7c335603bdc8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onClick() {\n\t\tsuper.onClick();\n\n\t\t//TODO we want a selection window for note type here, atm it's only plaintext notes\n\t\tNotes.CustomRecord custom = new Notes.CustomRecord(Messages.get(this, \"default_title_text\"), \"\");\n\t\tNotes.add(custom);\n\t\trefreshScene(custom);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onClick() {\n\t\tsuper.onClick();\n\n\t\tif (Notes.getRecords(Notes.CustomRecord.class).size() >= Notes.customRecordLimit()){\n\t\t\tGameScene.show(new WndTitledMessage(Icons.INFO.get(),\n\t\t\t\t\tMessages.get(this, \"limit_title\"),\n\t\t\t\t\tMessages.get(this, \"limit_text\")));\n\t\t\treturn;\n\t\t}\n\n\t\tGameScene.show(new WndOptions(Icons.SCROLL_COLOR.get(),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"title\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"desc\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_floor\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_inv\"),\n\t\t\t\tMessages.get(CustomNoteButton.class, \"new_type\")){\n\t\t\t@Override\n\t\t\tprotected void onSelect(int index) {\n\t\t\t\tif (index == 0){\n\t\t\t\t\tNotes.CustomRecord custom = new Notes.CustomRecord(\"\", \"\");\n\t\t\t\t\taddNote(custom,\n\t\t\t\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text\"),\n\t\t\t\t\t\t\tMessages.get(CustomNoteButton.class, \"new_text_title\"));\n\t\t\t\t} else if (index == 1){\n\t\t\t\t\tGameScene.show(new WndDepthSelect());\n\t\t\t\t} else if (index == 2){\n\t\t\t\t\tGameScene.selectItem(itemSelector);\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show(new WndItemtypeSelect());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void hide() {\n\t\t\t\t//do nothing, prevents window closing when user steps back in note creation process\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onBackPressed() {\n\t\t\t\tsuper.hide(); //actually hide in this case\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void addNote(Notes.CustomRecord note, String promptTitle, String prompttext){\n\t\tGameScene.show(new WndTextInput(promptTitle,\n\t\t\t\tprompttext,\n\t\t\t\t\"\",\n\t\t\t\t50,\n\t\t\t\tfalse,\n\t\t\t\tMessages.get(CustomNoteWindow.class, \"confirm\"),\n\t\t\t\tMessages.get(CustomNoteWindow.class, \"cancel\")){\n\t\t\t@Override\n\t\t\tpublic void onSelect(boolean positive, String text) {\n\t\t\t\tif (positive && !text.isEmpty()){\n\t\t\t\t\tNotes.add(note);\n\t\t\t\t\tnote.editText(text, \"\");\n\t\t\t\t\trefreshScene(null);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "uniqueId": "4071a47a5612e5cc0744f1dbcafe7c335603bdc8_45_53_329_346_58_102"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "aa7b64564557e85e5a27424caa033b2f1f7fc126",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/aa7b64564557e85e5a27424caa033b2f1f7fc126",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void sacrifice( Char ch ) {\n\n\t\tint firePos = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (volume > 0 && cur[ch.pos+i] > 0){\n\t\t\t\tfirePos = ch.pos+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firePos != -1) {\n\n\t\t\tint exp = 0;\n\t\t\tif (ch instanceof Mob) {\n\t\t\t\t//same rates as used in wand of corruption, except for swarms\n\t\t\t\tif (ch instanceof Statue || ch instanceof Mimic){\n\t\t\t\t\texp = 1 + Dungeon.depth;\n\t\t\t\t} else if (ch instanceof Piranha || ch instanceof Bee) {\n\t\t\t\t\texp = 1 + Dungeon.depth/2;\n\t\t\t\t} else if (ch instanceof Wraith) {\n\t\t\t\t\texp = 1 + Dungeon.depth/3;\n\t\t\t\t} else if (ch instanceof Swarm && ((Swarm) ch).EXP == 0){\n\t\t\t\t\t//give 1 exp for child swarms, instead of 0\n\t\t\t\t\texp = 1;\n\t\t\t\t} else if (((Mob) ch).EXP > 0) {\n\t\t\t\t\texp = 1 + ((Mob)ch).EXP;\n\t\t\t\t}\n\t\t\t\texp *= Random.IntRange( 2, 3 );\n\t\t\t} else if (ch instanceof Hero) {\n\t\t\t\texp = 1_000_000; //always enough to activate the reward, if you can somehow get it\n\t\t\t\tBadges.validateDeathFromSacrifice();\n\t\t\t}\n\n\t\t\tif (exp > 0) {\n\n\t\t\t\tint volumeLeft = cur[firePos] - exp;\n\t\t\t\tif (volumeLeft > 0) {\n\t\t\t\t\tcur[firePos] -= exp;\n\t\t\t\t\tvolume -= exp;\n\t\t\t\t\tbonusSpawns++;\n\t\t\t\t\tCellEmitter.get(firePos).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"worthy\"));\n\t\t\t\t} else {\n\t\t\t\t\tclear(firePos);\n\t\t\t\t\tNotes.remove(Notes.Landmark.SACRIFICIAL_FIRE);\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tCellEmitter.get(firePos+i).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\t}\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"reward\"));\n\t\t\t\t\tif (prize != null) {\n\t\t\t\t\t\tDungeon.level.drop(prize, firePos).sprite.drop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"unworthy\"));\n\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void sacrifice( Char ch ) {\n\n\t\tint firePos = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (volume > 0 && cur[ch.pos+i] > 0){\n\t\t\t\tfirePos = ch.pos+i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firePos != -1) {\n\n\t\t\tint exp = 0;\n\t\t\tif (ch instanceof Mob) {\n\t\t\t\t//same rates as used in wand of corruption, except for swarms\n\t\t\t\tif (ch instanceof Statue || ch instanceof Mimic){\n\t\t\t\t\texp = 1 + Dungeon.depth;\n\t\t\t\t} else if (ch instanceof Piranha || ch instanceof Bee) {\n\t\t\t\t\texp = 1 + Dungeon.depth/2;\n\t\t\t\t} else if (ch instanceof Wraith) {\n\t\t\t\t\texp = 1 + Dungeon.depth/3;\n\t\t\t\t} else if (ch instanceof Swarm && ((Swarm) ch).EXP == 0){\n\t\t\t\t\t//give 1 exp for child swarms, instead of 0\n\t\t\t\t\texp = 1;\n\t\t\t\t} else if (((Mob) ch).EXP > 0) {\n\t\t\t\t\texp = 1 + ((Mob)ch).EXP;\n\t\t\t\t}\n\t\t\t\texp *= Random.IntRange( 2, 3 );\n\t\t\t} else if (ch instanceof Hero) {\n\t\t\t\texp = 1_000_000; //always enough to activate the reward, if you can somehow get it\n\t\t\t\tBadges.validateDeathFromSacrifice();\n\t\t\t}\n\n\t\t\tif (exp > 0) {\n\n\t\t\t\tint volumeLeft = cur[firePos] - exp;\n\t\t\t\tif (volumeLeft > 0) {\n\t\t\t\t\tcur[firePos] -= exp;\n\t\t\t\t\tvolume -= exp;\n\t\t\t\t\tbonusSpawns++;\n\t\t\t\t\tCellEmitter.get(firePos).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"worthy\"));\n\t\t\t\t} else {\n\t\t\t\t\tclear(firePos);\n\t\t\t\t\tif (volume <= 0) Notes.remove( landmark() );\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tCellEmitter.get(firePos+i).burst( SacrificialParticle.FACTORY, 20 );\n\t\t\t\t\t}\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING );\n\t\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"reward\"));\n\t\t\t\t\tif (prize != null) {\n\t\t\t\t\t\tDungeon.level.drop(prize, firePos).sprite.drop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDungeon.level.drop(SacrificeRoom.prize(Dungeon.level), firePos).sprite.drop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tGLog.w( Messages.get(SacrificialFire.class, \"unworthy\"));\n\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.SACRIFICIAL_FIRE;\n\t}",
          "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_145_211_67_70_148_214"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tif (spawnRecorded){\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(Notes.Landmark.DEMON_SPAWNER);\n\t\t}\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t\tsuper.die(cause);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tif (spawnRecorded){\n\t\t\tStatistics.spawnersAlive--;\n\t\t\tNotes.remove(landmark());\n\t\t}\n\t\tGLog.h(Messages.get(this, \"on_death\"));\n\t\tsuper.die(cause);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.DEMON_SPAWNER;\n\t}",
          "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_148_156_144_147_149_157"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void destroy() {\n\t\tif (levelGenStatue) {\n\t\t\tNotes.remove( Notes.Landmark.STATUE );\n\t\t}\n\t\tsuper.destroy();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void destroy() {\n\t\tif (landmark() != null) {\n\t\t\tNotes.remove( landmark() );\n\t\t}\n\t\tsuper.destroy();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn levelGenStatue ? Notes.Landmark.STATUE : null;\n\t}",
          "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_164_170_156_159_161_167"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (Dungeon.hero.buff(AscensionChallenge.class) != null){\n\t\t\tdie(null);\n\t\t\treturn true;\n\t\t}\n\t\tif (Dungeon.level.heroFOV[pos] && !Quest.completed()){\n\t\t\tNotes.add( Notes.Landmark.GHOST );\n\t\t}\n\t\treturn super.act();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (Dungeon.hero.buff(AscensionChallenge.class) != null){\n\t\t\tdie(null);\n\t\t\tNotes.remove( landmark() );\n\t\t\treturn true;\n\t\t}\n\t\treturn super.act();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.GHOST;\n\t}",
          "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_84_94_84_87_89_97"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void flee() {\n\t\tdestroy();\n\n\t\tNotes.remove(Notes.Landmark.SHOP);\n\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void flee() {\n\t\tdestroy();\n\n\t\tNotes.remove( landmark() );\n\n\t\tif (sprite != null) {\n\t\t\tsprite.killAndErase();\n\t\t\tCellEmitter.get(pos).burst(ElmoParticle.FACTORY, 6);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Notes.Landmark landmark() {\n\t\treturn Notes.Landmark.SHOP;\n\t}",
          "uniqueId": "aa7b64564557e85e5a27424caa033b2f1f7fc126_148_157_72_75_149_158"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "be3de2d883d043596bb274ac7796e30bca891583",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/be3de2d883d043596bb274ac7796e30bca891583",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private int chargeLimit( int heroLvl ){\n\t\tif (level() >= 10){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t} else {\n\t\t\t//20 charges at base, plus:\n\t\t\t//2/3.1/4.2/5.5/6.8/8.4/10.4/13.2/18.0/30.8/inf. charges per hero level, at wand level:\n\t\t\t//0/1  /2  /3  /4  /5  /6   /7   /8   /9   /10\n\t\t\tfloat lvl = level();\n\t\t\treturn Math.round(20 + heroLvl * (2+lvl) * (1f + (lvl/(50 - 5*lvl))));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private int chargeLimit( int heroLvl ){\n\t\treturn chargeLimit(  heroLvl, level() );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int chargeLimit( int heroLvl, int wndLvl ){\n\t\tif (wndLvl >= 10){\n\t\t\treturn Integer.MAX_VALUE;\n\t\t} else {\n\t\t\t//20 charges at base, plus:\n\t\t\t//2/3.1/4.2/5.5/6.8/8.4/10.4/13.2/18.0/30.8/inf. charges per hero level, at wand level:\n\t\t\t//0/1  /2  /3  /4  /5  /6   /7   /8   /9   /10\n\t\t\treturn Math.round(20 + heroLvl * (2+wndLvl) * (1f + (wndLvl/(50 - 5*wndLvl))));\n\t\t}\n\t}",
          "uniqueId": "be3de2d883d043596bb274ac7796e30bca891583_203_213_207_216_203_205"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public WndUpgrade( Item upgrader, Item toUpgrade, boolean force){\n\n\t\tthis.force = force;\n\n\t\tIconTitle title = new IconTitle( new ItemSprite(upgrader), Messages.get(this, \"title\") );\n\n\t\ttitle.setRect(0, 0, WIDTH, 0);\n\t\tadd(title);\n\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock( 6 );\n\t\tmessage.text( Messages.get(this, \"desc\"), WIDTH);\n\t\tmessage.setPos(0, title.bottom()+GAP);\n\t\tadd(message);\n\n\t\t// *** Computing current and next level to display ***\n\n\t\tint levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n\t\tint levelTo = levelFrom + 1;\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tlevelTo--;\n\t\t}\n\n\t\tboolean curseInfused = (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n\n\t\tif (curseInfused){\n\t\t\tif (toUpgrade.trueLevel()/6 < (toUpgrade.trueLevel()+1)/6){\n\t\t\t\t//new level bracket for curse infusion bonus\n\t\t\t\tlevelTo++;\n\t\t\t}\n\t\t}\n\n\t\t// *** Sprites, showing item at current level and with +1 ***\n\n\t\tItemSprite i1 = new ItemSprite();\n\t\tadd(i1);\n\t\ti1.view(toUpgrade);\n\t\ti1.x = COL_2 - i1.width()/2f;\n\t\ti1.y = message.bottom() + GAP + (16-i1.height())/2f;\n\t\tPixelScene.align(i1);\n\t\tadd(i1);\n\n\t\tItemSprite i2 = new ItemSprite();\n\t\tadd(i2);\n\t\ti2.view(toUpgrade);\n\t\ti2.x = COL_3 - i2.width()/2f;\n\t\ti2.y = i1.y;\n\t\tPixelScene.align(i2);\n\t\tadd(i2);\n\n\t\tBitmapText t1 = new BitmapText(PixelScene.pixelFont);\n\t\tBitmapText t2 = new BitmapText(PixelScene.pixelFont);\n\t\tif (toUpgrade.isIdentified()){\n\t\t\tif (levelFrom > 0){\n\t\t\t\tt1.text(\"+\" + levelFrom);\n\t\t\t} else {\n\t\t\t\tt1.text(\"\");\n\t\t\t}\n\t\t\tt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);\n\n\t\t\tif (curseInfused){\n\t\t\t\tt1.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t\tt2.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t}\n\n\t\t} else {\n\t\t\tt1.text(\"?\");\n\t\t\tt1.hardlight(0.6f, 0.3f, 0.6f);\n\t\t\tt2.text(\"+1?\");\n\t\t\tt2.hardlight(0.6f, 0.3f, 0.6f);\n\t\t}\n\t\tt1.measure();\n\t\tt1.x = COL_2 + 8 - t1.width();\n\t\tt1.y = message.bottom() + GAP + 16 - t1.baseLine();\n\t\tadd(t1);\n\n\t\tt2.measure();\n\t\tt2.x = COL_3 + 8 - t2.width();\n\t\tt2.y = message.bottom() + GAP + 16 - t2.baseLine();\n\t\tadd(t2);\n\n\t\tfloat bottom = i1.y + 16 + GAP;\n\n\t\tfinal String LINE = Messages.lang() == Languages.CHINESE ? \"~\" : \"-\";\n\n\t\t// *** Various lines for stats, highlighting differences between current level and +1 ***\n\n\t\t//physical damage\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"damage\"),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelFrom) + LINE + ((Weapon) toUpgrade).max(levelFrom),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelTo) + LINE + ((Weapon) toUpgrade).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//blocking (armor and shields)\n\t\tif (toUpgrade instanceof Armor){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelFrom) + LINE + ((Armor) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelTo) + LINE + ((Armor) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof RoundShield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((RoundShield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Greatshield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + LINE + ((Greatshield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//weight (i.e. strength requirement)\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Armor) {\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//durability\n\t\tif (toUpgrade instanceof MissileWeapon){\n\t\t\t//missile weapons are always IDed currently, so we always use true level\n\t\t\tint uses1 = (int)Math.ceil(100f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tint uses2 = (int)Math.ceil(300f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tbottom = fillFields(Messages.get(this, \"durability\"),\n\t\t\t\t\tuses1 >= 100 ? \"∞\" : Integer.toString(uses1),\n\t\t\t\t\tuses2 >= 100 ? \"∞\" : Integer.toString(uses2),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//we use a separate reference for wand properties so that mage's staff can include them\n\t\tItem wand = toUpgrade;\n\t\tif (toUpgrade instanceof MagesStaff && ((MagesStaff) toUpgrade).wandClass() != null){\n\t\t\twand = Reflection.newInstance(((MagesStaff) toUpgrade).wandClass());\n\t\t}\n\n\t\t//direct damage and damage-adjacent effects\n\t\tif (wand instanceof DamageWand) {\n\t\t\tbottom = fillFields(Messages.get(this, \"zap_damage\"),\n\t\t\t\t\t((DamageWand) wand).min(levelFrom) + LINE + ((DamageWand) wand).max(levelFrom),\n\t\t\t\t\t((DamageWand) wand).min(levelTo) + LINE + ((DamageWand) wand).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfCorrosion){\n\t\t\t//TODO externalize!\n\t\t\tbottom = fillFields(Messages.get(this, \"corrosion_damage\"),\n\t\t\t\t\tInteger.toString(2+levelFrom),\n\t\t\t\t\tInteger.toString(2+levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (wand instanceof WandOfWarding){\n\t\t\t//TODO externalize!\n\t\t\tbottom = fillFields(Messages.get(this, \"ward_damage\"),\n\t\t\t\t\t(2 + levelFrom) + LINE + (8 + 4*levelFrom),\n\t\t\t\t\t(2 + levelTo) + LINE + (8 + 4*levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//TODO various extra wand effects\n\t\t//disintegration range?\n\t\t//corrosion AOE?\n\t\t//blast wave knockback?\n\t\t//rock guardian powers?\n\t\t//frost chill duration?\n\t\t//prismatic light blinding/lighting?\n\t\t//warding max energy\n\t\t//transfusion stats? and also de-emphasize damage?\n\t\t//corruption power?\n\t\t//regrowth power?\n\n\t\t//max charges\n\t\tif (wand instanceof Wand){\n\t\t\tint chargeboost = levelFrom + (toUpgrade instanceof MagesStaff ? 1 : 0);\n\t\t\tbottom = fillFields(Messages.get(this, \"charges\"),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost)),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost + 1)),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//TODO ring stats\n\t\tif (toUpgrade instanceof Ring){\n\n\t\t}\n\n\t\t//visual separators for each column\n\t\tColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = WIDTH/2f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\tsep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = 3*WIDTH/4f;\n\t\tsep.y = message.bottom();\n\t\tadd(sep);\n\n\t\t// *** Various extra info texts that can appear underneath stats ***\n\n\t\t//warning relating to identification\n\t\tif (!toUpgrade.isIdentified()){\n\t\t\tbottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t// various messages relating to enchantments and curses\n\t\tif (!(upgrader instanceof MagicalInfusion)) {\n\n\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n\t\t\t\tint lossChance;\n\t\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n\t\t\t\t} else {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n\t\t\t\t}\n\n\t\t\t\tif (lossChance >= 10) {\n\t\t\t\t\tString warn;\n\t\t\t\t\tif (toUpgrade instanceof Weapon) {\n\t\t\t\t\t\tif (((Weapon) toUpgrade).enchantHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"enchant\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((Armor) toUpgrade).glyphHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"glyph\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbottom = addMessage(warn, CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((toUpgrade.cursed\n\t\t\t\t\t|| (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph()))\n\t\t\t\t\t&& toUpgrade.cursedKnown) {\n\n\t\t\t\tif (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())){\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t} else {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t}\n\n\t\t\t\tif (curseInfused) {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"curse_infusion\"), CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//warning relating to arcane resin\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tbottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t// *** Buttons for confirming/cancelling ***\n\n\t\tbtnUpgrade = new RedButton(Messages.get(this, \"upgrade\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tScrollOfUpgrade.upgrade(Dungeon.hero);\n\n\t\t\t\tItem upgraded = toUpgrade;\n\t\t\t\tif (upgrader instanceof ScrollOfUpgrade){\n\t\t\t\t\t((ScrollOfUpgrade) upgrader).readAnimation();\n\t\t\t\t\tupgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t\t\t\t} else if (upgrader instanceof MagicalInfusion){\n\t\t\t\t\t((MagicalInfusion) upgrader).useAnimation();\n\t\t\t\t\tupgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t}\n\n\t\t\t\tItem moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n\n\t\t\t\thide();\n\n\t\t\t\tif (moreUpgradeItem != null && toUpgrade.isIdentified()){\n\t\t\t\t\tmoreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\t\tGameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnUpgrade.setRect(0, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnUpgrade);\n\n\t\tbtnCancel = new RedButton(Messages.get(this, \"cancel\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tif (!force) {\n\t\t\t\t\tupgrader.collect();\n\t\t\t\t\thide();\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show( new WndOptions(new ItemSprite(upgrader),\n\t\t\t\t\t\t\tMessages.titleCase(upgrader.name()),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tWndUpgrade.this.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onBackPressed() {}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t\tbtnCancel.setRect(btnUpgrade.right()+1, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnCancel);\n\n\t\tbtnUpgrade.enable(Dungeon.hero.ready);\n\n\t\tbottom = (int)btnCancel.bottom();\n\n\t\tresize(WIDTH, (int)bottom);\n\n\t}",
          "sourceCodeAfterRefactoring": "public WndUpgrade( Item upgrader, Item toUpgrade, boolean force){\n\n\t\tthis.force = force;\n\n\t\tIconTitle title = new IconTitle( new ItemSprite(upgrader), Messages.get(this, \"title\") );\n\n\t\ttitle.setRect(0, 0, WIDTH, 0);\n\t\tadd(title);\n\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock( 6 );\n\t\tmessage.text( Messages.get(this, \"desc\"), WIDTH);\n\t\tmessage.setPos(0, title.bottom()+GAP);\n\t\tadd(message);\n\n\t\t// *** Computing current and next level to display ***\n\n\t\tint levelFrom = toUpgrade.isIdentified() ? toUpgrade.level() : 0;\n\t\tint levelTo = levelFrom + 1;\n\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tlevelTo--;\n\t\t}\n\n\t\tboolean curseInfused = (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).curseInfusionBonus)\n\t\t\t\t|| (toUpgrade instanceof Wand && ((Wand) toUpgrade).curseInfusionBonus);\n\n\t\tif (curseInfused){\n\t\t\tif (toUpgrade.trueLevel()/6 < (toUpgrade.trueLevel()+1)/6){\n\t\t\t\t//new level bracket for curse infusion bonus\n\t\t\t\tlevelTo++;\n\t\t\t}\n\t\t}\n\n\t\t// *** Sprites, showing item at current level and with +1 ***\n\n\t\tItemSprite i1 = new ItemSprite();\n\t\tadd(i1);\n\t\ti1.view(toUpgrade);\n\t\ti1.x = COL_2 - i1.width()/2f;\n\t\ti1.y = message.bottom() + GAP + (16-i1.height())/2f;\n\t\tPixelScene.align(i1);\n\t\tadd(i1);\n\n\t\tItemSprite i2 = new ItemSprite();\n\t\tadd(i2);\n\t\ti2.view(toUpgrade);\n\t\ti2.x = COL_3 - i2.width()/2f;\n\t\ti2.y = i1.y;\n\t\tPixelScene.align(i2);\n\t\tadd(i2);\n\n\t\tBitmapText t1 = new BitmapText(PixelScene.pixelFont);\n\t\tBitmapText t2 = new BitmapText(PixelScene.pixelFont);\n\t\tif (toUpgrade.isIdentified()){\n\t\t\tif (levelFrom > 0){\n\t\t\t\tt1.text(\"+\" + levelFrom);\n\t\t\t} else {\n\t\t\t\tt1.text(\"\");\n\t\t\t}\n\t\t\tt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);\n\n\t\t\tif (curseInfused){\n\t\t\t\tt1.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t\tt2.hardlight(ItemSlot.CURSE_INFUSED);\n\t\t\t}\n\n\t\t} else {\n\t\t\tt1.text(\"?\");\n\t\t\tt1.hardlight(0.6f, 0.3f, 0.6f);\n\t\t\tt2.text(\"+1?\");\n\t\t\tt2.hardlight(0.6f, 0.3f, 0.6f);\n\t\t}\n\t\tt1.measure();\n\t\tt1.x = COL_2 + 8 - t1.width();\n\t\tt1.y = message.bottom() + GAP + 16 - t1.baseLine();\n\t\tadd(t1);\n\n\t\tt2.measure();\n\t\tt2.x = COL_3 + 8 - t2.width();\n\t\tt2.y = message.bottom() + GAP + 16 - t2.baseLine();\n\t\tadd(t2);\n\n\t\tfloat bottom = i1.y + 16 + GAP;\n\n\t\t// *** Various lines for stats, highlighting differences between current level and +1 ***\n\n\t\t//physical damage\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"damage\"),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelFrom) + \"-\" + ((Weapon) toUpgrade).max(levelFrom),\n\t\t\t\t\t((Weapon) toUpgrade).min(levelTo) + \"-\" + ((Weapon) toUpgrade).max(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//blocking (armor and shields)\n\t\tif (toUpgrade instanceof Armor){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelFrom) + \"-\" + ((Armor) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t((Armor) toUpgrade).DRMin(levelTo) + \"-\" + ((Armor) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof RoundShield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + \"-\" + ((RoundShield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + \"-\" + ((RoundShield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Greatshield){\n\t\t\tbottom = fillFields(Messages.get(this, \"blocking\"),\n\t\t\t\t\t0 + \"-\" + ((Greatshield) toUpgrade).DRMax(levelFrom),\n\t\t\t\t\t0 + \"-\" + ((Greatshield) toUpgrade).DRMax(levelTo),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//weight (i.e. strength requirement)\n\t\tif (toUpgrade instanceof Weapon){\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Weapon) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t} else if (toUpgrade instanceof Armor) {\n\t\t\tbottom = fillFields(Messages.get(this, \"weight\"),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelFrom))),\n\t\t\t\t\tInteger.toString((((Armor) toUpgrade).STRReq(levelTo))),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//TODO Duelist weapon abilities\n\n\t\t//durability\n\t\tif (toUpgrade instanceof MissileWeapon){\n\t\t\t//missile weapons are always IDed currently, so we always use true level\n\t\t\tint uses1 = (int)Math.ceil(100f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tint uses2 = (int)Math.ceil(300f/((MissileWeapon) toUpgrade).durabilityPerUse());\n\t\t\tbottom = fillFields(Messages.get(this, \"durability\"),\n\t\t\t\t\tuses1 >= 100 ? \"∞\" : Integer.toString(uses1),\n\t\t\t\t\tuses2 >= 100 ? \"∞\" : Integer.toString(uses2),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//we use a separate reference for wand properties so that mage's staff can include them\n\t\tItem wand = toUpgrade;\n\t\tif (toUpgrade instanceof MagesStaff && ((MagesStaff) toUpgrade).wandClass() != null){\n\t\t\twand = Reflection.newInstance(((MagesStaff) toUpgrade).wandClass());\n\t\t}\n\n\t\t//Various wand stats (varies by wand)\n\t\tif (wand instanceof Wand){\n\t\t\tif (((Wand) wand).upgradeStat1(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_1\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat1(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat1(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t\tif (((Wand) wand).upgradeStat2(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_2\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat2(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat2(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t\tif (((Wand) wand).upgradeStat3(levelFrom) != null){\n\t\t\t\tbottom = fillFields(Messages.get(wand, \"upgrade_stat_name_3\"),\n\t\t\t\t\t\t((Wand) wand).upgradeStat3(levelFrom),\n\t\t\t\t\t\t((Wand) wand).upgradeStat3(levelTo),\n\t\t\t\t\t\tbottom);\n\t\t\t}\n\t\t}\n\n\t\t//max charges\n\t\tif (wand instanceof Wand){\n\t\t\tint chargeboost = levelFrom + (toUpgrade instanceof MagesStaff ? 1 : 0);\n\t\t\tbottom = fillFields(Messages.get(this, \"charges\"),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost)),\n\t\t\t\t\tInteger.toString(Math.min(10, ((Wand) wand).initialCharges() + chargeboost + 1)),\n\t\t\t\t\tbottom);\n\t\t}\n\n\t\t//TODO Various ring stats (varies by ring)\n\t\tif (toUpgrade instanceof Ring){\n\n\t\t}\n\n\t\t//visual separators for each column\n\t\tColorBlock sep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = WIDTH/2f;\n\t\tsep.y = message.bottom() + GAP;\n\t\tadd(sep);\n\n\t\tsep = new ColorBlock(1, 1, 0xFF222222);\n\t\tsep.size(1, bottom - message.bottom());\n\t\tsep.x = 3*WIDTH/4f;\n\t\tsep.y = message.bottom() + GAP;\n\t\tadd(sep);\n\n\t\t// *** Various extra info texts that can appear underneath stats ***\n\n\t\t//warning relating to identification\n\t\tif (!toUpgrade.isIdentified()){\n\t\t\tbottom = addMessage(Messages.get(this, \"unided\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t// various messages relating to enchantments and curses\n\t\tif (!(upgrader instanceof MagicalInfusion)) {\n\n\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasGoodEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasGoodGlyph())) {\n\t\t\t\tint lossChance;\n\t\t\t\tif ((toUpgrade instanceof Weapon && ((Weapon) toUpgrade).enchantHardened)\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).glyphHardened)) {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 6));\n\t\t\t\t} else {\n\t\t\t\t\tlossChance = Math.min(100, 10 * (int) Math.pow(2, levelFrom - 4));\n\t\t\t\t}\n\n\t\t\t\tif (lossChance >= 10) {\n\t\t\t\t\tString warn;\n\t\t\t\t\tif (toUpgrade instanceof Weapon) {\n\t\t\t\t\t\tif (((Weapon) toUpgrade).enchantHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"enchant\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (((Armor) toUpgrade).glyphHardened) {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"harden\", lossChance);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twarn = Messages.get(this, \"glyph\", lossChance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbottom = addMessage(warn, CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((toUpgrade.cursed\n\t\t\t\t\t|| (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph()))\n\t\t\t\t\t&& toUpgrade.cursedKnown) {\n\n\t\t\t\tif (toUpgrade.cursed && (toUpgrade instanceof Weapon && ((Weapon) toUpgrade).hasCurseEnchant())\n\t\t\t\t\t\t|| (toUpgrade instanceof Armor && ((Armor) toUpgrade).hasCurseGlyph())){\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed_weaken\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t} else {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"cursed\"), CharSprite.POSITIVE, bottom);\n\t\t\t\t}\n\n\t\t\t\tif (curseInfused) {\n\t\t\t\t\tbottom = addMessage(Messages.get(this, \"curse_infusion\"), CharSprite.WARNING, bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//warning relating to arcane resin\n\t\tif (toUpgrade instanceof Wand && ((Wand) toUpgrade).resinBonus > 0){\n\t\t\tbottom = addMessage(Messages.get(this, \"resin\"), CharSprite.WARNING, bottom);\n\t\t}\n\n\t\t// *** Buttons for confirming/cancelling ***\n\n\t\tbtnUpgrade = new RedButton(Messages.get(this, \"upgrade\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tScrollOfUpgrade.upgrade(Dungeon.hero);\n\n\t\t\t\tItem upgraded = toUpgrade;\n\t\t\t\tif (upgrader instanceof ScrollOfUpgrade){\n\t\t\t\t\t((ScrollOfUpgrade) upgrader).readAnimation();\n\t\t\t\t\tupgraded = ((ScrollOfUpgrade) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t\t\t\t} else if (upgrader instanceof MagicalInfusion){\n\t\t\t\t\t((MagicalInfusion) upgrader).useAnimation();\n\t\t\t\t\tupgraded = ((MagicalInfusion) upgrader).upgradeItem(toUpgrade);\n\t\t\t\t}\n\n\t\t\t\tItem moreUpgradeItem = Dungeon.hero.belongings.getItem(upgrader.getClass());\n\n\t\t\t\thide();\n\n\t\t\t\tif (moreUpgradeItem != null && toUpgrade.isIdentified()){\n\t\t\t\t\tmoreUpgradeItem = moreUpgradeItem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\t\tGameScene.show(new WndUpgrade(moreUpgradeItem, upgraded, false));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnUpgrade.setRect(0, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnUpgrade);\n\n\t\tbtnCancel = new RedButton(Messages.get(this, \"cancel\")){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tif (!force) {\n\t\t\t\t\tupgrader.collect();\n\t\t\t\t\thide();\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show( new WndOptions(new ItemSprite(upgrader),\n\t\t\t\t\t\t\tMessages.titleCase(upgrader.name()),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(InventoryScroll.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tWndUpgrade.this.hide();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpublic void onBackPressed() {}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t\tbtnCancel.setRect(btnUpgrade.right()+1, bottom+2*GAP, WIDTH/2f, 16);\n\t\tadd(btnCancel);\n\n\t\tbtnUpgrade.enable(Dungeon.hero.ready);\n\n\t\tbottom = (int)btnCancel.bottom();\n\n\t\tresize(WIDTH, (int)bottom);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nt1.hardlight(ItemSlot.UPGRADED);\n\t\t\tt2.text(\"+\" + levelTo);\n\t\t\tt2.hardlight(ItemSlot.UPGRADED);",
          "uniqueId": "be3de2d883d043596bb274ac7796e30bca891583_71_405_128_131_68_392"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "40e7a4093fce70d72587f903be21237da2d02f8c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40e7a4093fce70d72587f903be21237da2d02f8c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 6+2*buffedLvl();             //6 extra defence, plus 2 per level\n\t}",
          "sourceCodeAfterRefactoring": "public int DRMax(int lvl){\n\t\treturn 6 + 2*lvl;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(int lvl){\n\t\treturn 6 + 2*lvl;\n\t}",
          "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_43_46_53_55_53_55"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 6+2*buffedLvl();             //6 extra defence, plus 2 per level\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn DRMax();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(){\n\t\treturn DRMax(buffedLvl());\n\t}",
          "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_43_46_48_50_43_46"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 4+buffedLvl();               //4 extra defence, plus 1 per level\n\t}",
          "sourceCodeAfterRefactoring": "public int DRMax(int lvl){\n\t\treturn 4 + lvl;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(int lvl){\n\t\treturn 4 + lvl;\n\t}",
          "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_52_55_62_64_62_64"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 4+buffedLvl();               //4 extra defence, plus 1 per level\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn DRMax();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int DRMax(){\n\t\treturn DRMax(buffedLvl());\n\t}",
          "uniqueId": "40e7a4093fce70d72587f903be21237da2d02f8c_52_55_57_59_52_55"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f0542ebf1e3b9f654c66a6303e4849b592811355",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f0542ebf1e3b9f654c66a6303e4849b592811355",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void countEncounter(Class<?> cls){\n\t\tif (classConversions.containsKey(cls)){\n\t\t\tcls = classConversions.get(cls);\n\t\t}\n\t\tfor (Bestiary cat : values()) {\n\t\t\tif (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE){\n\t\t\t\tcat.encounterCount.put(cls, cat.encounterCount.get(cls)+1);\n\t\t\t\tJournal.saveNeeded = true;\n\t\t\t}\n\t\t}\n\t\tBadges.validateCatalogBadges();\n\t}",
          "sourceCodeAfterRefactoring": "public static void countEncounter(Class<?> cls){\n\t\tcountEncounters(cls, 1);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void countEncounters(Class<?> cls, int encounters){\n\t\tif (classConversions.containsKey(cls)){\n\t\t\tcls = classConversions.get(cls);\n\t\t}\n\t\tfor (Bestiary cat : values()) {\n\t\t\tif (cat.encounterCount.containsKey(cls) && cat.encounterCount.get(cls) != Integer.MAX_VALUE){\n\t\t\t\tcat.encounterCount.put(cls, cat.encounterCount.get(cls)+encounters);\n\t\t\t\tif (cat.encounterCount.get(cls) < -1_000_000_000){ //to catch cases of overflow\n\t\t\t\t\tcat.encounterCount.put(cls, Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t\tJournal.saveNeeded = true;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "f0542ebf1e3b9f654c66a6303e4849b592811355_307_318_311_324_307_309"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2763cf42ca71fce0e4e942721d9db6509306daf3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2763cf42ca71fce0e4e942721d9db6509306daf3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v2_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v2.3.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Slightly improved the layout of shop rooms when many items are present\\n\\n\" +\n\t\t\t\t\"_-_ Updated a link in the game's credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.1:_\\n\" +\n\t\t\t\t\"_-_ Tengu being able to set himself on fire, oops =S\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Various minor textual errors\\n\" +\n\t\t\t\t\"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n\t\t\t\t\"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n\t\t\t\t\"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n\t\tchanges = new ChangeInfo(\"v2.3.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n\t\t\t\t\"_-_ Improved vibration on modern iOS devices\\n\" +\n\t\t\t\t\"_-_ Improved changing audio device behavior\\n\" +\n\t\t\t\t\"_-_ Misc. stability & compatibility improvements\\n\\n\" +\n\t\t\t\t\"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n\t\t\t\t\"_-_ Tengu's fire wall attack now ignites items\\n\\n\" +\n\t\t\t\t\"_-_ Improved music transitions in main menu when game was just won\\n\\n\" +\n\t\t\t\t\"_-_ Added support for controller vibration\\n\" +\n\t\t\t\t\"_-_ Added a vibration toggle in the settings\\n\\n\" +\n\t\t\t\t\"_-_ Updated translators and translator credits\\n\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported iOS version to 11, from 9\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Caused by v2.3.0:_\\n\" +\n\t\t\t\t\"Nothing! v2.3.0 is pretty stable. =)\\n\\n\" +\n\t\t\t\t\"_Existed prior to v2.3.0:_\\n\" +\n\t\t\t\t\"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n\t\t\t\t\"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n\t\t\t\t\"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n\t\t\t\t\"_-_ Incorrect death messages when player is killed by wards\\n\" +\n\t\t\t\t\"_-_ Amoked allies not being affected by aggression debuff\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released January 18th, 2024\\n\" +\n\t\t\t\t\"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n\t\t\t\t\"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n\t\t\t\t\"More Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n\t\t\t\t\"_A second variant has been added to the caves quest!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n\t\t\t\t\"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n\t\t\t\t\"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n\t\t\t\t\"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n\t\t\t\t\"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n\t\t\t\t\"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n\t\t\t\t\"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n\t\t\t\t\"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n\t\t\t\t\"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n\t\t\t\t\"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n\t\t\t\t\"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n\t\t\t\t\"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Allies:_\\n\" +\n\t\t\t\t\"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n\t\t\t\t\"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n\t\t\t\t\"_-_ Spirit hawk now interrupts the hero when it expires\",\n\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n\t\t\t\t\"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n\t\t\t\t\"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n\t\t\t\t\"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n\t\t\t\t\"_-_ Added support for themed icons on Android 13+\\n\" +\n\t\t\t\t\"_-_ Removed support for saves prior to v1.4.3\\n\" +\n\t\t\t\t\"_-_ Added developer commentary for v1.2.0\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n\t\t\t\t\"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n\t\t\t\t\"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n\t\t\t\t\"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n\t\t\t\t\"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Quests:_\\n\" +\n\t\t\t\t\"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n\t\t\t\t\"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n\t\t\t\t\"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n\t\t\t\t\"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n\t\t\t\t\"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n\t\t\t\t\"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n\t\t\t\t\"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n\t\t\t\t\"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n\t\t\t\t\"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n\t\t\t\t\"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n\t\t\t\t\"_-_ Rare errors in DM-201 target selection\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Rotberry seed being deleted in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n\t\t\t\t\"_-_ Foresight effects not triggering after level transition\\n\" +\n\t\t\t\t\"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n\t\t\t\t\"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n\t\t\t\t\"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n\t\t\t\t\"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n\t\t\t\t\"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n\t\t\t\t\"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n\t\t\t\t\"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n\t\t\t\t\"_-_ Rare quickslot errors when bags which already contain items are collected\",\n\n\t\t\t\t\"_Hero & Allies:_\\n\" +\n\t\t\t\t\"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n\t\t\t\t\"_-_ Sneak ability working while Duelist is rooted\\n\" +\n\t\t\t\t\"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n\t\t\t\t\"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n\t\t\t\t\"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n\t\t\t\t\"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n\t\t\t\t\"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n\t\t\t\t\"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n\t\t\t\t\"_-_ Ally warp working on corrupted DM-201s\\n\" +\n\t\t\t\t\"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc.:_\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Tutorial becoming stuck in rare cases\\n\" +\n\t\t\t\t\"_-_ Beta updates setting not working as intended\\n\" +\n\t\t\t\t\"_-_ Music fading not working in rare cases\\n\" +\n\t\t\t\t\"_-_ Scrolling pane in journal window freezing in rare cases\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n\t\t\t\t\"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v2_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released January 18th, 2024\\n\" +\n\t\t\t\t\"_-_ 92 days after Shattered v2.2.0\\n\\n\" +\n\t\t\t\t\"v2.3.0 was originally going to contain two new variants for the caves quest, but after a longer than expected dev cycle plus the holidays, I opted to release v2.3.0 with just one more variant and move on to other content for a while, instead of spending even more time on the caves quest.\\n\\n\" +\n\t\t\t\t\"More Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new GnollGuardSprite()), \"Gnoll Caves Quest\",\n\t\t\t\t\"_A second variant has been added to the caves quest!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This variant features _gnolls and earth-moving magic._ Expect to spend a bit more time digging, as this environment features collapsed walls, boulders, and angry gnolls wielding spears and earth-moving devices. Their magic is quite chaotic, so be ready to dodge and possibly get the gnolls caught in their own attacks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"The boss for this variant is the _gnoll geomancer,_ an experienced gnoll with access to lots of mobility and earth-moving power.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.REMAINS), \"New Remains Items\",\n\t\t\t\t\"_Heroes remains now contain a new unique item that varies based on the class of the hero that died._\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"These items are single use consumables that provide a small benefit that's themed after the hero who died. There are also two new badges relating to these items.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Remains now always contain a signature remains item in addition to an extra item from the previous run, if one was chosen. This replaces the previous behaviour, where remains would contain 50 or 10 gold if no eligible item could be chosen.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Additionally, remains which contain a stackable item from the previous run now cap the quantity of that item at 3.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.CANDY_CANE), \"New Holiday Items\",\n\t\t\t\t\"Shattered has had little holiday food items that temporarily replace cornish pasties ever since 2016, but only for Halloween and the Winter Holidays. Throughout 2024 you'll see a bunch of new items for more holidays through the year, which all have different tiny bonus effects when eaten.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For now I have implemented items for Lunar New Years and Easter, with more on the way in future updates.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"I've also shortened the duration for Halloween and the Winter Holidays after 2023, so as not to make the game overly festive in the later months of the year, and nerfed the healing effect on Halloween pumpkin pies.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BUFFS), \"Floating Text Icons\",\n\t\t\t\t\"The little bits of floating text that appear above characters to indicate damage, positive effects, and currency gain now have tiny icons to indicate the type!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For damage, it is now shown whether the damage is physical, magical, or if it comes from a particular debuff or DOT effect. There are separate physical damage icons depending on whether armor reduces the incoming damage. Armor never reduces magical or DOT damage. Damage text is also now always red,  warnings and negative effects are always orange.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"For positive effects, icons are now shown for healing, shielding, and exp gain. Loads of healing or shielding effects which previously didn't show floating text now do as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Improved the sprites for Armored Brutes and DM-201s\\n\" +\n\t\t\t\t\"_-_ The troll blacksmith no longer works on cursed items\\n\" +\n\t\t\t\t\"_-_ Reduced the chance for sleeping enemies to clump together in caves quest levels\\n\" +\n\t\t\t\t\"_-_ Random scroll and potion drops are now more consistent throughout a run\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ DM-300's rockfall attack now uses positional danger indicators\\n\" +\n\t\t\t\t\"_-_ Improved visual clarity of sparks in the DM-300 fight\\n\" +\n\t\t\t\t\"_-_ Removed unnecessary game log entries when DM-300 uses abilities\\n\" +\n\t\t\t\t\"_-_ Phantom piranhas now die on land if there is no water to teleport to\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Added a warning when trying to steal from shops with less than 100% success chance\\n\" +\n\t\t\t\t\"_-_ Curse infusion now preserves an existing curse on items that don't have the curse infusion bonus yet\\n\" +\n\t\t\t\t\"_-_ long pressing on the ghost equip window now shows the stats of equipped items\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Allies:_\\n\" +\n\t\t\t\t\"_-_ Ghosts and Rogue's shadow clone are now considered inorganic (immune to bleed, toxic, poison)\\n\" +\n\t\t\t\t\"_-_ Corrupted allies no longer attack passive enemies\\n\" +\n\t\t\t\t\"_-_ Spirit hawk now interrupts the hero when it expires\",\n\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Added a bit of clarity text to some parts of the blacksmith quest/rewards\\n\" +\n\t\t\t\t\"_-_ Surface scene now shows night later in the evening as well as after midnight\\n\" +\n\t\t\t\t\"_-_ Did a consistency pass on heal over time effects interrupting the hero resting\\n\" +\n\t\t\t\t\"_-_ Long-press to assign quickslot now works in the full UI inventory pane, just like the mobile inventory window\\n\" +\n\t\t\t\t\"_-_ Added support for themed icons on Android 13+\\n\" +\n\t\t\t\t\"_-_ Removed support for saves prior to v1.4.3\\n\" +\n\t\t\t\t\"_-_ Added developer commentary for v1.2.0\",\n\n\t\t\t\t\"_v2.3.1_\\n\" +\n\t\t\t\t\"I've updated to the latest version of Shattered's game library (libGDX), which has a few benefits:\\n\" +\n\t\t\t\t\"_-_ Improved vibration on modern iOS devices\\n\" +\n\t\t\t\t\"_-_ Improved changing audio device behavior\\n\" +\n\t\t\t\t\"_-_ Misc. stability & compatibility improvements\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Magical fire is now cleared by frost next to it, in addition to on top of it\\n\" +\n\t\t\t\t\"_-_ Tengu's fire wall attack now ignites items\\n\" +\n\t\t\t\t\"_-_ Improved music transitions in main menu when game was just won\\n\" +\n\t\t\t\t\"_-_ Added support for controller vibration\\n\" +\n\t\t\t\t\"_-_ Added a vibration toggle in the settings\\n\" +\n\t\t\t\t\"_-_ Updated translators and translator credits\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported iOS version to 11, from 9\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_v2.3.2_\\n\" +\n\t\t\t\t\"_-_ Slightly improved the layout of shop rooms when many items are present\\n\" +\n\t\t\t\t\"_-_ Updated a link in the game's credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Enemies continuing to fight each other after amok expires in many cases\\n\" +\n\t\t\t\t\"_-_ Some inter-level teleportation effects working inside caves quest level\\n\" +\n\t\t\t\t\"_-_ Transmutation being usable on the pickaxe during the caves quest\\n\" +\n\t\t\t\t\"_-_ Unintended changes to reforge functionality when both items are the same level\\n\" +\n\t\t\t\t\"_-_ Rounding errors causing tipped darts to last longer than intended in some cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Quests:_\\n\" +\n\t\t\t\t\"_-_ Crystal spire being considered a mini boss, not a full boss\\n\" +\n\t\t\t\t\"_-_ Crystal spire attacks ignoring damage-resisting effects\\n\" +\n\t\t\t\t\"_-_ Cases where remains would fail to appear in the new mining level\\n\" +\n\t\t\t\t\"_-_ Blacksmith landmark entry not clearing when you have spent all favor\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could appear to be on top of crystal spire\\n\" +\n\t\t\t\t\"_-_ Corpse dust quest tracking all wraiths instead of just the ones it spawned\\n\" +\n\t\t\t\t\"_-_ Some cases where new rot garden room could spawn much smaller than intended\",\n\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Final boss fight not properly interacting with the into darkness challenge\\n\" +\n\t\t\t\t\"_-_ Monk ability use disqualifying for dwarf king's 'no weapons' badge when a weapon was equipped\\n\" +\n\t\t\t\t\"_-_ Tengu behaving slightly incorrectly when taking massive damage\\n\" +\n\t\t\t\t\"_-_ Mimics not dropping their loot if corrupted while hiding\\n\" +\n\t\t\t\t\"_-_ Rare cases where DM-300 finale music would play before the fight\\n\" +\n\t\t\t\t\"_-_ Rare errors in DM-201 target selection\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Rotberry seed being deleted in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where the game would freeze after reviving via unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Some bombs and explosion-spawning effects incorrectly dealing magic damage\\n\" +\n\t\t\t\t\"_-_ Foresight effects not triggering after level transition\\n\" +\n\t\t\t\t\"_-_ Projecting missile weapons not working on enemies inside solid terrain\\n\" +\n\t\t\t\t\"_-_ Cursed wand of warding having different targeting properties than other wands\\n\" +\n\t\t\t\t\"_-_ Thrown potions not clearing fire/ooze if they shattered out of view\\n\" +\n\t\t\t\t\"_-_ Retribution and psionic blast not applying to all visible characters in very rare cases\\n\" +\n\t\t\t\t\"_-_ Degrade debuff not applying to thrown weapons\\n\" +\n\t\t\t\t\"_-_ Cloak of shadows not losing charge if it is dispelled as it is activated\\n\" +\n\t\t\t\t\"_-_ Items being assignable to non-visible quickslots in specific cases\\n\" +\n\t\t\t\t\"_-_ Rare quickslot errors when bags which already contain items are collected\",\n\n\t\t\t\t\"_Hero & Allies:_\\n\" +\n\t\t\t\t\"_-_ Thrown potions not triggering Liquid Agility talent\\n\" +\n\t\t\t\t\"_-_ Sneak ability working while Duelist is rooted\\n\" +\n\t\t\t\t\"_-_ Damage from Body Slam talent ignoring armor\\n\" +\n\t\t\t\t\"_-_ Lunge ability incorrectly interacting with movespeed in some cases\\n\" +\n\t\t\t\t\"_-_ Cases where prismatic images could keep appearing and then disappearing\\n\" +\n\t\t\t\t\"_-_ Hero not being able to self-trample plants when standing on stairs\\n\" +\n\t\t\t\t\"_-_ Berserker being able to rage without his seal equipped in some cases\\n\" +\n\t\t\t\t\"_-_ Allies rarely spawning on hazards after ankh revive\\n\" +\n\t\t\t\t\"_-_ Ally warp working on corrupted DM-201s\\n\" +\n\t\t\t\t\"_-_ Duelist's lunge ability not correctly applying range boosts in rare cases\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc.:_\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Tutorial becoming stuck in rare cases\\n\" +\n\t\t\t\t\"_-_ Beta updates setting not working as intended\\n\" +\n\t\t\t\t\"_-_ Music fading not working in rare cases\\n\" +\n\t\t\t\t\"_-_ Scrolling pane in journal window freezing in rare cases\",\n\n\t\t\t\t\"_v2.3.1:_\\n\" +\n\t\t\t\t\"_-_ Game unintentionally spamming new Google Play players with Play Games login requests\\n\" +\n\t\t\t\t\"_-_ Events which interrupt the hero not interrupting resting\\n\" +\n\t\t\t\t\"_-_ Rare cases where hero could lose a turn when moving between depths\\n\" +\n\t\t\t\t\"_-_ Transmutation removing items from quickslots in rare cases\\n\" +\n\t\t\t\t\"_-_ Incorrect death messages when player is killed by wards\\n\" +\n\t\t\t\t\"_-_ Amoked allies not being affected by aggression debuff\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_v2.3.2:_\\n\" +\n\t\t\t\t\"_-_ Various minor textual errors\\n\" +\n\t\t\t\t\"_-_ Very specific cases where levelgen could vary based on whether the player has a timekeeper's hourglass or not\\n\" +\n\t\t\t\t\"_-_ Hero leap vfx not causing the camera to follow them\\n\" +\n\t\t\t\t\"_-_ Cases where grass and embers wouldn't appear on top of specific ground visuals\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.TALENT.get(), \"Hero Abilities\",\n\t\t\t\t\"No nerfs this time, and just a couple targeted buffs to hero abilities/talents.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Rogue's Foresight_ talent trigger chance increased to 60% at +1 and 90% at +2, up from 50% at +1 and 75% at +2.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Elemental Strike_ ability base range increased to 4 from 3.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v2_4_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v2.4.0-ALPHA\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Alpha To-Do\",\n\t\t\t\t\"v2.4.0 isn't yet content complete, so there's a bit more I plan to add before beta/release:\\n\\n\" +\n\t\t\t\t\"_-_ I want to add a few more Trinkets, ideally so there are 10-12 in total for release.\\n\" +\n\t\t\t\t\"_-_ I'd like to make further alchemy UI improvements, mainly it'd be nice to include the guidebook on the main screen for desktop users.\\n\" +\n\t\t\t\t\"_-_ I plan on making a few supporter feature improvements, primarily better epitaphs and maybe custom notes. This might get delayed to a future patch/update though.\\n\" +\n\t\t\t\t\"_-_ I'll make further Hero tweaks in response to feedback as needed.\\n\" +\n\t\t\t\t\"_-_ And, of course, there'll be various misc tweaks and fixes as needed.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RAT_SKULL), \"Trinkets!\",\n\t\t\t\t\"_A new category of item has been added: Trinkets!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Trinkets are a new item type produced and upgraded via alchemical energy, and are more about tweaking gameplay variables than giving direct power or utility.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Look out for a trinket catalyst in the early stages of the game, which you can use at the first alchemy pot to produce one of three trinket options. There are _8 trinkets in total_ currently.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.STAIRS), \"New Rooms\",\n\t\t\t\t\"_New standard rooms have been added to the various regions of the game!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This includes one totally new room per region, and two new variants of entrance/exit rooms per region. Rooms that are mostly empty rectangles are now much less common, and there's a bunch of variety for which rooms can have entrance/exit stairs in them.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Entrance rooms are now also capable of merging with other rooms in a dungeon floor, but there are some guarantees so that enemies won't ever be near you right after descending to a new floor.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.PUMPKIN_PIE), \"More Holiday Items\",\n\t\t\t\t\"_I've added more holiday items for the rest of 2024!_\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Expect to see some new temporary holiday overrides for cornish pasties for:\\n\" +\n\t\t\t\t\"_-_ Pride in late June\\n\" +\n\t\t\t\t\"_-_ Shattered's Birthday in early August\\n\" +\n\t\t\t\t\"_-_ Pixel Dungeon's Birthday in early December\\n\" +\n\t\t\t\t\"_-_ New Years in late December and early January\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"This is in addition to the usual pumpkin pie around Halloween and candy cane around the Winter Holidays.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"...I may have also added a tiny little surprise for Rat King's birthday, but that won't appear until 2025.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(HeroSprite.avatar(HeroClass.DUELIST, 6), \"Duelist Weapon Abilities\",\n\t\t\t\t\"I'm making some overarching changes to the Duelist's weapon abilities, to make them stronger and feel more impactful:\\n\" +\n\t\t\t\t\"_-_ Weapon ability charge speed down by 33%\\n\" +\n\t\t\t\t\"_-_ Weapon abilities buffed across the board\\n\" +\n\t\t\t\t\"_-_ All weapon abilities now scale with weapon level in some way\\n\" +\n\t\t\t\t\"_-_ Weapon abilities now directly state their damage ranges\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"There are also some changes to the Champion subclass to go along with this:\\n\" +\n\t\t\t\t\"_-_ Champion's two weapons now share a charge count, but Champion gets boosted max charges and charge speed.\\n\" +\n\t\t\t\t\"_-_ Champion's secondary charge talent has been replaced with a new talent that encourages varied ability use.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.ENERGY), \"Alchemy Changes\",\n\t\t\t\t\"I've made a bunch of changes to the alchemy system to streamline things and complement the addition of trinkets:\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Catalysts have been removed entirely, recipes now simply cost more energy instead of requiring one.\\n\" +\n\t\t\t\t\"_-_ Lots of recipes have received adjustments to their overall energy cost or output quantities.\\n\" +\n\t\t\t\t\"_-_ High value potions/scrolls now grant a little more energy if they are energized.\\n\" +\n\t\t\t\t\"_-_ Alchemy pots now always spawn on the 3rd or 4th floor in each region.\\n\" +\n\t\t\t\t\"_-_ Various UI improvements have been made to the alchemy screen.\",\n\t\t\t\t\n\t\t\t\t\"Various specific alchemy items have also received more notable changes:\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_- Added Unstable Brew,_ which gives a random potion effect that's likely to be useful.\\n\" +\n\t\t\t\t\"_- Aqua Blast_ is now a brew, otherwise unchanged.\\n\" +\n\t\t\t\t\"_- Featherfall_ is now an elixir, otherwise unchanged.\\n\" +\n\t\t\t\t\"_- Elixir of Icy Touch_ now applies 3 chill each hit, up from 2.\\n\" +\n\t\t\t\t\"_- Elixir of Toxic Essence_ now spreads gas quicker and grants lingering gas immunity for 5 turns.\\n\" +\n\t\t\t\t\"_- Added Unstable Spell,_ which gives a random scroll effect that's likely to be useful.\\n\" +\n\t\t\t\t\"_- Alchemize_ has a new recipe, it is now much cheaper to make.\\n\" +\n\t\t\t\t\"_- Summon Elemental_ now retains its empowerment, rather than having it last only 1 use.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.TALENT), \"T1 talent changes\",\n\t\t\t\t\"I've made some changes meant to improve some of the least popular T1 talents:\\n\" +\n\t\t\t\t\"_- Cached Rations_ now awards a smaller number of unique 'supply rations'. These rations grant a little healing and cloak charge.\\n\" +\n\t\t\t\t\"_- Test Subject and Tested Hypothesis_ have been replaced with two new talents that grant small combat bonuses.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Plus one change to an unnecessarily complex T1 talent:\\n\" +\n\t\t\t\t\"_- Hearty Meal_ has been simplified, now just has one threshold at 30% HP\"));\n\n\t\t/*changes.addButton( new ChangeButton(Icons.get(Icons.GOLD), \"Supporter Changes\",\n\t\t\t\t\".\"));*/\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Potion and Scroll talents can now trigger from elixirs, brews, and spells\\n\" +\n\t\t\t\t\"_-_ Ankh resurrection window now warns if two items aren't selected\\n\" +\n\t\t\t\t\"_-_ Trying to attack an enemy that has charmed you now shows a warning\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Heroes:_\\n\" +\n\t\t\t\t\"_-_ Gladiator and Monk now include brief ability descriptions in their subclass descriptions\\n\" +\n\t\t\t\t\"_-_ Ability descriptions for Gladiator and Monk now change if their abilities are empowered\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Thrown weapons now state when they break in the game log\\n\" +\n\t\t\t\t\"_-_ Tipped darts now last forever when reaching 100 uses, like other thrown weapons\\n\" +\n\t\t\t\t\"_-_ Dried rose now includes the ghost's strength in its description\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Updated various code dependencies\\n\" +\n\t\t\t\t\"_-_ Slight optimizations to memory use\\n\" +\n\t\t\t\t\"_-_ Improved the error message on Android when native code is missing\\n\" +\n\t\t\t\t\"_-_ Removed the power saver setting on Android 4.4+ devices, if the user hadn't already enabled it.\\n\" +\n\t\t\t\t\"(Power saver was always meant for very old Android devices. It gives no real benefit for more modern ones.)\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed the following bugs:\\n\" +\n\t\t\t\t\"_Highlights:_\\n\" +\n\t\t\t\t\"_-_ Ruins rooms in the last region using incorrect wall shapes since v2.2.0\\n\" +\n\t\t\t\t\"_-_ Rare cases where some victory badges would not save if game was immediately closed\\n\" +\n\t\t\t\t\"_-_ Rare cases where game actors could continue to process for a moment when hero falls into a chasm\\n\" +\n\t\t\t\t\"_-_ Various cases where characters would not play death animations if they died while paralyzed\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Enemies:_\\n\" +\n\t\t\t\t\"_-_ Newborn elemental boss rarely firing its attack through walls\\n\" +\n\t\t\t\t\"_-_ Rare cases where the final boss could command minions to attack themselves\\n\" +\n\t\t\t\t\"_-_ Gnoll geomancer and sappers potentially dropping boulders next to entrance\\n\" +\n\t\t\t\t\"_-_ Gnoll sappers granting armor to corrupted gnoll guards\\n\" +\n\t\t\t\t\"_-_ Necromancer skeletons not following necromancer's aggro in some cases\",\n\n\t\t\t\t\"_Items:_\\n\" +\n\t\t\t\t\"_-_ Thieve's Armband not working on hiding mimics\\n\" +\n\t\t\t\t\"_-_ Chilling enchantment reducing chill duration in rare cases\\n\" +\n\t\t\t\t\"_-_ Rare cases where lucky enchantment wouldn't trigger\\n\" +\n\t\t\t\t\"_-_ Runestones affecting terrain when thrown at a character\\n\" +\n\t\t\t\t\"_-_ Thrown weapons sticking to downed ghouls in some cases\\n\" +\n\t\t\t\t\"_-_ Camouflage glyph not working if hero uses ethereal chains to move into grass\\n\" +\n\t\t\t\t\"_-_ Sandals of nature incorrectly interacting with artifact charging\\n\" +\n\t\t\t\t\"_-_ Several artifacts being unable to gain more than 1 (or 1%) charge per turn\\n\" +\n\t\t\t\t\"_-_ Brimstone glyph not benefiting from glyph power boosts past +50%\\n\" +\n\t\t\t\t\"_-_ Errors when leaving/entering blacksmith's area while a boomerang was circling back\\n\" +\n\t\t\t\t\"_-_ Transfusion not benefiting from wand damage bonuses\\n\" +\n\t\t\t\t\"_-_ Dwarf King's crown automatically IDing armor\\n\" +\n\t\t\t\t\"_-_ Armband allowing more than one steal in specific cases\\n\" +\n\t\t\t\t\"_-_ Swiftness glyph ignoring nearby enemies in specific cases\",\n\n\t\t\t\t\"_Heroes:_\\n\" +\n\t\t\t\t\"_-_ Duelist's swift equip not working during time freeze\\n\" +\n\t\t\t\t\"_-_ Monk's flurry of blows not using projecting enchantment when empowered\\n\" +\n\t\t\t\t\"_-_ Various battlemage on-hit effects not showing as magical damage\\n\" +\n\t\t\t\t\"_-_ Empowered strike talent not working with blastwave\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_Misc:_\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Specific cases where unbreakable traps could spawn in halls in the caves\\n\" +\n\t\t\t\t\"_-_ Music not properly pausing in background on desktop in some cases\\n\" +\n\t\t\t\t\"_-_ Various rare errors when game launches in fullscreen\\n\" +\n\t\t\t\t\"_-_ 'taste vengeance' badge not being earnable in a run after unlocking it\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new Image(new GhostSprite()), \"Ghost and Blacksmith Enchantments\",\n\t\t\t\t\"I've given a slight boost to the rewards of the Ghost quest and Blacksmith's smith reward, aimed at making enchantments/glyphs more likely. this should make these rewards a bit more interesting more often.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Ghost reward enchant rate up to 20% from 10%\\n\" +\n\t\t\t\t\"_-_ Blacksmith smith reward enchant rate up to 30% from 0%\"));\n\n\t}",
          "uniqueId": "2763cf42ca71fce0e4e942721d9db6509306daf3_77_277_79_247_249_434"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2a56271091b97a830ba128cd609928601f16eab7",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a56271091b97a830ba128cd609928601f16eab7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public int drRoll() {\n\t\tint dr = 0;\n\n\t\tdr += Random.NormalIntRange( 0 , Barkskin.currentLevel(this) );\n\n\t\treturn dr;\n\t}",
          "sourceCodeAfterRefactoring": "public int drRoll() {\n\t\tint dr = 0;\n\n\t\tdr += combatRoll( 0 , Barkskin.currentLevel(this) );\n\n\t\treturn dr;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int combatRoll(int min, int max ){\n\t\treturn Random.NormalIntRange( min, max );\n\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_605_611_595_597_611_617"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\tch.damage(dmg, link);\n\t\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\t\tlink.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 1.67f;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t//TODO improve this when I have proper damage source logic\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\n\t\tif (buff(Sickle.HarvestBleedTracker.class) != null){\n\t\t\tif (isImmune(Bleeding.class)){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.titleCase(Messages.get(this, \"immune\")));\n\t\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\tif (b == null){\n\t\t\t\tb = new Bleeding();\n\t\t\t}\n\t\t\tb.announced = false;\n\t\t\tb.set(dmg*buff(Sickle.HarvestBleedTracker.class).bleedFactor, Sickle.HarvestBleedTracker.class);\n\t\t\tb.attachTo(this);\n\t\t\tsprite.showStatus(CharSprite.WARNING, Messages.titleCase(b.name()) + \" \" + (int)b.level());\n\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t//FIXME: when I add proper damage properties, should add an IGNORES_SHIELDS property to use here.\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP > 0 && shielded > 0 && shielding() == 0){\n\t\t\tif (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)){\n\t\t\t\tBuff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n\t\t\t}\n\t\t}\n\n\t\tif (HP > 0 && buff(Grim.GrimTracker.class) != null){\n\n\t\t\tfloat finalChance = buff(Grim.GrimTracker.class).maxChance;\n\t\t\tfinalChance *= (float)Math.pow( ((HT - HP) / (float)HT), 2);\n\n\t\t\tif (Random.Float() < finalChance) {\n\t\t\t\tint extraDmg = Math.round(HP*resist(Grim.class));\n\t\t\t\tdmg += extraDmg;\n\t\t\t\tHP -= extraDmg;\n\n\t\t\t\tsprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\tif (!isAlive() && buff(Grim.GrimTracker.class).qualifiesForBadge){\n\t\t\t\t\tBadges.validateGrimWeapon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\t//defaults to normal damage icon if no other ones apply\n\t\t\tint                                                         icon = FloatingText.PHYS_DMG;\n\t\t\tif (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass()))     icon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\tif (AntiMagic.RESISTS.contains(src.getClass()))             icon = FloatingText.MAGIC_DMG;\n\t\t\tif (src instanceof Pickaxe)                                 icon = FloatingText.PICK_DMG;\n\n\t\t\t//special case for sniper when using ranged attacks\n\t\t\tif (src == Dungeon.hero\n\t\t\t\t\t&& Dungeon.hero.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t&& !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n\t\t\t\t\t&& Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon){\n\t\t\t\ticon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\t}\n\n\t\t\tif (src instanceof Hunger)                                  icon = FloatingText.HUNGER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Chill || src instanceof Frost)        icon = FloatingText.FROST;\n\t\t\tif (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Electricity)                             icon = FloatingText.SHOCKING;\n\t\t\tif (src instanceof Bleeding)                                icon = FloatingText.BLEEDING;\n\t\t\tif (src instanceof ToxicGas)                                icon = FloatingText.TOXIC;\n\t\t\tif (src instanceof Corrosion)                               icon = FloatingText.CORROSION;\n\t\t\tif (src instanceof Poison)                                  icon = FloatingText.POISON;\n\t\t\tif (src instanceof Ooze)                                    icon = FloatingText.OOZE;\n\t\t\tif (src instanceof Viscosity.DeferedDamage)                 icon = FloatingText.DEFERRED;\n\t\t\tif (src instanceof Corruption)                              icon = FloatingText.CORRUPTION;\n\t\t\tif (src instanceof AscensionChallenge)                      icon = FloatingText.AMULET;\n\n\t\t\tsprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\tch.damage(dmg, link);\n\t\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\t\tlink.detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 1.67f;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t//TODO improve this when I have proper damage source logic\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= combatRoll(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\n\t\tif (buff(Sickle.HarvestBleedTracker.class) != null){\n\t\t\tif (isImmune(Bleeding.class)){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.titleCase(Messages.get(this, \"immune\")));\n\t\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\tif (b == null){\n\t\t\t\tb = new Bleeding();\n\t\t\t}\n\t\t\tb.announced = false;\n\t\t\tb.set(dmg*buff(Sickle.HarvestBleedTracker.class).bleedFactor, Sickle.HarvestBleedTracker.class);\n\t\t\tb.attachTo(this);\n\t\t\tsprite.showStatus(CharSprite.WARNING, Messages.titleCase(b.name()) + \" \" + (int)b.level());\n\t\t\tbuff(Sickle.HarvestBleedTracker.class).detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t//FIXME: when I add proper damage properties, should add an IGNORES_SHIELDS property to use here.\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP > 0 && shielded > 0 && shielding() == 0){\n\t\t\tif (this instanceof Hero && ((Hero) this).hasTalent(Talent.PROVOKED_ANGER)){\n\t\t\t\tBuff.affect(this, Talent.ProvokedAngerTracker.class, 5f);\n\t\t\t}\n\t\t}\n\n\t\tif (HP > 0 && buff(Grim.GrimTracker.class) != null){\n\n\t\t\tfloat finalChance = buff(Grim.GrimTracker.class).maxChance;\n\t\t\tfinalChance *= (float)Math.pow( ((HT - HP) / (float)HT), 2);\n\n\t\t\tif (Random.Float() < finalChance) {\n\t\t\t\tint extraDmg = Math.round(HP*resist(Grim.class));\n\t\t\t\tdmg += extraDmg;\n\t\t\t\tHP -= extraDmg;\n\n\t\t\t\tsprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\tif (!isAlive() && buff(Grim.GrimTracker.class).qualifiesForBadge){\n\t\t\t\t\tBadges.validateGrimWeapon();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (HP < 0 && src instanceof Char && alignment == Alignment.ENEMY){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\t//defaults to normal damage icon if no other ones apply\n\t\t\tint                                                         icon = FloatingText.PHYS_DMG;\n\t\t\tif (NO_ARMOR_PHYSICAL_SOURCES.contains(src.getClass()))     icon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\tif (AntiMagic.RESISTS.contains(src.getClass()))             icon = FloatingText.MAGIC_DMG;\n\t\t\tif (src instanceof Pickaxe)                                 icon = FloatingText.PICK_DMG;\n\n\t\t\t//special case for sniper when using ranged attacks\n\t\t\tif (src == Dungeon.hero\n\t\t\t\t\t&& Dungeon.hero.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t&& !Dungeon.level.adjacent(Dungeon.hero.pos, pos)\n\t\t\t\t\t&& Dungeon.hero.belongings.attackingWeapon() instanceof MissileWeapon){\n\t\t\t\ticon = FloatingText.PHYS_DMG_NO_BLOCK;\n\t\t\t}\n\n\t\t\tif (src instanceof Hunger)                                  icon = FloatingText.HUNGER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Chill || src instanceof Frost)        icon = FloatingText.FROST;\n\t\t\tif (src instanceof GeyserTrap || src instanceof StormCloud) icon = FloatingText.WATER;\n\t\t\tif (src instanceof Burning)                                 icon = FloatingText.BURNING;\n\t\t\tif (src instanceof Electricity)                             icon = FloatingText.SHOCKING;\n\t\t\tif (src instanceof Bleeding)                                icon = FloatingText.BLEEDING;\n\t\t\tif (src instanceof ToxicGas)                                icon = FloatingText.TOXIC;\n\t\t\tif (src instanceof Corrosion)                               icon = FloatingText.CORROSION;\n\t\t\tif (src instanceof Poison)                                  icon = FloatingText.POISON;\n\t\t\tif (src instanceof Ooze)                                    icon = FloatingText.OOZE;\n\t\t\tif (src instanceof Viscosity.DeferedDamage)                 icon = FloatingText.DEFERRED;\n\t\t\tif (src instanceof Corruption)                              icon = FloatingText.CORRUPTION;\n\t\t\tif (src instanceof AscensionChallenge)                      icon = FloatingText.AMULET;\n\n\t\t\tsprite.showStatusWithIcon(CharSprite.NEGATIVE, Integer.toString(dmg + shielded), icon);\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int combatRoll(int min, int max ){\n\t\treturn Random.NormalIntRange( min, max );\n\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_669_851_595_597_675_857"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean act() {\n\t\t\n\t\tif (target.isAlive() && !target.isImmune(getClass())) {\n\t\t\t\n\t\t\tint damage = Random.NormalIntRange( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\tBuff.detach( target, Chill.class);\n\n\t\t\tif (target instanceof Hero && target.buff(TimekeepersHourglass.timeStasis.class) == null) {\n\t\t\t\t\n\t\t\t\tHero hero = (Hero)target;\n\n\t\t\t\thero.damage( damage, this );\n\t\t\t\tburnIncrement++;\n\n\t\t\t\t//at 4+ turns, there is a (turns-3)/3 chance an item burns\n\t\t\t\tif (Random.Int(3) < (burnIncrement - 3)){\n\t\t\t\t\tburnIncrement = 0;\n\n\t\t\t\t\tArrayList<Item> burnable = new ArrayList<>();\n\t\t\t\t\t//does not reach inside of containers\n\t\t\t\t\tif (!hero.belongings.lostInventory()) {\n\t\t\t\t\t\tfor (Item i : hero.belongings.backpack.items) {\n\t\t\t\t\t\t\tif (!i.unique && (i instanceof Scroll || i instanceof MysteryMeat || i instanceof FrozenCarpaccio)) {\n\t\t\t\t\t\t\t\tburnable.add(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!burnable.isEmpty()){\n\t\t\t\t\t\tItem toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n\t\t\t\t\t\tGLog.w( Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())) );\n\t\t\t\t\t\tif (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio){\n\t\t\t\t\t\t\tChargrilledMeat steak = new ChargrilledMeat();\n\t\t\t\t\t\t\tif (!steak.collect( hero.belongings.backpack )) {\n\t\t\t\t\t\t\t\tDungeon.level.drop( steak, hero.pos ).sprite.drop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHeap.burnFX( hero.pos );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\ttarget.damage( damage, this );\n\t\t\t}\n\n\t\t\tif (target instanceof Thief && ((Thief) target).item != null) {\n\n\t\t\t\tItem item = ((Thief) target).item;\n\n\t\t\t\tif (!item.unique && item instanceof Scroll) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = null;\n\t\t\t\t} else if (item instanceof MysteryMeat) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = new ChargrilledMeat();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tif (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n\t\t\tGameScene.add( Blob.seed( target.pos, 4, Fire.class ) );\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\tleft -= TICK;\n\t\t\n\t\tif (left <= 0 ||\n\t\t\t(Dungeon.level.water[target.pos] && !target.flying)) {\n\t\t\t\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean act() {\n\t\t\n\t\tif (target.isAlive() && !target.isImmune(getClass())) {\n\t\t\t\n\t\t\tint damage = Char.combatRoll( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\tBuff.detach( target, Chill.class);\n\n\t\t\tif (target instanceof Hero && target.buff(TimekeepersHourglass.timeStasis.class) == null) {\n\t\t\t\t\n\t\t\t\tHero hero = (Hero)target;\n\n\t\t\t\thero.damage( damage, this );\n\t\t\t\tburnIncrement++;\n\n\t\t\t\t//at 4+ turns, there is a (turns-3)/3 chance an item burns\n\t\t\t\tif (Random.Int(3) < (burnIncrement - 3)){\n\t\t\t\t\tburnIncrement = 0;\n\n\t\t\t\t\tArrayList<Item> burnable = new ArrayList<>();\n\t\t\t\t\t//does not reach inside of containers\n\t\t\t\t\tif (!hero.belongings.lostInventory()) {\n\t\t\t\t\t\tfor (Item i : hero.belongings.backpack.items) {\n\t\t\t\t\t\t\tif (!i.unique && (i instanceof Scroll || i instanceof MysteryMeat || i instanceof FrozenCarpaccio)) {\n\t\t\t\t\t\t\t\tburnable.add(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!burnable.isEmpty()){\n\t\t\t\t\t\tItem toBurn = Random.element(burnable).detach(hero.belongings.backpack);\n\t\t\t\t\t\tGLog.w( Messages.capitalize(Messages.get(this, \"burnsup\", toBurn.title())) );\n\t\t\t\t\t\tif (toBurn instanceof MysteryMeat || toBurn instanceof FrozenCarpaccio){\n\t\t\t\t\t\t\tChargrilledMeat steak = new ChargrilledMeat();\n\t\t\t\t\t\t\tif (!steak.collect( hero.belongings.backpack )) {\n\t\t\t\t\t\t\t\tDungeon.level.drop( steak, hero.pos ).sprite.drop();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tHeap.burnFX( hero.pos );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\ttarget.damage( damage, this );\n\t\t\t}\n\n\t\t\tif (target instanceof Thief && ((Thief) target).item != null) {\n\n\t\t\t\tItem item = ((Thief) target).item;\n\n\t\t\t\tif (!item.unique && item instanceof Scroll) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = null;\n\t\t\t\t} else if (item instanceof MysteryMeat) {\n\t\t\t\t\ttarget.sprite.emitter().burst( ElmoParticle.FACTORY, 6 );\n\t\t\t\t\t((Thief)target).item = new ChargrilledMeat();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tif (Dungeon.level.flamable[target.pos] && Blob.volumeAt(target.pos, Fire.class) == 0) {\n\t\t\tGameScene.add( Blob.seed( target.pos, 4, Fire.class ) );\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\tleft -= TICK;\n\t\t\n\t\tif (left <= 0 ||\n\t\t\t(Dungeon.level.water[target.pos] && !target.flying)) {\n\t\t\t\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_89_168_595_597_89_168"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int armorBonus(){\n\t\tif (pos == target.pos && target instanceof Hero){\n\t\t\treturn Random.NormalIntRange(0, 2* ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n\t\t} else {\n\t\t\tdetach();\n\t\t\treturn 0;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public int armorBonus(){\n\t\tif (pos == target.pos && target instanceof Hero){\n\t\t\treturn Char.combatRoll(0, 2* ((Hero) target).pointsInTalent(Talent.HOLD_FAST));\n\t\t} else {\n\t\t\tdetach();\n\t\t\treturn 0;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_58_595_597_51_58"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\tint dr = super.drRoll();\n\n\t\tif (belongings.armor() != null) {\n\t\t\tint armDr = Random.NormalIntRange( belongings.armor().DRMin(), belongings.armor().DRMax());\n\t\t\tif (STR() < belongings.armor().STRReq()){\n\t\t\t\tarmDr -= 2*(belongings.armor().STRReq() - STR());\n\t\t\t}\n\t\t\tif (armDr > 0) dr += armDr;\n\t\t}\n\t\tif (belongings.weapon() != null && !RingOfForce.fightingUnarmed(this))  {\n\t\t\tint wepDr = Random.NormalIntRange( 0 , belongings.weapon().defenseFactor( this ) );\n\t\t\tif (STR() < ((Weapon)belongings.weapon()).STRReq()){\n\t\t\t\twepDr -= 2*(((Weapon)belongings.weapon()).STRReq() - STR());\n\t\t\t}\n\t\t\tif (wepDr > 0) dr += wepDr;\n\t\t}\n\n\t\tif (buff(HoldFast.class) != null){\n\t\t\tdr += buff(HoldFast.class).armorBonus();\n\t\t}\n\t\t\n\t\treturn dr;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\tint dr = super.drRoll();\n\n\t\tif (belongings.armor() != null) {\n\t\t\tint armDr = Char.combatRoll( belongings.armor().DRMin(), belongings.armor().DRMax());\n\t\t\tif (STR() < belongings.armor().STRReq()){\n\t\t\t\tarmDr -= 2*(belongings.armor().STRReq() - STR());\n\t\t\t}\n\t\t\tif (armDr > 0) dr += armDr;\n\t\t}\n\t\tif (belongings.weapon() != null && !RingOfForce.fightingUnarmed(this))  {\n\t\t\tint wepDr = Char.combatRoll( 0 , belongings.weapon().defenseFactor( this ) );\n\t\t\tif (STR() < ((Weapon)belongings.weapon()).STRReq()){\n\t\t\t\twepDr -= 2*(((Weapon)belongings.weapon()).STRReq() - STR());\n\t\t\t}\n\t\t\tif (wepDr > 0) dr += wepDr;\n\t\t}\n\n\t\tif (buff(HoldFast.class) != null){\n\t\t\tdr += buff(HoldFast.class).armorBonus();\n\t\t}\n\t\t\n\t\treturn dr;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n} else {\n\t\t\tdmg = RingOfForce.damageRoll(this);\n\t\t\tif (RingOfForce.unarmedGetsWeaponAugment(this)){",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_560_584_595_597_560_584"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void perCharEffect(ConeAOE cone, Hero hero, Char primaryTarget, Weapon.Enchantment ench) {\n\n\t\tfloat powerMulti = 1f + 0.30f * Dungeon.hero.pointsInTalent(Talent.STRIKING_FORCE);\n\n\t\tArrayList<Char> affected = new ArrayList<>();\n\n\t\tfor (Char ch : Actor.chars()) {\n\t\t\tif (ch.alignment != Char.Alignment.ALLY && cone.cells.contains(ch.pos)) {\n\t\t\t\taffected.add(ch);\n\t\t\t}\n\t\t}\n\n\t\t//*** no enchantment ***\n\t\tif (ench == null) {\n\t\t\tfor (Char ch : affected){\n\t\t\t\tch.damage(Math.round(powerMulti*Random.NormalIntRange(6, 12)), ElementalStrike.this);\n\t\t\t}\n\n\t\t//*** Kinetic ***\n\t\t} else if (ench instanceof Kinetic){\n\t\t\tif (storedKineticDamage > 0) {\n\t\t\t\tfor (Char ch : affected) {\n\t\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\t\tch.damage(Math.round(storedKineticDamage * 0.4f * powerMulti), ench);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstoredKineticDamage = 0;\n\t\t\t}\n\t\t\t//clear stored damage if there was no primary target\n\t\t\tif (primaryTarget == null && hero.buff(Kinetic.ConservedDamage.class) != null){\n\t\t\t\thero.buff(Kinetic.ConservedDamage.class).detach();\n\t\t\t}\n\n\t\t//*** Blooming ***\n\t\t} else if (ench instanceof Blooming){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tBuff.affect(ch, Roots.class, Math.round(6f*powerMulti));\n\t\t\t}\n\n\t\t//*** Elastic ***\n\t\t} else if (ench instanceof Elastic){\n\n\t\t\t//sorts affected from furthest to closest\n\t\t\tCollections.sort(affected, new Comparator<Char>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Char a, Char b) {\n\t\t\t\t\treturn Dungeon.level.distance(hero.pos, a.pos) - Dungeon.level.distance(hero.pos, b.pos);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch == primaryTarget && oldEnemyPos != primaryTarget.pos) continue;\n\n\t\t\t\tBallistica aim = new Ballistica(hero.pos, ch.pos, Ballistica.WONT_STOP);\n\t\t\t\tint knockback = Math.round(5*powerMulti);\n\t\t\t\tWandOfBlastWave.throwChar(ch,\n\t\t\t\t\t\tnew Ballistica(ch.pos, aim.collisionPos, Ballistica.MAGIC_BOLT),\n\t\t\t\t\t\tknockback,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tElementalStrike.this);\n\t\t\t}\n\n\t\t//*** Lucky ***\n\t\t} else if (ench instanceof Lucky){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY\n\t\t\t\t\t\t&& Random.Float() < 0.125f*powerMulti\n\t\t\t\t\t\t&& ch.buff(ElementalStrikeLuckyTracker.class) == null) {\n\t\t\t\t\tDungeon.level.drop(Lucky.genLoot(), ch.pos).sprite.drop();\n\t\t\t\t\tLucky.showFlare(ch.sprite);\n\t\t\t\t\tBuff.affect(ch, ElementalStrikeLuckyTracker.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Projecting ***\n\t\t} else if (ench instanceof Projecting){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\tch.damage(Math.round(hero.damageRoll() * 0.3f * powerMulti), ench);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Unstable ***\n\t\t} else if (ench instanceof Unstable){\n\t\t\tKindOfWeapon w = hero.belongings.weapon();\n\t\t\tif (w instanceof Weapon) {\n\t\t\t\tfor (Char ch : affected){\n\t\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\t\tench.proc((Weapon) w, hero, ch, w.damageRoll(hero));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Corrupting ***\n\t\t} else if (ench instanceof Corrupting){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget\n\t\t\t\t\t\t&& !ch.isImmune(Corruption.class)\n\t\t\t\t\t\t&& ch.buff(Corruption.class) == null\n\t\t\t\t\t\t&& ch instanceof Mob\n\t\t\t\t\t\t&& ch.isAlive()) {\n\t\t\t\t\tfloat hpMissing = 1f - (ch.HP / (float)ch.HT);\n\t\t\t\t\tfloat chance = 0.05f + 0.2f*hpMissing; //5-25%\n\t\t\t\t\tif (Random.Float() < chance*powerMulti){\n\t\t\t\t\t\tCorruption.corruptionHeal(ch);\n\t\t\t\t\t\tAllyBuff.affectAndLoot((Mob) ch, hero, Corruption.class);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Grim ***\n\t\t} else if (ench instanceof Grim){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\tfloat hpMissing = 1f - (ch.HP / (float)ch.HT);\n\t\t\t\t\tfloat chance = 0.06f + 0.24f*hpMissing; //6-30%\n\t\t\t\t\tif (Random.Float() < chance*powerMulti){\n\t\t\t\t\t\tch.damage( ch.HP, Grim.class );\n\t\t\t\t\t\tch.sprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Annoying ***\n\t\t} else if (ench instanceof Annoying){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.2f*powerMulti){\n\t\t\t\t\t//TODO totally should add a bit of dialogue here\n\t\t\t\t\tBuff.affect(ch, Amok.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Displacing ***\n\t\t} else if (ench instanceof Displacing){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tint oldpos = ch.pos;\n\t\t\t\t\tif (ScrollOfTeleportation.teleportChar(ch)){\n\t\t\t\t\t\tif (Dungeon.level.heroFOV[oldpos]) {\n\t\t\t\t\t\t\tCellEmitter.get( oldpos ).start( Speck.factory( Speck.LIGHT ), 0.2f, 3 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ch instanceof Mob && ((Mob) ch).state == ((Mob) ch).HUNTING){\n\t\t\t\t\t\t\t((Mob) ch).state = ((Mob) ch).WANDERING;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Dazzling ***\n\t\t} else if (ench instanceof Dazzling){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Blindness.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Explosive ***\n\t\t} else if (ench instanceof Explosive){\n\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\tChar exploding = Random.element(affected);\n\t\t\t\tif (exploding != null) new Bomb.ConjuredBomb().explode(exploding.pos);\n\t\t\t}\n\n\t\t//*** Sacrificial ***\n\t\t} else if (ench instanceof Sacrificial){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tBuff.affect(ch, Bleeding.class).set(12f*powerMulti);\n\t\t\t}\n\n\t\t//*** Wayward ***\n\t\t} else if (ench instanceof Wayward){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Hex.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Polarized ***\n\t\t} else if (ench instanceof Polarized){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tch.damage(Random.NormalIntRange(24, 36), ElementalStrike.this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Friendly ***\n\t\t} else if (ench instanceof Friendly){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Charm.class, 6f).object = hero.id();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "private void perCharEffect(ConeAOE cone, Hero hero, Char primaryTarget, Weapon.Enchantment ench) {\n\n\t\tfloat powerMulti = 1f + 0.30f * Dungeon.hero.pointsInTalent(Talent.STRIKING_FORCE);\n\n\t\tArrayList<Char> affected = new ArrayList<>();\n\n\t\tfor (Char ch : Actor.chars()) {\n\t\t\tif (ch.alignment != Char.Alignment.ALLY && cone.cells.contains(ch.pos)) {\n\t\t\t\taffected.add(ch);\n\t\t\t}\n\t\t}\n\n\t\t//*** no enchantment ***\n\t\tif (ench == null) {\n\t\t\tfor (Char ch : affected){\n\t\t\t\tch.damage(Math.round(powerMulti* Char.combatRoll(6, 12)), ElementalStrike.this);\n\t\t\t}\n\n\t\t//*** Kinetic ***\n\t\t} else if (ench instanceof Kinetic){\n\t\t\tif (storedKineticDamage > 0) {\n\t\t\t\tfor (Char ch : affected) {\n\t\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\t\tch.damage(Math.round(storedKineticDamage * 0.4f * powerMulti), ench);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstoredKineticDamage = 0;\n\t\t\t}\n\t\t\t//clear stored damage if there was no primary target\n\t\t\tif (primaryTarget == null && hero.buff(Kinetic.ConservedDamage.class) != null){\n\t\t\t\thero.buff(Kinetic.ConservedDamage.class).detach();\n\t\t\t}\n\n\t\t//*** Blooming ***\n\t\t} else if (ench instanceof Blooming){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tBuff.affect(ch, Roots.class, Math.round(6f*powerMulti));\n\t\t\t}\n\n\t\t//*** Elastic ***\n\t\t} else if (ench instanceof Elastic){\n\n\t\t\t//sorts affected from furthest to closest\n\t\t\tCollections.sort(affected, new Comparator<Char>() {\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Char a, Char b) {\n\t\t\t\t\treturn Dungeon.level.distance(hero.pos, a.pos) - Dungeon.level.distance(hero.pos, b.pos);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch == primaryTarget && oldEnemyPos != primaryTarget.pos) continue;\n\n\t\t\t\tBallistica aim = new Ballistica(hero.pos, ch.pos, Ballistica.WONT_STOP);\n\t\t\t\tint knockback = Math.round(5*powerMulti);\n\t\t\t\tWandOfBlastWave.throwChar(ch,\n\t\t\t\t\t\tnew Ballistica(ch.pos, aim.collisionPos, Ballistica.MAGIC_BOLT),\n\t\t\t\t\t\tknockback,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\tElementalStrike.this);\n\t\t\t}\n\n\t\t//*** Lucky ***\n\t\t} else if (ench instanceof Lucky){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY\n\t\t\t\t\t\t&& Random.Float() < 0.125f*powerMulti\n\t\t\t\t\t\t&& ch.buff(ElementalStrikeLuckyTracker.class) == null) {\n\t\t\t\t\tDungeon.level.drop(Lucky.genLoot(), ch.pos).sprite.drop();\n\t\t\t\t\tLucky.showFlare(ch.sprite);\n\t\t\t\t\tBuff.affect(ch, ElementalStrikeLuckyTracker.class);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Projecting ***\n\t\t} else if (ench instanceof Projecting){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\tch.damage(Math.round(hero.damageRoll() * 0.3f * powerMulti), ench);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Unstable ***\n\t\t} else if (ench instanceof Unstable){\n\t\t\tKindOfWeapon w = hero.belongings.weapon();\n\t\t\tif (w instanceof Weapon) {\n\t\t\t\tfor (Char ch : affected){\n\t\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\t\tench.proc((Weapon) w, hero, ch, w.damageRoll(hero));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Corrupting ***\n\t\t} else if (ench instanceof Corrupting){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget\n\t\t\t\t\t\t&& !ch.isImmune(Corruption.class)\n\t\t\t\t\t\t&& ch.buff(Corruption.class) == null\n\t\t\t\t\t\t&& ch instanceof Mob\n\t\t\t\t\t\t&& ch.isAlive()) {\n\t\t\t\t\tfloat hpMissing = 1f - (ch.HP / (float)ch.HT);\n\t\t\t\t\tfloat chance = 0.05f + 0.2f*hpMissing; //5-25%\n\t\t\t\t\tif (Random.Float() < chance*powerMulti){\n\t\t\t\t\t\tCorruption.corruptionHeal(ch);\n\t\t\t\t\t\tAllyBuff.affectAndLoot((Mob) ch, hero, Corruption.class);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Grim ***\n\t\t} else if (ench instanceof Grim){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (ch != primaryTarget) {\n\t\t\t\t\tfloat hpMissing = 1f - (ch.HP / (float)ch.HT);\n\t\t\t\t\tfloat chance = 0.06f + 0.24f*hpMissing; //6-30%\n\t\t\t\t\tif (Random.Float() < chance*powerMulti){\n\t\t\t\t\t\tch.damage( ch.HP, Grim.class );\n\t\t\t\t\t\tch.sprite.emitter().burst( ShadowParticle.UP, 5 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Annoying ***\n\t\t} else if (ench instanceof Annoying){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.2f*powerMulti){\n\t\t\t\t\t//TODO totally should add a bit of dialogue here\n\t\t\t\t\tBuff.affect(ch, Amok.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Displacing ***\n\t\t} else if (ench instanceof Displacing){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tint oldpos = ch.pos;\n\t\t\t\t\tif (ScrollOfTeleportation.teleportChar(ch)){\n\t\t\t\t\t\tif (Dungeon.level.heroFOV[oldpos]) {\n\t\t\t\t\t\t\tCellEmitter.get( oldpos ).start( Speck.factory( Speck.LIGHT ), 0.2f, 3 );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ch instanceof Mob && ((Mob) ch).state == ((Mob) ch).HUNTING){\n\t\t\t\t\t\t\t((Mob) ch).state = ((Mob) ch).WANDERING;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Dazzling ***\n\t\t} else if (ench instanceof Dazzling){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Blindness.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Explosive ***\n\t\t} else if (ench instanceof Explosive){\n\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\tChar exploding = Random.element(affected);\n\t\t\t\tif (exploding != null) new Bomb.ConjuredBomb().explode(exploding.pos);\n\t\t\t}\n\n\t\t//*** Sacrificial ***\n\t\t} else if (ench instanceof Sacrificial){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tBuff.affect(ch, Bleeding.class).set(12f*powerMulti);\n\t\t\t}\n\n\t\t//*** Wayward ***\n\t\t} else if (ench instanceof Wayward){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Hex.class, 6f);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Polarized ***\n\t\t} else if (ench instanceof Polarized){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tch.damage(Char.combatRoll(24, 36), ElementalStrike.this);\n\t\t\t\t}\n\t\t\t}\n\n\t\t//*** Friendly ***\n\t\t} else if (ench instanceof Friendly){\n\t\t\tfor (Char ch : affected){\n\t\t\t\tif (Random.Float() < 0.5f*powerMulti){\n\t\t\t\t\tBuff.affect(ch, Charm.class, 6f).object = hero.id();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_358_554_595_597_358_554"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Random.NormalIntRange(5, 10);\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Char.combatRoll(5, 10);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_178_181_595_597_178_181"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void activate(ClassArmor armor, Hero hero, Integer target) {\n\t\tif (target == null){\n\t\t\treturn;\n\t\t}\n\n\t\tif (hero.buff(WarpBeaconTracker.class) != null){\n\t\t\tfinal WarpBeaconTracker tracker = hero.buff(WarpBeaconTracker.class);\n\n\t\t\tGameScene.show( new WndOptions(\n\t\t\t\t\tnew Image(hero.sprite),\n\t\t\t\t\tMessages.titleCase(name()),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_desc\", tracker.depth),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_tele\"),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_clear\"),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_cancel\")){\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\tif (index == 0){\n\n\t\t\t\t\t\tif (tracker.depth != Dungeon.depth && !hero.hasTalent(Talent.LONGRANGE_WARP)){\n\t\t\t\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"depths\") );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfloat chargeNeeded = chargeUse(hero);\n\n\t\t\t\t\t\tif (tracker.depth != Dungeon.depth){\n\t\t\t\t\t\t\tchargeNeeded *= 1.833f - 0.333f*Dungeon.hero.pointsInTalent(Talent.LONGRANGE_WARP);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (armor.charge < chargeNeeded){\n\t\t\t\t\t\t\tGLog.w( Messages.get(ClassArmor.class, \"low_charge\") );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarmor.charge -= chargeNeeded;\n\t\t\t\t\t\tarmor.updateQuickslot();\n\n\t\t\t\t\t\tif (tracker.depth == Dungeon.depth && tracker.branch == Dungeon.branch){\n\t\t\t\t\t\t\tChar existing = Actor.findChar(tracker.pos);\n\n\t\t\t\t\t\t\tif (existing != null && existing != hero){\n\t\t\t\t\t\t\t\tif (hero.hasTalent(Talent.TELEFRAG)){\n\t\t\t\t\t\t\t\t\tint heroHP = hero.HP + hero.shielding();\n\t\t\t\t\t\t\t\t\tint heroDmg = 5 * hero.pointsInTalent(Talent.TELEFRAG);\n\t\t\t\t\t\t\t\t\thero.damage(Math.min(heroDmg, heroHP-1), WarpBeacon.this);\n\n\t\t\t\t\t\t\t\t\tint damage = Random.NormalIntRange(10*hero.pointsInTalent(Talent.TELEFRAG), 15*hero.pointsInTalent(Talent.TELEFRAG));\n\t\t\t\t\t\t\t\t\texisting.sprite.flash();\n\t\t\t\t\t\t\t\t\texisting.sprite.bloodBurstA(existing.sprite.center(), damage);\n\t\t\t\t\t\t\t\t\texisting.damage(damage, WarpBeacon.this);\n\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_CRUSH);\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (existing.isAlive()){\n\t\t\t\t\t\t\t\t\tChar toPush = Char.hasProp(existing, Char.Property.IMMOVABLE) ? hero : existing;\n\n\t\t\t\t\t\t\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\t\t\t\t\t\t\t\t\tfor (int n : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\t\t\t\t\tint cell = tracker.pos + n;\n\t\t\t\t\t\t\t\t\t\tif (!Dungeon.level.solid[cell] && Actor.findChar( cell ) == null\n\t\t\t\t\t\t\t\t\t\t\t\t&& (!Char.hasProp(toPush, Char.Property.LARGE) || Dungeon.level.openSpace[cell])) {\n\t\t\t\t\t\t\t\t\t\t\tcandidates.add( cell );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tRandom.shuffle(candidates);\n\n\t\t\t\t\t\t\t\t\tif (!candidates.isEmpty()){\n\t\t\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t\t\t\tActor.add( new Pushing( toPush, toPush.pos, candidates.get(0) ));\n\n\t\t\t\t\t\t\t\t\t\ttoPush.pos = candidates.get(0);\n\t\t\t\t\t\t\t\t\t\tDungeon.level.occupyCell(toPush);\n\t\t\t\t\t\t\t\t\t\thero.next();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\tDungeon.observe();\n\t\t\t\t\t\t\tGameScene.updateFog();\n\t\t\t\t\t\t\thero.checkVisibleMobs();\n\t\t\t\t\t\t\tAttackIndicator.updateState();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (!Dungeon.interfloorTeleportAllowed()){\n\t\t\t\t\t\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//transition before dispel, to cancel out trap effects\n\t\t\t\t\t\t\tLevel.beforeTransition();\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.RETURN;\n\t\t\t\t\t\t\tInterlevelScene.returnDepth = tracker.depth;\n\t\t\t\t\t\t\tInterlevelScene.returnBranch = tracker.branch;\n\t\t\t\t\t\t\tInterlevelScene.returnPos = tracker.pos;\n\t\t\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (index == 1){\n\t\t\t\t\t\thero.buff(WarpBeaconTracker.class).detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t} else {\n\t\t\tif (!Dungeon.level.mapped[target] && !Dungeon.level.visited[target]){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Dungeon.level.distance(hero.pos, target) > 4*hero.pointsInTalent(Talent.REMOTE_BEACON)){\n\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"too_far\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPathFinder.buildDistanceMap(target, BArray.or(Dungeon.level.passable, Dungeon.level.avoid, null));\n\t\t\tif (Dungeon.level.pit[target] ||\n\t\t\t\t\t(Dungeon.level.solid[target] && !Dungeon.level.passable[target]) ||\n\t\t\t\t\t!(Dungeon.level.passable[target] || Dungeon.level.avoid[target]) ||\n\t\t\t\t\tPathFinder.distance[hero.pos] == Integer.MAX_VALUE){\n\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"invalid_beacon\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tWarpBeaconTracker tracker = new WarpBeaconTracker();\n\t\t\ttracker.pos = target;\n\t\t\ttracker.depth = Dungeon.depth;\n\t\t\ttracker.branch = Dungeon.branch;\n\t\t\ttracker.attachTo(hero);\n\n\t\t\thero.sprite.operate(target);\n\t\t\tSample.INSTANCE.play(Assets.Sounds.TELEPORT);\n\t\t\tInvisibility.dispel();\n\t\t\thero.spendAndNext(Actor.TICK);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void activate(ClassArmor armor, Hero hero, Integer target) {\n\t\tif (target == null){\n\t\t\treturn;\n\t\t}\n\n\t\tif (hero.buff(WarpBeaconTracker.class) != null){\n\t\t\tfinal WarpBeaconTracker tracker = hero.buff(WarpBeaconTracker.class);\n\n\t\t\tGameScene.show( new WndOptions(\n\t\t\t\t\tnew Image(hero.sprite),\n\t\t\t\t\tMessages.titleCase(name()),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_desc\", tracker.depth),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_tele\"),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_clear\"),\n\t\t\t\t\tMessages.get(WarpBeacon.class, \"window_cancel\")){\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\tif (index == 0){\n\n\t\t\t\t\t\tif (tracker.depth != Dungeon.depth && !hero.hasTalent(Talent.LONGRANGE_WARP)){\n\t\t\t\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"depths\") );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfloat chargeNeeded = chargeUse(hero);\n\n\t\t\t\t\t\tif (tracker.depth != Dungeon.depth){\n\t\t\t\t\t\t\tchargeNeeded *= 1.833f - 0.333f*Dungeon.hero.pointsInTalent(Talent.LONGRANGE_WARP);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (armor.charge < chargeNeeded){\n\t\t\t\t\t\t\tGLog.w( Messages.get(ClassArmor.class, \"low_charge\") );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarmor.charge -= chargeNeeded;\n\t\t\t\t\t\tarmor.updateQuickslot();\n\n\t\t\t\t\t\tif (tracker.depth == Dungeon.depth && tracker.branch == Dungeon.branch){\n\t\t\t\t\t\t\tChar existing = Actor.findChar(tracker.pos);\n\n\t\t\t\t\t\t\tif (existing != null && existing != hero){\n\t\t\t\t\t\t\t\tif (hero.hasTalent(Talent.TELEFRAG)){\n\t\t\t\t\t\t\t\t\tint heroHP = hero.HP + hero.shielding();\n\t\t\t\t\t\t\t\t\tint heroDmg = 5 * hero.pointsInTalent(Talent.TELEFRAG);\n\t\t\t\t\t\t\t\t\thero.damage(Math.min(heroDmg, heroHP-1), WarpBeacon.this);\n\n\t\t\t\t\t\t\t\t\tint damage = Char.combatRoll(10*hero.pointsInTalent(Talent.TELEFRAG), 15*hero.pointsInTalent(Talent.TELEFRAG));\n\t\t\t\t\t\t\t\t\texisting.sprite.flash();\n\t\t\t\t\t\t\t\t\texisting.sprite.bloodBurstA(existing.sprite.center(), damage);\n\t\t\t\t\t\t\t\t\texisting.damage(damage, WarpBeacon.this);\n\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_CRUSH);\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (existing.isAlive()){\n\t\t\t\t\t\t\t\t\tChar toPush = Char.hasProp(existing, Char.Property.IMMOVABLE) ? hero : existing;\n\n\t\t\t\t\t\t\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\t\t\t\t\t\t\t\t\tfor (int n : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\t\t\t\t\tint cell = tracker.pos + n;\n\t\t\t\t\t\t\t\t\t\tif (!Dungeon.level.solid[cell] && Actor.findChar( cell ) == null\n\t\t\t\t\t\t\t\t\t\t\t\t&& (!Char.hasProp(toPush, Char.Property.LARGE) || Dungeon.level.openSpace[cell])) {\n\t\t\t\t\t\t\t\t\t\t\tcandidates.add( cell );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tRandom.shuffle(candidates);\n\n\t\t\t\t\t\t\t\t\tif (!candidates.isEmpty()){\n\t\t\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t\t\t\tActor.add( new Pushing( toPush, toPush.pos, candidates.get(0) ));\n\n\t\t\t\t\t\t\t\t\t\ttoPush.pos = candidates.get(0);\n\t\t\t\t\t\t\t\t\t\tDungeon.level.occupyCell(toPush);\n\t\t\t\t\t\t\t\t\t\thero.next();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tScrollOfTeleportation.appear(hero, tracker.pos);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\tDungeon.observe();\n\t\t\t\t\t\t\tGameScene.updateFog();\n\t\t\t\t\t\t\thero.checkVisibleMobs();\n\t\t\t\t\t\t\tAttackIndicator.updateState();\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (!Dungeon.interfloorTeleportAllowed()){\n\t\t\t\t\t\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//transition before dispel, to cancel out trap effects\n\t\t\t\t\t\t\tLevel.beforeTransition();\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.RETURN;\n\t\t\t\t\t\t\tInterlevelScene.returnDepth = tracker.depth;\n\t\t\t\t\t\t\tInterlevelScene.returnBranch = tracker.branch;\n\t\t\t\t\t\t\tInterlevelScene.returnPos = tracker.pos;\n\t\t\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (index == 1){\n\t\t\t\t\t\thero.buff(WarpBeaconTracker.class).detach();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t} else {\n\t\t\tif (!Dungeon.level.mapped[target] && !Dungeon.level.visited[target]){\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Dungeon.level.distance(hero.pos, target) > 4*hero.pointsInTalent(Talent.REMOTE_BEACON)){\n\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"too_far\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPathFinder.buildDistanceMap(target, BArray.or(Dungeon.level.passable, Dungeon.level.avoid, null));\n\t\t\tif (Dungeon.level.pit[target] ||\n\t\t\t\t\t(Dungeon.level.solid[target] && !Dungeon.level.passable[target]) ||\n\t\t\t\t\t!(Dungeon.level.passable[target] || Dungeon.level.avoid[target]) ||\n\t\t\t\t\tPathFinder.distance[hero.pos] == Integer.MAX_VALUE){\n\t\t\t\tGLog.w( Messages.get(WarpBeacon.class, \"invalid_beacon\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tWarpBeaconTracker tracker = new WarpBeaconTracker();\n\t\t\ttracker.pos = target;\n\t\t\ttracker.depth = Dungeon.depth;\n\t\t\ttracker.branch = Dungeon.branch;\n\t\t\ttracker.attachTo(hero);\n\n\t\t\thero.sprite.operate(target);\n\t\t\tSample.INSTANCE.play(Assets.Sounds.TELEPORT);\n\t\t\tInvisibility.dispel();\n\t\t\thero.spendAndNext(Actor.TICK);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_77_224_595_597_77_224"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tint damage = Random.NormalIntRange(10, 20);\n\t\t\tint heroDamage = Dungeon.hero.damageRoll();\n\t\t\theroDamage /= Dungeon.hero.attackDelay(); //normalize hero damage based on atk speed\n\t\t\theroDamage = Math.round(0.08f * Dungeon.hero.pointsInTalent(Talent.SHADOW_BLADE) * heroDamage);\n\t\t\tif (heroDamage > 0){\n\t\t\t\tdamage += heroDamage;\n\t\t\t}\n\t\t\treturn damage;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tint damage = Char.combatRoll(10, 20);\n\t\t\tint heroDamage = Dungeon.hero.damageRoll();\n\t\t\theroDamage /= Dungeon.hero.attackDelay(); //normalize hero damage based on atk speed\n\t\t\theroDamage = Math.round(0.08f * Dungeon.hero.pointsInTalent(Talent.SHADOW_BLADE) * heroDamage);\n\t\t\tif (heroDamage > 0){\n\t\t\t\tdamage += heroDamage;\n\t\t\t}\n\t\t\treturn damage;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_206_216_595_597_206_216"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\n\t\t\tdr += Random.NormalIntRange(Dungeon.hero.pointsInTalent(Talent.BODY_REPLACEMENT),\n\t\t\t\t\t3*Dungeon.hero.pointsInTalent(Talent.BODY_REPLACEMENT));\n\n\t\t\treturn dr;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\n\t\t\tdr += Char.combatRoll(Dungeon.hero.pointsInTalent(Talent.BODY_REPLACEMENT),\n\t\t\t\t\t3*Dungeon.hero.pointsInTalent(Talent.BODY_REPLACEMENT));\n\n\t\t\treturn dr;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_178_186_595_597_177_185"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate( ClassArmor armor, Hero hero, Integer target ) {\n\t\tif (target != null) {\n\n\t\t\tif (hero.rooted){\n\t\t\t\tPixelScene.shake( 1, 1f );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBallistica route = new Ballistica(hero.pos, target, Ballistica.STOP_TARGET | Ballistica.STOP_SOLID);\n\t\t\tint cell = route.collisionPos;\n\n\t\t\t//can't occupy the same cell as another char, so move back one.\n\t\t\tint backTrace = route.dist-1;\n\t\t\twhile (Actor.findChar( cell ) != null && cell != hero.pos) {\n\t\t\t\tcell = route.path.get(backTrace);\n\t\t\t\tbackTrace--;\n\t\t\t}\n\n\t\t\tarmor.charge -= chargeUse( hero );\n\t\t\tarmor.updateQuickslot();\n\n\t\t\tfinal int dest = cell;\n\t\t\thero.busy();\n\t\t\thero.sprite.jump(hero.pos, cell, new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\thero.move(dest);\n\t\t\t\t\tDungeon.level.occupyCell(hero);\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t\tGameScene.updateFog();\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\tChar mob = Actor.findChar(hero.pos + i);\n\t\t\t\t\t\tif (mob != null && mob != hero && mob.alignment != Char.Alignment.ALLY) {\n\t\t\t\t\t\t\tif (hero.hasTalent(Talent.BODY_SLAM)){\n\t\t\t\t\t\t\t\tint damage = Random.NormalIntRange(hero.pointsInTalent(Talent.BODY_SLAM), 4*hero.pointsInTalent(Talent.BODY_SLAM));\n\t\t\t\t\t\t\t\tdamage += Math.round(hero.drRoll()*0.25f*hero.pointsInTalent(Talent.BODY_SLAM));\n\t\t\t\t\t\t\t\tdamage -= mob.drRoll();\n\t\t\t\t\t\t\t\tmob.damage(damage, hero);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mob.pos == hero.pos + i && hero.hasTalent(Talent.IMPACT_WAVE)){\n\t\t\t\t\t\t\t\tBallistica trajectory = new Ballistica(mob.pos, mob.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\t\t\t\tint strength = 1+hero.pointsInTalent(Talent.IMPACT_WAVE);\n\t\t\t\t\t\t\t\tWandOfBlastWave.throwChar(mob, trajectory, strength, true, true, HeroicLeap.this);\n\t\t\t\t\t\t\t\tif (Random.Int(4) < hero.pointsInTalent(Talent.IMPACT_WAVE)){\n\t\t\t\t\t\t\t\t\tBuff.prolong(mob, Vulnerable.class, 5f);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tWandOfBlastWave.BlastWave.blast(dest);\n\t\t\t\t\tPixelScene.shake(2, 0.5f);\n\n\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\thero.spendAndNext(Actor.TICK);\n\n\t\t\t\t\tif (hero.buff(DoubleJumpTracker.class) != null){\n\t\t\t\t\t\thero.buff(DoubleJumpTracker.class).detach();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (hero.hasTalent(Talent.DOUBLE_JUMP)) {\n\t\t\t\t\t\t\tBuff.affect(hero, DoubleJumpTracker.class, 3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate( ClassArmor armor, Hero hero, Integer target ) {\n\t\tif (target != null) {\n\n\t\t\tif (hero.rooted){\n\t\t\t\tPixelScene.shake( 1, 1f );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tBallistica route = new Ballistica(hero.pos, target, Ballistica.STOP_TARGET | Ballistica.STOP_SOLID);\n\t\t\tint cell = route.collisionPos;\n\n\t\t\t//can't occupy the same cell as another char, so move back one.\n\t\t\tint backTrace = route.dist-1;\n\t\t\twhile (Actor.findChar( cell ) != null && cell != hero.pos) {\n\t\t\t\tcell = route.path.get(backTrace);\n\t\t\t\tbackTrace--;\n\t\t\t}\n\n\t\t\tarmor.charge -= chargeUse( hero );\n\t\t\tarmor.updateQuickslot();\n\n\t\t\tfinal int dest = cell;\n\t\t\thero.busy();\n\t\t\thero.sprite.jump(hero.pos, cell, new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\thero.move(dest);\n\t\t\t\t\tDungeon.level.occupyCell(hero);\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t\tGameScene.updateFog();\n\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\tChar mob = Actor.findChar(hero.pos + i);\n\t\t\t\t\t\tif (mob != null && mob != hero && mob.alignment != Char.Alignment.ALLY) {\n\t\t\t\t\t\t\tif (hero.hasTalent(Talent.BODY_SLAM)){\n\t\t\t\t\t\t\t\tint damage = Char.combatRoll(hero.pointsInTalent(Talent.BODY_SLAM), 4*hero.pointsInTalent(Talent.BODY_SLAM));\n\t\t\t\t\t\t\t\tdamage += Math.round(hero.drRoll()*0.25f*hero.pointsInTalent(Talent.BODY_SLAM));\n\t\t\t\t\t\t\t\tdamage -= mob.drRoll();\n\t\t\t\t\t\t\t\tmob.damage(damage, hero);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (mob.pos == hero.pos + i && hero.hasTalent(Talent.IMPACT_WAVE)){\n\t\t\t\t\t\t\t\tBallistica trajectory = new Ballistica(mob.pos, mob.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\t\t\t\tint strength = 1+hero.pointsInTalent(Talent.IMPACT_WAVE);\n\t\t\t\t\t\t\t\tWandOfBlastWave.throwChar(mob, trajectory, strength, true, true, HeroicLeap.this);\n\t\t\t\t\t\t\t\tif (Random.Int(4) < hero.pointsInTalent(Talent.IMPACT_WAVE)){\n\t\t\t\t\t\t\t\t\tBuff.prolong(mob, Vulnerable.class, 5f);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tWandOfBlastWave.BlastWave.blast(dest);\n\t\t\t\t\tPixelScene.shake(2, 0.5f);\n\n\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\thero.spendAndNext(Actor.TICK);\n\n\t\t\t\t\tif (hero.buff(DoubleJumpTracker.class) != null){\n\t\t\t\t\t\thero.buff(DoubleJumpTracker.class).detach();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (hero.hasTalent(Talent.DOUBLE_JUMP)) {\n\t\t\t\t\t\t\tBuff.affect(hero, DoubleJumpTracker.class, 3);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_66_134_595_597_66_134"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange( armor.DRMin(), armor.DRMax());\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll( armor.DRMin(), armor.DRMax());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_76_79_595_597_75_78"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 5, 18 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 5, 18 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_54_595_597_50_53"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_61_64_595_597_60_63"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( HT / 10, HT / 4 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( HT / 10, HT / 4 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_112_115_595_597_112_115"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn buff(BruteRage.class) != null ?\n\t\t\tRandom.NormalIntRange( 15, 40 ) :\n\t\t\tRandom.NormalIntRange( 5, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn buff(BruteRage.class) != null ?\n\t\t\tChar.combatRoll( 15, 40 ) :\n\t\t\tChar.combatRoll( 5, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_58_63_595_597_57_62"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 8);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 8);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_70_73_595_597_69_72"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 7 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 7 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_45_48_595_597_44_47"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_55_58_595_597_54_57"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 10, 16 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 10, 16 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_85_88_595_597_85_88"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_107_110_595_597_107_110"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t//char logic\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\tthrowItems();\n\n\t\tsprite.hideAlert();\n\t\tsprite.hideLost();\n\n\t\t//mob logic\n\t\tenemy = Dungeon.hero;\n\n\t\t//crystal can still track an invisible hero\n\t\tenemySeen = enemy.isAlive() && fieldOfView[enemy.pos];\n\t\t//end of char/mob logic\n\n\t\tif (!targetedCells.isEmpty()){\n\n\t\t\tArrayList<Integer> cellsToAttack = targetedCells.remove(0);\n\n\t\t\tfor (int i : cellsToAttack){\n\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch instanceof CrystalSpire){\n\t\t\t\t\tcontinue; //don't spawn crystals on itself\n\t\t\t\t}\n\n\t\t\t\tLevel.set(i, Terrain.MINE_CRYSTAL);\n\t\t\t\tGameScene.updateMap(i);\n\n\t\t\t\tSplash.at(i, 0xFFFFFF, 5);\n\t\t\t}\n\n\t\t\tfor (int i : cellsToAttack){\n\t\t\t\tChar ch = Actor.findChar(i);\n\n\t\t\t\tif (ch != null && !(ch instanceof CrystalWisp || ch instanceof CrystalSpire)){\n\t\t\t\t\tint dmg = Random.NormalIntRange(6, 15);\n\n\t\t\t\t\t//guardians are hit harder by the attack\n\t\t\t\t\tif (ch instanceof CrystalGuardian) {\n\t\t\t\t\t\tdmg += 12; //18-27 damage\n\t\t\t\t\t\tBuff.prolong(ch, Cripple.class, 30f);\n\t\t\t\t\t}\n\t\t\t\t\tch.damage(dmg, new SpireSpike());\n\n\t\t\t\t\tint movePos = i;\n\t\t\t\t\t//crystal guardians get knocked away from the hero, others get knocked away from the spire\n\t\t\t\t\tif (ch instanceof CrystalGuardian){\n\t\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (!Dungeon.level.solid[i+j] && Actor.findChar(i+j) == null &&\n\t\t\t\t\t\t\t\t\tDungeon.level.trueDistance(i+j, Dungeon.hero.pos) > Dungeon.level.trueDistance(movePos, Dungeon.hero.pos)){\n\t\t\t\t\t\t\t\tmovePos = i+j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!Char.hasProp(ch, Property.IMMOVABLE)) {\n\t\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (!Dungeon.level.solid[i+j] && Actor.findChar(i+j) == null &&\n\t\t\t\t\t\t\t\t\tDungeon.level.trueDistance(i+j, pos) > Dungeon.level.trueDistance(movePos, pos)){\n\t\t\t\t\t\t\t\tmovePos = i+j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ch.isAlive()){\n\t\t\t\t\t\tif (movePos != i){\n\t\t\t\t\t\t\tActor.add(new Pushing(ch, i, movePos));\n\t\t\t\t\t\t\tch.pos = movePos;\n\t\t\t\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPixelScene.shake( 1, 0.7f );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.SHATTER );\n\n\t\t\tif (!targetedCells.isEmpty()){\n\t\t\t\tfor (int i : targetedCells.get(0)){\n\t\t\t\t\tsprite.parent.add(new TargetedCell(i, 0xFF0000));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (hits < 3 || !enemySeen){\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tif (abilityCooldown <= 0){\n\n\t\t\t\tif (Random.Int(2) == 0) {\n\t\t\t\t\tdiamondAOEAttack();\n\t\t\t\t} else {\n\t\t\t\t\tlineAttack();\n\t\t\t\t}\n\n\t\t\t\tfor (int i : targetedCells.get(0)){\n\t\t\t\t\tsprite.parent.add(new TargetedCell(i, 0xFF0000));\n\t\t\t\t}\n\n\t\t\t\tabilityCooldown += ABILITY_CD;\n\n\t\t\t\tspend(GameMath.gate(TICK, (int)Math.ceil(Dungeon.hero.cooldown()), 3*TICK));\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t} else {\n\t\t\t\tabilityCooldown -= 1;\n\t\t\t\tspend(TICK);\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t//char logic\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\tthrowItems();\n\n\t\tsprite.hideAlert();\n\t\tsprite.hideLost();\n\n\t\t//mob logic\n\t\tenemy = Dungeon.hero;\n\n\t\t//crystal can still track an invisible hero\n\t\tenemySeen = enemy.isAlive() && fieldOfView[enemy.pos];\n\t\t//end of char/mob logic\n\n\t\tif (!targetedCells.isEmpty()){\n\n\t\t\tArrayList<Integer> cellsToAttack = targetedCells.remove(0);\n\n\t\t\tfor (int i : cellsToAttack){\n\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch instanceof CrystalSpire){\n\t\t\t\t\tcontinue; //don't spawn crystals on itself\n\t\t\t\t}\n\n\t\t\t\tLevel.set(i, Terrain.MINE_CRYSTAL);\n\t\t\t\tGameScene.updateMap(i);\n\n\t\t\t\tSplash.at(i, 0xFFFFFF, 5);\n\t\t\t}\n\n\t\t\tfor (int i : cellsToAttack){\n\t\t\t\tChar ch = Actor.findChar(i);\n\n\t\t\t\tif (ch != null && !(ch instanceof CrystalWisp || ch instanceof CrystalSpire)){\n\t\t\t\t\tint dmg = Char.combatRoll(6, 15);\n\n\t\t\t\t\t//guardians are hit harder by the attack\n\t\t\t\t\tif (ch instanceof CrystalGuardian) {\n\t\t\t\t\t\tdmg += 12; //18-27 damage\n\t\t\t\t\t\tBuff.prolong(ch, Cripple.class, 30f);\n\t\t\t\t\t}\n\t\t\t\t\tch.damage(dmg, new SpireSpike());\n\n\t\t\t\t\tint movePos = i;\n\t\t\t\t\t//crystal guardians get knocked away from the hero, others get knocked away from the spire\n\t\t\t\t\tif (ch instanceof CrystalGuardian){\n\t\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (!Dungeon.level.solid[i+j] && Actor.findChar(i+j) == null &&\n\t\t\t\t\t\t\t\t\tDungeon.level.trueDistance(i+j, Dungeon.hero.pos) > Dungeon.level.trueDistance(movePos, Dungeon.hero.pos)){\n\t\t\t\t\t\t\t\tmovePos = i+j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!Char.hasProp(ch, Property.IMMOVABLE)) {\n\t\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (!Dungeon.level.solid[i+j] && Actor.findChar(i+j) == null &&\n\t\t\t\t\t\t\t\t\tDungeon.level.trueDistance(i+j, pos) > Dungeon.level.trueDistance(movePos, pos)){\n\t\t\t\t\t\t\t\tmovePos = i+j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ch.isAlive()){\n\t\t\t\t\t\tif (movePos != i){\n\t\t\t\t\t\t\tActor.add(new Pushing(ch, i, movePos));\n\t\t\t\t\t\t\tch.pos = movePos;\n\t\t\t\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPixelScene.shake( 1, 0.7f );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.SHATTER );\n\n\t\t\tif (!targetedCells.isEmpty()){\n\t\t\t\tfor (int i : targetedCells.get(0)){\n\t\t\t\t\tsprite.parent.add(new TargetedCell(i, 0xFF0000));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (hits < 3 || !enemySeen){\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tif (abilityCooldown <= 0){\n\n\t\t\t\tif (Random.Int(2) == 0) {\n\t\t\t\t\tdiamondAOEAttack();\n\t\t\t\t} else {\n\t\t\t\t\tlineAttack();\n\t\t\t\t}\n\n\t\t\t\tfor (int i : targetedCells.get(0)){\n\t\t\t\t\tsprite.parent.add(new TargetedCell(i, 0xFF0000));\n\t\t\t\t}\n\n\t\t\t\tabilityCooldown += ABILITY_CD;\n\n\t\t\t\tspend(GameMath.gate(TICK, (int)Math.ceil(Dungeon.hero.cooldown()), 3*TICK));\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t} else {\n\t\t\t\tabilityCooldown -= 1;\n\t\t\t\tspend(TICK);\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_88_209_595_597_88_209"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 5, 10 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 5, 10 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_76_79_595_597_76_79"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_86_89_595_597_86_89"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void zap() {\n\t\tspend( 1f );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\n\t\t\tint dmg = Random.NormalIntRange( 5, 10 );\n\t\t\tenemy.damage( dmg, new LightBeam() );\n\n\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"beam_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void zap() {\n\t\tspend( 1f );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\n\t\t\tint dmg = Char.combatRoll( 5, 10 );\n\t\t\tenemy.damage( dmg, new LightBeam() );\n\n\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"beam_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_119_137_595_597_119_137"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 2, 8 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 2, 8 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_60_63_595_597_59_62"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_70_73_595_597_69_72"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean doAttack( Char enemy ) {\n\n\t\tif (Dungeon.level.adjacent( pos, enemy.pos )\n\t\t\t\t|| new Ballistica( pos, enemy.pos, Ballistica.MAGIC_BOLT).collisionPos != enemy.pos) {\n\t\t\t\n\t\t\treturn super.doAttack( enemy );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tspend( TIME_TO_ZAP );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tif (hit( this, enemy, true )) {\n\t\t\t\tint dmg = Random.NormalIntRange(3, 10);\n\t\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\t\tenemy.damage( dmg, new LightningBolt() );\n\n\t\t\t\tif (enemy.sprite.visible) {\n\t\t\t\t\tenemy.sprite.centerEmitter().burst(SparkParticle.FACTORY, 3);\n\t\t\t\t\tenemy.sprite.flash();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tPixelScene.shake( 2, 0.3f );\n\t\t\t\t\t\n\t\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\t\tGLog.n( Messages.get(this, \"zap_kill\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\t\t\t\n\t\t\tif (sprite != null && (sprite.visible || enemy.sprite.visible)) {\n\t\t\t\tsprite.zap( enemy.pos );\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean doAttack( Char enemy ) {\n\n\t\tif (Dungeon.level.adjacent( pos, enemy.pos )\n\t\t\t\t|| new Ballistica( pos, enemy.pos, Ballistica.MAGIC_BOLT).collisionPos != enemy.pos) {\n\t\t\t\n\t\t\treturn super.doAttack( enemy );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tspend( TIME_TO_ZAP );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tif (hit( this, enemy, true )) {\n\t\t\t\tint dmg = Char.combatRoll(3, 10);\n\t\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\t\tenemy.damage( dmg, new LightningBolt() );\n\n\t\t\t\tif (enemy.sprite.visible) {\n\t\t\t\t\tenemy.sprite.centerEmitter().burst(SparkParticle.FACTORY, 3);\n\t\t\t\t\tenemy.sprite.flash();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tPixelScene.shake( 2, 0.3f );\n\t\t\t\t\t\n\t\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\t\tGLog.n( Messages.get(this, \"zap_kill\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\t\t\t\n\t\t\tif (sprite != null && (sprite.visible || enemy.sprite.visible)) {\n\t\t\t\tsprite.zap( enemy.pos );\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_84_128_595_597_83_127"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 10, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 10, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_58_61_595_597_58_61"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 8);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 8);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_68_71_595_597_68_71"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 15, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 15, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_46_49_595_597_46_49"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 15, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 15, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (!supercharged || state != HUNTING || rooted || target == pos || Dungeon.level.adjacent(pos, target)) {\n\t\t\t\treturn false;",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_92_95_595_597_92_95"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (!supercharged || state != HUNTING || rooted || target == pos || Dungeon.level.adjacent(pos, target)) {\n\t\t\t\treturn false;",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_102_105_595_597_102_105"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 12);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 12);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_68_71_595_597_69_72"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tdelay--;\n\n\t\t\tif (delay <= 0){\n\n\t\t\t\tif (summon == DKGolem.class){\n\t\t\t\t\tparticles.burst(SparkParticle.FACTORY, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CHARGEUP);\n\t\t\t\t} else if (summon == DKWarlock.class){\n\t\t\t\t\tparticles.burst(ShadowParticle.CURSE, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CURSED);\n\t\t\t\t} else if (summon == DKMonk.class){\n\t\t\t\t\tparticles.burst(ElmoParticle.FACTORY, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\t\t} else {\n\t\t\t\t\tparticles.burst(Speck.factory(Speck.BONE), 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BONES);\n\t\t\t\t}\n\t\t\t\tparticles = null;\n\n\t\t\t\tif (Actor.findChar(pos) != null){\n\t\t\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\tif (Dungeon.level.passable[pos+i] && Actor.findChar(pos+i) == null){\n\t\t\t\t\t\t\tcandidates.add(pos+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!candidates.isEmpty()){\n\t\t\t\t\t\tpos = Random.element(candidates);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//kill sheep that are right on top of the spawner instead of failing to spawn\n\t\t\t\tif (Actor.findChar(pos) instanceof Sheep){\n\t\t\t\t\tActor.findChar(pos).die(null);\n\t\t\t\t}\n\n\t\t\t\tif (Actor.findChar(pos) == null) {\n\t\t\t\t\tMob m = Reflection.newInstance(summon);\n\t\t\t\t\tm.pos = pos;\n\t\t\t\t\tm.maxLvl = -2;\n\t\t\t\t\tGameScene.add(m);\n\t\t\t\t\tDungeon.level.occupyCell(m);\n\t\t\t\t\tm.state = m.HUNTING;\n\t\t\t\t\tif (((DwarfKing)target).phase == 2){\n\t\t\t\t\t\tBuff.affect(m, KingDamager.class);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tChar ch = Actor.findChar(pos);\n\t\t\t\t\tch.damage(Random.NormalIntRange(20, 40), this);\n\t\t\t\t\tif (((DwarfKing)target).phase == 2){\n\t\t\t\t\t\tif (Dungeon.isChallenged(Challenges.STRONGER_BOSSES)){\n\t\t\t\t\t\t\ttarget.damage(target.HT/18, new KingDamager());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.damage(target.HT/12, new KingDamager());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\tDungeon.fail(DwarfKing.class);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", Messages.get(DwarfKing.class, \"name\"))));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdetach();\n\t\t\t}\n\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tdelay--;\n\n\t\t\tif (delay <= 0){\n\n\t\t\t\tif (summon == DKGolem.class){\n\t\t\t\t\tparticles.burst(SparkParticle.FACTORY, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CHARGEUP);\n\t\t\t\t} else if (summon == DKWarlock.class){\n\t\t\t\t\tparticles.burst(ShadowParticle.CURSE, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CURSED);\n\t\t\t\t} else if (summon == DKMonk.class){\n\t\t\t\t\tparticles.burst(ElmoParticle.FACTORY, 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\t\t} else {\n\t\t\t\t\tparticles.burst(Speck.factory(Speck.BONE), 10);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BONES);\n\t\t\t\t}\n\t\t\t\tparticles = null;\n\n\t\t\t\tif (Actor.findChar(pos) != null){\n\t\t\t\t\tArrayList<Integer> candidates = new ArrayList<>();\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\tif (Dungeon.level.passable[pos+i] && Actor.findChar(pos+i) == null){\n\t\t\t\t\t\t\tcandidates.add(pos+i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!candidates.isEmpty()){\n\t\t\t\t\t\tpos = Random.element(candidates);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//kill sheep that are right on top of the spawner instead of failing to spawn\n\t\t\t\tif (Actor.findChar(pos) instanceof Sheep){\n\t\t\t\t\tActor.findChar(pos).die(null);\n\t\t\t\t}\n\n\t\t\t\tif (Actor.findChar(pos) == null) {\n\t\t\t\t\tMob m = Reflection.newInstance(summon);\n\t\t\t\t\tm.pos = pos;\n\t\t\t\t\tm.maxLvl = -2;\n\t\t\t\t\tGameScene.add(m);\n\t\t\t\t\tDungeon.level.occupyCell(m);\n\t\t\t\t\tm.state = m.HUNTING;\n\t\t\t\t\tif (((DwarfKing)target).phase == 2){\n\t\t\t\t\t\tBuff.affect(m, KingDamager.class);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tChar ch = Actor.findChar(pos);\n\t\t\t\t\tch.damage(Char.combatRoll(20, 40), this);\n\t\t\t\t\tif (((DwarfKing)target).phase == 2){\n\t\t\t\t\t\tif (Dungeon.isChallenged(Challenges.STRONGER_BOSSES)){\n\t\t\t\t\t\t\ttarget.damage(target.HT/18, new KingDamager());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.damage(target.HT/12, new KingDamager());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\tDungeon.fail(DwarfKing.class);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", Messages.get(DwarfKing.class, \"name\"))));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdetach();\n\t\t\t}\n\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_639_708_595_597_639_708"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 15, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 15, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_90_93_595_597_90_93"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_100_103_595_597_100_103"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tif (!summonedALly) {\n\t\t\t\treturn Random.NormalIntRange(10, 12);\n\t\t\t} else {\n\t\t\t\treturn super.damageRoll();\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tif (!summonedALly) {\n\t\t\t\treturn combatRoll(10, 12);\n\t\t\t} else {\n\t\t\t\treturn super.damageRoll();\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_384_391_595_597_384_391"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (!summonedALly) {\n\t\t\treturn Random.NormalIntRange(20, 25);\n\t\t} else {\n\t\t\tint regionScale = Math.max(2, (1 + Dungeon.scalingDepth()/5));\n\t\t\treturn Random.NormalIntRange(5*regionScale, 5 + 5*regionScale);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (!summonedALly) {\n\t\t\treturn Char.combatRoll(20, 25);\n\t\t} else {\n\t\t\tint regionScale = Math.max(2, (1 + Dungeon.scalingDepth()/5));\n\t\t\treturn Char.combatRoll(5*regionScale, 5 + 5*regionScale);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_81_89_595_597_81_89"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_109_112_595_597_109_112"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean add( Buff buff ) {\n\t\tif (harmfulBuffs.contains( buff.getClass() )) {\n\t\t\tdamage( Random.NormalIntRange( HT/2, HT * 3/5 ), buff );\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn super.add( buff );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean add( Buff buff ) {\n\t\tif (harmfulBuffs.contains( buff.getClass() )) {\n\t\t\tdamage( Char.combatRoll( HT/2, HT * 3/5 ), buff );\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn super.add( buff );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_183_191_595_597_183_191"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange(20, 30);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll(20, 30);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_70_73_595_597_70_73"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_80_83_595_597_80_83"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void deathGaze(){\n\t\tif (!beamCharged || beamCooldown > 0 || beam == null)\n\t\t\treturn;\n\n\t\tbeamCharged = false;\n\t\tbeamCooldown = Random.IntRange(4, 6);\n\n\t\tboolean terrainAffected = false;\n\n\t\tInvisibility.dispel(this);\n\t\tfor (int pos : beam.subPath(1, beam.dist)) {\n\n\t\t\tif (Dungeon.level.flamable[pos]) {\n\n\t\t\t\tDungeon.level.destroy( pos );\n\t\t\t\tGameScene.updateMap( pos );\n\t\t\t\tterrainAffected = true;\n\n\t\t\t}\n\n\t\t\tChar ch = Actor.findChar( pos );\n\t\t\tif (ch == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (hit( this, ch, true )) {\n\t\t\t\tint dmg = Random.NormalIntRange( 30, 50 );\n\t\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\t\tch.damage( dmg, new DeathGaze() );\n\n\t\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\t\tch.sprite.flash();\n\t\t\t\t\tCellEmitter.center( pos ).burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t\t\t}\n\n\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"deathgaze_kill\") );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tch.sprite.showStatus( CharSprite.NEUTRAL,  ch.defenseVerb() );\n\t\t\t}\n\t\t}\n\n\t\tif (terrainAffected) {\n\t\t\tDungeon.observe();\n\t\t}\n\n\t\tbeam = null;\n\t\tbeamTarget = -1;\n\t}",
          "sourceCodeAfterRefactoring": "public void deathGaze(){\n\t\tif (!beamCharged || beamCooldown > 0 || beam == null)\n\t\t\treturn;\n\n\t\tbeamCharged = false;\n\t\tbeamCooldown = Random.IntRange(4, 6);\n\n\t\tboolean terrainAffected = false;\n\n\t\tInvisibility.dispel(this);\n\t\tfor (int pos : beam.subPath(1, beam.dist)) {\n\n\t\t\tif (Dungeon.level.flamable[pos]) {\n\n\t\t\t\tDungeon.level.destroy( pos );\n\t\t\t\tGameScene.updateMap( pos );\n\t\t\t\tterrainAffected = true;\n\n\t\t\t}\n\n\t\t\tChar ch = Actor.findChar( pos );\n\t\t\tif (ch == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (hit( this, ch, true )) {\n\t\t\t\tint dmg = Char.combatRoll( 30, 50 );\n\t\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\t\tch.damage( dmg, new DeathGaze() );\n\n\t\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\t\tch.sprite.flash();\n\t\t\t\t\tCellEmitter.center( pos ).burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t\t\t}\n\n\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"deathgaze_kill\") );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tch.sprite.showStatus( CharSprite.NEUTRAL,  ch.defenseVerb() );\n\t\t\t}\n\t\t}\n\n\t\tif (terrainAffected) {\n\t\t\tDungeon.observe();\n\t\t}\n\n\t\tbeam = null;\n\t\tbeamTarget = -1;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_161_212_595_597_161_212"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 2);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_58_61_595_597_58_61"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange(5, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll(5, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_69_72_595_597_68_71"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 16, 22 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 16, 22 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_66_69_595_597_66_69"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_76_79_595_597_76_79"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 6 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 6 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_44_47_595_597_43_46"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 2);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_54_57_595_597_53_56"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void affectChar(Char ch) {\n\t\t\tch.damage(Random.NormalIntRange(6, 12), this);\n\t\t\tif (ch.isAlive()) {\n\t\t\t\tBuff.prolong(ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3);\n\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\tDungeon.fail( target );\n\t\t\t\tGLog.n( Messages.get( GnollGeomancer.class, \"rockfall_kill\") );\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void affectChar(Char ch) {\n\t\t\tch.damage(Char.combatRoll(6, 12), this);\n\t\t\tif (ch.isAlive()) {\n\t\t\t\tBuff.prolong(ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3);\n\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\tDungeon.fail( target );\n\t\t\t\tGLog.n( Messages.get( GnollGeomancer.class, \"rockfall_kill\") );\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\naim = GnollGeomancer.prepRockThrowAttack(enemy, GnollGeomancer.this);\n\t\t\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_796_805_595_597_796_805"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 3, 6 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 3, 6 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\naim = GnollGeomancer.prepRockThrowAttack(enemy, GnollGeomancer.this);\n\t\t\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_138_141_595_597_138_141"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 6);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 6);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\naim = GnollGeomancer.prepRockThrowAttack(enemy, GnollGeomancer.this);\n\t\t\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_148_151_595_597_148_151"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void doRockThrowAttack( Char source, int from, int to ){\n\n\t\tLevel.set(from, Terrain.EMPTY);\n\t\tGameScene.updateMap(from);\n\t\tsource.sprite.attack(from, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tsource.sprite.idle();\n\t\t\t\t//do nothing\n\t\t\t}\n\t\t});\n\n\t\tBallistica rockPath = new Ballistica(from, to, Ballistica.MAGIC_BOLT);\n\n\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\t((MissileSprite)source.sprite.parent.recycle( MissileSprite.class )).\n\t\t\t\treset( from, rockPath.collisionPos, new GnollGeomancer.Boulder(), new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tSplash.at(rockPath.collisionPos, 0x555555, 15);\n\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.ROCKS);\n\n\t\t\t\t\t\tChar ch = Actor.findChar(rockPath.collisionPos);\n\t\t\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t\t\tPixelScene.shake( 3, 0.7f );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPixelScene.shake(0.5f, 0.5f);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ch != null && !(ch instanceof GnollGeomancer)){\n\t\t\t\t\t\t\tch.damage(Random.NormalIntRange(6, 12), new GnollGeomancer.Boulder());\n\n\t\t\t\t\t\t\tif (ch.isAlive()){\n\t\t\t\t\t\t\t\tBuff.prolong( ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3 );\n\t\t\t\t\t\t\t} else if (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\t\t\tDungeon.fail( source.getClass() );\n\t\t\t\t\t\t\t\tGLog.n( Messages.get( GnollGeomancer.class, \"rock_kill\") );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!knockedChars.contains(ch) && rockPath.path.size() > rockPath.dist+1) {\n\t\t\t\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, rockPath.path.get(rockPath.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\t\t\t\t\tWandOfBlastWave.throwChar(ch, trajectory, 1, false, false, source);\n\t\t\t\t\t\t\t\tknockedChars.add(ch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (ch == null) {\n\t\t\t\t\t\t\tDungeon.level.pressCell(rockPath.collisionPos);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trocksInFlight--;\n\t\t\t\t\t\tif (rocksInFlight <= 0) {\n\t\t\t\t\t\t\trocksInFlight = 0;\n\t\t\t\t\t\t\tsource.next();\n\t\t\t\t\t\t\tknockedChars.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\trocksInFlight++;\n\t}",
          "sourceCodeAfterRefactoring": "public static void doRockThrowAttack( Char source, int from, int to ){\n\n\t\tLevel.set(from, Terrain.EMPTY);\n\t\tGameScene.updateMap(from);\n\t\tsource.sprite.attack(from, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tsource.sprite.idle();\n\t\t\t\t//do nothing\n\t\t\t}\n\t\t});\n\n\t\tBallistica rockPath = new Ballistica(from, to, Ballistica.MAGIC_BOLT);\n\n\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\t((MissileSprite)source.sprite.parent.recycle( MissileSprite.class )).\n\t\t\t\treset( from, rockPath.collisionPos, new GnollGeomancer.Boulder(), new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tSplash.at(rockPath.collisionPos, 0x555555, 15);\n\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.ROCKS);\n\n\t\t\t\t\t\tChar ch = Actor.findChar(rockPath.collisionPos);\n\t\t\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t\t\tPixelScene.shake( 3, 0.7f );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tPixelScene.shake(0.5f, 0.5f);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ch != null && !(ch instanceof GnollGeomancer)){\n\t\t\t\t\t\t\tch.damage(Char.combatRoll(6, 12), new GnollGeomancer.Boulder());\n\n\t\t\t\t\t\t\tif (ch.isAlive()){\n\t\t\t\t\t\t\t\tBuff.prolong( ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3 );\n\t\t\t\t\t\t\t} else if (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\t\t\tDungeon.fail( source.getClass() );\n\t\t\t\t\t\t\t\tGLog.n( Messages.get( GnollGeomancer.class, \"rock_kill\") );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!knockedChars.contains(ch) && rockPath.path.size() > rockPath.dist+1) {\n\t\t\t\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, rockPath.path.get(rockPath.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\t\t\t\t\tWandOfBlastWave.throwChar(ch, trajectory, 1, false, false, source);\n\t\t\t\t\t\t\t\tknockedChars.add(ch);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (ch == null) {\n\t\t\t\t\t\t\tDungeon.level.pressCell(rockPath.collisionPos);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trocksInFlight--;\n\t\t\t\t\t\tif (rocksInFlight <= 0) {\n\t\t\t\t\t\t\trocksInFlight = 0;\n\t\t\t\t\t\t\tsource.next();\n\t\t\t\t\t\t\tknockedChars.clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\trocksInFlight++;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\naim = GnollGeomancer.prepRockThrowAttack(enemy, GnollGeomancer.this);\n\t\t\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_665_723_595_597_665_723"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (enemy != null && !Dungeon.level.adjacent(pos, enemy.pos)){\n\t\t\treturn Random.NormalIntRange( 16, 22 );\n\t\t} else {\n\t\t\treturn Random.NormalIntRange( 6, 12 );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (enemy != null && !Dungeon.level.adjacent(pos, enemy.pos)){\n\t\t\treturn Char.combatRoll( 16, 22 );\n\t\t} else {\n\t\t\treturn Char.combatRoll( 6, 12 );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_82_89_595_597_81_88"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 6);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 6);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_105_108_595_597_104_107"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 6 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 6 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_97_100_595_597_97_100"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 6);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 6);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_113_116_595_597_113_116"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 25, 30 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 25, 30 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_61_64_595_597_61_64"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 12);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 12);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_71_74_595_597_71_74"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tint min = 1;\n\t\tint max = (HP*2 <= HT) ? 12 : 8;\n\t\tif (pumpedUp > 0) {\n\t\t\tpumpedUp = 0;\n\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\tStatistics.bossScores[0] -= 100;\n\t\t\t}\n\t\t\treturn Random.NormalIntRange( min*3, max*3 );\n\t\t} else {\n\t\t\treturn Random.NormalIntRange( min, max );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tint min = 1;\n\t\tint max = (HP*2 <= HT) ? 12 : 8;\n\t\tif (pumpedUp > 0) {\n\t\t\tpumpedUp = 0;\n\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\tStatistics.bossScores[0] -= 100;\n\t\t\t}\n\t\t\treturn Char.combatRoll( min*3, max*3 );\n\t\t} else {\n\t\t\treturn Char.combatRoll( min, max );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_67_81_595_597_67_81"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 2);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_96_99_595_597_96_99"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange(4, 12);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll(4, 12);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_65_68_595_597_64_67"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 7);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 7);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_138_141_595_597_137_140"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 1 + level/2);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 1 + level/2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_222_225_595_597_222_225"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 12, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 12, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_54_57_595_597_54_57"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 2);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_69_72_595_597_69_72"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_85_88_595_597_84_87"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void summonMinion(){\n\t\tif (Actor.findChar(summoningPos) != null) {\n\n\t\t\t//cancel if character cannot be moved\n\t\t\tif (Char.hasProp(Actor.findChar(summoningPos), Property.IMMOVABLE)){\n\t\t\t\tsummoning = false;\n\t\t\t\t((NecromancerSprite)sprite).finishSummoning();\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint pushPos = pos;\n\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\tif (pushPos != pos) {\n\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\tActor.add( new Pushing( ch, ch.pos, pushPos ) );\n\n\t\t\t\tch.pos = pushPos;\n\t\t\t\tDungeon.level.occupyCell(ch );\n\n\t\t\t} else {\n\n\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\tblocker.damage( Random.NormalIntRange(2, 10), new SummoningBlockDamage() );\n\t\t\t\t\tif (blocker == Dungeon.hero && !blocker.isAlive()){\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsummoning = firstSummon = false;\n\n\t\tmySkeleton = new NecroSkeleton();\n\t\tmySkeleton.pos = summoningPos;\n\t\tGameScene.add( mySkeleton );\n\t\tDungeon.level.occupyCell( mySkeleton );\n\t\t((NecromancerSprite)sprite).finishSummoning();\n\n\t\tfor (Buff b : buffs(AllyBuff.class)){\n\t\t\tBuff.affect(mySkeleton, b.getClass());\n\t\t}\n\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\tBuff.affect( mySkeleton, b.getClass());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void summonMinion(){\n\t\tif (Actor.findChar(summoningPos) != null) {\n\n\t\t\t//cancel if character cannot be moved\n\t\t\tif (Char.hasProp(Actor.findChar(summoningPos), Property.IMMOVABLE)){\n\t\t\t\tsummoning = false;\n\t\t\t\t((NecromancerSprite)sprite).finishSummoning();\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint pushPos = pos;\n\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\tif (pushPos != pos) {\n\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\tActor.add( new Pushing( ch, ch.pos, pushPos ) );\n\n\t\t\t\tch.pos = pushPos;\n\t\t\t\tDungeon.level.occupyCell(ch );\n\n\t\t\t} else {\n\n\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\tblocker.damage( Char.combatRoll(2, 10), new SummoningBlockDamage() );\n\t\t\t\t\tif (blocker == Dungeon.hero && !blocker.isAlive()){\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsummoning = firstSummon = false;\n\n\t\tmySkeleton = new NecroSkeleton();\n\t\tmySkeleton.pos = summoningPos;\n\t\tGameScene.add( mySkeleton );\n\t\tDungeon.level.occupyCell( mySkeleton );\n\t\t((NecromancerSprite)sprite).finishSummoning();\n\n\t\tfor (Buff b : buffs(AllyBuff.class)){\n\t\t\tBuff.affect(mySkeleton, b.getClass());\n\t\t}\n\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\tBuff.affect( mySkeleton, b.getClass());\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_186_246_595_597_185_245"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( Dungeon.depth, 4 + Dungeon.depth * 2 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( Dungeon.depth, 4 + Dungeon.depth * 2 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_77_80_595_597_77_80"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, Dungeon.depth);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, Dungeon.depth);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_87_90_595_597_87_90"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void shockChar( Char ch ){\n\t\tif (ch != null && !(ch instanceof DM300)){\n\t\t\tch.sprite.flash();\n\t\t\tch.damage(Random.NormalIntRange(10, 20), new Electricity());\n\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\tStatistics.bossScores[2] -= 100;\n\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\tDungeon.fail(DM300.class);\n\t\t\t\t\tGLog.n(Messages.get(Electricity.class, \"ondeath\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void shockChar( Char ch ){\n\t\tif (ch != null && !(ch instanceof DM300)){\n\t\t\tch.sprite.flash();\n\t\t\tch.damage(Char.combatRoll(10, 20), new Electricity());\n\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\tStatistics.bossScores[2] -= 100;\n\t\t\t\tif (!ch.isAlive()) {\n\t\t\t\t\tDungeon.fail(DM300.class);\n\t\t\t\t\tGLog.n(Messages.get(Electricity.class, \"ondeath\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_140_154_595_597_140_154"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 4 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 4 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_54_595_597_50_53"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 1);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 1);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_61_64_595_597_60_63"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 15, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 15, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_70_73_595_597_70_73"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_85_88_595_597_85_88"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_132_135_595_597_131_134"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange(10, 20);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll(10, 20);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_97_100_595_597_96_99"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 8);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 8);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_107_110_595_597_106_109"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 30, 40 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 30, 40 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_57_60_595_597_57_60"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 16);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 16);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_67_70_595_597_67_70"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 16, 25 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 16, 25 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_45_48_595_597_45_48"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 5, 10 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 5, 10 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_57_60_595_597_57_60"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 6);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 6);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_67_70_595_597_67_70"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void zap() {\n\t\tspend( 1f );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\t\t\t\n\t\t\tif (Random.Int( 2 ) == 0) {\n\t\t\t\tdebuff( enemy );\n\t\t\t\tif (enemy == Dungeon.hero) Sample.INSTANCE.play( Assets.Sounds.DEBUFF );\n\t\t\t}\n\t\t\t\n\t\t\tint dmg = Random.NormalIntRange( 6, 15 );\n\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\tenemy.damage( dmg, new EarthenBolt() );\n\t\t\t\n\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"bolt_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void zap() {\n\t\tspend( 1f );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\t\t\t\n\t\t\tif (Random.Int( 2 ) == 0) {\n\t\t\t\tdebuff( enemy );\n\t\t\t\tif (enemy == Dungeon.hero) Sample.INSTANCE.play( Assets.Sounds.DEBUFF );\n\t\t\t}\n\t\t\t\n\t\t\tint dmg = Char.combatRoll( 6, 15 );\n\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\tenemy.damage( dmg, new EarthenBolt() );\n\t\t\t\n\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"bolt_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_113_137_595_597_113_137"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 2, 10 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 2, 10 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_56_59_595_597_55_58"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\t\t\n\t\tsuper.die( cause );\n\t\t\n\t\tif (cause == Chasm.class) return;\n\t\t\n\t\tboolean heroKilled = false;\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tChar ch = findChar( pos + PathFinder.NEIGHBOURS8[i] );\n\t\t\tif (ch != null && ch.isAlive()) {\n\t\t\t\tint damage = Math.round(Random.NormalIntRange(6, 12));\n\t\t\t\tdamage = Math.round( damage * AscensionChallenge.statModifier(this));\n\t\t\t\t//armor is 2x effective against bone explosion\n\t\t\t\tdamage = Math.max( 0,  damage - (ch.drRoll() + ch.drRoll()) );\n\t\t\t\tch.damage( damage, this );\n\t\t\t\tif (ch == Dungeon.hero && !ch.isAlive()) {\n\t\t\t\t\theroKilled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\tSample.INSTANCE.play( Assets.Sounds.BONES );\n\t\t}\n\t\t\n\t\tif (heroKilled) {\n\t\t\tDungeon.fail( this );\n\t\t\tGLog.n( Messages.get(this, \"explo_kill\") );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\t\t\n\t\tsuper.die( cause );\n\t\t\n\t\tif (cause == Chasm.class) return;\n\t\t\n\t\tboolean heroKilled = false;\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tChar ch = findChar( pos + PathFinder.NEIGHBOURS8[i] );\n\t\t\tif (ch != null && ch.isAlive()) {\n\t\t\t\tint damage = Math.round(Char.combatRoll(6, 12));\n\t\t\t\tdamage = Math.round( damage * AscensionChallenge.statModifier(this));\n\t\t\t\t//armor is 2x effective against bone explosion\n\t\t\t\tdamage = Math.max( 0,  damage - (ch.drRoll() + ch.drRoll()) );\n\t\t\t\tch.damage( damage, this );\n\t\t\t\tif (ch == Dungeon.hero && !ch.isAlive()) {\n\t\t\t\t\theroKilled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\tSample.INSTANCE.play( Assets.Sounds.BONES );\n\t\t}\n\t\t\n\t\tif (heroKilled) {\n\t\t\tDungeon.fail( this );\n\t\t\tGLog.n( Messages.get(this, \"explo_kill\") );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_61_91_595_597_60_90"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_111_114_595_597_110_113"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 2, 5 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 2, 5 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_47_50_595_597_46_49"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 4 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 4 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_50_53_595_597_49_52"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void summonMinion() {\n\t\tif (Actor.findChar(summoningPos) != null) {\n\n\t\t\t//cancel if character cannot be moved\n\t\t\tif (Char.hasProp(Actor.findChar(summoningPos), Property.IMMOVABLE)){\n\t\t\t\tsummoning = false;\n\t\t\t\t((SpectralNecromancerSprite)sprite).finishSummoning();\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint pushPos = pos;\n\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\tif (pushPos != pos) {\n\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\tActor.add( new Pushing( ch, ch.pos, pushPos ) );\n\n\t\t\t\tch.pos = pushPos;\n\t\t\t\tDungeon.level.occupyCell(ch );\n\n\t\t\t} else {\n\n\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\tblocker.damage( Random.NormalIntRange(2, 10), new SummoningBlockDamage() );\n\t\t\t\t\tif (blocker == Dungeon.hero && !blocker.isAlive()){\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsummoning = firstSummon = false;\n\n\t\tWraith wraith = Wraith.spawnAt(summoningPos, Wraith.class);\n\t\twraith.adjustStats(0);\n\t\tDungeon.level.occupyCell( wraith );\n\t\t((SpectralNecromancerSprite)sprite).finishSummoning();\n\n\t\tfor (Buff b : buffs(AllyBuff.class)){\n\t\t\tBuff.affect( wraith, b.getClass());\n\t\t}\n\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\tBuff.affect( wraith, b.getClass());\n\t\t}\n\t\twraithIDs.add(wraith.id());\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void summonMinion() {\n\t\tif (Actor.findChar(summoningPos) != null) {\n\n\t\t\t//cancel if character cannot be moved\n\t\t\tif (Char.hasProp(Actor.findChar(summoningPos), Property.IMMOVABLE)){\n\t\t\t\tsummoning = false;\n\t\t\t\t((SpectralNecromancerSprite)sprite).finishSummoning();\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint pushPos = pos;\n\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\tif (pushPos != pos) {\n\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\tActor.add( new Pushing( ch, ch.pos, pushPos ) );\n\n\t\t\t\tch.pos = pushPos;\n\t\t\t\tDungeon.level.occupyCell(ch );\n\n\t\t\t} else {\n\n\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\tblocker.damage( Char.combatRoll(2, 10), new SummoningBlockDamage() );\n\t\t\t\t\tif (blocker == Dungeon.hero && !blocker.isAlive()){\n\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tspend(TICK);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsummoning = firstSummon = false;\n\n\t\tWraith wraith = Wraith.spawnAt(summoningPos, Wraith.class);\n\t\twraith.adjustStats(0);\n\t\tDungeon.level.occupyCell( wraith );\n\t\t((SpectralNecromancerSprite)sprite).finishSummoning();\n\n\t\tfor (Buff b : buffs(AllyBuff.class)){\n\t\t\tBuff.affect( wraith, b.getClass());\n\t\t}\n\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\tBuff.affect( wraith, b.getClass());\n\t\t}\n\t\twraithIDs.add(wraith.id());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_105_166_595_597_105_166"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange(10, 20);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll(10, 20);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_59_62_595_597_59_62"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 6);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 6);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_69_72_595_597_69_72"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, Dungeon.depth + weapon.defenseFactor(this));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, Dungeon.depth + weapon.defenseFactor(this));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_115_118_595_597_115_118"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 25, 30 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 25, 30 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_71_74_595_597_71_74"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 10);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 10);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_167_170_595_597_167_170"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 4 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 4 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_78_81_595_597_78_81"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 6, 12 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 6, 12 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nthrower.next();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_102_105_595_597_102_105"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 5);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 5);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nthrower.next();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_116_119_595_597_116_119"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 1, 10 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 1, 10 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_81_84_595_597_81_84"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 3);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 3);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_120_123_595_597_120_123"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 12, 18 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 12, 18 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_63_66_595_597_63_66"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 8);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 8);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_73_76_595_597_73_76"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "protected void zap() {\n\t\tspend( TIME_TO_ZAP );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\t\t\t//TODO would be nice for this to work on ghost/statues too\n\t\t\tif (enemy == Dungeon.hero && Random.Int( 2 ) == 0) {\n\t\t\t\tBuff.prolong( enemy, Degrade.class, Degrade.DURATION );\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.DEBUFF );\n\t\t\t}\n\t\t\t\n\t\t\tint dmg = Random.NormalIntRange( 12, 18 );\n\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\tenemy.damage( dmg, new DarkBolt() );\n\t\t\t\n\t\t\tif (enemy == Dungeon.hero && !enemy.isAlive()) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"bolt_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void zap() {\n\t\tspend( TIME_TO_ZAP );\n\n\t\tInvisibility.dispel(this);\n\t\tChar enemy = this.enemy;\n\t\tif (hit( this, enemy, true )) {\n\t\t\t//TODO would be nice for this to work on ghost/statues too\n\t\t\tif (enemy == Dungeon.hero && Random.Int( 2 ) == 0) {\n\t\t\t\tBuff.prolong( enemy, Degrade.class, Degrade.DURATION );\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.DEBUFF );\n\t\t\t}\n\t\t\t\n\t\t\tint dmg = Char.combatRoll( 12, 18 );\n\t\t\tdmg = Math.round(dmg * AscensionChallenge.statModifier(this));\n\t\t\tenemy.damage( dmg, new DarkBolt() );\n\t\t\t\n\t\t\tif (enemy == Dungeon.hero && !enemy.isAlive()) {\n\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\tDungeon.fail( this );\n\t\t\t\tGLog.n( Messages.get(this, \"bolt_kill\") );\n\t\t\t}\n\t\t} else {\n\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_106_130_595_597_106_130"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Random.NormalIntRange( 15, 25 );\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Char.combatRoll( 15, 25 );\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static final String REGULAR_SUMMONS = \"regular_summons\";\n\tprivate static final String CHALLENGE_SUMMONS = \"challenges_summons\";",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_664_667_595_597_664_667"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\treturn super.drRoll() + Random.NormalIntRange(0, 4);\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\treturn super.drRoll() + Char.combatRoll(0, 4);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static final String REGULAR_SUMMONS = \"regular_summons\";\n\tprivate static final String CHALLENGE_SUMMONS = \"challenges_summons\";",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_669_672_595_597_669_672"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t//char logic\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\tthrowItems();\n\n\t\tsprite.hideAlert();\n\t\tsprite.hideLost();\n\n\t\t//mob logic\n\t\tenemy = chooseEnemy();\n\n\t\tenemySeen = enemy != null && enemy.isAlive() && fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t//end of char/mob logic\n\n\t\tif (phase == 0){\n\t\t\tif (Dungeon.hero.viewDistance >= Dungeon.level.distance(pos, Dungeon.hero.pos)) {\n\t\t\t\tDungeon.observe();\n\t\t\t}\n\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\tnotice();\n\t\t\t}\n\t\t}\n\n\t\tif (phase == 4 && findFist() == null){\n\t\t\tyell(Messages.get(this, \"hope\"));\n\t\t\tsummonCooldown = -15; //summon a burst of minions!\n\t\t\tphase = 5;\n\t\t\tBossHealthBar.bleed(true);\n\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tMusic.INSTANCE.fadeOut(0.5f, new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tMusic.INSTANCE.play(Assets.Music.HALLS_BOSS_FINALE, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (phase == 0){\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tboolean terrainAffected = false;\n\t\t\tHashSet<Char> affected = new HashSet<>();\n\t\t\t//delay fire on a rooted hero\n\t\t\tif (!Dungeon.hero.rooted) {\n\t\t\t\tfor (int i : targetedCells) {\n\t\t\t\t\tBallistica b = new Ballistica(pos, i, Ballistica.WONT_STOP);\n\t\t\t\t\t//shoot beams\n\t\t\t\t\tsprite.parent.add(new Beam.DeathRay(sprite.center(), DungeonTilemap.raisedTileCenterToWorld(b.collisionPos)));\n\t\t\t\t\tfor (int p : b.path) {\n\t\t\t\t\t\tChar ch = Actor.findChar(p);\n\t\t\t\t\t\tif (ch != null && (ch.alignment != alignment || ch instanceof Bee)) {\n\t\t\t\t\t\t\taffected.add(ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Dungeon.level.flamable[p]) {\n\t\t\t\t\t\t\tDungeon.level.destroy(p);\n\t\t\t\t\t\t\tGameScene.updateMap(p);\n\t\t\t\t\t\t\tterrainAffected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (terrainAffected) {\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t}\n\t\t\t\tInvisibility.dispel(this);\n\t\t\t\tfor (Char ch : affected) {\n\n\t\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\t\tStatistics.bossScores[4] -= 500;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hit( this, ch, true )) {\n\t\t\t\t\t\tif (Dungeon.isChallenged(Challenges.STRONGER_BOSSES)) {\n\t\t\t\t\t\t\tch.damage(Random.NormalIntRange(30, 50), new Eye.DeathGaze());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch.damage(Random.NormalIntRange(20, 30), new Eye.DeathGaze());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\t\t\t\tch.sprite.flash();\n\t\t\t\t\t\t\tCellEmitter.center(pos).burst(PurpleParticle.BURST, Random.IntRange(1, 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\t\tGLog.n(Messages.get(Char.class, \"kill\", name()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch.sprite.showStatus( CharSprite.NEUTRAL,  ch.defenseVerb() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttargetedCells.clear();\n\t\t\t}\n\n\t\t\tif (abilityCooldown <= 0){\n\n\t\t\t\tint beams = 1 + (HT - HP)/400;\n\t\t\t\tHashSet<Integer> affectedCells = new HashSet<>();\n\t\t\t\tfor (int i = 0; i < beams; i++){\n\n\t\t\t\t\tint targetPos = Dungeon.hero.pos;\n\t\t\t\t\tif (i != 0){\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttargetPos = Dungeon.hero.pos + PathFinder.NEIGHBOURS8[Random.Int(8)];\n\t\t\t\t\t\t} while (Dungeon.level.trueDistance(pos, Dungeon.hero.pos)\n\t\t\t\t\t\t\t\t> Dungeon.level.trueDistance(pos, targetPos));\n\t\t\t\t\t}\n\t\t\t\t\ttargetedCells.add(targetPos);\n\t\t\t\t\tBallistica b = new Ballistica(pos, targetPos, Ballistica.WONT_STOP);\n\t\t\t\t\taffectedCells.addAll(b.path);\n\t\t\t\t}\n\n\t\t\t\t//remove one beam if multiple shots would cause every cell next to the hero to be targeted\n\t\t\t\tboolean allAdjTargeted = true;\n\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\tif (!affectedCells.contains(Dungeon.hero.pos + i) && Dungeon.level.passable[Dungeon.hero.pos + i]){\n\t\t\t\t\t\tallAdjTargeted = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allAdjTargeted){\n\t\t\t\t\ttargetedCells.remove(targetedCells.size()-1);\n\t\t\t\t}\n\t\t\t\tfor (int i : targetedCells){\n\t\t\t\t\tBallistica b = new Ballistica(pos, i, Ballistica.WONT_STOP);\n\t\t\t\t\tfor (int p : b.path){\n\t\t\t\t\t\tsprite.parent.add(new TargetedCell(p, 0xFF0000));\n\t\t\t\t\t\taffectedCells.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//don't want to overly punish players with slow move or attack speed\n\t\t\t\tspend(GameMath.gate(TICK, (int)Math.ceil(Dungeon.hero.cooldown()), 3*TICK));\n\t\t\t\tDungeon.hero.interrupt();\n\n\t\t\t\tabilityCooldown += Random.NormalFloat(MIN_ABILITY_CD, MAX_ABILITY_CD);\n\t\t\t\tabilityCooldown -= (phase - 1);\n\n\t\t\t} else {\n\t\t\t\tspend(TICK);\n\t\t\t}\n\n\t\t\twhile (summonCooldown <= 0){\n\n\t\t\t\tClass<?extends Mob> cls = regularSummons.remove(0);\n\t\t\t\tMob summon = Reflection.newInstance(cls);\n\t\t\t\tregularSummons.add(cls);\n\n\t\t\t\tint spawnPos = -1;\n\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\tif (Actor.findChar(pos+i) == null){\n\t\t\t\t\t\tif (spawnPos == -1 || Dungeon.level.trueDistance(Dungeon.hero.pos, spawnPos) > Dungeon.level.trueDistance(Dungeon.hero.pos, pos+i)){\n\t\t\t\t\t\t\tspawnPos = pos + i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//if no other valid spawn spots exist, try to kill an adjacent sheep to spawn anyway\n\t\t\t\tif (spawnPos == -1){\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\tif (Actor.findChar(pos+i) instanceof Sheep){\n\t\t\t\t\t\t\tif (spawnPos == -1 || Dungeon.level.trueDistance(Dungeon.hero.pos, spawnPos) > Dungeon.level.trueDistance(Dungeon.hero.pos, pos+i)){\n\t\t\t\t\t\t\t\tspawnPos = pos + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (spawnPos != -1){\n\t\t\t\t\t\tActor.findChar(spawnPos).die(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPos != -1) {\n\t\t\t\t\tsummon.pos = spawnPos;\n\t\t\t\t\tGameScene.add( summon );\n\t\t\t\t\tActor.add( new Pushing( summon, pos, summon.pos ) );\n\t\t\t\t\tsummon.beckon(Dungeon.hero.pos);\n\t\t\t\t\tDungeon.level.occupyCell(summon);\n\n\t\t\t\t\tsummonCooldown += Random.NormalFloat(MIN_SUMMON_CD, MAX_SUMMON_CD);\n\t\t\t\t\tsummonCooldown -= (phase - 1);\n\t\t\t\t\tif (findFist() != null){\n\t\t\t\t\t\tsummonCooldown += MIN_SUMMON_CD - (phase - 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (summonCooldown > 0) summonCooldown--;\n\t\tif (abilityCooldown > 0) abilityCooldown--;\n\n\t\t//extra fast abilities and summons at the final 100 HP\n\t\tif (phase == 5 && abilityCooldown > 2){\n\t\t\tabilityCooldown = 2;\n\t\t}\n\t\tif (phase == 5 && summonCooldown > 3){\n\t\t\tsummonCooldown = 3;\n\t\t}\n\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t//char logic\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\tthrowItems();\n\n\t\tsprite.hideAlert();\n\t\tsprite.hideLost();\n\n\t\t//mob logic\n\t\tenemy = chooseEnemy();\n\n\t\tenemySeen = enemy != null && enemy.isAlive() && fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t//end of char/mob logic\n\n\t\tif (phase == 0){\n\t\t\tif (Dungeon.hero.viewDistance >= Dungeon.level.distance(pos, Dungeon.hero.pos)) {\n\t\t\t\tDungeon.observe();\n\t\t\t}\n\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\tnotice();\n\t\t\t}\n\t\t}\n\n\t\tif (phase == 4 && findFist() == null){\n\t\t\tyell(Messages.get(this, \"hope\"));\n\t\t\tsummonCooldown = -15; //summon a burst of minions!\n\t\t\tphase = 5;\n\t\t\tBossHealthBar.bleed(true);\n\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tMusic.INSTANCE.fadeOut(0.5f, new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tMusic.INSTANCE.play(Assets.Music.HALLS_BOSS_FINALE, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (phase == 0){\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t} else {\n\n\t\t\tboolean terrainAffected = false;\n\t\t\tHashSet<Char> affected = new HashSet<>();\n\t\t\t//delay fire on a rooted hero\n\t\t\tif (!Dungeon.hero.rooted) {\n\t\t\t\tfor (int i : targetedCells) {\n\t\t\t\t\tBallistica b = new Ballistica(pos, i, Ballistica.WONT_STOP);\n\t\t\t\t\t//shoot beams\n\t\t\t\t\tsprite.parent.add(new Beam.DeathRay(sprite.center(), DungeonTilemap.raisedTileCenterToWorld(b.collisionPos)));\n\t\t\t\t\tfor (int p : b.path) {\n\t\t\t\t\t\tChar ch = Actor.findChar(p);\n\t\t\t\t\t\tif (ch != null && (ch.alignment != alignment || ch instanceof Bee)) {\n\t\t\t\t\t\t\taffected.add(ch);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Dungeon.level.flamable[p]) {\n\t\t\t\t\t\t\tDungeon.level.destroy(p);\n\t\t\t\t\t\t\tGameScene.updateMap(p);\n\t\t\t\t\t\t\tterrainAffected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (terrainAffected) {\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t}\n\t\t\t\tInvisibility.dispel(this);\n\t\t\t\tfor (Char ch : affected) {\n\n\t\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\t\tStatistics.bossScores[4] -= 500;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (hit( this, ch, true )) {\n\t\t\t\t\t\tif (Dungeon.isChallenged(Challenges.STRONGER_BOSSES)) {\n\t\t\t\t\t\t\tch.damage(Char.combatRoll(30, 50), new Eye.DeathGaze());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tch.damage(Char.combatRoll(20, 30), new Eye.DeathGaze());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Dungeon.level.heroFOV[pos]) {\n\t\t\t\t\t\t\tch.sprite.flash();\n\t\t\t\t\t\t\tCellEmitter.center(pos).burst(PurpleParticle.BURST, Random.IntRange(1, 2));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero) {\n\t\t\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\t\t\tGLog.n(Messages.get(Char.class, \"kill\", name()));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch.sprite.showStatus( CharSprite.NEUTRAL,  ch.defenseVerb() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttargetedCells.clear();\n\t\t\t}\n\n\t\t\tif (abilityCooldown <= 0){\n\n\t\t\t\tint beams = 1 + (HT - HP)/400;\n\t\t\t\tHashSet<Integer> affectedCells = new HashSet<>();\n\t\t\t\tfor (int i = 0; i < beams; i++){\n\n\t\t\t\t\tint targetPos = Dungeon.hero.pos;\n\t\t\t\t\tif (i != 0){\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\ttargetPos = Dungeon.hero.pos + PathFinder.NEIGHBOURS8[Random.Int(8)];\n\t\t\t\t\t\t} while (Dungeon.level.trueDistance(pos, Dungeon.hero.pos)\n\t\t\t\t\t\t\t\t> Dungeon.level.trueDistance(pos, targetPos));\n\t\t\t\t\t}\n\t\t\t\t\ttargetedCells.add(targetPos);\n\t\t\t\t\tBallistica b = new Ballistica(pos, targetPos, Ballistica.WONT_STOP);\n\t\t\t\t\taffectedCells.addAll(b.path);\n\t\t\t\t}\n\n\t\t\t\t//remove one beam if multiple shots would cause every cell next to the hero to be targeted\n\t\t\t\tboolean allAdjTargeted = true;\n\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\t\t\tif (!affectedCells.contains(Dungeon.hero.pos + i) && Dungeon.level.passable[Dungeon.hero.pos + i]){\n\t\t\t\t\t\tallAdjTargeted = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (allAdjTargeted){\n\t\t\t\t\ttargetedCells.remove(targetedCells.size()-1);\n\t\t\t\t}\n\t\t\t\tfor (int i : targetedCells){\n\t\t\t\t\tBallistica b = new Ballistica(pos, i, Ballistica.WONT_STOP);\n\t\t\t\t\tfor (int p : b.path){\n\t\t\t\t\t\tsprite.parent.add(new TargetedCell(p, 0xFF0000));\n\t\t\t\t\t\taffectedCells.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//don't want to overly punish players with slow move or attack speed\n\t\t\t\tspend(GameMath.gate(TICK, (int)Math.ceil(Dungeon.hero.cooldown()), 3*TICK));\n\t\t\t\tDungeon.hero.interrupt();\n\n\t\t\t\tabilityCooldown += Random.NormalFloat(MIN_ABILITY_CD, MAX_ABILITY_CD);\n\t\t\t\tabilityCooldown -= (phase - 1);\n\n\t\t\t} else {\n\t\t\t\tspend(TICK);\n\t\t\t}\n\n\t\t\twhile (summonCooldown <= 0){\n\n\t\t\t\tClass<?extends Mob> cls = regularSummons.remove(0);\n\t\t\t\tMob summon = Reflection.newInstance(cls);\n\t\t\t\tregularSummons.add(cls);\n\n\t\t\t\tint spawnPos = -1;\n\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\tif (Actor.findChar(pos+i) == null){\n\t\t\t\t\t\tif (spawnPos == -1 || Dungeon.level.trueDistance(Dungeon.hero.pos, spawnPos) > Dungeon.level.trueDistance(Dungeon.hero.pos, pos+i)){\n\t\t\t\t\t\t\tspawnPos = pos + i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//if no other valid spawn spots exist, try to kill an adjacent sheep to spawn anyway\n\t\t\t\tif (spawnPos == -1){\n\t\t\t\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\tif (Actor.findChar(pos+i) instanceof Sheep){\n\t\t\t\t\t\t\tif (spawnPos == -1 || Dungeon.level.trueDistance(Dungeon.hero.pos, spawnPos) > Dungeon.level.trueDistance(Dungeon.hero.pos, pos+i)){\n\t\t\t\t\t\t\t\tspawnPos = pos + i;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (spawnPos != -1){\n\t\t\t\t\t\tActor.findChar(spawnPos).die(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPos != -1) {\n\t\t\t\t\tsummon.pos = spawnPos;\n\t\t\t\t\tGameScene.add( summon );\n\t\t\t\t\tActor.add( new Pushing( summon, pos, summon.pos ) );\n\t\t\t\t\tsummon.beckon(Dungeon.hero.pos);\n\t\t\t\t\tDungeon.level.occupyCell(summon);\n\n\t\t\t\t\tsummonCooldown += Random.NormalFloat(MIN_SUMMON_CD, MAX_SUMMON_CD);\n\t\t\t\t\tsummonCooldown -= (phase - 1);\n\t\t\t\t\tif (findFist() != null){\n\t\t\t\t\t\tsummonCooldown += MIN_SUMMON_CD - (phase - 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tif (summonCooldown > 0) summonCooldown--;\n\t\tif (abilityCooldown > 0) abilityCooldown--;\n\n\t\t//extra fast abilities and summons at the final 100 HP\n\t\tif (phase == 5 && abilityCooldown > 2){\n\t\t\tabilityCooldown = 2;\n\t\t}\n\t\tif (phase == 5 && summonCooldown > 3){\n\t\t\tsummonCooldown = 3;\n\t\t}\n\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static final String REGULAR_SUMMONS = \"regular_summons\";\n\tprivate static final String CHALLENGE_SUMMONS = \"challenges_summons\";",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_165_376_595_597_165_376"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Random.NormalIntRange( 22, 44 );\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Char.combatRoll( 22, 44 );\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (l != null){\n\t\t\t\t\tl.detach();\n\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_450_453_595_597_450_453"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected void zap() {\n\t\t\tspend( 1f );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tChar enemy = this.enemy;\n\t\t\tif (hit( this, enemy, true )) {\n\n\t\t\t\tenemy.damage( Random.NormalIntRange(10, 20), new LightBeam() );\n\t\t\t\tBuff.prolong( enemy, Blindness.class, Blindness.DURATION/2f );\n\n\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected void zap() {\n\t\t\tspend( 1f );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tChar enemy = this.enemy;\n\t\t\tif (hit( this, enemy, true )) {\n\n\t\t\t\tenemy.damage( Char.combatRoll(10, 20), new LightBeam() );\n\t\t\t\tBuff.prolong( enemy, Blindness.class, Blindness.DURATION/2f );\n\n\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (l != null){\n\t\t\t\t\tl.detach();\n\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_494_516_595_597_494_516"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected void zap() {\n\t\t\tspend( 1f );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tChar enemy = this.enemy;\n\t\t\tif (hit( this, enemy, true )) {\n\n\t\t\t\tenemy.damage( Random.NormalIntRange(10, 20), new DarkBolt() );\n\n\t\t\t\tLight l = enemy.buff(Light.class);\n\t\t\t\tif (l != null){\n\t\t\t\t\tl.weaken(50);\n\t\t\t\t}\n\n\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected void zap() {\n\t\t\tspend( 1f );\n\n\t\t\tInvisibility.dispel(this);\n\t\t\tChar enemy = this.enemy;\n\t\t\tif (hit( this, enemy, true )) {\n\n\t\t\t\tenemy.damage( Char.combatRoll(10, 20), new DarkBolt() );\n\n\t\t\t\tLight l = enemy.buff(Light.class);\n\t\t\t\tif (l != null){\n\t\t\t\t\tl.weaken(50);\n\t\t\t\t}\n\n\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (l != null){\n\t\t\t\t\tl.detach();\n\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_560_586_595_597_560_586"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Random.NormalIntRange( 18, 36 );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\treturn Char.combatRoll( 18, 36 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (l != null){\n\t\t\t\t\tl.detach();\n\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_173_176_595_597_173_176"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Random.NormalIntRange(0, 15);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\treturn super.drRoll() + Char.combatRoll(0, 15);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (l != null){\n\t\t\t\t\tl.detach();\n\t\t\t\t}",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_178_181_595_597_178_181"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int drRoll() {\n\t\tint dr = super.drRoll();\n\t\tif (hero != null && hero.belongings.weapon() != null){\n\t\t\treturn dr + Random.NormalIntRange(0, hero.belongings.weapon().defenseFactor(this)/2);\n\t\t} else {\n\t\t\treturn dr;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int drRoll() {\n\t\tint dr = super.drRoll();\n\t\tif (hero != null && hero.belongings.weapon() != null){\n\t\t\treturn dr + Char.combatRoll(0, hero.belongings.weapon().defenseFactor(this)/2);\n\t\t} else {\n\t\t\treturn dr;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_150_158_595_597_149_157"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (hero != null) {\n\t\t\treturn Random.NormalIntRange( 2 + hero.lvl/4, 4 + hero.lvl/2 );\n\t\t} else {\n\t\t\treturn Random.NormalIntRange( 2, 4 );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll() {\n\t\tif (hero != null) {\n\t\t\treturn Char.combatRoll( 2 + hero.lvl/4, 4 + hero.lvl/2 );\n\t\t} else {\n\t\t\treturn Char.combatRoll( 2, 4 );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_152_159_595_597_151_158"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int damageRoll( Char owner ) {\n\t\treturn Random.NormalIntRange( min(), max() );\n\t}",
          "sourceCodeAfterRefactoring": "public int damageRoll( Char owner ) {\n\t\treturn Char.combatRoll( min(), max() );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_227_229_595_597_226_228"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static int drRoll( Char ch, int level ){\n\t\treturn Random.NormalIntRange(\n\t\t\t\tMath.round(level * genericProcChanceMultiplier(ch)),\n\t\t\t\tMath.round((3 + (level*1.5f)) * genericProcChanceMultiplier(ch)));\n\t}",
          "sourceCodeAfterRefactoring": "public static int drRoll( Char ch, int level ){\n\t\treturn Char.combatRoll(\n\t\t\t\tMath.round(level * genericProcChanceMultiplier(ch)),\n\t\t\t\tMath.round((3 + (level*1.5f)) * genericProcChanceMultiplier(ch)));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_131_135_595_597_130_134"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int proc(int damage, Char attacker, Char defender){\n\t\t\tif (cooldown == 0){\n\t\t\t\tcharge += damage*(0.5+level()*0.05);\n\t\t\t\tif (charge >= chargeCap){\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tcooldown = 10+level();\n\t\t\t\t\tGLog.p( Messages.get(this, \"radiating\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cooldown != 0){\n\t\t\t\tint deflected = Random.NormalIntRange(0, damage);\n\t\t\t\tdamage -= deflected;\n\n\t\t\t\tif (attacker != null && Dungeon.level.adjacent(attacker.pos, defender.pos)) {\n\t\t\t\t\tattacker.damage(deflected, this);\n\t\t\t\t}\n\n\t\t\t\texp+= deflected;\n\n\t\t\t\tif (exp >= (level()+1)*5 && level() < levelCap){\n\t\t\t\t\texp -= (level()+1)*5;\n\t\t\t\t\tupgrade();\n\t\t\t\t\tGLog.p( Messages.get(this, \"levelup\") );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tupdateQuickslot();\n\t\t\treturn damage;\n\t\t}",
          "sourceCodeAfterRefactoring": "public int proc(int damage, Char attacker, Char defender){\n\t\t\tif (cooldown == 0){\n\t\t\t\tcharge += damage*(0.5+level()*0.05);\n\t\t\t\tif (charge >= chargeCap){\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tcooldown = 10+level();\n\t\t\t\t\tGLog.p( Messages.get(this, \"radiating\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cooldown != 0){\n\t\t\t\tint deflected = Char.combatRoll(0, damage);\n\t\t\t\tdamage -= deflected;\n\n\t\t\t\tif (attacker != null && Dungeon.level.adjacent(attacker.pos, defender.pos)) {\n\t\t\t\t\tattacker.damage(deflected, this);\n\t\t\t\t}\n\n\t\t\t\texp+= deflected;\n\n\t\t\t\tif (exp >= (level()+1)*5 && level() < levelCap){\n\t\t\t\t\texp -= (level()+1)*5;\n\t\t\t\t\tupgrade();\n\t\t\t\t\tGLog.p( Messages.get(this, \"levelup\") );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tupdateQuickslot();\n\t\t\treturn damage;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_92_121_595_597_91_120"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tint dmg = 0;\n\t\t\tif (rose != null && rose.weapon != null){\n\t\t\t\tdmg += rose.weapon.damageRoll(this);\n\t\t\t} else {\n\t\t\t\tdmg += Random.NormalIntRange(0, 5);\n\t\t\t}\n\t\t\t\n\t\t\treturn dmg;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\tint dmg = 0;\n\t\t\tif (rose != null && rose.weapon != null){\n\t\t\t\tdmg += rose.weapon.damageRoll(this);\n\t\t\t} else {\n\t\t\t\tdmg += Char.combatRoll(0, 5);\n\t\t\t}\n\t\t\t\n\t\t\treturn dmg;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int attackSkill(Char target) {\n\t\t\t\n\t\t\t//same accuracy as the hero.",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_621_631_595_597_621_631"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (rose != null && rose.armor != null){\n\t\t\t\tdr += Random.NormalIntRange( rose.armor.DRMin(), rose.armor.DRMax());\n\t\t\t}\n\t\t\tif (rose != null && rose.weapon != null){\n\t\t\t\tdr += Random.NormalIntRange( 0, rose.weapon.defenseFactor( this ));\n\t\t\t}\n\t\t\treturn dr;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (rose != null && rose.armor != null){\n\t\t\t\tdr += Char.combatRoll( rose.armor.DRMin(), rose.armor.DRMax());\n\t\t\t}\n\t\t\tif (rose != null && rose.weapon != null){\n\t\t\t\tdr += Char.combatRoll( 0, rose.weapon.defenseFactor( this ));\n\t\t\t}\n\t\t\treturn dr;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int attackSkill(Char target) {\n\t\t\t\n\t\t\t//same accuracy as the hero.",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_709_719_595_597_709_719"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tif (Dungeon.level.heroFOV[i]) {\n\t\t\t\t\tCellEmitter.get(i).burst(ElmoParticle.FACTORY, 10);\n\t\t\t\t}\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null){\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\t// 100%/83%/67% bomb damage based on distance, but pierces armor.\n\t\t\tint damage = Math.round(Random.NormalIntRange( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ));\n\t\t\tfloat multiplier = 1f - (.16667f*Dungeon.level.distance(cell, ch.pos));\n\t\t\tch.damage(Math.round(damage*multiplier), this);\n\t\t\tif (ch == Dungeon.hero && !ch.isAlive()){\n\t\t\t\tBadges.validateDeathFromFriendlyMagic();\n\t\t\t\tDungeon.fail(this);\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tif (Dungeon.level.heroFOV[i]) {\n\t\t\t\t\tCellEmitter.get(i).burst(ElmoParticle.FACTORY, 10);\n\t\t\t\t}\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null){\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\t// 100%/83%/67% bomb damage based on distance, but pierces armor.\n\t\t\tint damage = Math.round(Char.combatRoll( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ));\n\t\t\tfloat multiplier = 1f - (.16667f*Dungeon.level.distance(cell, ch.pos));\n\t\t\tch.damage(Math.round(damage*multiplier), this);\n\t\t\tif (ch == Dungeon.hero && !ch.isAlive()){\n\t\t\t\tBadges.validateDeathFromFriendlyMagic();\n\t\t\t\tDungeon.fail(this);\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_63_92_595_597_62_91"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\tnew Flare(10, 64).show(Dungeon.hero.sprite.parent, DungeonTilemap.tileCenterToWorld(cell), 2f);\n\t\t}\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\tif (ch.properties().contains(Char.Property.UNDEAD) || ch.properties().contains(Char.Property.DEMONIC)){\n\t\t\t\tch.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10 );\n\t\t\t\t\n\t\t\t\t//bomb deals an additional 50% damage to unholy enemies in a 5x5 range\n\t\t\t\tint damage = Math.round(Random.NormalIntRange( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ) * 0.5f);\n\t\t\t\tch.damage(damage, new HolyDamage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\tnew Flare(10, 64).show(Dungeon.hero.sprite.parent, DungeonTilemap.tileCenterToWorld(cell), 2f);\n\t\t}\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null) {\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\tif (ch.properties().contains(Char.Property.UNDEAD) || ch.properties().contains(Char.Property.DEMONIC)){\n\t\t\t\tch.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10 );\n\t\t\t\t\n\t\t\t\t//bomb deals an additional 50% damage to unholy enemies in a 5x5 range\n\t\t\t\tint damage = Math.round(Char.combatRoll( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ) * 0.5f);\n\t\t\t\tch.damage(damage, new HolyDamage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.READ );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_45_77_595_597_44_76"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 3 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE\n\t\t\t\t&& Actor.findChar(i) != null) {\n\t\t\t\taffected.add(Actor.findChar(i));\n\t\t\t}\n\t\t}\n\n\t\tfor (Char ch : affected.toArray(new Char[0])){\n\t\t\tBallistica LOS = new Ballistica(cell, ch.pos, Ballistica.PROJECTILE);\n\t\t\tif (LOS.collisionPos != ch.pos){\n\t\t\t\taffected.remove(ch);\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Lightning.Arc> arcs = new ArrayList<>();\n\t\tfor (Char ch : affected){\n\t\t\tint power = 16 - 4*Dungeon.level.distance(ch.pos, cell);\n\t\t\tif (power > 0){\n\t\t\t\t//32% to 8% regular bomb damage\n\t\t\t\tint damage = Math.round(Random.NormalIntRange(5 + Dungeon.scalingDepth(), 10 + 2*Dungeon.scalingDepth()) * (power/50f));\n\t\t\t\tch.damage(damage, this);\n\t\t\t\tif (ch.isAlive()) Buff.prolong(ch, Paralysis.class, power);\n\t\t\t\tarcs.add(new Lightning.Arc(DungeonTilemap.tileCenterToWorld(cell), ch.sprite.center()));\n\t\t\t}\n\t\t}\n\n\t\tCellEmitter.center(cell).burst(SparkParticle.FACTORY, 20);\n\t\tDungeon.hero.sprite.parent.addToFront(new Lightning(arcs, null));\n\t\tSample.INSTANCE.play( Assets.Sounds.LIGHTNING );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\tPathFinder.buildDistanceMap( cell, BArray.not( Dungeon.level.solid, null ), 3 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE\n\t\t\t\t&& Actor.findChar(i) != null) {\n\t\t\t\taffected.add(Actor.findChar(i));\n\t\t\t}\n\t\t}\n\n\t\tfor (Char ch : affected.toArray(new Char[0])){\n\t\t\tBallistica LOS = new Ballistica(cell, ch.pos, Ballistica.PROJECTILE);\n\t\t\tif (LOS.collisionPos != ch.pos){\n\t\t\t\taffected.remove(ch);\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Lightning.Arc> arcs = new ArrayList<>();\n\t\tfor (Char ch : affected){\n\t\t\tint power = 16 - 4*Dungeon.level.distance(ch.pos, cell);\n\t\t\tif (power > 0){\n\t\t\t\t//32% to 8% regular bomb damage\n\t\t\t\tint damage = Math.round(Char.combatRoll(5 + Dungeon.scalingDepth(), 10 + 2*Dungeon.scalingDepth()) * (power/50f));\n\t\t\t\tch.damage(damage, this);\n\t\t\t\tif (ch.isAlive()) Buff.prolong(ch, Paralysis.class, power);\n\t\t\t\tarcs.add(new Lightning.Arc(DungeonTilemap.tileCenterToWorld(cell), ch.sprite.center()));\n\t\t\t}\n\t\t}\n\n\t\tCellEmitter.center(cell).burst(SparkParticle.FACTORY, 20);\n\t\tDungeon.hero.sprite.parent.addToFront(new Lightning(arcs, null));\n\t\tSample.INSTANCE.play( Assets.Sounds.LIGHTNING );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_49_84_595_597_48_83"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tboolean[] FOV = new boolean[Dungeon.level.length()];\n\t\tPoint c = Dungeon.level.cellToPoint(cell);\n\t\tShadowCaster.castShadow(c.x, c.y, FOV, Dungeon.level.losBlocking, 8);\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < FOV.length; i++) {\n\t\t\tif (FOV[i]) {\n\t\t\t\tif (Dungeon.level.heroFOV[i] && !Dungeon.level.solid[i]) {\n\t\t\t\t\tCellEmitter.center( i ).burst( BlastParticle.FACTORY, 5 );\n\t\t\t\t}\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null){\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\t//regular bomb damage, which falls off at a rate of 5% per tile of distance\n\t\t\tint damage = Math.round(Random.NormalIntRange( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ));\n\t\t\tdamage = Math.round(damage * (1f - .05f*Dungeon.level.distance(cell, ch.pos)));\n\t\t\tdamage -= ch.drRoll();\n\t\t\tch.damage(damage, this);\n\t\t\tif (ch == Dungeon.hero && !ch.isAlive()) {\n\t\t\t\tDungeon.fail(this);\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void explode(int cell) {\n\t\tsuper.explode(cell);\n\t\t\n\t\tboolean[] FOV = new boolean[Dungeon.level.length()];\n\t\tPoint c = Dungeon.level.cellToPoint(cell);\n\t\tShadowCaster.castShadow(c.x, c.y, FOV, Dungeon.level.losBlocking, 8);\n\t\t\n\t\tArrayList<Char> affected = new ArrayList<>();\n\t\t\n\t\tfor (int i = 0; i < FOV.length; i++) {\n\t\t\tif (FOV[i]) {\n\t\t\t\tif (Dungeon.level.heroFOV[i] && !Dungeon.level.solid[i]) {\n\t\t\t\t\tCellEmitter.center( i ).burst( BlastParticle.FACTORY, 5 );\n\t\t\t\t}\n\t\t\t\tChar ch = Actor.findChar(i);\n\t\t\t\tif (ch != null){\n\t\t\t\t\taffected.add(ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (Char ch : affected){\n\t\t\t//regular bomb damage, which falls off at a rate of 5% per tile of distance\n\t\t\tint damage = Math.round(Char.combatRoll( Dungeon.scalingDepth()+5, 10 + Dungeon.scalingDepth() * 2 ));\n\t\t\tdamage = Math.round(damage * (1f - .05f*Dungeon.level.distance(cell, ch.pos)));\n\t\t\tdamage -= ch.drRoll();\n\t\t\tch.damage(damage, this);\n\t\t\tif (ch == Dungeon.hero && !ch.isAlive()) {\n\t\t\t\tDungeon.fail(this);\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_47_79_595_597_46_78"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static int damageRoll( Hero hero ){\n\t\tif (hero.buff(Force.class) != null\n\t\t\t\t&& hero.buff(MonkEnergy.MonkAbility.UnarmedAbilityTracker.class) == null) {\n\t\t\tint level = getBuffedBonus(hero, Force.class);\n\t\t\tfloat tier = tier(hero.STR());\n\t\t\treturn Random.NormalIntRange(min(level, tier), max(level, tier));\n\t\t} else {\n\t\t\t//attack without any ring of force influence\n\t\t\treturn Random.NormalIntRange(1, Math.max(hero.STR()-8, 1));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static int damageRoll( Hero hero ){\n\t\tif (hero.buff(Force.class) != null\n\t\t\t\t&& hero.buff(MonkEnergy.MonkAbility.UnarmedAbilityTracker.class) == null) {\n\t\t\tint level = getBuffedBonus(hero, Force.class);\n\t\t\tfloat tier = tier(hero.STR());\n\t\t\treturn Char.combatRoll(min(level, tier), max(level, tier));\n\t\t} else {\n\t\t\t//attack without any ring of force influence\n\t\t\treturn Char.combatRoll(1, Math.max(hero.STR()-8, 1));\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_80_90_595_597_79_89"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int damageRoll(int lvl){\n\t\tint dmg = Random.NormalIntRange(min(lvl), max(lvl));\n\t\tWandEmpower emp = Dungeon.hero.buff(WandEmpower.class);\n\t\tif (emp != null){\n\t\t\tdmg += emp.dmgBoost;\n\t\t\temp.left--;\n\t\t\tif (emp.left <= 0) {\n\t\t\t\temp.detach();\n\t\t\t}\n\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG, 0.75f, 1.2f);\n\t\t}\n\t\treturn dmg;\n\t}",
          "sourceCodeAfterRefactoring": "public int damageRoll(int lvl){\n\t\tint dmg = Char.combatRoll(min(lvl), max(lvl));\n\t\tWandEmpower emp = Dungeon.hero.buff(WandEmpower.class);\n\t\tif (emp != null){\n\t\t\tdmg += emp.dmgBoost;\n\t\t\temp.left--;\n\t\t\tif (emp.left <= 0) {\n\t\t\t\temp.detach();\n\t\t\t}\n\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG, 0.75f, 1.2f);\n\t\t}\n\t\treturn dmg;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_63_595_597_51_63"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void throwChar(final Char ch, final Ballistica trajectory, int power,\n\t                             boolean closeDoors, boolean collideDmg, Object cause){\n\t\tif (ch.properties().contains(Char.Property.BOSS)) {\n\t\t\tpower = (power+1)/2;\n\t\t}\n\n\t\tint dist = Math.min(trajectory.dist, power);\n\n\t\tboolean collided = dist == trajectory.dist;\n\n\t\tif (dist <= 0\n\t\t\t\t|| ch.rooted\n\t\t\t\t|| ch.properties().contains(Char.Property.IMMOVABLE)) return;\n\n\t\t//large characters cannot be moved into non-open space\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)) {\n\t\t\tfor (int i = 1; i <= dist; i++) {\n\t\t\t\tif (!Dungeon.level.openSpace[trajectory.path.get(i)]){\n\t\t\t\t\tdist = i-1;\n\t\t\t\t\tcollided = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Actor.findChar(trajectory.path.get(dist)) != null){\n\t\t\tdist--;\n\t\t\tcollided = true;\n\t\t}\n\n\t\tif (dist < 0) return;\n\n\t\tfinal int newPos = trajectory.path.get(dist);\n\n\t\tif (newPos == ch.pos) return;\n\n\t\tfinal int finalDist = dist;\n\t\tfinal boolean finalCollided = collided && collideDmg;\n\t\tfinal int initialpos = ch.pos;\n\n\t\tActor.add(new Pushing(ch, ch.pos, newPos, new Callback() {\n\t\t\tpublic void call() {\n\t\t\t\tif (initialpos != ch.pos || Actor.findChar(newPos) != null) {\n\t\t\t\t\t//something caused movement or added chars before pushing resolved, cancel to be safe.\n\t\t\t\t\tch.sprite.place(ch.pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint oldPos = ch.pos;\n\t\t\t\tch.pos = newPos;\n\t\t\t\tif (finalCollided && ch.isActive()) {\n\t\t\t\t\tch.damage(Random.NormalIntRange(finalDist, 2*finalDist), new Knockback());\n\t\t\t\t\tif (ch.isActive()) {\n\t\t\t\t\t\tParalysis.prolong(ch, Paralysis.class, 1 + finalDist/2f);\n\t\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\t\tif (cause instanceof WandOfBlastWave){\n\t\t\t\t\t\t\tBadges.validateDeathFromFriendlyMagic();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDungeon.fail(cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (closeDoors && Dungeon.level.map[oldPos] == Terrain.OPEN_DOOR){\n\t\t\t\t\tDoor.leave(oldPos);\n\t\t\t\t}\n\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t\tGameScene.updateFog();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}",
          "sourceCodeAfterRefactoring": "public static void throwChar(final Char ch, final Ballistica trajectory, int power,\n\t                             boolean closeDoors, boolean collideDmg, Object cause){\n\t\tif (ch.properties().contains(Char.Property.BOSS)) {\n\t\t\tpower = (power+1)/2;\n\t\t}\n\n\t\tint dist = Math.min(trajectory.dist, power);\n\n\t\tboolean collided = dist == trajectory.dist;\n\n\t\tif (dist <= 0\n\t\t\t\t|| ch.rooted\n\t\t\t\t|| ch.properties().contains(Char.Property.IMMOVABLE)) return;\n\n\t\t//large characters cannot be moved into non-open space\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)) {\n\t\t\tfor (int i = 1; i <= dist; i++) {\n\t\t\t\tif (!Dungeon.level.openSpace[trajectory.path.get(i)]){\n\t\t\t\t\tdist = i-1;\n\t\t\t\t\tcollided = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Actor.findChar(trajectory.path.get(dist)) != null){\n\t\t\tdist--;\n\t\t\tcollided = true;\n\t\t}\n\n\t\tif (dist < 0) return;\n\n\t\tfinal int newPos = trajectory.path.get(dist);\n\n\t\tif (newPos == ch.pos) return;\n\n\t\tfinal int finalDist = dist;\n\t\tfinal boolean finalCollided = collided && collideDmg;\n\t\tfinal int initialpos = ch.pos;\n\n\t\tActor.add(new Pushing(ch, ch.pos, newPos, new Callback() {\n\t\t\tpublic void call() {\n\t\t\t\tif (initialpos != ch.pos || Actor.findChar(newPos) != null) {\n\t\t\t\t\t//something caused movement or added chars before pushing resolved, cancel to be safe.\n\t\t\t\t\tch.sprite.place(ch.pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint oldPos = ch.pos;\n\t\t\t\tch.pos = newPos;\n\t\t\t\tif (finalCollided && ch.isActive()) {\n\t\t\t\t\tch.damage(Char.combatRoll(finalDist, 2*finalDist), new Knockback());\n\t\t\t\t\tif (ch.isActive()) {\n\t\t\t\t\t\tParalysis.prolong(ch, Paralysis.class, 1 + finalDist/2f);\n\t\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\t\tif (cause instanceof WandOfBlastWave){\n\t\t\t\t\t\t\tBadges.validateDeathFromFriendlyMagic();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDungeon.fail(cause);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (closeDoors && Dungeon.level.map[oldPos] == Terrain.OPEN_DOOR){\n\t\t\t\t\tDoor.leave(oldPos);\n\t\t\t\t}\n\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t\tGameScene.updateFog();\n\t\t\t\t}\n\t\t\t}\n\t\t}));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_111_181_595_597_111_181"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Random.NormalIntRange(2, 4 + Dungeon.scalingDepth()/2);\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int damageRoll() {\n\t\t\treturn Char.combatRoll(2, 4 + Dungeon.scalingDepth()/2);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_354_357_595_597_354_357"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (Dungeon.isChallenged(Challenges.NO_ARMOR)){\n\t\t\t\treturn dr + Random.NormalIntRange(wandLevel, 2 + wandLevel);\n\t\t\t} else {\n\t\t\t\treturn dr + Random.NormalIntRange(wandLevel, 3 + 3 * wandLevel);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (Dungeon.isChallenged(Challenges.NO_ARMOR)){\n\t\t\t\treturn dr + Char.combatRoll(wandLevel, 2 + wandLevel);\n\t\t\t} else {\n\t\t\t\treturn dr + Char.combatRoll(wandLevel, 3 + 3 * wandLevel);\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_359_367_595_597_359_367"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onZap(Ballistica beam) {\n\n\t\tfor (int c : beam.subPath(0, beam.dist))\n\t\t\tCellEmitter.center(c).burst( BloodParticle.BURST, 1 );\n\n\t\tint cell = beam.collisionPos;\n\n\t\tChar ch = Actor.findChar(cell);\n\n\t\tif (ch instanceof Mob){\n\t\t\t\n\t\t\twandProc(ch, chargesPerCast());\n\t\t\t\n\t\t\t//this wand does different things depending on the target.\n\t\t\t\n\t\t\t//heals/shields an ally or a charmed enemy while damaging self\n\t\t\tif (ch.alignment == Char.Alignment.ALLY || ch.buff(Charm.class) != null){\n\t\t\t\t\n\t\t\t\t// 5% of max hp\n\t\t\t\tint selfDmg = Math.round(curUser.HT*0.05f);\n\t\t\t\t\n\t\t\t\tint healing = selfDmg + 3*buffedLvl();\n\t\t\t\tint shielding = (ch.HP + healing) - ch.HT;\n\t\t\t\tif (shielding > 0){\n\t\t\t\t\thealing -= shielding;\n\t\t\t\t\tBuff.affect(ch, Barrier.class).setShield(shielding);\n\t\t\t\t} else {\n\t\t\t\t\tshielding = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tch.HP += healing;\n\t\t\t\t\n\t\t\t\tch.sprite.emitter().burst(Speck.factory(Speck.HEALING), 2 + buffedLvl() / 2);\n\t\t\t\tif (healing > 0) {\n\t\t\t\t\tch.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(healing), FloatingText.HEALING);\n\t\t\t\t}\n\t\t\t\tif (shielding > 0){\n\t\t\t\t\tch.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(shielding), FloatingText.SHIELDING);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!freeCharge) {\n\t\t\t\t\tdamageHero(selfDmg);\n\t\t\t\t} else {\n\t\t\t\t\tfreeCharge = false;\n\t\t\t\t}\n\n\t\t\t//for enemies...\n\t\t\t//(or for mimics which are hiding, special case)\n\t\t\t} else if (ch.alignment == Char.Alignment.ENEMY || ch instanceof Mimic) {\n\n\t\t\t\t//grant a self-shield, and...\n\t\t\t\tBuff.affect(curUser, Barrier.class).setShield((5 + buffedLvl()));\n\t\t\t\tcurUser.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(5+buffedLvl()), FloatingText.SHIELDING);\n\t\t\t\t\n\t\t\t\t//charms living enemies\n\t\t\t\tif (!ch.properties().contains(Char.Property.UNDEAD)) {\n\t\t\t\t\tCharm charm = Buff.affect(ch, Charm.class, Charm.DURATION/2f);\n\t\t\t\t\tcharm.object = curUser.id();\n\t\t\t\t\tcharm.ignoreHeroAllies = true;\n\t\t\t\t\tch.sprite.centerEmitter().start( Speck.factory( Speck.HEART ), 0.2f, 3 );\n\t\t\t\t\n\t\t\t\t//harms the undead\n\t\t\t\t} else {\n\t\t\t\t\tch.damage(Random.NormalIntRange(3 + buffedLvl(), 6+2*buffedLvl()), this);\n\t\t\t\t\tch.sprite.emitter().start(ShadowParticle.UP, 0.05f, 10 + buffedLvl());\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onZap(Ballistica beam) {\n\n\t\tfor (int c : beam.subPath(0, beam.dist))\n\t\t\tCellEmitter.center(c).burst( BloodParticle.BURST, 1 );\n\n\t\tint cell = beam.collisionPos;\n\n\t\tChar ch = Actor.findChar(cell);\n\n\t\tif (ch instanceof Mob){\n\t\t\t\n\t\t\twandProc(ch, chargesPerCast());\n\t\t\t\n\t\t\t//this wand does different things depending on the target.\n\t\t\t\n\t\t\t//heals/shields an ally or a charmed enemy while damaging self\n\t\t\tif (ch.alignment == Char.Alignment.ALLY || ch.buff(Charm.class) != null){\n\t\t\t\t\n\t\t\t\t// 5% of max hp\n\t\t\t\tint selfDmg = Math.round(curUser.HT*0.05f);\n\t\t\t\t\n\t\t\t\tint healing = selfDmg + 3*buffedLvl();\n\t\t\t\tint shielding = (ch.HP + healing) - ch.HT;\n\t\t\t\tif (shielding > 0){\n\t\t\t\t\thealing -= shielding;\n\t\t\t\t\tBuff.affect(ch, Barrier.class).setShield(shielding);\n\t\t\t\t} else {\n\t\t\t\t\tshielding = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tch.HP += healing;\n\t\t\t\t\n\t\t\t\tch.sprite.emitter().burst(Speck.factory(Speck.HEALING), 2 + buffedLvl() / 2);\n\t\t\t\tif (healing > 0) {\n\t\t\t\t\tch.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(healing), FloatingText.HEALING);\n\t\t\t\t}\n\t\t\t\tif (shielding > 0){\n\t\t\t\t\tch.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(shielding), FloatingText.SHIELDING);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!freeCharge) {\n\t\t\t\t\tdamageHero(selfDmg);\n\t\t\t\t} else {\n\t\t\t\t\tfreeCharge = false;\n\t\t\t\t}\n\n\t\t\t//for enemies...\n\t\t\t//(or for mimics which are hiding, special case)\n\t\t\t} else if (ch.alignment == Char.Alignment.ENEMY || ch instanceof Mimic) {\n\n\t\t\t\t//grant a self-shield, and...\n\t\t\t\tBuff.affect(curUser, Barrier.class).setShield((5 + buffedLvl()));\n\t\t\t\tcurUser.sprite.showStatusWithIcon(CharSprite.POSITIVE, Integer.toString(5+buffedLvl()), FloatingText.SHIELDING);\n\t\t\t\t\n\t\t\t\t//charms living enemies\n\t\t\t\tif (!ch.properties().contains(Char.Property.UNDEAD)) {\n\t\t\t\t\tCharm charm = Buff.affect(ch, Charm.class, Charm.DURATION/2f);\n\t\t\t\t\tcharm.object = curUser.id();\n\t\t\t\t\tcharm.ignoreHeroAllies = true;\n\t\t\t\t\tch.sprite.centerEmitter().start( Speck.factory( Speck.HEART ), 0.2f, 3 );\n\t\t\t\t\n\t\t\t\t//harms the undead\n\t\t\t\t} else {\n\t\t\t\t\tch.damage(Char.combatRoll(3 + buffedLvl(), 6+2*buffedLvl()), this);\n\t\t\t\t\tch.sprite.emitter().start(ShadowParticle.UP, 0.05f, 10 + buffedLvl());\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_63_136_595_597_63_136"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (tier > 3){\n\t\t\t\treturn dr + Math.round(Random.NormalIntRange(0, 3 + Dungeon.scalingDepth()/2) / (7f - tier));\n\t\t\t} else {\n\t\t\t\treturn dr;\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int drRoll() {\n\t\t\tint dr = super.drRoll();\n\t\t\tif (tier > 3){\n\t\t\t\treturn dr + Math.round(Char.combatRoll(0, 3 + Dungeon.scalingDepth()/2) / (7f - tier));\n\t\t\t} else {\n\t\t\t\treturn dr;\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_303_311_595_597_303_311"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\tint level = Math.max( 0, weapon.buffedLvl() );\n\n\t\t// lvl 0 - 33%\n\t\t// lvl 1 - 50%\n\t\t// lvl 2 - 60%\n\t\tfloat procChance = (level+1f)/(level+3f) * procChanceMultiplier(attacker);\n\t\tif (Random.Float() < procChance) {\n\n\t\t\tfloat powerMulti = Math.max(1f, procChance);\n\n\t\t\tif (defender.buff(Burning.class) == null){\n\t\t\t\tBuff.affect(defender, Burning.class).reignite(defender, 8f);\n\t\t\t\tpowerMulti -= 1;\n\t\t\t}\n\n\t\t\tif (powerMulti > 0){\n\t\t\t\tint burnDamage = Random.NormalIntRange( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\t\tburnDamage = Math.round(burnDamage * 0.67f * powerMulti);\n\t\t\t\tif (burnDamage > 0) {\n\t\t\t\t\tdefender.damage(burnDamage, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdefender.sprite.emitter().burst( FlameParticle.FACTORY, level + 1 );\n\t\t\t\n\t\t}\n\n\t\treturn damage;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\tint level = Math.max( 0, weapon.buffedLvl() );\n\n\t\t// lvl 0 - 33%\n\t\t// lvl 1 - 50%\n\t\t// lvl 2 - 60%\n\t\tfloat procChance = (level+1f)/(level+3f) * procChanceMultiplier(attacker);\n\t\tif (Random.Float() < procChance) {\n\n\t\t\tfloat powerMulti = Math.max(1f, procChance);\n\n\t\t\tif (defender.buff(Burning.class) == null){\n\t\t\t\tBuff.affect(defender, Burning.class).reignite(defender, 8f);\n\t\t\t\tpowerMulti -= 1;\n\t\t\t}\n\n\t\t\tif (powerMulti > 0){\n\t\t\t\tint burnDamage = Char.combatRoll( 1, 3 + Dungeon.scalingDepth()/4 );\n\t\t\t\tburnDamage = Math.round(burnDamage * 0.67f * powerMulti);\n\t\t\t\tif (burnDamage > 0) {\n\t\t\t\t\tdefender.damage(burnDamage, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdefender.sprite.emitter().burst( FlameParticle.FACTORY, level + 1 );\n\t\t\t\n\t\t}\n\n\t\treturn damage;\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_38_69_595_597_38_69"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 50% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Random.NormalIntRange(\n\t\t\t\t\t\tmin() + Math.round(diff*0.50f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Random.IntRange(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 50% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Char.combatRoll(\n\t\t\t\t\t\tmin() + Math.round(diff*0.50f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Char.combatRoll(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_48_67_595_597_47_66"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 75% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Random.NormalIntRange(\n\t\t\t\t\t\tmin() + Math.round(diff*0.75f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Random.IntRange(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 75% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Char.combatRoll(\n\t\t\t\t\t\tmin() + Math.round(diff*0.75f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Char.combatRoll(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_62_81_595_597_61_80"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 67% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Random.NormalIntRange(\n\t\t\t\t\t\tmin() + Math.round(diff*0.67f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Random.IntRange(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 67% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Char.combatRoll(\n\t\t\t\t\t\tmin() + Math.round(diff*0.67f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Char.combatRoll(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_48_67_595_597_47_66"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 60% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Random.NormalIntRange(\n\t\t\t\t\t\tmin() + Math.round(diff*0.6f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Random.IntRange(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 60% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Char.combatRoll(\n\t\t\t\t\t\tmin() + Math.round(diff*0.6f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Char.combatRoll(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_51_69_595_597_50_68"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 75% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Random.NormalIntRange(\n\t\t\t\t\t\tmin() + Math.round(diff*0.75f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Random.IntRange(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int damageRoll(Char owner) {\n\t\tif (owner instanceof Hero) {\n\t\t\tHero hero = (Hero)owner;\n\t\t\tChar enemy = hero.enemy();\n\t\t\tif (enemy instanceof Mob && ((Mob) enemy).surprisedBy(hero)) {\n\t\t\t\t//deals 75% toward max to max on surprise, instead of min to max.\n\t\t\t\tint diff = max() - min();\n\t\t\t\tint damage = augment.damageFactor(Char.combatRoll(\n\t\t\t\t\t\tmin() + Math.round(diff*0.75f),\n\t\t\t\t\t\tmax()));\n\t\t\t\tint exStr = hero.STR() - STRReq();\n\t\t\t\tif (exStr > 0) {\n\t\t\t\t\tdamage += Char.combatRoll(0, exStr);\n\t\t\t\t}\n\t\t\t\treturn damage;\n\t\t\t}\n\t\t}\n\t\treturn super.damageRoll(owner);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_50_69_595_597_49_68"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int proc(Char attacker, Char defender, int damage) {\n\n\t\t//do nothing to the hero when processing charged shot\n\t\tif (processingChargedShot && defender == attacker){\n\t\t\treturn super.proc(attacker, defender, damage);\n\t\t}\n\n\t\tif (attacker.alignment == defender.alignment){\n\t\t\tBuff.affect(defender, Bless.class, Math.round(Bless.DURATION));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (Char.hasProp(defender, Char.Property.UNDEAD) || Char.hasProp(defender, Char.Property.DEMONIC)){\n\t\t\tdefender.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10+buffedLvl() );\n\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\tdefender.damage(Random.NormalIntRange(10 + Dungeon.scalingDepth()/3, 20 + Dungeon.scalingDepth()/3), this);\n\t\t//also do not bless enemies if processing charged shot\n\t\t} else if (!processingChargedShot){\n\t\t\tBuff.affect(defender, Bless.class, Math.round(Bless.DURATION));\n\t\t}\n\t\t\n\t\treturn super.proc(attacker, defender, damage);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int proc(Char attacker, Char defender, int damage) {\n\n\t\t//do nothing to the hero when processing charged shot\n\t\tif (processingChargedShot && defender == attacker){\n\t\t\treturn super.proc(attacker, defender, damage);\n\t\t}\n\n\t\tif (attacker.alignment == defender.alignment){\n\t\t\tBuff.affect(defender, Bless.class, Math.round(Bless.DURATION));\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (Char.hasProp(defender, Char.Property.UNDEAD) || Char.hasProp(defender, Char.Property.DEMONIC)){\n\t\t\tdefender.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10+buffedLvl() );\n\t\t\tSample.INSTANCE.play(Assets.Sounds.BURNING);\n\t\t\tdefender.damage(Char.combatRoll(10 + Dungeon.scalingDepth()/3, 20 + Dungeon.scalingDepth()/3), this);\n\t\t//also do not bless enemies if processing charged shot\n\t\t} else if (!processingChargedShot){\n\t\t\tBuff.affect(defender, Bless.class, Math.round(Bless.DURATION));\n\t\t}\n\t\t\n\t\treturn super.proc(attacker, defender, damage);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_40_63_595_597_39_62"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int proc(Char attacker, Char defender, int damage) {\n\n\t\t//when processing charged shot, only shock enemies\n\t\tif (!processingChargedShot || attacker.alignment != defender.alignment) {\n\t\t\tdefender.damage(Random.NormalIntRange(5 + Dungeon.scalingDepth() / 4, 10 + Dungeon.scalingDepth() / 4), new Electricity());\n\n\t\t\tCharSprite s = defender.sprite;\n\t\t\tif (s != null && s.parent != null) {\n\t\t\t\tArrayList<Lightning.Arc> arcs = new ArrayList<>();\n\t\t\t\tarcs.add(new Lightning.Arc(new PointF(s.x, s.y + s.height / 2), new PointF(s.x + s.width, s.y + s.height / 2)));\n\t\t\t\tarcs.add(new Lightning.Arc(new PointF(s.x + s.width / 2, s.y), new PointF(s.x + s.width / 2, s.y + s.height)));\n\t\t\t\ts.parent.add(new Lightning(arcs, null));\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.LIGHTNING);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn super.proc(attacker, defender, damage);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int proc(Char attacker, Char defender, int damage) {\n\n\t\t//when processing charged shot, only shock enemies\n\t\tif (!processingChargedShot || attacker.alignment != defender.alignment) {\n\t\t\tdefender.damage(Char.combatRoll(5 + Dungeon.scalingDepth() / 4, 10 + Dungeon.scalingDepth() / 4), new Electricity());\n\n\t\t\tCharSprite s = defender.sprite;\n\t\t\tif (s != null && s.parent != null) {\n\t\t\t\tArrayList<Lightning.Arc> arcs = new ArrayList<>();\n\t\t\t\tarcs.add(new Lightning.Arc(new PointF(s.x, s.y + s.height / 2), new PointF(s.x + s.width, s.y + s.height / 2)));\n\t\t\t\tarcs.add(new Lightning.Arc(new PointF(s.x + s.width / 2, s.y), new PointF(s.x + s.width / 2, s.y + s.height)));\n\t\t\t\ts.parent.add(new Lightning(arcs, null));\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.LIGHTNING);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn super.proc(attacker, defender, damage);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_43_61_595_597_42_60"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected void evolve() {\n\t\t\tfor (int cell = 0; cell < Dungeon.level.length(); cell++) {\n\t\t\t\tif (Dungeon.level.insideMap(cell)) {\n\t\t\t\t\toff[cell] = cur[cell];\n\n\t\t\t\t\t//instantly spreads to water cells\n\t\t\t\t\tif (off[cell] == 0 && Dungeon.level.water[cell]){\n\t\t\t\t\t\toff[cell]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tvolume += off[cell];\n\n\t\t\t\t\tif (off[cell] > 0){\n\n\t\t\t\t\t\tChar ch = Actor.findChar(cell);\n\t\t\t\t\t\tif (ch != null && !(ch instanceof DM300) && !ch.flying) {\n\t\t\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.LIGHTNING );\n\t\t\t\t\t\t\tch.damage( Random.NormalIntRange(6, 12), new Electricity());\n\t\t\t\t\t\t\tch.sprite.flash();\n\n\t\t\t\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t\t\t\tif (energySourceSprite != null && energySourceSprite instanceof PylonSprite){\n\t\t\t\t\t\t\t\t\t//took damage while DM-300 was supercharged\n\t\t\t\t\t\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatistics.bossScores[2] -= 200;\n\t\t\t\t\t\t\t\tif ( !ch.isAlive()) {\n\t\t\t\t\t\t\t\t\tDungeon.fail(DM300.class);\n\t\t\t\t\t\t\t\t\tGLog.n(Messages.get(Electricity.class, \"ondeath\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected void evolve() {\n\t\t\tfor (int cell = 0; cell < Dungeon.level.length(); cell++) {\n\t\t\t\tif (Dungeon.level.insideMap(cell)) {\n\t\t\t\t\toff[cell] = cur[cell];\n\n\t\t\t\t\t//instantly spreads to water cells\n\t\t\t\t\tif (off[cell] == 0 && Dungeon.level.water[cell]){\n\t\t\t\t\t\toff[cell]++;\n\t\t\t\t\t}\n\n\t\t\t\t\tvolume += off[cell];\n\n\t\t\t\t\tif (off[cell] > 0){\n\n\t\t\t\t\t\tChar ch = Actor.findChar(cell);\n\t\t\t\t\t\tif (ch != null && !(ch instanceof DM300) && !ch.flying) {\n\t\t\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.LIGHTNING );\n\t\t\t\t\t\t\tch.damage( Char.combatRoll(6, 12), new Electricity());\n\t\t\t\t\t\t\tch.sprite.flash();\n\n\t\t\t\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t\t\t\tif (energySourceSprite != null && energySourceSprite instanceof PylonSprite){\n\t\t\t\t\t\t\t\t\t//took damage while DM-300 was supercharged\n\t\t\t\t\t\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tStatistics.bossScores[2] -= 200;\n\t\t\t\t\t\t\t\tif ( !ch.isAlive()) {\n\t\t\t\t\t\t\t\t\tDungeon.fail(DM300.class);\n\t\t\t\t\t\t\t\t\tGLog.n(Messages.get(Electricity.class, \"ondeath\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\ncorner3,\n\t\t\tcorner4\n\t};",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_812_848_595_597_812_848"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void heroLand() {\n\t\t\n\t\tHero hero = Dungeon.hero;\n\t\t\n\t\tElixirOfFeatherFall.FeatherBuff b = hero.buff(ElixirOfFeatherFall.FeatherBuff.class);\n\t\t\n\t\tif (b != null){\n\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.JET ), 20);\n\t\t\tb.detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tPixelScene.shake( 4, 1f );\n\n\t\tDungeon.level.occupyCell(hero );\n\t\tBuff.prolong( hero, Cripple.class, Cripple.DURATION );\n\n\t\t//The lower the hero's HP, the more bleed and the less upfront damage.\n\t\t//Hero has a 50% chance to bleed out at 66% HP, and begins to risk instant-death at 25%\n\t\tBuff.affect( hero, Bleeding.class).set( Math.round(hero.HT / (6f + (6f*(hero.HP/(float)hero.HT)))), Chasm.class);\n\t\thero.damage( Math.max( hero.HP / 2, Random.NormalIntRange( hero.HP / 2, hero.HT / 4 )), new Chasm() );\n\t}",
          "sourceCodeAfterRefactoring": "public static void heroLand() {\n\t\t\n\t\tHero hero = Dungeon.hero;\n\t\t\n\t\tElixirOfFeatherFall.FeatherBuff b = hero.buff(ElixirOfFeatherFall.FeatherBuff.class);\n\t\t\n\t\tif (b != null){\n\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.JET ), 20);\n\t\t\tb.detach();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tPixelScene.shake( 4, 1f );\n\n\t\tDungeon.level.occupyCell(hero );\n\t\tBuff.prolong( hero, Cripple.class, Cripple.DURATION );\n\n\t\t//The lower the hero's HP, the more bleed and the less upfront damage.\n\t\t//Hero has a 50% chance to bleed out at 66% HP, and begins to risk instant-death at 25%\n\t\tBuff.affect( hero, Bleeding.class).set( Math.round(hero.HT / (6f + (6f*(hero.HP/(float)hero.HT)))), Chasm.class);\n\t\thero.damage( Math.max( hero.HP / 2, Char.combatRoll( hero.HP / 2, hero.HT / 4 )), new Chasm() );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_129_150_595_597_129_150"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void onZapComplete(){\n\t\t\tif (hit(this, Dungeon.hero, true)) {\n\t\t\t\tDungeon.hero.damage(Random.NormalIntRange(2 + Dungeon.depth / 2, 4 + Dungeon.depth), new Eye.DeathGaze());\n\t\t\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\tGLog.n(Messages.capitalize(Messages.get(Char.class, \"kill\", name())));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDungeon.hero.sprite.showStatus( CharSprite.NEUTRAL,  Dungeon.hero.defenseVerb() );\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "public void onZapComplete(){\n\t\t\tif (hit(this, Dungeon.hero, true)) {\n\t\t\t\tDungeon.hero.damage(Char.combatRoll(2 + Dungeon.depth / 2, 4 + Dungeon.depth), new Eye.DeathGaze());\n\t\t\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\t\t\tBadges.validateDeathFromEnemyMagic();\n\t\t\t\t\tDungeon.fail(this);\n\t\t\t\t\tGLog.n(Messages.capitalize(Messages.get(Char.class, \"kill\", name())));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDungeon.hero.sprite.showStatus( CharSprite.NEUTRAL,  Dungeon.hero.defenseVerb() );\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_278_289_595_597_278_289"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\t\tChar target = Actor.findChar(pos);\n\t\t\n\t\t//find the closest char that can be aimed at\n\t\tif (target == null){\n\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\tif (bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\ttarget = ch;\n\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tHeap heap = Dungeon.level.heaps.get(pos);\n\t\tif (heap != null) heap.explode();\n\t\t\n\t\tif (target != null) {\n\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.RAY);\n\t\t\t\tShatteredPixelDungeon.scene().add(new Beam.DeathRay(DungeonTilemap.tileCenterToWorld(pos), target.sprite.center()));\n\t\t\t}\n\t\t\ttarget.damage( Random.NormalIntRange(30, 50) + scalingDepth(), this );\n\t\t\tif (target == Dungeon.hero){\n\t\t\t\tHero hero = (Hero)target;\n\t\t\t\tif (!hero.isAlive()){\n\t\t\t\t\tBadges.validateDeathFromGrimOrDisintTrap();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\t\tChar target = Actor.findChar(pos);\n\t\t\n\t\t//find the closest char that can be aimed at\n\t\tif (target == null){\n\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\tif (bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\ttarget = ch;\n\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tHeap heap = Dungeon.level.heaps.get(pos);\n\t\tif (heap != null) heap.explode();\n\t\t\n\t\tif (target != null) {\n\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.RAY);\n\t\t\t\tShatteredPixelDungeon.scene().add(new Beam.DeathRay(DungeonTilemap.tileCenterToWorld(pos), target.sprite.center()));\n\t\t\t}\n\t\t\ttarget.damage( Char.combatRoll(30, 50) + scalingDepth(), this );\n\t\t\tif (target == Dungeon.hero){\n\t\t\t\tHero hero = (Hero)target;\n\t\t\t\tif (!hero.isAlive()){\n\t\t\t\t\tBadges.validateDeathFromGrimOrDisintTrap();\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_50_88_595_597_49_87"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\n\t\tArrayList<Integer> rockCells = new ArrayList<>();\n\n\t\t//drop rocks in a 5x5 grid, ignoring cells next to barricades\n\t\tPathFinder.buildDistanceMap( pos, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tif (Dungeon.level instanceof MiningLevel){\n\t\t\t\t\tboolean barricade = false;\n\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tif (Dungeon.level.map[i+j] == Terrain.BARRICADE){\n\t\t\t\t\t\t\tbarricade = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (barricade) continue;\n\t\t\t\t}\n\t\t\t\trockCells.add(i);\n\t\t\t}\n\t\t}\n\n\t\tboolean seen = false;\n\t\tfor (int cell : rockCells){\n\n\t\t\tif (Dungeon.level.heroFOV[ cell ]){\n\t\t\t\tCellEmitter.get( cell - Dungeon.level.width() ).start(Speck.factory(Speck.ROCK), 0.07f, 10);\n\t\t\t\tseen = true;\n\t\t\t}\n\n\t\t\tChar ch = Actor.findChar( cell );\n\n\t\t\tif (ch != null && ch.isAlive() && !(ch instanceof GnollGeomancer)){\n\t\t\t\t//deals notably less damage than a regular rockfall trap, but ignores armor\n\t\t\t\tint damage = Random.NormalIntRange(6, 12);\n\t\t\t\tch.damage( Math.max(damage, 0) , this);\n\n\t\t\t\t//guards take full paralysis, otherwise just a little\n\t\t\t\tBuff.prolong(ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3);\n\n\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t} else if (ch == null\n\t\t\t\t\t&& Dungeon.level instanceof MiningLevel\n\t\t\t\t\t&& Dungeon.level.traps.get(cell) == null\n\t\t\t\t\t&& Dungeon.level.plants.get(cell) == null\n\t\t\t\t\t&& Random.Int(2) == 0){\n\t\t\t\tLevel.set( cell, Terrain.MINE_BOULDER );\n\t\t\t\tGameScene.updateMap(cell);\n\t\t\t}\n\t\t}\n\n\t\tif (seen){\n\t\t\tPixelScene.shake(3, 0.7f);\n\t\t\tSample.INSTANCE.play(Assets.Sounds.ROCKS);\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\n\t\tArrayList<Integer> rockCells = new ArrayList<>();\n\n\t\t//drop rocks in a 5x5 grid, ignoring cells next to barricades\n\t\tPathFinder.buildDistanceMap( pos, BArray.not( Dungeon.level.solid, null ), 2 );\n\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\t\t\t\tif (Dungeon.level instanceof MiningLevel){\n\t\t\t\t\tboolean barricade = false;\n\t\t\t\t\tfor (int j : PathFinder.NEIGHBOURS9){\n\t\t\t\t\t\tif (Dungeon.level.map[i+j] == Terrain.BARRICADE){\n\t\t\t\t\t\t\tbarricade = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (barricade) continue;\n\t\t\t\t}\n\t\t\t\trockCells.add(i);\n\t\t\t}\n\t\t}\n\n\t\tboolean seen = false;\n\t\tfor (int cell : rockCells){\n\n\t\t\tif (Dungeon.level.heroFOV[ cell ]){\n\t\t\t\tCellEmitter.get( cell - Dungeon.level.width() ).start(Speck.factory(Speck.ROCK), 0.07f, 10);\n\t\t\t\tseen = true;\n\t\t\t}\n\n\t\t\tChar ch = Actor.findChar( cell );\n\n\t\t\tif (ch != null && ch.isAlive() && !(ch instanceof GnollGeomancer)){\n\t\t\t\t//deals notably less damage than a regular rockfall trap, but ignores armor\n\t\t\t\tint damage = Char.combatRoll(6, 12);\n\t\t\t\tch.damage( Math.max(damage, 0) , this);\n\n\t\t\t\t//guards take full paralysis, otherwise just a little\n\t\t\t\tBuff.prolong(ch, Paralysis.class, ch instanceof GnollGuard ? 10 : 3);\n\n\t\t\t\tif (!ch.isAlive() && ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( this );\n\t\t\t\t\tGLog.n( Messages.get(this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t} else if (ch == null\n\t\t\t\t\t&& Dungeon.level instanceof MiningLevel\n\t\t\t\t\t&& Dungeon.level.traps.get(cell) == null\n\t\t\t\t\t&& Dungeon.level.plants.get(cell) == null\n\t\t\t\t\t&& Random.Int(2) == 0){\n\t\t\t\tLevel.set( cell, Terrain.MINE_BOULDER );\n\t\t\t\tGameScene.updateMap(cell);\n\t\t\t}\n\t\t}\n\n\t\tif (seen){\n\t\t\tPixelScene.shake(3, 0.7f);\n\t\t\tSample.INSTANCE.play(Assets.Sounds.ROCKS);\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_50_109_595_597_50_109"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\n\t\t//we handle this inside of a separate actor as the trap may produce a visual effect we need to pause for\n\t\tActor.add(new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tActor.remove(this);\n\t\t\t\tChar target = Actor.findChar(pos);\n\n\t\t\t\tif (target != null && !canTarget(target)){\n\t\t\t\t\ttarget = null;\n\t\t\t\t}\n\n\t\t\t\t//find the closest char that can be aimed at\n\t\t\t\tif (target == null){\n\t\t\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\t\t\tif (canTarget(ch) && bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\t\t\ttarget = ch;\n\t\t\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target != null) {\n\t\t\t\t\tfinal Char finalTarget = target;\n\t\t\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new PoisonDart(), new Callback() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\t\tint dmg = Random.NormalIntRange(4, 8) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, PoisonDartTrap.this);\n\t\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero){\n\t\t\t\t\t\t\t\t\t\t\t//for the poison dart traps in the Tengu fight\n\t\t\t\t\t\t\t\t\t\t\tif (Dungeon.depth == 10) {\n\t\t\t\t\t\t\t\t\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\t\t\t\t\t\t\t\t\tStatistics.bossScores[1] -= 100;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (!finalTarget.isAlive()) {\n\t\t\t\t\t\t\t\t\t\t\t\tDungeon.fail(PoisonDartTrap.this);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalTarget.damage(Random.NormalIntRange(4, 8) - finalTarget.drRoll(), PoisonDartTrap.this);\n\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\n\t\t//we handle this inside of a separate actor as the trap may produce a visual effect we need to pause for\n\t\tActor.add(new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tActor.remove(this);\n\t\t\t\tChar target = Actor.findChar(pos);\n\n\t\t\t\tif (target != null && !canTarget(target)){\n\t\t\t\t\ttarget = null;\n\t\t\t\t}\n\n\t\t\t\t//find the closest char that can be aimed at\n\t\t\t\tif (target == null){\n\t\t\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\t\t\tif (canTarget(ch) && bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\t\t\ttarget = ch;\n\t\t\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target != null) {\n\t\t\t\t\tfinal Char finalTarget = target;\n\t\t\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new PoisonDart(), new Callback() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\t\tint dmg = Char.combatRoll(4, 8) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, PoisonDartTrap.this);\n\t\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero){\n\t\t\t\t\t\t\t\t\t\t\t//for the poison dart traps in the Tengu fight\n\t\t\t\t\t\t\t\t\t\t\tif (Dungeon.depth == 10) {\n\t\t\t\t\t\t\t\t\t\t\t\tStatistics.qualifiedForBossChallengeBadge = false;\n\t\t\t\t\t\t\t\t\t\t\t\tStatistics.bossScores[1] -= 100;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (!finalTarget.isAlive()) {\n\t\t\t\t\t\t\t\t\t\t\t\tDungeon.fail(PoisonDartTrap.this);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalTarget.damage(Char.combatRoll(4, 8) - finalTarget.drRoll(), PoisonDartTrap.this);\n\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_57_129_595_597_57_129"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\n\t\t//we handle this inside of a separate actor as the trap may produce a visual effect we need to pause for\n\t\tActor.add(new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tActor.remove(this);\n\t\t\t\tChar target = Actor.findChar(pos);\n\n\t\t\t\t//find the closest char that can be aimed at\n\t\t\t\tif (target == null){\n\t\t\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\t\t\tif (bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\t\t\ttarget = ch;\n\t\t\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target != null) {\n\t\t\t\t\tfinal Char finalTarget = target;\n\t\t\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new Dart(), new Callback() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\t\tint dmg = Random.NormalIntRange(4, 8) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, WornDartTrap.this);\n\t\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero && !finalTarget.isAlive()){\n\t\t\t\t\t\t\t\t\t\t\tDungeon.fail( WornDartTrap.this  );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalTarget.damage(Random.NormalIntRange(4, 8) - finalTarget.drRoll(), WornDartTrap.this);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\n\t\t//we handle this inside of a separate actor as the trap may produce a visual effect we need to pause for\n\t\tActor.add(new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tActor.remove(this);\n\t\t\t\tChar target = Actor.findChar(pos);\n\n\t\t\t\t//find the closest char that can be aimed at\n\t\t\t\tif (target == null){\n\t\t\t\t\tfloat closestDist = Float.MAX_VALUE;\n\t\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\t\tif (!ch.isAlive()) continue;\n\t\t\t\t\t\tfloat curDist = Dungeon.level.trueDistance(pos, ch.pos);\n\t\t\t\t\t\tif (ch.invisible > 0) curDist += 1000;\n\t\t\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\t\t\tif (bolt.collisionPos == ch.pos && curDist < closestDist){\n\t\t\t\t\t\t\ttarget = ch;\n\t\t\t\t\t\t\tclosestDist = curDist;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (target != null) {\n\t\t\t\t\tfinal Char finalTarget = target;\n\t\t\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new Dart(), new Callback() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\t\tint dmg = Char.combatRoll(4, 8) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, WornDartTrap.this);\n\t\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero && !finalTarget.isAlive()){\n\t\t\t\t\t\t\t\t\t\t\tDungeon.fail( WornDartTrap.this  );\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalTarget.damage(Char.combatRoll(4, 8) - finalTarget.drRoll(), WornDartTrap.this);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "2a56271091b97a830ba128cd609928601f16eab7_46_105_595_597_46_105"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ba3c7f590a0fa795c3786f02a6e4830a1b69049a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ba3c7f590a0fa795c3786f02a6e4830a1b69049a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void undoDrop(Item item){\n\t\tfor (Category cat : Category.values()){\n\t\t\tif (item.getClass().isAssignableFrom(cat.superClass)){\n\t\t\t\tif (cat.defaultProbs == null) continue;\n\t\t\t\tfor (int i = 0; i < cat.classes.length; i++){\n\t\t\t\t\tif (item.getClass() == cat.classes[i]){\n\t\t\t\t\t\tcat.probs[i]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void undoDrop(Item item){\n\t\tundoDrop(item.getClass());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void undoDrop(Class cls){\n\t\tfor (Category cat : Category.values()){\n\t\t\tif (cls.isAssignableFrom(cat.superClass)){\n\t\t\t\tif (cat.defaultProbs == null) continue;\n\t\t\t\tfor (int i = 0; i < cat.classes.length; i++){\n\t\t\t\t\tif (cls == cat.classes[i]){\n\t\t\t\t\t\tcat.probs[i]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "ba3c7f590a0fa795c3786f02a6e4830a1b69049a_584_595_594_605_590_592"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ae020c1f71a432fc5915aa3ff77e13a1f0ecff50",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ae020c1f71a432fc5915aa3ff77e13a1f0ecff50",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void combine( int slot ){\n\t\t\n\t\tArrayList<Item> ingredients = filterInput(Item.class);\n\t\tif (ingredients.isEmpty()) return;\n\n\t\tlastIngredients.clear();\n\t\tfor (Item i : ingredients){\n\t\t\tlastIngredients.add(i.duplicate());\n\t\t}\n\n\t\tArrayList<Recipe> recipes = Recipe.findRecipes(ingredients);\n\t\tif (recipes.size() <= slot) return;\n\n\t\tRecipe recipe = recipes.get(slot);\n\t\t\n\t\tItem result = null;\n\t\t\n\t\tif (recipe != null){\n\t\t\tint cost = recipe.cost(ingredients);\n\t\t\tif (toolkit != null){\n\t\t\t\tcost = toolkit.consumeEnergy(cost);\n\t\t\t}\n\t\t\tDungeon.energy -= cost;\n\n\t\t\tString energyText = Messages.get(AlchemyScene.class, \"energy\") + \" \" + Dungeon.energy;\n\t\t\tif (toolkit != null){\n\t\t\t\tenergyText += \"+\" + toolkit.availableEnergy();\n\t\t\t}\n\t\t\tenergyLeft.text(energyText);\n\t\t\tenergyLeft.setPos(\n\t\t\t\t\t(Camera.main.width - energyLeft.width())/2,\n\t\t\t\t\tCamera.main.height - 8 - energyLeft.height()\n\t\t\t);\n\n\t\t\tenergyIcon.x = energyLeft.left() - energyIcon.width();\n\t\t\talign(energyIcon);\n\n\t\t\tenergyAdd.setPos(energyLeft.right(), energyAdd.top());\n\t\t\talign(energyAdd);\n\t\t\t\n\t\t\tresult = recipe.brew(ingredients);\n\t\t}\n\t\t\n\t\tif (result != null){\n\t\t\tbubbleEmitter.start(Speck.factory( Speck.BUBBLE ), 0.01f, 100 );\n\t\t\tsmokeEmitter.burst(Speck.factory( Speck.WOOL ), 10 );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.PUFF );\n\n\t\t\tint resultQuantity = result.quantity();\n\t\t\tif (!result.collect()){\n\t\t\t\tDungeon.level.drop(result, Dungeon.hero.pos);\n\t\t\t}\n\n\t\t\tStatistics.itemsCrafted++;\n\t\t\tBadges.validateItemsCrafted();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tDungeon.saveAll();\n\t\t\t} catch (IOException e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t}\n\t\t\t\n\t\t\tsynchronized (inputs) {\n\t\t\t\tfor (int i = 0; i < inputs.length; i++) {\n\t\t\t\t\tif (inputs[i] != null && inputs[i].item() != null) {\n\t\t\t\t\t\tItem item = inputs[i].item();\n\t\t\t\t\t\tif (item.quantity() <= 0) {\n\t\t\t\t\t\t\tinputs[i].item(null);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinputs[i].slot.updateText();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tupdateState();\n\t\t\t//we reset the quantity in case the result was merged into another stack in the backpack\n\t\t\tresult.quantity(resultQuantity);\n\t\t\toutputs[0].item(result);\n\t\t}\n\n\t\tboolean foundItems = true;\n\t\tfor (Item i : lastIngredients){\n\t\t\tItem found = Dungeon.hero.belongings.getSimilar(i);\n\t\t\tif (found == null){ //atm no quantity check as items are always loaded individually\n\t\t\t\t//currently found can be true if we need, say, 3x of an item but only have 2x of it\n\t\t\t\tfoundItems = false;\n\t\t\t}\n\t\t}\n\n\t\tlastRecipe = recipe;\n\t\trepeat.enable(foundItems);\n\t\tcancel.enable(false);\n\t}",
          "sourceCodeAfterRefactoring": "private void combine( int slot ){\n\t\t\n\t\tArrayList<Item> ingredients = filterInput(Item.class);\n\t\tif (ingredients.isEmpty()) return;\n\n\t\tlastIngredients.clear();\n\t\tfor (Item i : ingredients){\n\t\t\tlastIngredients.add(i.duplicate());\n\t\t}\n\n\t\tArrayList<Recipe> recipes = Recipe.findRecipes(ingredients);\n\t\tif (recipes.size() <= slot) return;\n\n\t\tRecipe recipe = recipes.get(slot);\n\t\t\n\t\tItem result = null;\n\t\t\n\t\tif (recipe != null){\n\t\t\tint cost = recipe.cost(ingredients);\n\t\t\tif (toolkit != null){\n\t\t\t\tcost = toolkit.consumeEnergy(cost);\n\t\t\t}\n\t\t\tDungeon.energy -= cost;\n\n\t\t\tString energyText = Messages.get(AlchemyScene.class, \"energy\") + \" \" + Dungeon.energy;\n\t\t\tif (toolkit != null){\n\t\t\t\tenergyText += \"+\" + toolkit.availableEnergy();\n\t\t\t}\n\t\t\tenergyLeft.text(energyText);\n\t\t\tenergyLeft.setPos(\n\t\t\t\t\t(Camera.main.width - energyLeft.width())/2,\n\t\t\t\t\tCamera.main.height - 8 - energyLeft.height()\n\t\t\t);\n\n\t\t\tenergyIcon.x = energyLeft.left() - energyIcon.width();\n\t\t\talign(energyIcon);\n\n\t\t\tenergyAdd.setPos(energyLeft.right(), energyAdd.top());\n\t\t\talign(energyAdd);\n\t\t\t\n\t\t\tresult = recipe.brew(ingredients);\n\t\t}\n\t\t\n\t\tif (result != null){\n\n\t\t\tcraftItem(ingredients, result);\n\n\t\t}\n\n\t\tboolean foundItems = true;\n\t\tfor (Item i : lastIngredients){\n\t\t\tItem found = Dungeon.hero.belongings.getSimilar(i);\n\t\t\tif (found == null){ //atm no quantity check as items are always loaded individually\n\t\t\t\t//currently found can be true if we need, say, 3x of an item but only have 2x of it\n\t\t\t\tfoundItems = false;\n\t\t\t}\n\t\t}\n\n\t\tlastRecipe = recipe;\n\t\trepeat.enable(foundItems);\n\t\tcancel.enable(false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void craftItem( ArrayList<Item> ingredients, Item result ){\n\t\tbubbleEmitter.start(Speck.factory( Speck.BUBBLE ), 0.01f, 100 );\n\t\tsmokeEmitter.burst(Speck.factory( Speck.WOOL ), 10 );\n\t\tSample.INSTANCE.play( Assets.Sounds.PUFF );\n\n\t\tint resultQuantity = result.quantity();\n\t\tif (!result.collect()){\n\t\t\tDungeon.level.drop(result, Dungeon.hero.pos);\n\t\t}\n\n\t\tStatistics.itemsCrafted++;\n\t\tBadges.validateItemsCrafted();\n\n\t\ttry {\n\t\t\tDungeon.saveAll();\n\t\t} catch (IOException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\n\t\tsynchronized (inputs) {\n\t\t\tfor (int i = 0; i < inputs.length; i++) {\n\t\t\t\tif (inputs[i] != null && inputs[i].item() != null) {\n\t\t\t\t\tItem item = inputs[i].item();\n\t\t\t\t\tif (item.quantity() <= 0) {\n\t\t\t\t\t\tinputs[i].item(null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinputs[i].slot.updateText();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateState();\n\t\t//we reset the quantity in case the result was merged into another stack in the backpack\n\t\tresult.quantity(resultQuantity);\n\t\toutputs[0].item(result);\n\t}",
          "uniqueId": "ae020c1f71a432fc5915aa3ff77e13a1f0ecff50_566_659_629_665_566_627"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8630dafd9985738cde4ef2c568be5a29bb659c14",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8630dafd9985738cde4ef2c568be5a29bb659c14",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndResurrect( final Ankh ankh ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tinstance = this;\n\t\t\n\t\tIconTitle titlebar = new IconTitle();\n\t\ttitlebar.icon( new ItemSprite( ankh.image(), null ) );\n\t\ttitlebar.label( Messages.titleCase(Messages.get(this, \"title\")) );\n\t\ttitlebar.setRect( 0, 0, WIDTH, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock(Messages.get(this, \"message\"), 6 );\n\t\tmessage.maxWidth(WIDTH);\n\t\tmessage.setPos(0, titlebar.bottom() + GAP);\n\t\tadd( message );\n\n\t\tbtnItem1 = new ItemButton() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tbtnPressed = btnItem1;\n\t\t\t\tGameScene.selectItem( itemSelector );\n\t\t\t}\n\t\t};\n\t\tbtnItem1.item(Dungeon.hero.belongings.weapon());\n\t\tbtnItem1.setRect( (WIDTH - BTN_GAP) / 2 - BTN_SIZE, message.bottom() + BTN_GAP, BTN_SIZE, BTN_SIZE );\n\t\tadd( btnItem1 );\n\n\t\tbtnItem2 = new ItemButton() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tbtnPressed = btnItem2;\n\t\t\t\tGameScene.selectItem( itemSelector );\n\t\t\t}\n\t\t};\n\t\tbtnItem2.item(Dungeon.hero.belongings.armor());\n\t\tbtnItem2.setRect( btnItem1.right() + BTN_GAP, btnItem1.top(), BTN_SIZE, BTN_SIZE );\n\t\tadd( btnItem2 );\n\t\t\n\t\tbtnContinue = new RedButton( Messages.get(this, \"confirm\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\thide();\n\t\t\t\t\n\t\t\t\tStatistics.ankhsUsed++;\n\n\t\t\t\tankh.detach(Dungeon.hero.belongings.backpack);\n\n\t\t\t\tif (btnItem1.item() != null){\n\t\t\t\t\tbtnItem1.item().keptThoughLostInvent = true;\n\t\t\t\t}\n\t\t\t\tif (btnItem2.item() != null){\n\t\t\t\t\tbtnItem2.item().keptThoughLostInvent = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.RESURRECT;\n\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t}\n\t\t};\n\t\tbtnContinue.setRect( 0, btnItem1.bottom() + BTN_GAP, WIDTH, BTN_HEIGHT );\n\t\tadd( btnContinue );\n\n\t\tresize( WIDTH, (int)btnContinue.bottom() );\n\t}",
          "sourceCodeAfterRefactoring": "public WndResurrect( final Ankh ankh ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tinstance = this;\n\t\t\n\t\tIconTitle titlebar = new IconTitle();\n\t\ttitlebar.icon( new ItemSprite( ankh.image(), null ) );\n\t\ttitlebar.label( Messages.titleCase(Messages.get(this, \"title\")) );\n\t\ttitlebar.setRect( 0, 0, WIDTH, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextBlock message = PixelScene.renderTextBlock(Messages.get(this, \"message\"), 6 );\n\t\tmessage.maxWidth(WIDTH);\n\t\tmessage.setPos(0, titlebar.bottom() + GAP);\n\t\tadd( message );\n\n\t\tbtnItem1 = new ItemButton() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tbtnPressed = btnItem1;\n\t\t\t\tGameScene.selectItem( itemSelector );\n\t\t\t}\n\t\t};\n\t\tbtnItem1.item(Dungeon.hero.belongings.weapon());\n\t\tbtnItem1.setRect( (WIDTH - BTN_GAP) / 2 - BTN_SIZE, message.bottom() + BTN_GAP, BTN_SIZE, BTN_SIZE );\n\t\tadd( btnItem1 );\n\n\t\tbtnItem2 = new ItemButton() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tbtnPressed = btnItem2;\n\t\t\t\tGameScene.selectItem( itemSelector );\n\t\t\t}\n\t\t};\n\t\tbtnItem2.item(Dungeon.hero.belongings.armor());\n\t\tbtnItem2.setRect( btnItem1.right() + BTN_GAP, btnItem1.top(), BTN_SIZE, BTN_SIZE );\n\t\tadd( btnItem2 );\n\t\t\n\t\tbtnContinue = new RedButton( Messages.get(this, \"confirm\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tif (btnItem1.item() == null || btnItem2.item() == null){\n\t\t\t\t\tGameScene.show(new WndOptions(Icons.WARNING.get(),\n\t\t\t\t\t\t\tMessages.get(WndResurrect.class, \"warn_title\"),\n\t\t\t\t\t\t\tMessages.get(WndResurrect.class, \"warn_body\"),\n\t\t\t\t\t\t\tMessages.get(WndResurrect.class, \"warn_yes\"),\n\t\t\t\t\t\t\tMessages.get(WndResurrect.class, \"warn_no\")){\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\tif (index == 0){\n\t\t\t\t\t\t\t\tresurrect(ankh);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tresurrect( ankh );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbtnContinue.setRect( 0, btnItem1.bottom() + BTN_GAP, WIDTH, BTN_HEIGHT );\n\t\tadd( btnContinue );\n\n\t\tresize( WIDTH, (int)btnContinue.bottom() );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void resurrect( final Ankh ankh ){\n\t\thide();\n\n\t\tStatistics.ankhsUsed++;\n\n\t\tankh.detach(Dungeon.hero.belongings.backpack);\n\n\t\tif (btnItem1.item() != null){\n\t\t\tbtnItem1.item().keptThoughLostInvent = true;\n\t\t}\n\t\tif (btnItem2.item() != null){\n\t\t\tbtnItem2.item().keptThoughLostInvent = true;\n\t\t}\n\n\t\tInterlevelScene.mode = InterlevelScene.Mode.RESURRECT;\n\t\tGame.switchScene( InterlevelScene.class );\n\t}",
          "uniqueId": "8630dafd9985738cde4ef2c568be5a29bb659c14_57_120_124_140_58_122"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2466974a7144fe1a9fd04c061951e30dfe64ff23",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2466974a7144fe1a9fd04c061951e30dfe64ff23",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public KindOfWeapon weapon(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (weapon != null && weapon.keptThroughLostInventory())){\n\t\t\treturn weapon;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public KindOfWeapon weapon(){\n\t\tif (!lostInventory() || (weapon != null && weapon.keptThroughLostInventory())){\n\t\t\treturn weapon;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_104_111_110_112_114_120"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Armor armor(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (armor != null && armor.keptThroughLostInventory())){\n\t\t\treturn armor;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Armor armor(){\n\t\tif (!lostInventory() || (armor != null && armor.keptThroughLostInventory())){\n\t\t\treturn armor;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_113_120_110_112_122_128"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Artifact artifact(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (artifact != null && artifact.keptThroughLostInventory())){\n\t\t\treturn artifact;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Artifact artifact(){\n\t\tif (!lostInventory() || (artifact != null && artifact.keptThroughLostInventory())){\n\t\t\treturn artifact;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_122_129_110_112_130_136"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public KindofMisc misc(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (misc != null && misc.keptThroughLostInventory())){\n\t\t\treturn misc;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public KindofMisc misc(){\n\t\tif (!lostInventory() || (misc != null && misc.keptThroughLostInventory())){\n\t\t\treturn misc;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_131_138_110_112_138_144"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Ring ring(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (ring != null && ring.keptThroughLostInventory())){\n\t\t\treturn ring;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Ring ring(){\n\t\tif (!lostInventory() || (ring != null && ring.keptThroughLostInventory())){\n\t\t\treturn ring;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_140_147_110_112_146_152"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public KindOfWeapon secondWep(){\n\t\tboolean lostInvent = owner != null && owner.buff(LostInventory.class) != null;\n\t\tif (!lostInvent || (secondWep != null && secondWep.keptThroughLostInventory())){\n\t\t\treturn secondWep;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public KindOfWeapon secondWep(){\n\t\tif (!lostInventory() || (secondWep != null && secondWep.keptThroughLostInventory())){\n\t\t\treturn secondWep;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean lostInventory(){\n\t\treturn lostInvent;\n\t}",
          "uniqueId": "2466974a7144fe1a9fd04c061951e30dfe64ff23_149_156_110_112_154_160"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5b58aec93fc50fa787df64f8069fdf823b9e57f4",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5b58aec93fc50fa787df64f8069fdf823b9e57f4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( Messages.get(this, \"eat_msg\") );\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.EAT );\n\t\t\t\n\t\t\thero.spend( eatingTime() );\n\n\t\t\tTalent.onFoodEaten(hero, energy, this);\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( Messages.get(this, \"eat_msg\") );\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\teatSFX();\n\t\t\t\n\t\t\thero.spend( eatingTime() );\n\n\t\t\tTalent.onFoodEaten(hero, energy, this);\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void eatSFX(){\n\t\tSample.INSTANCE.play( Assets.Sounds.EAT );\n\t}",
          "uniqueId": "5b58aec93fc50fa787df64f8069fdf823b9e57f4_68_93_95_97_68_93"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f36dda306412215ced3711c07196368f90813163",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f36dda306412215ced3711c07196368f90813163",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void vibrate( int millis ){\n\t\tif (Controllers.getCurrent().canVibrate()) {\n\t\t\tControllers.getCurrent().startVibration(millis, 1f);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void vibrate( int millis ){\n\t\tif (vibrationSupported()) {\n\t\t\tControllers.getCurrent().startVibration(millis, 1f);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean vibrationSupported(){\n\t\treturn isControllerConnected() && Controllers.getCurrent().canVibrate();\n\t}",
          "uniqueId": "f36dda306412215ced3711c07196368f90813163_87_91_87_89_91_95"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "96e4c74ca833825f04196578156eec3c704ba3b4",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/96e4c74ca833825f04196578156eec3c704ba3b4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public GnollGeomancerSprite() {\n\t\tsuper();\n\n\t\ttexture(Assets.Sprites.GNOLL_GEOMANCER);\n\n\t\tTextureFilm frames = new TextureFilm( texture, 12, 16 );\n\n\t\tidle = new Animation( 2, true );\n\t\tidle.frames( frames, 1, 1, 1, 2, 1, 1, 2, 2 );\n\n\t\trun = new Animation( 12, true );\n\t\trun.frames( frames, 5, 6, 7, 8 );\n\n\t\tattack = new Animation( 12, false );\n\t\tattack.frames( frames, 3, 4, 1 );\n\n\t\tzap = attack.clone();\n\n\t\tdie = new Animation( 12, false );\n\t\tdie.frames( frames, 9, 10, 11 );\n\n\t\tstatue = new Animation(1, true);\n\t\tstatue.frames( frames, 0 );\n\n\t\tplay(idle);\n\n\t\tscale.set(1.25f);\n\t}",
          "sourceCodeAfterRefactoring": "public GnollGeomancerSprite() {\n\t\tsuper();\n\n\t\ttexture(Assets.Sprites.GNOLL_GEOMANCER);\n\n\t\tupdateAnims();\n\n\t\tscale.set(1.25f);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateAnims(){\n\n\t\tTextureFilm frames = new TextureFilm( texture, 12, 16 );\n\n\t\tint ofs = isStatue ? 21 : 0;\n\t\tidle = new Animation( isStatue ? 1 : 2, true );\n\t\tidle.frames( frames, ofs+0, ofs+0, ofs+0, ofs+1, ofs+0, ofs+0, ofs+1, ofs+1 );\n\n\t\trun = new Animation( 12, true );\n\t\trun.frames( frames, ofs+4, ofs+5, ofs+6, ofs+7 );\n\n\t\tattack = new Animation( 12, false );\n\t\tattack.frames( frames, ofs+2, ofs+3, ofs+0 );\n\n\t\tzap = attack.clone();\n\n\t\tdie = new Animation( 12, false );\n\t\tdie.frames( frames, ofs+8, ofs+9, ofs+10 );\n\n\t\tplay(idle);\n\n\t\tplay(idle);\n\t}",
          "uniqueId": "96e4c74ca833825f04196578156eec3c704ba3b4_37_64_60_82_37_45"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f9e6fbc94229863db33771e61af8f9a9bc1c8d05",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f9e6fbc94229863db33771e61af8f9a9bc1c8d05",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public float durabilityPerUse(){\n\t\tfloat usages = baseUses * (float)(Math.pow(3, level()));\n\n\t\t//+50%/75% durability\n\t\tif (Dungeon.hero.hasTalent(Talent.DURABLE_PROJECTILES)){\n\t\t\tusages *= 1.25f + (0.25f*Dungeon.hero.pointsInTalent(Talent.DURABLE_PROJECTILES));\n\t\t}\n\t\tif (holster) {\n\t\t\tusages *= MagicalHolster.HOLSTER_DURABILITY_FACTOR;\n\t\t}\n\t\t\n\t\tusages *= RingOfSharpshooting.durabilityMultiplier( Dungeon.hero );\n\t\t\n\t\t//at 100 uses, items just last forever.\n\t\tif (usages >= 100f) return 0;\n\n\t\tusages = Math.round(usages);\n\t\t\n\t\t//add a tiny amount to account for rounding error for calculations like 1/3\n\t\treturn (MAX_DURABILITY/usages) + 0.001f;\n\t}",
          "sourceCodeAfterRefactoring": "public float durabilityPerUse(){\n\t\t//classes that override durabilityPerUse can turn rounding off, to do their own rounding after more logic\n\t\treturn durabilityPerUse(true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected final float durabilityPerUse( boolean rounded){\n\t\tfloat usages = baseUses * (float)(Math.pow(3, level()));\n\n\t\t//+50%/75% durability\n\t\tif (Dungeon.hero.hasTalent(Talent.DURABLE_PROJECTILES)){\n\t\t\tusages *= 1.25f + (0.25f*Dungeon.hero.pointsInTalent(Talent.DURABLE_PROJECTILES));\n\t\t}\n\t\tif (holster) {\n\t\t\tusages *= MagicalHolster.HOLSTER_DURABILITY_FACTOR;\n\t\t}\n\n\t\tusages *= RingOfSharpshooting.durabilityMultiplier( Dungeon.hero );\n\n\t\t//at 100 uses, items just last forever.\n\t\tif (usages >= 100f) return 0;\n\n\t\tif (rounded){\n\t\t\tusages = Math.round(usages);\n\t\t\t//add a tiny amount to account for rounding error for calculations like 1/3\n\t\t\treturn (MAX_DURABILITY/usages) + 0.001f;\n\t\t} else {\n\t\t\t//rounding can be disabled for classes that override durability per use\n\t\t\treturn MAX_DURABILITY/usages;\n\t\t}\n\t}",
          "uniqueId": "f9e6fbc94229863db33771e61af8f9a9bc1c8d05_316_336_321_345_316_319"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "bc4663e81dada5eb15d9bb52999cc58881fe8a6f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/bc4663e81dada5eb15d9bb52999cc58881fe8a6f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) GameScene.add(Blob.seed(leftPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[webPos])  GameScene.add(Blob.seed(webPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[rightPos])GameScene.add(Blob.seed(rightPos, 20, Web.class));\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "sourceCodeAfterRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) applyWebToCell(leftPos);\n\t\t\tif (Dungeon.level.passable[webPos])  applyWebToCell(webPos);\n\t\t\tif (Dungeon.level.passable[rightPos])applyWebToCell(rightPos);\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void applyWebToCell(int cell){\n\t\tGameScene.add(Blob.seed(cell, 20, Web.class));\n\t}",
          "uniqueId": "bc4663e81dada5eb15d9bb52999cc58881fe8a6f_180_205_207_209_180_205"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) GameScene.add(Blob.seed(leftPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[webPos])  GameScene.add(Blob.seed(webPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[rightPos])GameScene.add(Blob.seed(rightPos, 20, Web.class));\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "sourceCodeAfterRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) applyWebToCell(leftPos);\n\t\t\tif (Dungeon.level.passable[webPos])  applyWebToCell(webPos);\n\t\t\tif (Dungeon.level.passable[rightPos])applyWebToCell(rightPos);\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void applyWebToCell(int cell){\n\t\tGameScene.add(Blob.seed(cell, 20, Web.class));\n\t}",
          "uniqueId": "bc4663e81dada5eb15d9bb52999cc58881fe8a6f_180_205_207_209_180_205"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) GameScene.add(Blob.seed(leftPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[webPos])  GameScene.add(Blob.seed(webPos, 20, Web.class));\n\t\t\tif (Dungeon.level.passable[rightPos])GameScene.add(Blob.seed(rightPos, 20, Web.class));\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "sourceCodeAfterRefactoring": "public void shootWeb(){\n\t\tint webPos = webPos();\n\t\tif (webPos != -1){\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < PathFinder.CIRCLE8.length; i++){\n\t\t\t\tif ((enemy.pos + PathFinder.CIRCLE8[i]) == webPos){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//spread to the tile hero was moving towards and the two adjacent ones\n\t\t\tint leftPos = enemy.pos + PathFinder.CIRCLE8[left(i)];\n\t\t\tint rightPos = enemy.pos + PathFinder.CIRCLE8[right(i)];\n\t\t\t\n\t\t\tif (Dungeon.level.passable[leftPos]) applyWebToCell(leftPos);\n\t\t\tif (Dungeon.level.passable[webPos])  applyWebToCell(webPos);\n\t\t\tif (Dungeon.level.passable[rightPos])applyWebToCell(rightPos);\n\t\t\t\n\t\t\twebCoolDown = 10;\n\n\t\t\tif (Dungeon.level.heroFOV[enemy.pos]){\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t}\n\t\tnext();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void applyWebToCell(int cell){\n\t\tGameScene.add(Blob.seed(cell, 20, Web.class));\n\t}",
          "uniqueId": "bc4663e81dada5eb15d9bb52999cc58881fe8a6f_180_205_207_209_180_205"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "1c8b13fa62f8cb2e3c186ed5de923f376b2b6118",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/1c8b13fa62f8cb2e3c186ed5de923f376b2b6118",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void show( float x, float y, String text, int color ) {\n\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tFloatingText txt = GameScene.status();\n\t\t\t\tif (txt != null){\n\t\t\t\t\ttxt.reset(x, y, text, color);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "public static void show( float x, float y, String text, int color) {\n\t\tshow(x, y, -1, text, color, -1, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void show( float x, float y, int key, String text, int color, int iconIdx, boolean left ) {\n\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tFloatingText txt = GameScene.status();\n\t\t\t\tif (txt != null){\n\t\t\t\t\ttxt.reset(x, y, text, color, iconIdx, left);\n\t\t\t\t\tif (key != -1) push(txt, key);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "uniqueId": "1c8b13fa62f8cb2e3c186ed5de923f376b2b6118_108_118_192_203_184_186"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void show( float x, float y, int key, String text, int color ) {\n\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tFloatingText txt = GameScene.status();\n\t\t\t\tif (txt != null){\n\t\t\t\t\ttxt.reset(x, y, text, color);\n\t\t\t\t\tpush(txt, key);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "public static void show( float x, float y, int key, String text, int color) {\n\t\tshow(x, y, key, text, color, -1, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void show( float x, float y, int key, String text, int color, int iconIdx, boolean left ) {\n\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tFloatingText txt = GameScene.status();\n\t\t\t\tif (txt != null){\n\t\t\t\t\ttxt.reset(x, y, text, color, iconIdx, left);\n\t\t\t\t\tif (key != -1) push(txt, key);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "uniqueId": "1c8b13fa62f8cb2e3c186ed5de923f376b2b6118_120_131_192_203_188_190"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void showStatus( int color, String text, Object... args ) {\n\t\tif (visible) {\n\t\t\tif (args.length > 0) {\n\t\t\t\ttext = Messages.format( text, args );\n\t\t\t}\n\t\t\tfloat x = destinationCenter().x;\n\t\t\tfloat y = destinationCenter().y - height()/2f;\n\t\t\tif (ch != null) {\n\t\t\t\tFloatingText.show( x, y, ch.pos, text, color );\n\t\t\t} else {\n\t\t\t\tFloatingText.show( x, y, text, color );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void showStatus( int color, String text, Object... args ) {\n\t\tshowStatusWithIcon(color, text, FloatingText.NO_ICON, args);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void showStatusWithIcon( int color, String text, int icon, Object... args ) {\n\t\tif (visible) {\n\t\t\tif (args.length > 0) {\n\t\t\t\ttext = Messages.format( text, args );\n\t\t\t}\n\t\t\tfloat x = destinationCenter().x;\n\t\t\tfloat y = destinationCenter().y - height()/2f;\n\t\t\tif (ch != null) {\n\t\t\t\tFloatingText.show( x, y, ch.pos, text, color, icon, true );\n\t\t\t} else {\n\t\t\t\tFloatingText.show( x, y, -1, text, color, icon, true );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "1c8b13fa62f8cb2e3c186ed5de923f376b2b6118_191_204_195_208_191_193"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c3c4cc9f543c5d82ab6f3f07e18ca0896b756069",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c3c4cc9f543c5d82ab6f3f07e18ca0896b756069",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tsuper.die(cause);\n\t\tif (guardID != -1 && Actor.findById(guardID) instanceof GnollGuard){\n\t\t\t((GnollGuard) Actor.findById(guardID)).loseSapper();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void die(Object cause) {\n\t\tsuper.die(cause);\n\t\tlosePartner();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void losePartner(){\n\t\tif (partnerID != -1){\n\t\t\tif (Actor.findById(partnerID) instanceof GnollGuard) {\n\t\t\t\t((GnollGuard) Actor.findById(partnerID)).loseSapper();\n\t\t\t} else if (Actor.findById(partnerID) instanceof GnollGeomancer) {\n\t\t\t\t((GnollGeomancer) Actor.findById(partnerID)).loseSapper();\n\t\t\t}\n\t\t\tpartnerID = -1;\n\t\t}\n\t}",
          "uniqueId": "c3c4cc9f543c5d82ab6f3f07e18ca0896b756069_70_76_75_84_86_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "fae73101aaa70ac5b51ea577a9389809a91fdafe",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fae73101aaa70ac5b51ea577a9389809a91fdafe",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tspend( TICK );\n\n\t\t\tboolean smthFound = false;\n\n\t\t\tint distance = 3;\n\n\t\t\tint cx = target.pos % Dungeon.level.width();\n\t\t\tint cy = target.pos / Dungeon.level.width();\n\t\t\tint ax = cx - distance;\n\t\t\tif (ax < 0) {\n\t\t\t\tax = 0;\n\t\t\t}\n\t\t\tint bx = cx + distance;\n\t\t\tif (bx >= Dungeon.level.width()) {\n\t\t\t\tbx = Dungeon.level.width() - 1;\n\t\t\t}\n\t\t\tint ay = cy - distance;\n\t\t\tif (ay < 0) {\n\t\t\t\tay = 0;\n\t\t\t}\n\t\t\tint by = cy + distance;\n\t\t\tif (by >= Dungeon.level.height()) {\n\t\t\t\tby = Dungeon.level.height() - 1;\n\t\t\t}\n\n\t\t\tfor (int y = ay; y <= by; y++) {\n\t\t\t\tfor (int x = ax, p = ax + y * Dungeon.level.width(); x <= bx; x++, p++) {\n\n\t\t\t\t\tif (Dungeon.level.heroFOV[p]\n\t\t\t\t\t\t\t&& Dungeon.level.secret[p]\n\t\t\t\t\t\t\t&& Dungeon.level.map[p] != Terrain.SECRET_DOOR) {\n\t\t\t\t\t\tif (Dungeon.level.traps.get(p) != null && Dungeon.level.traps.get(p).canBeSearched) {\n\t\t\t\t\t\t\tsmthFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (smthFound\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null){\n\t\t\t\tif (!warn){\n\t\t\t\t\tGLog.w( Messages.get(this, \"uneasy\") );\n\t\t\t\t\tif (target instanceof Hero){\n\t\t\t\t\t\t((Hero)target).interrupt();\n\t\t\t\t\t}\n\t\t\t\t\twarn = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarn = false;\n\t\t\t}\n\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//fully charges in 2000 turns at +0, scaling to 1000 turns at +10.\n\t\t\t\tfloat chargeGain = (0.05f+(level()*0.005f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge > 1 && charge < chargeCap) {\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tcharge++;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t} else if (charge >= chargeCap) {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tGLog.p( Messages.get(TalismanOfForesight.class, \"full_charge\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tspend( TICK );\n\n\t\t\tcheckAwareness();\n\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//fully charges in 2000 turns at +0, scaling to 1000 turns at +10.\n\t\t\t\tfloat chargeGain = (0.05f+(level()*0.005f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge > 1 && charge < chargeCap) {\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tcharge++;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t} else if (charge >= chargeCap) {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tGLog.p( Messages.get(TalismanOfForesight.class, \"full_charge\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void checkAwareness(){\n\t\t\tboolean smthFound = false;\n\n\t\t\tint distance = 3;\n\n\t\t\tint cx = target.pos % Dungeon.level.width();\n\t\t\tint cy = target.pos / Dungeon.level.width();\n\t\t\tint ax = cx - distance;\n\t\t\tif (ax < 0) {\n\t\t\t\tax = 0;\n\t\t\t}\n\t\t\tint bx = cx + distance;\n\t\t\tif (bx >= Dungeon.level.width()) {\n\t\t\t\tbx = Dungeon.level.width() - 1;\n\t\t\t}\n\t\t\tint ay = cy - distance;\n\t\t\tif (ay < 0) {\n\t\t\t\tay = 0;\n\t\t\t}\n\t\t\tint by = cy + distance;\n\t\t\tif (by >= Dungeon.level.height()) {\n\t\t\t\tby = Dungeon.level.height() - 1;\n\t\t\t}\n\n\t\t\tfor (int y = ay; y <= by; y++) {\n\t\t\t\tfor (int x = ax, p = ax + y * Dungeon.level.width(); x <= bx; x++, p++) {\n\n\t\t\t\t\tif (Dungeon.level.heroFOV[p]\n\t\t\t\t\t\t\t&& Dungeon.level.secret[p]\n\t\t\t\t\t\t\t&& Dungeon.level.map[p] != Terrain.SECRET_DOOR) {\n\t\t\t\t\t\tif (Dungeon.level.traps.get(p) != null && Dungeon.level.traps.get(p).canBeSearched) {\n\t\t\t\t\t\t\tsmthFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (smthFound\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null){\n\t\t\t\tif (!warn){\n\t\t\t\t\tGLog.w( Messages.get(this, \"uneasy\") );\n\t\t\t\t\tif (target instanceof Hero){\n\t\t\t\t\t\t((Hero)target).interrupt();\n\t\t\t\t\t}\n\t\t\t\t\twarn = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarn = false;\n\t\t\t}\n\t\t}",
          "uniqueId": "fae73101aaa70ac5b51ea577a9389809a91fdafe_263_337_291_341_263_289"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "a86e20c79369043e4c6d815fd56beac0e50cb683",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/a86e20c79369043e4c6d815fd56beac0e50cb683",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Statue random(){\n\t\tStatue statue = null;\n\t\tif (Random.Int(10) == 0){\n\t\t\tstatue = new ArmoredStatue();\n\t\t} else {\n\t\t\tstatue = new Statue();\n\t\t}\n\t\tstatue.createWeapon();\n\t\treturn statue;\n\t}",
          "sourceCodeAfterRefactoring": "public static Statue random(){\n\t\treturn random( true );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Statue random( boolean useDecks ){\n\t\tStatue statue;\n\t\tif (Random.Int(10) == 0){\n\t\t\tstatue = new ArmoredStatue();\n\t\t} else {\n\t\t\tstatue = new Statue();\n\t\t}\n\t\tstatue.createWeapon(useDecks);\n\t\treturn statue;\n\t}",
          "uniqueId": "a86e20c79369043e4c6d815fd56beac0e50cb683_193_202_195_204_191_193"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "cf7ddd4dbd5e21bed004833f3091bb8a23177223",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/cf7ddd4dbd5e21bed004833f3091bb8a23177223",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statue() {\n\t\tsuper();\n\t\t\n\t\tdo {\n\t\t\tweapon = (MeleeWeapon) Generator.random(Generator.Category.WEAPON);\n\t\t} while (weapon.cursed);\n\t\t\n\t\tweapon.enchant( Enchantment.random() );\n\t\t\n\t\tHP = HT = 15 + Dungeon.depth * 5;\n\t\tdefenseSkill = 4 + Dungeon.depth;\n\t}",
          "sourceCodeAfterRefactoring": "public Statue() {\n\t\tsuper();\n\t\t\n\t\tweapon = createWeapon();\n\t\t\n\t\tHP = HT = 15 + Dungeon.depth * 5;\n\t\tdefenseSkill = 4 + Dungeon.depth;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Weapon createWeapon(){\n\t\tWeapon weapon = (MeleeWeapon) Generator.random(Generator.Category.WEAPON);\n\t\tweapon.cursed = false;\n\t\tweapon.enchant( Enchantment.random() );\n\t\treturn weapon;\n\t}",
          "uniqueId": "cf7ddd4dbd5e21bed004833f3091bb8a23177223_54_65_63_68_54_61"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5d16bf99b04e471d56e581490bf9bcd2057627e9",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5d16bf99b04e471d56e581490bf9bcd2057627e9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void occupyCell(Char ch) {\n\t\tsuper.occupyCell(ch);\n\t\tif (ch == Dungeon.hero) {\n\t\t\tif (wandmakerQuestWasActive == null) {\n\t\t\t\twandmakerQuestWasActive = Wandmaker.Quest.active();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (Wandmaker.Quest.active() != wandmakerQuestWasActive) {\n\t\t\t\twandmakerQuestWasActive = Wandmaker.Quest.active();\n\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tMusic.INSTANCE.fadeOut(1f, new Callback() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\tif (Dungeon.level != null) {\n\t\t\t\t\t\t\t\t\tDungeon.level.playLevelMusic();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void occupyCell(Char ch) {\n\t\tsuper.occupyCell(ch);\n\t\tif (ch == Dungeon.hero) {\n\t\t\tupdateWandmakerQuestMusic();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateWandmakerQuestMusic(){\n\t\tif (wandmakerQuestWasActive == null) {\n\t\t\twandmakerQuestWasActive = Wandmaker.Quest.active();\n\t\t\treturn;\n\t\t}\n\t\tif (Wandmaker.Quest.active() != wandmakerQuestWasActive) {\n\t\t\twandmakerQuestWasActive = Wandmaker.Quest.active();\n\n\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tMusic.INSTANCE.fadeOut(1f, new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tif (Dungeon.level != null) {\n\t\t\t\t\t\t\t\tDungeon.level.playLevelMusic();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}",
          "uniqueId": "5d16bf99b04e471d56e581490bf9bcd2057627e9_143_169_151_173_141_147"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5c59b3e77764d783729acd4202302ed63e115096",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5c59b3e77764d783729acd4202302ed63e115096",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean paint(Level level, ArrayList<Room> rooms) {\n\t\t\n\t\t//painter can be used without rooms\n\t\tif (rooms != null) {\n\t\t\t\n\t\t\tint padding = level.feeling == Level.Feeling.CHASM ? 2 : 1;\n\t\t\t\n\t\t\tint leftMost = Integer.MAX_VALUE, topMost = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor (Room r : rooms) {\n\t\t\t\tif (r.left < leftMost) leftMost = r.left;\n\t\t\t\tif (r.top < topMost) topMost = r.top;\n\t\t\t}\n\t\t\t\n\t\t\tleftMost -= padding;\n\t\t\ttopMost -= padding;\n\t\t\t\n\t\t\tint rightMost = 0, bottomMost = 0;\n\t\t\t\n\t\t\tfor (Room r : rooms) {\n\t\t\t\tr.shift(-leftMost, -topMost);\n\t\t\t\tif (r.right > rightMost) rightMost = r.right;\n\t\t\t\tif (r.bottom > bottomMost) bottomMost = r.bottom;\n\t\t\t}\n\t\t\t\n\t\t\trightMost += padding;\n\t\t\tbottomMost += padding;\n\t\t\t\n\t\t\t//add 1 to account for 0 values\n\t\t\tlevel.setSize(rightMost + 1, bottomMost + 1);\n\t\t} else {\n\t\t\t//check if the level's size was already initialized by something else\n\t\t\tif (level.length() == 0) return false;\n\t\t\t\n\t\t\t//easier than checking for null everywhere\n\t\t\trooms = new ArrayList<>();\n\t\t}\n\t\t\n\t\tRandom.shuffle(rooms);\n\t\t\n\t\tfor (Room r : rooms.toArray(new Room[0])) {\n\t\t\tif (r.connected.isEmpty()){\n\t\t\t\tGame.reportException( new RuntimeException(\"Painting a room with no connections! Room:\" + r.getClass().getSimpleName() + \" Seed:\" + Dungeon.seed + \" Depth:\" + Dungeon.depth));\n\t\t\t\tif (r instanceof SpecialRoom) return false;\n\t\t\t}\n\t\t\tplaceDoors( r );\n\t\t\tr.paint( level );\n\t\t}\n\t\t\n\t\tpaintDoors( level, rooms );\n\t\t\n\t\tif (waterFill > 0f) {\n\t\t\tpaintWater( level, rooms );\n\t\t}\n\t\t\n\t\tif (grassFill > 0f){\n\t\t\tpaintGrass( level, rooms );\n\t\t}\n\t\t\n\t\tif (nTraps > 0){\n\t\t\tpaintTraps( level, rooms );\n\t\t}\n\t\t\n\t\tdecorate( level, rooms );\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean paint(Level level, ArrayList<Room> rooms) {\n\t\t\n\t\t//painter can be used without rooms\n\t\tif (rooms != null) {\n\t\t\t\n\t\t\tint padding = padding(level);\n\t\t\t\n\t\t\tint leftMost = Integer.MAX_VALUE, topMost = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tfor (Room r : rooms) {\n\t\t\t\tif (r.left < leftMost) leftMost = r.left;\n\t\t\t\tif (r.top < topMost) topMost = r.top;\n\t\t\t}\n\t\t\t\n\t\t\tleftMost -= padding;\n\t\t\ttopMost -= padding;\n\t\t\t\n\t\t\tint rightMost = 0, bottomMost = 0;\n\t\t\t\n\t\t\tfor (Room r : rooms) {\n\t\t\t\tr.shift(-leftMost, -topMost);\n\t\t\t\tif (r.right > rightMost) rightMost = r.right;\n\t\t\t\tif (r.bottom > bottomMost) bottomMost = r.bottom;\n\t\t\t}\n\t\t\t\n\t\t\trightMost += padding;\n\t\t\tbottomMost += padding;\n\t\t\t\n\t\t\t//add 1 to account for 0 values\n\t\t\tlevel.setSize(rightMost + 1, bottomMost + 1);\n\t\t} else {\n\t\t\t//check if the level's size was already initialized by something else\n\t\t\tif (level.length() == 0) return false;\n\t\t\t\n\t\t\t//easier than checking for null everywhere\n\t\t\trooms = new ArrayList<>();\n\t\t}\n\t\t\n\t\tRandom.shuffle(rooms);\n\t\t\n\t\tfor (Room r : rooms.toArray(new Room[0])) {\n\t\t\tif (r.connected.isEmpty()){\n\t\t\t\tGame.reportException( new RuntimeException(\"Painting a room with no connections! Room:\" + r.getClass().getSimpleName() + \" Seed:\" + Dungeon.seed + \" Depth:\" + Dungeon.depth));\n\t\t\t\tif (r instanceof SpecialRoom) return false;\n\t\t\t}\n\t\t\tplaceDoors( r );\n\t\t\tr.paint( level );\n\t\t}\n\t\t\n\t\tpaintDoors( level, rooms );\n\t\t\n\t\tif (waterFill > 0f) {\n\t\t\tpaintWater( level, rooms );\n\t\t}\n\t\t\n\t\tif (grassFill > 0f){\n\t\t\tpaintGrass( level, rooms );\n\t\t}\n\t\t\n\t\tif (nTraps > 0){\n\t\t\tpaintTraps( level, rooms );\n\t\t}\n\t\t\n\t\tdecorate( level, rooms );\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int padding(Level level){\n\t\treturn level.feeling == Level.Feeling.CHASM ? 2 : 1;\n\t}",
          "uniqueId": "5c59b3e77764d783729acd4202302ed63e115096_79_146_79_81_83_150"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "dc6749f43effbf7da6ef2e77dde2cfdb434d54d3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/dc6749f43effbf7da6ef2e77dde2cfdb434d54d3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private synchronized void play(String track, com.badlogic.gdx.audio.Music.OnCompletionListener listener){\n\t\ttry {\n\t\t\tplayer = Gdx.audio.newMusic(Gdx.files.internal(track));\n\t\t\tplayer.setLooping(looping);\n\t\t\tplayer.setVolume(volume);\n\t\t\tplayer.play();\n\t\t\tif (listener != null) {\n\t\t\t\tplayer.setOnCompletionListener(listener);\n\t\t\t}\n\t\t} catch (Exception e){\n\t\t\tGame.reportException(e);\n\t\t\tplayer = null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private synchronized void play(String track, com.badlogic.gdx.audio.Music.OnCompletionListener listener){\n\t\ttry {\n\t\t\tplayer = Gdx.audio.newMusic(Gdx.files.internal(track));\n\t\t\tplayer.setLooping(looping);\n\t\t\tplayer.setVolume(volumeWithFade());\n\t\t\tplayer.play();\n\t\t\tif (listener != null) {\n\t\t\t\tplayer.setOnCompletionListener(listener);\n\t\t\t}\n\t\t} catch (Exception e){\n\t\t\tGame.reportException(e);\n\t\t\tplayer = null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate synchronized float volumeWithFade(){\n\t\tif (fadeTotal > 0f){\n\t\t\treturn Math.max(0, volume * ((fadeTotal - fadeTime) / fadeTotal));\n\t\t} else {\n\t\t\treturn volume;\n\t\t}\n\t}",
          "uniqueId": "dc6749f43effbf7da6ef2e77dde2cfdb434d54d3_166_179_242_248_194_207"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c7d71180e61042e063cbe76c8522f3dfeb453d6c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c7d71180e61042e063cbe76c8522f3dfeb453d6c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\t\tflee();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\t\tprocessHarm();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void processHarm(){\n\n\t\t//do nothing if the shopkeeper is out of the hero's FOV\n\t\tif (!Dungeon.level.heroFOV[pos]){\n\t\t\treturn;\n\t\t}\n\n\t\tif (turnsSinceHarmed == -1){\n\t\t\tturnsSinceHarmed = 0;\n\t\t\tyell(Messages.get(this, \"warn\"));\n\n\t\t\t//cleanses all harmful blobs in the shop\n\t\t\tArrayList<Blob> blobs = new ArrayList<>();\n\t\t\tfor (Class c : new BlobImmunity().immunities()){\n\t\t\t\tBlob b = Dungeon.level.blobs.get(c);\n\t\t\t\tif (b != null && b.volume > 0){\n\t\t\t\t\tblobs.add(b);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPathFinder.buildDistanceMap( pos, BArray.not( Dungeon.level.solid, null ), 4 );\n\n\t\t\tfor (int i=0; i < Dungeon.level.length(); i++) {\n\t\t\t\tif (PathFinder.distance[i] < Integer.MAX_VALUE) {\n\n\t\t\t\t\tboolean affected = false;\n\t\t\t\t\tfor (Blob blob : blobs) {\n\t\t\t\t\t\tif (blob.cur[i] > 0) {\n\t\t\t\t\t\t\tblob.clear(i);\n\t\t\t\t\t\t\taffected = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (affected && Dungeon.level.heroFOV[i]) {\n\t\t\t\t\t\tCellEmitter.get( i ).burst( Speck.factory( Speck.DISCOVER ), 2 );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t//There is a 1 turn buffer before more damage/debuffs make the shopkeeper flee\n\t\t//This is mainly to prevent stacked effects from causing an instant flee\n\t\t} else if (turnsSinceHarmed >= 1) {\n\t\t\tflee();\n\t\t}\n\t}",
          "uniqueId": "c7d71180e61042e063cbe76c8522f3dfeb453d6c_77_80_100_145_87_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8f741edbc91d1c476f36e04a84cb58b1b63cce7d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8f741edbc91d1c476f36e04a84cb58b1b63cce7d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Vein( int pos ) {\n\t\t\tsuper();\n\t\t\t\n\t\t\tthis.pos = pos;\n\t\t\t\n\t\t\tdelay = Random.Float( 2 );\n\t\t}",
          "sourceCodeAfterRefactoring": "public Vein( int pos ) {\n\t\t\tthis(pos, false);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Vein( int pos, boolean includeOverhang ) {\n\t\t\tsuper();\n\t\t\t\n\t\t\tthis.pos = pos;\n\t\t\tthis.includeOverhang = includeOverhang;\n\t\t\t\n\t\t\tdelay = Random.Float( 2 );\n\t\t}",
          "uniqueId": "8f741edbc91d1c476f36e04a84cb58b1b63cce7d_176_182_187_194_183_185"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void addCavesVisuals( Level level, Group group ) {\n\t\tfor (int i=0; i < level.length(); i++) {\n\t\t\tif (level.map[i] == Terrain.WALL_DECO) {\n\t\t\t\tgroup.add( new Vein( i ) );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void addCavesVisuals( Level level, Group group ) {\n\t\taddCavesVisuals(level, group, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void addCavesVisuals( Level level, Group group, boolean overHang ) {\n\t\tfor (int i=0; i < level.length(); i++) {\n\t\t\tif (level.map[i] == Terrain.WALL_DECO) {\n\t\t\t\tgroup.add( new Vein( i, overHang ) );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "8f741edbc91d1c476f36e04a84cb58b1b63cce7d_162_168_167_173_163_165"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "af0cef90dec8581a62554f35fd4860c901e5e9e0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/af0cef90dec8581a62554f35fd4860c901e5e9e0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected boolean continueWandering(){\n\t\t\tenemySeen = false;\n\t\t\t\n\t\t\tint oldPos = pos;\n\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t} else {\n\t\t\t\ttarget = Dungeon.level.randomDestination( Mob.this );\n\t\t\t\tspend( TICK );\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "protected boolean continueWandering(){\n\t\t\tenemySeen = false;\n\t\t\t\n\t\t\tint oldPos = pos;\n\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t} else {\n\t\t\t\ttarget = randomDestination();\n\t\t\t\tspend( TICK );\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int randomDestination(){\n\t\t\treturn Dungeon.level.randomDestination( Mob.this );\n\t\t}",
          "uniqueId": "af0cef90dec8581a62554f35fd4860c901e5e9e0_1076_1089_1091_1093_1076_1089"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected boolean continueWandering() {\n\t\t\tenemySeen = false;\n\n\t\t\tint oldPos = pos;\n\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t} else if (!Dungeon.bossLevel() && target != -1 && target != pos && selfTeleCooldown <= 0) {\n\t\t\t\t((GolemSprite)sprite).teleParticles(true);\n\t\t\t\tteleporting = true;\n\t\t\t\tspend( 2*TICK );\n\t\t\t} else {\n\t\t\t\ttarget = Dungeon.level.randomDestination( Golem.this );\n\t\t\t\tspend( TICK );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected boolean continueWandering() {\n\t\t\tenemySeen = false;\n\n\t\t\tint oldPos = pos;\n\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t} else if (!Dungeon.bossLevel() && target != -1 && target != pos && selfTeleCooldown <= 0) {\n\t\t\t\t((GolemSprite)sprite).teleParticles(true);\n\t\t\t\tteleporting = true;\n\t\t\t\tspend( 2*TICK );\n\t\t\t} else {\n\t\t\t\ttarget = randomDestination();\n\t\t\t\tspend( TICK );\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "af0cef90dec8581a62554f35fd4860c901e5e9e0_187_205_1091_1093_187_205"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "da0968702e76cd2458018252c760d67f7cfaa7b1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/da0968702e76cd2458018252c760d67f7cfaa7b1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tDoor entrance = entrance();\n\n\t\tPoint center;\n\t\tdo {\n\t\t\tcenter = center();\n\t\t} while (center.x == entrance.x || center.y == entrance.y);\n\n\t\t//draw walls between internal rooms\n\t\tPainter.drawLine(level, new Point(center.x, top+1), new Point(center.x, bottom-1), Terrain.WALL);\n\t\tPainter.drawLine(level, new Point(left+1, center.y), new Point(right-1, center.y), Terrain.WALL);\n\n\t\tPoint door = new Point(entrance);\n\n\t\t//determine if the door and loot order should be clockwise or counterclockwise\n\t\tboolean clockwise;\n\t\tif (entrance.x == left || entrance.x == right){\n\t\t\tdoor.x = center.x;\n\t\t\tclockwise = entrance.y < center.y;\n\t\t\tif (entrance.x  == right) clockwise = !clockwise;\n\t\t} else {\n\t\t\tdoor.y = center.y;\n\t\t\tclockwise = entrance.x > center.x;\n\t\t\tif (entrance.y == bottom) clockwise = !clockwise;\n\t\t}\n\n\t\t//define the four sub-rooms. clockwise from top-left\n\t\tRoom[] rooms = new EmptyRoom[4];\n\t\trooms[0] = new EmptyRoom();\n\t\trooms[0].set(left+1, top+1, center.x-1, center.y-1);\n\t\trooms[1] = new EmptyRoom();\n\t\trooms[1].set(center.x+1, top+1, right-1, center.y-1);\n\t\trooms[2] = new EmptyRoom();\n\t\trooms[2].set(center.x+1, center.y+1, right-1, bottom-1);\n\t\trooms[3] = new EmptyRoom();\n\t\trooms[3].set(left+1, center.y+1, center.x-1, bottom-1);\n\n\t\t//place 3 crystal doors in the center between rooms,\n\t\t// forming a clockwise or counterclockwise pattern\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tif (door.x == center.x){\n\t\t\t\tif (door.y < center.y){\n\t\t\t\t\tdoor.y = rooms[0].center().y;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.y = rooms[2].center().y;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (door.x < center.x){\n\t\t\t\t\tdoor.x = rooms[0].center().x;\n\t\t\t\t} else {\n\t\t\t\t\tdoor.x = rooms[1].center().x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tPainter.set(level, door, Terrain.CRYSTAL_DOOR);\n\t\t\tdoor.x -= center.x;\n\t\t\tdoor.y -= center.y;\n\t\t\tint tmp = door.x;\n\t\t\tdoor.x = door.y;\n\t\t\tdoor.y = tmp;\n\t\t\tif (clockwise)  door.x = -door.x;\n\t\t\telse            door.y = -door.y;\n\t\t\tdoor.x += center.x;\n\t\t\tdoor.y += center.y;\n\t\t}\n\n\t\t//figure out room order for loot, and start generating it!\n\t\tint idx = 0;\n\t\tfor (int i = 0; i < rooms.length; i++){\n\t\t\trooms[i].set(rooms[i].shrink(-2)); //we grow/shrink the room to increase intersection bounds\n\t\t\tif (rooms[i].inside(entrance)){\n\t\t\t\tidx = i;\n\t\t\t}\n\t\t\trooms[i].set(rooms[i].shrink(2));\n\t\t}\n\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tint pos = level.pointToCell(rooms[idx].center());\n\t\t\tItem item;\n\t\t\tswitch (i){\n\t\t\t\tcase 0: default:\n\t\t\t\t\titem = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\titem = Generator.random(Generator.Category.POTION);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Generator.random(Generator.Category.SCROLL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (Random.Int(4)){\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\tcase 0: item = new StoneOfAugmentation(); break;\n\t\t\t\t\t\tcase 1: item = new ScrollOfTransmutation(); break;\n\t\t\t\t\t\tcase 2: item = new Starflower.Seed(); break;\n\t\t\t\t\t\tcase 3: item = new PotionOfExperience(); break;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlevel.drop(item, pos);\n\t\t\tif (clockwise){\n\t\t\t\tidx++;\n\t\t\t\tif (idx > 3) idx = 0;\n\t\t\t} else {\n\t\t\t\tidx--;\n\t\t\t\tif (idx < 0) idx = 3;\n\t\t\t}\n\t\t}\n\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\t\tlevel.addItemToSpawn( new CrystalKey( Dungeon.depth ) );\n\n\t\tentrance().set( Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\n\t\tPainter.fill( level, this, Terrain.WALL );\n\n\t\t//rooms are ordered from closest to furthest from the entrance\n\t\tEmptyRoom[] rooms = new EmptyRoom[6];\n\t\tfor( int i=0; i<rooms.length; i++){\n\t\t\trooms[i] = new EmptyRoom();\n\t\t}\n\n\t\tPoint entry = new Point(entrance());\n\n\t\tint prize1 = 0, prize2 = 0;\n\t\tif (entry.x == left || entry.x == right){\n\n\t\t\tPainter.drawInside(level, this, entry, width() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW1 = width() >= 9 ? 2 : 1;\n\t\t\tint roomW2 = width() % 2 == 0 ? 2 : 1;\n\t\t\tint roomH = height() >= 9 ? 2 : 1;\n\n\t\t\tif (entry.x == left){\n\t\t\t\trooms[0].setPos(left+1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].left, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(left+1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].left, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].right+2, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].left, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].right+2, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].left, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].right+2, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].left-1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].right+2, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].left-1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].left, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(right-roomW1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[0].right, rooms[0].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(right-roomW1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[1].right, rooms[1].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(rooms[1].left-roomW1-1, entry.y-roomH-1).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[2].right, rooms[2].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(rooms[1].left-roomW1-1, entry.y+2).resize(roomW1-1, roomH-1);\n\t\t\t\tPainter.set(level, rooms[3].right, rooms[3].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(rooms[3].left-roomW2-1, entry.y-roomH-1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[4].right+1, rooms[4].bottom-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(rooms[3].left-roomW2-1, entry.y+1).resize(roomW2-1, roomH);\n\t\t\t\tPainter.set(level, rooms[5].right+1, rooms[5].top+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].right, rooms[5].top));\n\t\t\t}\n\n\t\t} else {\n\t\t\tPainter.drawInside(level, this, entry, height() > 8 ? 5 : 3, Terrain.EMPTY);\n\n\t\t\tint roomW = width() >= 9 ? 2 : 1;\n\t\t\tint roomH1 = height() >= 9 ? 2 : 1;\n\t\t\tint roomH2 = height() % 2 == 0 ? 2 : 1;\n\n\t\t\tif (entry.y == top){\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, top+1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].top, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2,  rooms[1].bottom+2).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].top, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].top-1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1, rooms[3].bottom+2).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].top-1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].top));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].top));\n\t\t\t} else {\n\t\t\t\trooms[0].setPos(entry.x-roomW-1, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[0].right+1, rooms[0].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[1].setPos(entry.x+2, bottom-roomH1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[1].left-1, rooms[1].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[2].setPos(entry.x-roomW-1, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[2].right+1, rooms[2].bottom, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[3].setPos(entry.x+2, rooms[1].top-roomH1-1).resize(roomW-1, roomH1-1);\n\t\t\t\tPainter.set(level, rooms[3].left-1, rooms[3].bottom, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\trooms[4].setPos(entry.x-roomW-1, rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[4].right-1, rooms[4].bottom+1, Terrain.CRYSTAL_DOOR);\n\t\t\t\trooms[5].setPos(entry.x+1,  rooms[3].top-roomH2-1).resize(roomW, roomH2-1);\n\t\t\t\tPainter.set(level, rooms[5].left+1, rooms[5].bottom+1, Terrain.CRYSTAL_DOOR);\n\n\t\t\t\tprize1 = level.pointToCell(new Point(rooms[4].right, rooms[4].bottom));\n\t\t\t\tprize2 = level.pointToCell(new Point(rooms[5].left, rooms[5].bottom));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (EmptyRoom room : rooms) {\n\t\t\tPainter.fill(level, room, Terrain.EMPTY_SP);\n\t\t}\n\t\tPainter.set(level, prize1, Terrain.PEDESTAL);\n\t\tPainter.set(level, prize2, Terrain.PEDESTAL);\n\n\t\t//random potion/scroll in rooms 1-4, with lower value ones going into earlier rooms\n\t\tArrayList<Item> rewardItems = new ArrayList<>();\n\n\t\tArrayList<Item> duplicates = new ArrayList<>();\n\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\tif (Random.Int(2) == 0){\n\t\t\taddRewardItem(Generator.Category.POTION, rewardItems, duplicates);\n\t\t\trewardItems.add(new ScrollOfTransmutation());\n\t\t} else {\n\t\t\trewardItems.add(new PotionOfExperience());\n\t\t\taddRewardItem(Generator.Category.SCROLL, rewardItems, duplicates);\n\t\t}\n\n\t\t//need to undo the changes to spawn chances that the duplicates created\n\t\tfor (Item i : duplicates){\n\t\t\tGenerator.undoDrop(i);\n\t\t}\n\n\t\t//rarer potions/scroll go later in the order\n\t\tCollections.sort(rewardItems, new Comparator<Item>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Item a, Item b) {\n\t\t\t\tint aVal = 0, bVal = 0;\n\t\t\t\tfor (int i = 0; i < Generator.Category.POTION.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.POTION.classes[i]) aVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.POTION.classes[i]) bVal = (int)Generator.Category.POTION.defaultProbs[i];\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < Generator.Category.SCROLL.classes.length; i++){\n\t\t\t\t\tif (a.getClass() == Generator.Category.SCROLL.classes[i]) aVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t\tif (b.getClass() == Generator.Category.SCROLL.classes[i]) bVal = (int)Generator.Category.SCROLL.defaultProbs[i];\n\t\t\t\t}\n\n\t\t\t\treturn aVal - bVal;\n\t\t\t}\n\t\t});\n\n\t\t//least valuable items go into rooms 2&3, then rooms 0&1, and finally 4&5\n\t\tint shuffle = Random.Int(2);\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 2 : 3].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 3 : 2].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 0 : 1].center()));\n\t\tlevel.drop(rewardItems.remove(0), level.pointToCell(rooms[shuffle == 1 ? 1 : 0].center()));\n\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize1 : prize2);\n\t\tlevel.drop(rewardItems.remove(0), shuffle == 1 ? prize2 : prize1);\n\n\t\tentrance().set( Door.Type.UNLOCKED );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addRewardItem(Generator.Category cat, ArrayList<Item> items, ArrayList<Item> dupes){\n\t\twhile (true) {\n\t\t\tItem reward = Generator.random(cat);\n\n\t\t\tboolean dupe = false;\n\t\t\tfor (Item i : items){\n\t\t\t\tif (i.isSimilar(reward)){\n\t\t\t\t\tdupes.add(reward);\n\t\t\t\t\tdupe = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!dupe){\n\t\t\t\titems.add(reward);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "da0968702e76cd2458018252c760d67f7cfaa7b1_48_168_214_232_45_211"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d6fa0b82dddaf09295a009a6f08e3a2b958d3733",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d6fa0b82dddaf09295a009a6f08e3a2b958d3733",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void decorate(Level level, ArrayList<Room> rooms) {\n\t\t\n\t\tint w = level.width();\n\t\tint l = level.length();\n\t\tint[] map = level.map;\n\n\t\tfor (Room r : rooms) {\n\t\t\tfor (Room n : r.neigbours) {\n\t\t\t\tif (!r.connected.containsKey( n )) {\n\t\t\t\t\tmergeRooms(level, r, n, null, Terrain.CHASM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (Room room : rooms) {\n\t\t\tif (!(room instanceof StandardRoom)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (room.width() <= 4 || room.height() <= 4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint s = room.square();\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.left + 1) + (room.top + 1) * w;\n\t\t\t\tif (map[corner - 1] == Terrain.WALL && map[corner - w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.right - 1) + (room.top + 1) * w;\n\t\t\t\tif (map[corner + 1] == Terrain.WALL && map[corner - w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.left + 1) + (room.bottom - 1) * w;\n\t\t\t\tif (map[corner - 1] == Terrain.WALL && map[corner + w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.right - 1) + (room.bottom - 1) * w;\n\t\t\t\tif (map[corner + 1] == Terrain.WALL && map[corner + w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tfor (int i=w + 1; i < l - w; i++) {\n\t\t\tif (map[i] == Terrain.EMPTY) {\n\t\t\t\tint n = 0;\n\t\t\t\tif (map[i+1] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i-1] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i+w] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i-w] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (Random.Int( 6 ) <= n) {\n\t\t\t\t\tmap[i] = Terrain.EMPTY_DECO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i < l - w; i++) {\n\t\t\tif (map[i] == Terrain.WALL &&\n\t\t\t\t\tDungeonTileSheet.floorTile(map[i + w])\n\t\t\t\t\t&& Random.Int( 4 ) == 0) {\n\t\t\t\tmap[i] = Terrain.WALL_DECO;\n\t\t\t}\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void decorate(Level level, ArrayList<Room> rooms) {\n\t\t\n\t\tint w = level.width();\n\t\tint l = level.length();\n\t\tint[] map = level.map;\n\n\t\tfor (Room r : rooms) {\n\t\t\tfor (Room n : r.neigbours) {\n\t\t\t\tif (!r.connected.containsKey( n )) {\n\t\t\t\t\tmergeRooms(level, r, n, null, Terrain.CHASM);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (Room room : rooms) {\n\t\t\tif (!(room instanceof StandardRoom)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tif (room.width() <= 4 || room.height() <= 4) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint s = room.square();\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.left + 1) + (room.top + 1) * w;\n\t\t\t\tif (map[corner - 1] == Terrain.WALL && map[corner - w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.right - 1) + (room.top + 1) * w;\n\t\t\t\tif (map[corner + 1] == Terrain.WALL && map[corner - w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.left + 1) + (room.bottom - 1) * w;\n\t\t\t\tif (map[corner - 1] == Terrain.WALL && map[corner + w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Random.Int( s ) > 8) {\n\t\t\t\tint corner = (room.right - 1) + (room.bottom - 1) * w;\n\t\t\t\tif (map[corner + 1] == Terrain.WALL && map[corner + w] == Terrain.WALL) {\n\t\t\t\t\tmap[corner] = Terrain.WALL;\n\t\t\t\t\tlevel.traps.remove(corner);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tfor (int i=w + 1; i < l - w; i++) {\n\t\t\tif (map[i] == Terrain.EMPTY) {\n\t\t\t\tint n = 0;\n\t\t\t\tif (map[i+1] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i-1] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i+w] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (map[i-w] == Terrain.WALL) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (Random.Int( 6 ) <= n) {\n\t\t\t\t\tmap[i] = Terrain.EMPTY_DECO;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tgenerateGold(level, rooms);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void generateGold(Level level, ArrayList<Room> rooms){\n\t\tint w = level.width();\n\t\tint l = level.length();\n\t\tint[] map = level.map;\n\n\t\tfor (int i=0; i < l - w; i++) {\n\t\t\tif (map[i] == Terrain.WALL &&\n\t\t\t\t\tDungeonTileSheet.floorTile(map[i + w])\n\t\t\t\t\t&& Random.Int( 4 ) == 0) {\n\t\t\t\tmap[i] = Terrain.WALL_DECO;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "d6fa0b82dddaf09295a009a6f08e3a2b958d3733_35_124_120_132_35_118"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "39a50a1dc0f3e51d4b574062ad51db809685b0d6",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/39a50a1dc0f3e51d4b574062ad51db809685b0d6",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected boolean act() {\n\n\t\t\t//something caused our bomb to explode early, or be defused. Do nothing.\n\t\t\tif (bomb.fuse != this){\n\t\t\t\tActor.remove( this );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//look for our bomb, remove it from its heap, and blow it up.\n\t\t\tfor (Heap heap : Dungeon.level.heaps.valueList()) {\n\t\t\t\tif (heap.items.contains(bomb)) {\n\n\t\t\t\t\t//FIXME this is a bit hacky, might want to generalize the functionality\n\t\t\t\t\t//of bombs that don't explode instantly when their fuse ends\n\t\t\t\t\tif (bomb instanceof Noisemaker){\n\n\t\t\t\t\t\t((Noisemaker) bomb).setTrigger(heap.pos);\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\theap.remove(bomb);\n\n\t\t\t\t\t\tbomb.explode(heap.pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tdiactivate();\n\t\t\t\t\tActor.remove(this);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//can't find our bomb, something must have removed it, do nothing.\n\t\t\tbomb.fuse = null;\n\t\t\tActor.remove( this );\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected boolean act() {\n\n\t\t\t//something caused our bomb to explode early, or be defused. Do nothing.\n\t\t\tif (bomb.fuse != this){\n\t\t\t\tActor.remove( this );\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//look for our bomb, remove it from its heap, and blow it up.\n\t\t\tfor (Heap heap : Dungeon.level.heaps.valueList()) {\n\t\t\t\tif (heap.items.contains(bomb)) {\n\n\t\t\t\t\ttrigger(heap);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//can't find our bomb, something must have removed it, do nothing.\n\t\t\tbomb.fuse = null;\n\t\t\tActor.remove( this );\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void trigger(Heap heap){\n\t\t\theap.remove(bomb);\n\t\t\tbomb.explode(heap.pos);\n\t\t\tActor.remove(this);\n\t\t}",
          "uniqueId": "39a50a1dc0f3e51d4b574062ad51db809685b0d6_279_315_307_311_283_305"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f39a859353a57e62316b6775ac33f0e5b341e27c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f39a859353a57e62316b6775ac33f0e5b341e27c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean act() {\n\t\tif (target.isAlive()) {\n\n\t\t\tif (target.HP < regencap() && !((Hero)target).isStarving()) {\n\t\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\t\tif (lock == null || lock.regenOn()) {\n\t\t\t\t\ttarget.HP += 1;\n\t\t\t\t\tif (target.HP == regencap()) {\n\t\t\t\t\t\t((Hero) target).resting = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tChaliceOfBlood.chaliceRegen regenBuff = Dungeon.hero.buff( ChaliceOfBlood.chaliceRegen.class);\n\n\t\t\tfloat delay = REGENERATION_DELAY;\n\t\t\tif (regenBuff != null && target.buff(MagicImmune.class) == null) {\n\t\t\t\tif (regenBuff.isCursed()) {\n\t\t\t\t\tdelay *= 1.5f;\n\t\t\t\t} else {\n\t\t\t\t\t//15% boost at +0, scaling to a 500% boost at +10\n\t\t\t\t\tdelay -= 1.33f + regenBuff.itemLevel()*0.667f;\n\t\t\t\t\tdelay /= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspend( delay );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tdiactivate();\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean act() {\n\t\tif (target.isAlive()) {\n\n\t\t\tif (target.HP < regencap() && !((Hero)target).isStarving()) {\n\t\t\t\tif (regenOn()) {\n\t\t\t\t\ttarget.HP += 1;\n\t\t\t\t\tif (target.HP == regencap()) {\n\t\t\t\t\t\t((Hero) target).resting = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tChaliceOfBlood.chaliceRegen regenBuff = Dungeon.hero.buff( ChaliceOfBlood.chaliceRegen.class);\n\n\t\t\tfloat delay = REGENERATION_DELAY;\n\t\t\tif (regenBuff != null && target.buff(MagicImmune.class) == null) {\n\t\t\t\tif (regenBuff.isCursed()) {\n\t\t\t\t\tdelay *= 1.5f;\n\t\t\t\t} else {\n\t\t\t\t\t//15% boost at +0, scaling to a 500% boost at +10\n\t\t\t\t\tdelay -= 1.33f + regenBuff.itemLevel()*0.667f;\n\t\t\t\t\tdelay /= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t}\n\t\t\t}\n\t\t\tspend( delay );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tdiactivate();\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean regenOn(){\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null && !lock.regenOn()){\n\t\t\treturn false;\n\t\t}\n\t\tif (Dungeon.level instanceof MiningLevel){\n\t\t\treturn false; //this is mainly for the current test sub-level\n\t\t}\n\t\treturn true;\n\t}",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_39_74_80_89_40_74"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (lock == null || lock.regenOn()) {\n\t\t\t\tfloat chargeGain = 100 / 500f; //500 turns to full charge\n\t\t\t\tchargeGain *= RingOfEnergy.armorChargeMultiplier(target);\n\t\t\t\tcharge += chargeGain;\n\t\t\t\tupdateQuickslot();\n\t\t\t\tif (charge > 100) {\n\t\t\t\t\tcharge = 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (Regeneration.regenOn()) {\n\t\t\t\tfloat chargeGain = 100 / 500f; //500 turns to full charge\n\t\t\t\tchargeGain *= RingOfEnergy.armorChargeMultiplier(target);\n\t\t\t\tcharge += chargeGain;\n\t\t\t\tupdateQuickslot();\n\t\t\t\tif (charge > 100) {\n\t\t\t\t\tcharge = 100;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (charger != null){\n\t\t\t\tcharger.detach();\n\t\t\t\tcharger = null;\n\t\t\t}\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn false;\n\n\t\t}",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_304_318_80_89_304_317"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (charge < chargeCap && !cursed && target.buff(MagicImmune.class) == null) {\n\t\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\t\tif (activeBuff == null && (lock == null || lock.regenOn())) {\n\t\t\t\t\tfloat missing = (chargeCap - charge);\n\t\t\t\t\tif (level() > 7) missing += 5*(level() - 7)/3f;\n\t\t\t\t\tfloat turnsToCharge = (45 - missing);\n\t\t\t\t\tturnsToCharge /= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t\tfloat chargeToGain = (1f / turnsToCharge);\n\t\t\t\t\tif (!isEquipped(Dungeon.hero)){\n\t\t\t\t\t\tchargeToGain *= 0.75f*Dungeon.hero.pointsInTalent(Talent.LIGHT_CLOAK)/3f;\n\t\t\t\t\t}\n\t\t\t\t\tpartialCharge += chargeToGain;\n\t\t\t\t}\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tcharge++;\n\t\t\t\t\tpartialCharge -= 1;\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (cooldown > 0)\n\t\t\t\tcooldown --;\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (charge < chargeCap && !cursed && target.buff(MagicImmune.class) == null) {\n\t\t\t\tif (activeBuff == null && Regeneration.regenOn()) {\n\t\t\t\t\tfloat missing = (chargeCap - charge);\n\t\t\t\t\tif (level() > 7) missing += 5*(level() - 7)/3f;\n\t\t\t\t\tfloat turnsToCharge = (45 - missing);\n\t\t\t\t\tturnsToCharge /= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t\tfloat chargeToGain = (1f / turnsToCharge);\n\t\t\t\t\tif (!isEquipped(Dungeon.hero)){\n\t\t\t\t\t\tchargeToGain *= 0.75f*Dungeon.hero.pointsInTalent(Talent.LIGHT_CLOAK)/3f;\n\t\t\t\t\t}\n\t\t\t\t\tpartialCharge += chargeToGain;\n\t\t\t\t}\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tcharge++;\n\t\t\t\t\tpartialCharge -= 1;\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (cooldown > 0)\n\t\t\t\tcooldown --;\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (hero.buff(MagicImmune.class) != null) return;\n\n\t\tif (action.equals( AC_STEALTH )) {",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_226_262_80_89_226_261"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\t\n\t\t\tspend( TICK );\n\t\t\t\n\t\t\tif (ghost == null && ghostID != 0){\n\t\t\t\tActor a = Actor.findById(ghostID);\n\t\t\t\tif (a != null){\n\t\t\t\t\tghost = (GhostHero)a;\n\t\t\t\t} else {\n\t\t\t\t\tghostID = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ghost != null && !ghost.isAlive()){\n\t\t\t\tghost = null;\n\t\t\t}\n\t\t\t\n\t\t\t//rose does not charge while ghost hero is alive\n\t\t\tif (ghost != null && !cursed && target.buff(MagicImmune.class) == null){\n\t\t\t\t\n\t\t\t\t//heals to full over 500 turns\n\t\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\t\tif (ghost.HP < ghost.HT && (lock == null || lock.regenOn())) {\n\t\t\t\t\tpartialCharge += (ghost.HT / 500f) * RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t\t\n\t\t\t\t\tif (partialCharge > 1) {\n\t\t\t\t\t\tghost.HP++;\n\t\t\t\t\t\tpartialCharge--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& (lock == null || lock.regenOn())) {\n\t\t\t\t//500 turns to a full charge\n\t\t\t\tpartialCharge += (1/5f * RingOfEnergy.artifactChargeMultiplier(target));\n\t\t\t\tif (partialCharge > 1){\n\t\t\t\t\tcharge++;\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0f;\n\t\t\t\t\t\tGLog.p( Messages.get(DriedRose.class, \"charged\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cursed && Random.Int(100) == 0) {\n\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<>();\n\n\t\t\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = target.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tWraith.spawnAt(Random.element(spawnPoints), false);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CURSED);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\t\n\t\t\tspend( TICK );\n\t\t\t\n\t\t\tif (ghost == null && ghostID != 0){\n\t\t\t\tActor a = Actor.findById(ghostID);\n\t\t\t\tif (a != null){\n\t\t\t\t\tghost = (GhostHero)a;\n\t\t\t\t} else {\n\t\t\t\t\tghostID = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ghost != null && !ghost.isAlive()){\n\t\t\t\tghost = null;\n\t\t\t}\n\t\t\t\n\t\t\t//rose does not charge while ghost hero is alive\n\t\t\tif (ghost != null && !cursed && target.buff(MagicImmune.class) == null){\n\t\t\t\t\n\t\t\t\t//heals to full over 500 turns\n\t\t\t\tif (ghost.HP < ghost.HT && Regeneration.regenOn()) {\n\t\t\t\t\tpartialCharge += (ghost.HT / 500f) * RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t\t\n\t\t\t\t\tif (partialCharge > 1) {\n\t\t\t\t\t\tghost.HP++;\n\t\t\t\t\t\tpartialCharge--;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//500 turns to a full charge\n\t\t\t\tpartialCharge += (1/5f * RingOfEnergy.artifactChargeMultiplier(target));\n\t\t\t\tif (partialCharge > 1){\n\t\t\t\t\tcharge++;\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0f;\n\t\t\t\t\t\tGLog.p( Messages.get(DriedRose.class, \"charged\") );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cursed && Random.Int(100) == 0) {\n\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<>();\n\n\t\t\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = target.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tWraith.spawnAt(Random.element(spawnPoints), false);\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CURSED);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nimport java.util.ArrayList;\n\npublic class DriedRose extends Artifact {\n\n\t{\n\t\timage = ItemSpriteSheet.ARTIFACT_ROSE1;\n\n\t\tlevelCap = 10;\n\n\t\tcharge = 100;",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_378_452_80_89_378_450"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tint chargeTarget = 5+(level()*2);\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeTarget\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& (lock == null || lock.regenOn())) {\n\t\t\t\t//gains a charge in 40 - 2*missingCharge turns\n\t\t\t\tfloat chargeGain = (1 / (40f - (chargeTarget - charge)*2f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\t\t\t} else if (cursed && Random.Int(100) == 0){\n\t\t\t\tBuff.prolong( target, Cripple.class, 10f);\n\t\t\t}\n\n\t\t\tif (partialCharge >= 1) {\n\t\t\t\tpartialCharge --;\n\t\t\t\tcharge ++;\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tint chargeTarget = 5+(level()*2);\n\t\t\tif (charge < chargeTarget\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//gains a charge in 40 - 2*missingCharge turns\n\t\t\t\tfloat chargeGain = (1 / (40f - (chargeTarget - charge)*2f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\t\t\t} else if (cursed && Random.Int(100) == 0){\n\t\t\t\tBuff.prolong( target, Cripple.class, 10f);\n\t\t\t}\n\n\t\t\tif (partialCharge >= 1) {\n\t\t\t\tpartialCharge --;\n\t\t\t\tcharge ++;\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int targetingPos( Hero user, int dst ){\n\t\treturn dst;\n\t}\n\n\t@Override\n\tpublic void execute(Hero hero, String action) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (hero.buff(MagicImmune.class) != null) return;",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_305_331_80_89_305_330"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeCap && !cursed && (lock == null || lock.regenOn())) {\n\t\t\t\tpartialCharge += 1 / (100f - (chargeCap - charge)*10f);\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (charge < chargeCap && !cursed && Regeneration.regenOn()) {\n\t\t\t\tpartialCharge += 1 / (100f - (chargeCap - charge)*10f);\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void storeInBundle( Bundle bundle ) {\n\t\tsuper.storeInBundle( bundle );\n\t\tbundle.put( DEPTH, returnDepth );\n\t\tif (returnDepth != -1) {\n\t\t\tbundle.put( POS, returnPos );\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void restoreFromBundle( Bundle bundle ) {",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_312_331_80_89_312_330"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tspend( TICK );\n\n\t\t\tboolean smthFound = false;\n\n\t\t\tint distance = 3;\n\n\t\t\tint cx = target.pos % Dungeon.level.width();\n\t\t\tint cy = target.pos / Dungeon.level.width();\n\t\t\tint ax = cx - distance;\n\t\t\tif (ax < 0) {\n\t\t\t\tax = 0;\n\t\t\t}\n\t\t\tint bx = cx + distance;\n\t\t\tif (bx >= Dungeon.level.width()) {\n\t\t\t\tbx = Dungeon.level.width() - 1;\n\t\t\t}\n\t\t\tint ay = cy - distance;\n\t\t\tif (ay < 0) {\n\t\t\t\tay = 0;\n\t\t\t}\n\t\t\tint by = cy + distance;\n\t\t\tif (by >= Dungeon.level.height()) {\n\t\t\t\tby = Dungeon.level.height() - 1;\n\t\t\t}\n\n\t\t\tfor (int y = ay; y <= by; y++) {\n\t\t\t\tfor (int x = ax, p = ax + y * Dungeon.level.width(); x <= bx; x++, p++) {\n\n\t\t\t\t\tif (Dungeon.level.heroFOV[p]\n\t\t\t\t\t\t\t&& Dungeon.level.secret[p]\n\t\t\t\t\t\t\t&& Dungeon.level.map[p] != Terrain.SECRET_DOOR) {\n\t\t\t\t\t\tif (Dungeon.level.traps.get(p) != null && Dungeon.level.traps.get(p).canBeSearched) {\n\t\t\t\t\t\t\tsmthFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (smthFound\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null){\n\t\t\t\tif (!warn){\n\t\t\t\t\tGLog.w( Messages.get(this, \"uneasy\") );\n\t\t\t\t\tif (target instanceof Hero){\n\t\t\t\t\t\t((Hero)target).interrupt();\n\t\t\t\t\t}\n\t\t\t\t\twarn = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarn = false;\n\t\t\t}\n\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& (lock == null || lock.regenOn())) {\n\t\t\t\t//fully charges in 2000 turns at +0, scaling to 1000 turns at +10.\n\t\t\t\tfloat chargeGain = (0.05f+(level()*0.005f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge > 1 && charge < chargeCap) {\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tcharge++;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t} else if (charge >= chargeCap) {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tGLog.p( Messages.get(TalismanOfForesight.class, \"full_charge\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tspend( TICK );\n\n\t\t\tboolean smthFound = false;\n\n\t\t\tint distance = 3;\n\n\t\t\tint cx = target.pos % Dungeon.level.width();\n\t\t\tint cy = target.pos / Dungeon.level.width();\n\t\t\tint ax = cx - distance;\n\t\t\tif (ax < 0) {\n\t\t\t\tax = 0;\n\t\t\t}\n\t\t\tint bx = cx + distance;\n\t\t\tif (bx >= Dungeon.level.width()) {\n\t\t\t\tbx = Dungeon.level.width() - 1;\n\t\t\t}\n\t\t\tint ay = cy - distance;\n\t\t\tif (ay < 0) {\n\t\t\t\tay = 0;\n\t\t\t}\n\t\t\tint by = cy + distance;\n\t\t\tif (by >= Dungeon.level.height()) {\n\t\t\t\tby = Dungeon.level.height() - 1;\n\t\t\t}\n\n\t\t\tfor (int y = ay; y <= by; y++) {\n\t\t\t\tfor (int x = ax, p = ax + y * Dungeon.level.width(); x <= bx; x++, p++) {\n\n\t\t\t\t\tif (Dungeon.level.heroFOV[p]\n\t\t\t\t\t\t\t&& Dungeon.level.secret[p]\n\t\t\t\t\t\t\t&& Dungeon.level.map[p] != Terrain.SECRET_DOOR) {\n\t\t\t\t\t\tif (Dungeon.level.traps.get(p) != null && Dungeon.level.traps.get(p).canBeSearched) {\n\t\t\t\t\t\t\tsmthFound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (smthFound\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null){\n\t\t\t\tif (!warn){\n\t\t\t\t\tGLog.w( Messages.get(this, \"uneasy\") );\n\t\t\t\t\tif (target instanceof Hero){\n\t\t\t\t\t\t((Hero)target).interrupt();\n\t\t\t\t\t}\n\t\t\t\t\twarn = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twarn = false;\n\t\t\t}\n\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//fully charges in 2000 turns at +0, scaling to 1000 turns at +10.\n\t\t\t\tfloat chargeGain = (0.05f+(level()*0.005f));\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge > 1 && charge < chargeCap) {\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tcharge++;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t} else if (charge >= chargeCap) {\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tGLog.p( Messages.get(TalismanOfForesight.class, \"full_charge\") );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tsuper.execute(hero, action);\n\n\t\tif (hero.buff(MagicImmune.class) != null) return;\n\n\t\tif (action.equals(AC_SCRY)){\n\t\t\tif (!isEquipped(hero))  GLog.i( Messages.get(Artifact.class, \"need_to_equip\") );\n\t\t\telse if (charge < 5)    GLog.i( Messages.get(this, \"low_charge\") );",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_263_338_80_89_263_337"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& (lock == null || lock.regenOn())) {\n\t\t\t\t//90 turns to charge at full, 60 turns to charge at 0/10\n\t\t\t\tfloat chargeGain = 1 / (90f - (chargeCap - charge)*3f);\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cursed && Random.Int(10) == 0)\n\t\t\t\t((Hero) target).spend( TICK );\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//90 turns to charge at full, 60 turns to charge at 0/10\n\t\t\t\tfloat chargeGain = 1 / (90f - (chargeCap - charge)*3f);\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (cursed && Random.Int(10) == 0)\n\t\t\t\t((Hero) target).spend( TICK );\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n&& (charge > 0 || activeBuff != null)) {\n\t\t\tactions.add(AC_ACTIVATE);\n\t\t}\n\t\treturn actions;\n\t}\n\n\t@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_232_261_80_89_232_260"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& (lock == null || lock.regenOn())) {\n\t\t\t\t//120 turns to charge at full, 80 turns to charge at 0/8\n\t\t\t\tfloat chargeGain = 1 / (120f - (chargeCap - charge)*5f);\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (charge < chargeCap\n\t\t\t\t\t&& !cursed\n\t\t\t\t\t&& target.buff(MagicImmune.class) == null\n\t\t\t\t\t&& Regeneration.regenOn()) {\n\t\t\t\t//120 turns to charge at full, 80 turns to charge at 0/8\n\t\t\t\tfloat chargeGain = 1 / (120f - (chargeCap - charge)*5f);\n\t\t\t\tchargeGain *= RingOfEnergy.artifactChargeMultiplier(target);\n\t\t\t\tpartialCharge += chargeGain;\n\n\t\t\t\tif (partialCharge >= 1) {\n\t\t\t\t\tpartialCharge --;\n\t\t\t\t\tcharge ++;\n\n\t\t\t\t\tif (charge == chargeCap){\n\t\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdateQuickslot();\n\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic UnstableSpellbook() {\n\t\tsuper();\n\n\t\tClass<?>[] scrollClasses = Generator.Category.SCROLL.classes;\n\t\tfloat[] probs = Generator.Category.SCROLL.defaultProbs.clone(); //array of primitives, clone gives deep copy.\n\t\tint i = Random.chances(probs);\n\n\t\twhile (i != -1){\n\t\t\tscrolls.add(scrollClasses[i]);\n\t\t\tprobs[i] = 0;",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_289_316_80_89_289_315"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void recharge(){\n\t\t\tint missingCharges = maxCharges - curCharges;\n\t\t\tmissingCharges = Math.max(0, missingCharges);\n\n\t\t\tfloat turnsToCharge = (float) (BASE_CHARGE_DELAY\n\t\t\t\t\t+ (SCALING_CHARGE_ADDITION * Math.pow(scalingFactor, missingCharges)));\n\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (lock == null || lock.regenOn())\n\t\t\t\tpartialCharge += (1f/turnsToCharge) * RingOfEnergy.wandChargeMultiplier(target);\n\n\t\t\tfor (Recharging bonus : target.buffs(Recharging.class)){\n\t\t\t\tif (bonus != null && bonus.remainder() > 0f) {\n\t\t\t\t\tpartialCharge += CHARGE_BUFF_BONUS * bonus.remainder();\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "private void recharge(){\n\t\t\tint missingCharges = maxCharges - curCharges;\n\t\t\tmissingCharges = Math.max(0, missingCharges);\n\n\t\t\tfloat turnsToCharge = (float) (BASE_CHARGE_DELAY\n\t\t\t\t\t+ (SCALING_CHARGE_ADDITION * Math.pow(scalingFactor, missingCharges)));\n\n\t\t\tif (Regeneration.regenOn())\n\t\t\t\tpartialCharge += (1f/turnsToCharge) * RingOfEnergy.wandChargeMultiplier(target);\n\n\t\t\tfor (Recharging bonus : target.buffs(Recharging.class)){\n\t\t\t\tif (bonus != null && bonus.remainder() > 0f) {\n\t\t\t\t\tpartialCharge += CHARGE_BUFF_BONUS * bonus.remainder();\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean curseInfusionBonus = false;\n\tpublic int resinBonus = 0;\n\n\tprivate static final int USES_TO_ID = 10;\n\tprivate float usesLeftToID = USES_TO_ID;\n\tprivate float availableUsesToID = USES_TO_ID/2f;\n\n\tprotected int collisionProperties = Ballistica.MAGIC_BOLT;\n\t\n\t{",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_716_732_80_89_716_731"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tLockedFloor lock = target.buff(LockedFloor.class);\n\t\t\tif (charges < chargeCap()){\n\t\t\t\tif (lock == null || lock.regenOn()){\n\t\t\t\t\tpartialCharge += 1/(40f-(chargeCap()-charges)); // 40 to 30 turns per charge\n\t\t\t\t}\n\n\t\t\t\tint points = ((Hero)target).pointsInTalent(Talent.WEAPON_RECHARGING);\n\t\t\t\tif (points > 0 && target.buff(Recharging.class) != null || target.buff(ArtifactRecharge.class) != null){\n\t\t\t\t\t//1 every 10 turns at +1, 6 turns at +2\n\t\t\t\t\tpartialCharge += 1/(14f - 4f*points);\n\t\t\t\t}\n\n\t\t\t\tif (partialCharge >= 1){\n\t\t\t\t\tcharges++;\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (Dungeon.hero.subClass == HeroSubClass.CHAMPION\n\t\t\t\t\t&& secondCharges < secondChargeCap()) {\n\t\t\t\tif (lock == null || lock.regenOn()) {\n\t\t\t\t\t// 80 to 60 turns per charge without talent\n\t\t\t\t\t// up to 53.333 to 40 turns per charge at max talent level\n\t\t\t\t\tsecondPartialCharge += secondChargeMultiplier() / (40f-(secondChargeCap()-secondCharges));\n\t\t\t\t}\n\n\t\t\t\tif (secondPartialCharge >= 1) {\n\t\t\t\t\tsecondCharges++;\n\t\t\t\t\tsecondPartialCharge--;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tsecondPartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (ActionIndicator.action != this && Dungeon.hero.subClass == HeroSubClass.CHAMPION) {\n\t\t\t\tActionIndicator.setAction(this);\n\t\t\t}\n\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (charges < chargeCap()){\n\t\t\t\tif (Regeneration.regenOn()){\n\t\t\t\t\tpartialCharge += 1/(40f-(chargeCap()-charges)); // 40 to 30 turns per charge\n\t\t\t\t}\n\n\t\t\t\tint points = ((Hero)target).pointsInTalent(Talent.WEAPON_RECHARGING);\n\t\t\t\tif (points > 0 && target.buff(Recharging.class) != null || target.buff(ArtifactRecharge.class) != null){\n\t\t\t\t\t//1 every 10 turns at +1, 6 turns at +2\n\t\t\t\t\tpartialCharge += 1/(14f - 4f*points);\n\t\t\t\t}\n\n\t\t\t\tif (partialCharge >= 1){\n\t\t\t\t\tcharges++;\n\t\t\t\t\tpartialCharge--;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (Dungeon.hero.subClass == HeroSubClass.CHAMPION\n\t\t\t\t\t&& secondCharges < secondChargeCap()) {\n\t\t\t\tif (Regeneration.regenOn()) {\n\t\t\t\t\t// 80 to 60 turns per charge without talent\n\t\t\t\t\t// up to 53.333 to 40 turns per charge at max talent level\n\t\t\t\t\tsecondPartialCharge += secondChargeMultiplier() / (40f-(secondChargeCap()-secondCharges));\n\t\t\t\t}\n\n\t\t\t\tif (secondPartialCharge >= 1) {\n\t\t\t\t\tsecondCharges++;\n\t\t\t\t\tsecondPartialCharge--;\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tsecondPartialCharge = 0;\n\t\t\t}\n\n\t\t\tif (ActionIndicator.action != this && Dungeon.hero.subClass == HeroSubClass.CHAMPION) {\n\t\t\t\tActionIndicator.setAction(this);\n\t\t\t}\n\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ArrayList<String> actions(Hero hero) {\n\t\tArrayList<String> actions = super.actions(hero);\n\t\tif (isEquipped(hero) && hero.heroClass == HeroClass.DUELIST){\n\t\t\tactions.add(AC_ABILITY);\n\t\t}\n\t\treturn actions;\n\t}\n\n\t@Override\n\tpublic String actionName(String action, Hero hero) {",
          "uniqueId": "f39a859353a57e62316b6775ac33f0e5b341e27c_456_503_80_89_456_502"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8d116774834ef001bc113c04fdd52e0c828b23a8",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8d116774834ef001bc113c04fdd52e0c828b23a8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Item get() {\n\t\t//daily runs do not interact with remains\n\t\tif (Dungeon.daily){\n\t\t\treturn null;\n\t\t}\n\n\t\tif (depth == -1) {\n\n\t\t\ttry {\n\t\t\t\tBundle bundle = FileUtils.bundleFromFile(BONES_FILE);\n\n\t\t\t\tdepth = bundle.getInt( LEVEL );\n\t\t\t\tif (depth > 0) {\n\t\t\t\t\titem = (Item) bundle.get(ITEM);\n\t\t\t\t}\n\n\t\t\t\treturn get();\n\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (depth == Dungeon.depth) {\n\n\t\t\t\tBundle emptyBones = new Bundle();\n\t\t\t\temptyBones.put(LEVEL, 0);\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.bundleToFile( BONES_FILE, emptyBones );\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t}\n\t\t\t\tdepth = 0;\n\n\t\t\t\t//challenged or seeded runs will always find 10 gold\n\t\t\t\tif (Dungeon.challenges != 0 || !Dungeon.customSeedText.isEmpty()){\n\t\t\t\t\titem = new Gold(10);\n\t\t\t\t}\n\n\t\t\t\tif (item == null) {\n\t\t\t\t\titem = new Gold(50);\n\t\t\t\t}\n\n\t\t\t\t//Enforces artifact uniqueness\n\t\t\t\tif (item instanceof Artifact){\n\t\t\t\t\tif (Generator.removeArtifact(((Artifact)item).getClass())) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//generates a new artifact of the same type, always +0\n\t\t\t\t\t\tArtifact artifact = Reflection.newInstance(((Artifact)item).getClass());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (artifact == null){\n\t\t\t\t\t\t\treturn new Gold(item.value());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tartifact.cursed = true;\n\t\t\t\t\t\tartifact.cursedKnown = true;\n\n\t\t\t\t\t\treturn artifact;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new Gold(item.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item.isUpgradable() && !(item instanceof MissileWeapon)) {\n\t\t\t\t\titem.cursed = true;\n\t\t\t\t\titem.cursedKnown = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item.isUpgradable()) {\n\t\t\t\t\t//caps at +3\n\t\t\t\t\tif (item.level() > 3) {\n\t\t\t\t\t\titem.degrade( item.level() - 3 );\n\t\t\t\t\t}\n\t\t\t\t\t//thrown weapons are always IDed, otherwise set unknown\n\t\t\t\t\titem.levelKnown = item instanceof MissileWeapon;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.reset();\n\t\t\t\t\n\t\t\t\treturn item;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static Item get() {\n\t\t//daily runs do not interact with remains\n\t\tif (Dungeon.daily){\n\t\t\treturn null;\n\t\t}\n\n\t\tif (depth == -1) {\n\n\t\t\ttry {\n\t\t\t\tBundle bundle = FileUtils.bundleFromFile(BONES_FILE);\n\n\t\t\t\tdepth = bundle.getInt( LEVEL );\n\t\t\t\tbranch = bundle.getInt( BRANCH );\n\t\t\t\tif (depth > 0) {\n\t\t\t\t\titem = (Item) bundle.get(ITEM);\n\t\t\t\t}\n\n\t\t\t\treturn get();\n\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (lootAtCurLevel()) {\n\n\t\t\t\tBundle emptyBones = new Bundle();\n\t\t\t\temptyBones.put(LEVEL, 0);\n\t\t\t\ttry {\n\t\t\t\t\tFileUtils.bundleToFile( BONES_FILE, emptyBones );\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t}\n\t\t\t\tdepth = 0;\n\n\t\t\t\t//challenged or seeded runs will always find 10 gold\n\t\t\t\tif (Dungeon.challenges != 0 || !Dungeon.customSeedText.isEmpty()){\n\t\t\t\t\titem = new Gold(10);\n\t\t\t\t}\n\n\t\t\t\tif (item == null) {\n\t\t\t\t\titem = new Gold(50);\n\t\t\t\t}\n\n\t\t\t\t//Enforces artifact uniqueness\n\t\t\t\tif (item instanceof Artifact){\n\t\t\t\t\tif (Generator.removeArtifact(((Artifact)item).getClass())) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//generates a new artifact of the same type, always +0\n\t\t\t\t\t\tArtifact artifact = Reflection.newInstance(((Artifact)item).getClass());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (artifact == null){\n\t\t\t\t\t\t\treturn new Gold(item.value());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tartifact.cursed = true;\n\t\t\t\t\t\tartifact.cursedKnown = true;\n\n\t\t\t\t\t\treturn artifact;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn new Gold(item.value());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item.isUpgradable() && !(item instanceof MissileWeapon)) {\n\t\t\t\t\titem.cursed = true;\n\t\t\t\t\titem.cursedKnown = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item.isUpgradable()) {\n\t\t\t\t\t//caps at +3\n\t\t\t\t\tif (item.level() > 3) {\n\t\t\t\t\t\titem.degrade( item.level() - 3 );\n\t\t\t\t\t}\n\t\t\t\t\t//thrown weapons are always IDed, otherwise set unknown\n\t\t\t\t\titem.levelKnown = item instanceof MissileWeapon;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.reset();\n\t\t\t\t\n\t\t\t\treturn item;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static boolean lootAtCurLevel(){\n\t\tif (branch == Dungeon.branch) {\n\t\t\tif (branch == 0) {\n\t\t\t\t//always match depth exactly for main path\n\t\t\t\treturn depth == Dungeon.depth;\n\t\t\t} else if (branch == 1) {\n\t\t\t\t//just match the region for quest sub-floors\n\t\t\t\treturn depth/5 == Dungeon.depth/5;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
          "uniqueId": "8d116774834ef001bc113c04fdd52e0c828b23a8_145_230_237_248_149_235"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8d3226ba5a873054273d18e7b2cd4efbf364b6f7",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8d3226ba5a873054273d18e7b2cd4efbf364b6f7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars){\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (chars && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passable;\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars){\n\t\treturn findPassable(ch, pass, vis, chars, chars);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars, boolean considerLarge){\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (considerLarge && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passable;\n\t}",
          "uniqueId": "8d3226ba5a873054273d18e7b2cd4efbf364b6f7_960_981_964_985_960_962"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "a49215ccc7f116b1adb4a02863c4bbeb06a9177f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/a49215ccc7f116b1adb4a02863c4bbeb06a9177f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static PathFinder.Path findPath(Char ch, int to, boolean[] pass, boolean[] vis, boolean chars) {\n\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (chars && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn PathFinder.find( ch.pos, to, passable );\n\n\t}",
          "sourceCodeAfterRefactoring": "public static PathFinder.Path findPath(Char ch, int to, boolean[] pass, boolean[] vis, boolean chars) {\n\n\t\treturn PathFinder.find( ch.pos, to, findPassable(ch, pass, vis, chars) );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars){\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (chars && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passable;\n\t}",
          "uniqueId": "a49215ccc7f116b1adb4a02863c4bbeb06a9177f_960_983_960_981_983_987"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int findStep(Char ch, int to, boolean[] pass, boolean[] visible, boolean chars ) {\n\n\t\tif (Dungeon.level.adjacent( ch.pos, to )) {\n\t\t\treturn Actor.findChar( to ) == null && (pass[to] || Dungeon.level.avoid[to]) ? to : -1;\n\t\t}\n\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars){\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (visible[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn PathFinder.getStep( ch.pos, to, passable );\n\n\t}",
          "sourceCodeAfterRefactoring": "public static int findStep(Char ch, int to, boolean[] pass, boolean[] visible, boolean chars ) {\n\n\t\tif (Dungeon.level.adjacent( ch.pos, to )) {\n\t\t\treturn Actor.findChar( to ) == null && (pass[to] || Dungeon.level.avoid[to]) ? to : -1;\n\t\t}\n\n\t\treturn PathFinder.getStep( ch.pos, to, findPassable(ch, pass, visible, chars) );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars){\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (chars && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passable;\n\t}",
          "uniqueId": "a49215ccc7f116b1adb4a02863c4bbeb06a9177f_985_1012_960_981_989_997"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int flee( Char ch, int from, boolean[] pass, boolean[] visible, boolean chars ) {\n\n\t\tsetupPassable();\n\t\tif (ch.flying) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tpassable[ch.pos] = true;\n\n\t\t//only consider chars impassable if our retreat path runs into them\n\t\tint step = PathFinder.getStepBack( ch.pos, from, passable );\n\t\twhile (step != -1 && Actor.findChar(step) != null){\n\t\t\tpassable[step] = false;\n\t\t\tstep = PathFinder.getStepBack( ch.pos, from, passable );\n\t\t}\n\t\treturn step;\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "public static int flee( Char ch, int from, boolean[] pass, boolean[] visible, boolean chars ) {\n\t\t//only consider chars impassable if our retreat path runs into them\n\t\tboolean[] passable = findPassable(ch, pass, visible, false);\n\t\tpassable[ch.pos] = true;\n\n\t\tint step = PathFinder.getStepBack( ch.pos, from, passable );\n\t\twhile (step != -1 && Actor.findChar(step) != null && chars){\n\t\t\tpassable[step] = false;\n\t\t\tstep = PathFinder.getStepBack( ch.pos, from, passable );\n\t\t}\n\t\treturn step;\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean[] findPassable(Char ch, boolean[] pass, boolean[] vis, boolean chars){\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Dungeon.level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tif (chars && Char.hasProp(ch, Char.Property.LARGE)){\n\t\t\tBArray.and( passable, Dungeon.level.openSpace, passable );\n\t\t}\n\n\t\tif (chars) {\n\t\t\tfor (Char c : Actor.chars()) {\n\t\t\t\tif (vis[c.pos]) {\n\t\t\t\t\tpassable[c.pos] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn passable;\n\t}",
          "uniqueId": "a49215ccc7f116b1adb4a02863c4bbeb06a9177f_1014_1037_960_981_999_1011"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "13fb3387e740a7c0f2ab1b7a8aa28f07be10807d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/13fb3387e740a7c0f2ab1b7a8aa28f07be10807d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static MeleeWeapon randomWeapon(int floorSet) {\n\n\t\tfloorSet = (int)GameMath.gate(0, floorSet, floorSetTierProbs.length-1);\n\t\t\n\t\tMeleeWeapon w = (MeleeWeapon)random(wepTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\tw.random();\n\t\treturn w;\n\t}",
          "sourceCodeAfterRefactoring": "public static MeleeWeapon randomWeapon(int floorSet) {\n\t\treturn randomWeapon(floorSet, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static MeleeWeapon randomWeapon(int floorSet, boolean useDefaults) {\n\n\t\tfloorSet = (int)GameMath.gate(0, floorSet, floorSetTierProbs.length-1);\n\n\t\tMeleeWeapon w;\n\t\tif (useDefaults){\n\t\t\tw = (MeleeWeapon) randomUsingDefaults(wepTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\t} else {\n\t\t\tw = (MeleeWeapon) random(wepTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\t}\n\t\tw.random();\n\t\treturn w;\n\t}",
          "uniqueId": "13fb3387e740a7c0f2ab1b7a8aa28f07be10807d_637_644_649_661_641_643"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static MissileWeapon randomMissile(int floorSet) {\n\t\t\n\t\tfloorSet = (int)GameMath.gate(0, floorSet, floorSetTierProbs.length-1);\n\n\t\tMissileWeapon w = (MissileWeapon)random(misTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\tw.random();\n\t\treturn w;\n\t}",
          "sourceCodeAfterRefactoring": "public static MissileWeapon randomMissile(int floorSet) {\n\t\treturn randomMissile(floorSet, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static MissileWeapon randomMissile(int floorSet, boolean useDefaults) {\n\t\t\n\t\tfloorSet = (int)GameMath.gate(0, floorSet, floorSetTierProbs.length-1);\n\n\t\tMissileWeapon w;\n\t\tif (useDefaults){\n\t\t\tw = (MissileWeapon)randomUsingDefaults(misTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\t} else {\n\t\t\tw = (MissileWeapon)random(misTiers[Random.chances(floorSetTierProbs[floorSet])]);\n\t\t}\n\t\tw.random();\n\t\treturn w;\n\t}",
          "uniqueId": "13fb3387e740a7c0f2ab1b7a8aa28f07be10807d_658_665_683_695_675_677"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "070b380b8a013fe760d088351eeca75dff29faa7",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/070b380b8a013fe760d088351eeca75dff29faa7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void sell( Item item ) {\n\t\t\n\t\tHero hero = Dungeon.hero;\n\t\t\n\t\tif (item.isEquipped( hero ) && !((EquipableItem)item).doUnequip( hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( hero.belongings.backpack );\n\n\t\t//selling items in the sell interface doesn't spend time\n\t\thero.spend(-hero.cooldown());\n\n\t\tnew Gold( item.value() ).doPickUp( hero );\n\t}",
          "sourceCodeAfterRefactoring": "public static void sell( Item item ) {\n\t\tsell(item, null);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void sell( Item item, Shopkeeper shop ) {\n\t\t\n\t\tHero hero = Dungeon.hero;\n\t\t\n\t\tif (item.isEquipped( hero ) && !((EquipableItem)item).doUnequip( hero, false )) {\n\t\t\treturn;\n\t\t}\n\t\titem.detachAll( hero.belongings.backpack );\n\n\t\t//selling items in the sell interface doesn't spend time\n\t\thero.spend(-hero.cooldown());\n\n\t\tnew Gold( item.value() ).doPickUp( hero );\n\n\t\tif (shop != null){\n\t\t\tshop.buybackItems.add(item);\n\t\t\twhile (shop.buybackItems.size() > Shopkeeper.MAX_BUYBACK_HISTORY){\n\t\t\t\tshop.buybackItems.remove(0);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "070b380b8a013fe760d088351eeca75dff29faa7_180_193_196_216_192_194"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void sellOne( Item item ) {\n\t\t\n\t\tif (item.quantity() <= 1) {\n\t\t\tsell( item );\n\t\t} else {\n\t\t\t\n\t\t\tHero hero = Dungeon.hero;\n\t\t\t\n\t\t\titem = item.detach( hero.belongings.backpack );\n\n\t\t\t//selling items in the sell interface doesn't spend time\n\t\t\thero.spend(-hero.cooldown());\n\n\t\t\tnew Gold( item.value() ).doPickUp( hero );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void sellOne( Item item ) {\n\t\tsellOne( item, null );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void sellOne( Item item, Shopkeeper shop ) {\n\t\t\n\t\tif (item.quantity() <= 1) {\n\t\t\tsell( item, shop );\n\t\t} else {\n\t\t\t\n\t\t\tHero hero = Dungeon.hero;\n\t\t\t\n\t\t\titem = item.detach( hero.belongings.backpack );\n\n\t\t\t//selling items in the sell interface doesn't spend time\n\t\t\thero.spend(-hero.cooldown());\n\n\t\t\tnew Gold( item.value() ).doPickUp( hero );\n\n\t\t\tif (shop != null){\n\t\t\t\tshop.buybackItems.add(item);\n\t\t\t\twhile (shop.buybackItems.size() > Shopkeeper.MAX_BUYBACK_HISTORY){\n\t\t\t\t\tshop.buybackItems.remove(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "070b380b8a013fe760d088351eeca75dff29faa7_195_210_222_244_218_220"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b3fb41175cd619b8abd778b432b1e6d51a662ad2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b3fb41175cd619b8abd778b432b1e6d51a662ad2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tif (!Dungeon.level.water[pos]) {\n\t\t\tdie( null );\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn super.act();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tif (!Dungeon.level.water[pos]) {\n\t\t\tdieOnLand();\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn super.act();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void dieOnLand(){\n\t\tdie( null );\n\t}",
          "uniqueId": "b3fb41175cd619b8abd778b432b1e6d51a662ad2_65_74_103_105_65_74"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void paint(Level level ) {\n\t\t\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.WATER );\n\t\t\n\t\tDoor door = entrance();\n\t\tdoor.set( Door.Type.REGULAR );\n\n\t\tint x = -1;\n\t\tint y = -1;\n\t\tif (door.x == left) {\n\t\t\t\n\t\t\tx = right - 1;\n\t\t\ty = top + height() / 2;\n\t\t\tPainter.fill(level, left+1, top+1, 1, height()-2, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.x == right) {\n\t\t\t\n\t\t\tx = left + 1;\n\t\t\ty = top + height() / 2;\n\t\t\tPainter.fill(level, right-1, top+1, 1, height()-2, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.y == top) {\n\t\t\t\n\t\t\tx = left + width() / 2;\n\t\t\ty = bottom - 1;\n\t\t\tPainter.fill(level, left+1, top+1, width()-2, 1, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.y == bottom) {\n\t\t\t\n\t\t\tx = left + width() / 2;\n\t\t\ty = top + 1;\n\t\t\tPainter.fill(level, left+1, bottom-1, width()-2, 1, Terrain.EMPTY_SP);\n\t\t\t\n\t\t}\n\t\t\n\t\tint pos = x + y * level.width();\n\t\tlevel.drop( prize( level ), pos ).type = Heap.Type.CHEST;\n\t\tPainter.set( level, pos, Terrain.PEDESTAL );\n\t\t\n\t\tlevel.addItemToSpawn( new PotionOfInvisibility() );\n\t\t\n\t\tfor (int i=0; i < NPIRANHAS; i++) {\n\t\t\tPiranha piranha = new Piranha();\n\t\t\tdo {\n\t\t\t\tpiranha.pos = level.pointToCell(random());\n\t\t\t} while (level.map[piranha.pos] != Terrain.WATER|| level.findMob( piranha.pos ) != null);\n\t\t\tlevel.mobs.add( piranha );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void paint(Level level ) {\n\t\t\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.WATER );\n\t\t\n\t\tDoor door = entrance();\n\t\tdoor.set( Door.Type.REGULAR );\n\n\t\tint x = -1;\n\t\tint y = -1;\n\t\tif (door.x == left) {\n\t\t\t\n\t\t\tx = right - 1;\n\t\t\ty = top + height() / 2;\n\t\t\tPainter.fill(level, left+1, top+1, 1, height()-2, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.x == right) {\n\t\t\t\n\t\t\tx = left + 1;\n\t\t\ty = top + height() / 2;\n\t\t\tPainter.fill(level, right-1, top+1, 1, height()-2, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.y == top) {\n\t\t\t\n\t\t\tx = left + width() / 2;\n\t\t\ty = bottom - 1;\n\t\t\tPainter.fill(level, left+1, top+1, width()-2, 1, Terrain.EMPTY_SP);\n\t\t\t\n\t\t} else if (door.y == bottom) {\n\t\t\t\n\t\t\tx = left + width() / 2;\n\t\t\ty = top + 1;\n\t\t\tPainter.fill(level, left+1, bottom-1, width()-2, 1, Terrain.EMPTY_SP);\n\t\t\t\n\t\t}\n\t\t\n\t\tint pos = x + y * level.width();\n\t\tlevel.drop( prize( level ), pos ).type = Heap.Type.CHEST;\n\t\tPainter.set( level, pos, Terrain.PEDESTAL );\n\t\t\n\t\tlevel.addItemToSpawn( new PotionOfInvisibility() );\n\t\t\n\t\tfor (int i=0; i < NPIRANHAS; i++) {\n\t\t\tPiranha piranha = Piranha.random();\n\t\t\tdo {\n\t\t\t\tpiranha.pos = level.pointToCell(random());\n\t\t\t} while (level.map[piranha.pos] != Terrain.WATER|| level.findMob( piranha.pos ) != null);\n\t\t\tlevel.mobs.add( piranha );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "b3fb41175cd619b8abd778b432b1e6d51a662ad2_50_99_199_205_50_99"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void paint(Level level) {\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY );\n\t\tPainter.fill( level, this, 2, Terrain.EMPTY_SP );\n\t\tPainter.fill( level, this, 3, Terrain.WATER );\n\t\t\n\t\tint minDim = Math.min(width(), height());\n\t\tint numFish = (minDim - 4)/3; //1-3 fish, depending on room size\n\t\t\n\t\tfor (int i=0; i < numFish; i++) {\n\t\t\tPiranha piranha = new Piranha();\n\t\t\tdo {\n\t\t\t\tpiranha.pos = level.pointToCell(random(3));\n\t\t\t} while (level.map[piranha.pos] != Terrain.WATER|| level.findMob( piranha.pos ) != null);\n\t\t\tlevel.mobs.add( piranha );\n\t\t}\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.REGULAR );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void paint(Level level) {\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY );\n\t\tPainter.fill( level, this, 2, Terrain.EMPTY_SP );\n\t\tPainter.fill( level, this, 3, Terrain.WATER );\n\t\t\n\t\tint minDim = Math.min(width(), height());\n\t\tint numFish = (minDim - 4)/3; //1-3 fish, depending on room size\n\t\t\n\t\tfor (int i=0; i < numFish; i++) {\n\t\t\tPiranha piranha = Piranha.random();\n\t\t\tdo {\n\t\t\t\tpiranha.pos = level.pointToCell(random(3));\n\t\t\t} while (level.map[piranha.pos] != Terrain.WATER|| level.findMob( piranha.pos ) != null);\n\t\t\tlevel.mobs.add( piranha );\n\t\t}\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.REGULAR );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "b3fb41175cd619b8abd778b432b1e6d51a662ad2_57_78_199_205_57_78"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void occupyCell( Char ch ){\n\t\tif (!ch.isImmune(Web.class) && Blob.volumeAt(ch.pos, Web.class) > 0){\n\t\t\tblobs.get(Web.class).clear(ch.pos);\n\t\t\tWeb.affectChar( ch );\n\t\t}\n\n\t\tif (!ch.flying){\n\n\t\t\tif ( (map[ch.pos] == Terrain.GRASS || map[ch.pos] == Terrain.EMBERS)\n\t\t\t\t\t&& ch == Dungeon.hero && Dungeon.hero.hasTalent(Talent.REJUVENATING_STEPS)\n\t\t\t\t\t&& ch.buff(Talent.RejuvenatingStepsCooldown.class) == null){\n\n\t\t\t\tif (Dungeon.hero.buff(LockedFloor.class) != null && !Dungeon.hero.buff(LockedFloor.class).regenOn()){\n\t\t\t\t\tset(ch.pos, Terrain.FURROWED_GRASS);\n\t\t\t\t} else if (ch.buff(Talent.RejuvenatingStepsFurrow.class) != null && ch.buff(Talent.RejuvenatingStepsFurrow.class).count() >= 200) {\n\t\t\t\t\tset(ch.pos, Terrain.FURROWED_GRASS);\n\t\t\t\t} else {\n\t\t\t\t\tset(ch.pos, Terrain.HIGH_GRASS);\n\t\t\t\t\tBuff.count(ch, Talent.RejuvenatingStepsFurrow.class, 3 - Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));\n\t\t\t\t}\n\t\t\t\tGameScene.updateMap(ch.pos);\n\t\t\t\tBuff.affect(ch, Talent.RejuvenatingStepsCooldown.class, 15f - 5f*Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));\n\t\t\t}\n\t\t\t\n\t\t\tif (pit[ch.pos]){\n\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\tChasm.heroFall(ch.pos);\n\t\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//characters which are not the hero or a sheep 'soft' press cells\n\t\t\tpressCell( ch.pos, ch instanceof Hero || ch instanceof Sheep);\n\t\t} else {\n\t\t\tif (map[ch.pos] == Terrain.DOOR){\n\t\t\t\tDoor.enter( ch.pos );\n\t\t\t}\n\t\t}\n\n\t\tif (ch.isAlive() && ch instanceof Piranha && !water[ch.pos]){\n\t\t\tch.die(null);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void occupyCell( Char ch ){\n\t\tif (!ch.isImmune(Web.class) && Blob.volumeAt(ch.pos, Web.class) > 0){\n\t\t\tblobs.get(Web.class).clear(ch.pos);\n\t\t\tWeb.affectChar( ch );\n\t\t}\n\n\t\tif (!ch.flying){\n\n\t\t\tif ( (map[ch.pos] == Terrain.GRASS || map[ch.pos] == Terrain.EMBERS)\n\t\t\t\t\t&& ch == Dungeon.hero && Dungeon.hero.hasTalent(Talent.REJUVENATING_STEPS)\n\t\t\t\t\t&& ch.buff(Talent.RejuvenatingStepsCooldown.class) == null){\n\n\t\t\t\tif (Dungeon.hero.buff(LockedFloor.class) != null && !Dungeon.hero.buff(LockedFloor.class).regenOn()){\n\t\t\t\t\tset(ch.pos, Terrain.FURROWED_GRASS);\n\t\t\t\t} else if (ch.buff(Talent.RejuvenatingStepsFurrow.class) != null && ch.buff(Talent.RejuvenatingStepsFurrow.class).count() >= 200) {\n\t\t\t\t\tset(ch.pos, Terrain.FURROWED_GRASS);\n\t\t\t\t} else {\n\t\t\t\t\tset(ch.pos, Terrain.HIGH_GRASS);\n\t\t\t\t\tBuff.count(ch, Talent.RejuvenatingStepsFurrow.class, 3 - Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));\n\t\t\t\t}\n\t\t\t\tGameScene.updateMap(ch.pos);\n\t\t\t\tBuff.affect(ch, Talent.RejuvenatingStepsCooldown.class, 15f - 5f*Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));\n\t\t\t}\n\t\t\t\n\t\t\tif (pit[ch.pos]){\n\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\tChasm.heroFall(ch.pos);\n\t\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\t//characters which are not the hero or a sheep 'soft' press cells\n\t\t\tpressCell( ch.pos, ch instanceof Hero || ch instanceof Sheep);\n\t\t} else {\n\t\t\tif (map[ch.pos] == Terrain.DOOR){\n\t\t\t\tDoor.enter( ch.pos );\n\t\t\t}\n\t\t}\n\n\t\tif (ch.isAlive() && ch instanceof Piranha && !water[ch.pos]){\n\t\t\t((Piranha) ch).dieOnLand();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic abstract class Level implements Bundlable {\n\t\n\tpublic static enum Feeling {",
          "uniqueId": "b3fb41175cd619b8abd778b432b1e6d51a662ad2_1042_1086_103_105_1042_1086"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8c7bb67b8f3650ed35ca1ad24655a7409236c190",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8c7bb67b8f3650ed35ca1ad24655a7409236c190",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void saveGlobal() {\n\t\tif (saveNeeded) {\n\t\t\t\n\t\t\tBundle bundle = new Bundle();\n\t\t\tstore( bundle, global );\n\t\t\t\n\t\t\ttry {\n\t\t\t\tFileUtils.bundleToFile(BADGES_FILE, bundle);\n\t\t\t\tsaveNeeded = false;\n\t\t\t} catch (IOException e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void saveGlobal(){\n\t\tsaveGlobal(false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void saveGlobal(boolean force) {\n\t\tif (saveNeeded || force) {\n\t\t\t\n\t\t\tBundle bundle = new Bundle();\n\t\t\tstore( bundle, global );\n\t\t\t\n\t\t\ttry {\n\t\t\t\tFileUtils.bundleToFile(BADGES_FILE, bundle);\n\t\t\t\tsaveNeeded = false;\n\t\t\t} catch (IOException e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "8c7bb67b8f3650ed35ca1ad24655a7409236c190_292_305_296_309_292_294"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void saveGlobal(){\n\t\tif (!saveNeeded){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tBundle bundle = new Bundle();\n\t\t\n\t\tCatalog.store(bundle);\n\t\tDocument.store(bundle);\n\t\t\n\t\ttry {\n\t\t\tFileUtils.bundleToFile( JOURNAL_FILE, bundle );\n\t\t\tsaveNeeded = false;\n\t\t} catch (IOException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "public static void saveGlobal(){\n\t\tsaveGlobal(false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void saveGlobal(boolean force){\n\t\tif (!force && !saveNeeded){\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tBundle bundle = new Bundle();\n\t\t\n\t\tCatalog.store(bundle);\n\t\tDocument.store(bundle);\n\t\t\n\t\ttry {\n\t\t\tFileUtils.bundleToFile( JOURNAL_FILE, bundle );\n\t\t\tsaveNeeded = false;\n\t\t} catch (IOException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\t\t\n\t}",
          "uniqueId": "8c7bb67b8f3650ed35ca1ad24655a7409236c190_58_75_62_79_58_60"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "613182fd8de4e8ab899beae63745121f78636855",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/613182fd8de4e8ab899beae63745121f78636855",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void duelistAbility(Hero hero, Integer target) {\n\t\tif (target == null){\n\t\t\treturn;\n\t\t}\n\n\t\tChar enemy = Actor.findChar(target);\n\t\t//duelist can lunge out of her FOV, but this wastes the ability instead of cancelling if there is no target\n\t\tif (Dungeon.level.heroFOV[target]) {\n\t\t\tif (enemy == null || enemy == hero || hero.isCharmedBy(enemy)) {\n\t\t\t\tGLog.w(Messages.get(this, \"ability_no_target\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (hero.rooted || Dungeon.level.distance(hero.pos, target) < 2\n\t\t\t\t|| Dungeon.level.distance(hero.pos, target)-1 > reachFactor(hero)){\n\t\t\tGLog.w(Messages.get(this, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\tint lungeCell = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\tif (Dungeon.level.distance(hero.pos+i, target) <= reachFactor(hero)\n\t\t\t\t\t&& Actor.findChar(hero.pos+i) == null\n\t\t\t\t\t&& (Dungeon.level.passable[hero.pos+i] || (Dungeon.level.avoid[hero.pos+i] && hero.flying))){\n\t\t\t\tif (lungeCell == -1 || Dungeon.level.trueDistance(hero.pos + i, target) < Dungeon.level.trueDistance(lungeCell, target)){\n\t\t\t\t\tlungeCell = hero.pos + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (lungeCell == -1){\n\t\t\tGLog.w(Messages.get(this, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int dest = lungeCell;\n\t\thero.busy();\n\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\thero.sprite.jump(hero.pos, dest, 0, 0.1f, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tif (Dungeon.level.map[hero.pos] == Terrain.OPEN_DOOR) {\n\t\t\t\t\tDoor.leave( hero.pos );\n\t\t\t\t}\n\t\t\t\thero.pos = dest;\n\t\t\t\tDungeon.level.occupyCell(hero);\n\n\t\t\t\tif (enemy != null && hero.canAttack(enemy)) {\n\t\t\t\t\thero.sprite.attack(enemy.pos, new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t//+3+lvl damage, equivalent to +67% damage, but more consistent\n\t\t\t\t\t\t\tbeforeAbilityUsed(hero);\n\t\t\t\t\t\t\tAttackIndicator.target(enemy);\n\t\t\t\t\t\t\tif (hero.attack(enemy, 1f, augment.damageFactor(3 + level()), Char.INFINITE_ACCURACY)) {\n\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\t\t\t\t\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\t\t\t\t\tonAbilityKill(hero);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\thero.spendAndNext(hero.attackDelay());\n\t\t\t\t\t\t\tafterAbilityUsed(hero);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tbeforeAbilityUsed(hero);\n\t\t\t\t\tGLog.w(Messages.get(Rapier.class, \"ability_no_target\"));\n\t\t\t\t\thero.spendAndNext(hero.speed());\n\t\t\t\t\tafterAbilityUsed(hero);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void duelistAbility(Hero hero, Integer target) {\n\t\t//+(3+lvl) damage, equivalent to +67% damage, but more consistent\n\t\tint dmgBoost = augment.damageFactor(3 + level());\n\t\tlungeAbility(hero, target, 1, dmgBoost, this);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void lungeAbility(Hero hero, Integer target, float dmgMulti, int dmgBoost, MeleeWeapon wep){\n\t\tif (target == null){\n\t\t\treturn;\n\t\t}\n\n\t\tChar enemy = Actor.findChar(target);\n\t\t//duelist can lunge out of her FOV, but this wastes the ability instead of cancelling if there is no target\n\t\tif (Dungeon.level.heroFOV[target]) {\n\t\t\tif (enemy == null || enemy == hero || hero.isCharmedBy(enemy)) {\n\t\t\t\tGLog.w(Messages.get(wep, \"ability_no_target\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (hero.rooted || Dungeon.level.distance(hero.pos, target) < 2\n\t\t\t\t|| Dungeon.level.distance(hero.pos, target)-1 > wep.reachFactor(hero)){\n\t\t\tGLog.w(Messages.get(wep, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\tint lungeCell = -1;\n\t\tfor (int i : PathFinder.NEIGHBOURS8){\n\t\t\tif (Dungeon.level.distance(hero.pos+i, target) <= wep.reachFactor(hero)\n\t\t\t\t\t&& Actor.findChar(hero.pos+i) == null\n\t\t\t\t\t&& (Dungeon.level.passable[hero.pos+i] || (Dungeon.level.avoid[hero.pos+i] && hero.flying))){\n\t\t\t\tif (lungeCell == -1 || Dungeon.level.trueDistance(hero.pos + i, target) < Dungeon.level.trueDistance(lungeCell, target)){\n\t\t\t\t\tlungeCell = hero.pos + i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (lungeCell == -1){\n\t\t\tGLog.w(Messages.get(wep, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int dest = lungeCell;\n\t\thero.busy();\n\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\thero.sprite.jump(hero.pos, dest, 0, 0.1f, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tif (Dungeon.level.map[hero.pos] == Terrain.OPEN_DOOR) {\n\t\t\t\t\tDoor.leave( hero.pos );\n\t\t\t\t}\n\t\t\t\thero.pos = dest;\n\t\t\t\tDungeon.level.occupyCell(hero);\n\n\t\t\t\tif (enemy != null && hero.canAttack(enemy)) {\n\t\t\t\t\thero.sprite.attack(enemy.pos, new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\n\t\t\t\t\t\t\twep.beforeAbilityUsed(hero);\n\t\t\t\t\t\t\tAttackIndicator.target(enemy);\n\t\t\t\t\t\t\tif (hero.attack(enemy, dmgMulti, dmgBoost, Char.INFINITE_ACCURACY)) {\n\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\t\t\t\t\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\t\t\t\t\twep.onAbilityKill(hero);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\t\t\thero.spendAndNext(hero.attackDelay());\n\t\t\t\t\t\t\twep.afterAbilityUsed(hero);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\twep.beforeAbilityUsed(hero);\n\t\t\t\t\tGLog.w(Messages.get(Rapier.class, \"ability_no_target\"));\n\t\t\t\t\thero.spendAndNext(hero.speed());\n\t\t\t\t\twep.afterAbilityUsed(hero);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "uniqueId": "613182fd8de4e8ab899beae63745121f78636855_68_143_75_149_68_73"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "36edb9c87db5064ccb54757b582c867347570db5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/36edb9c87db5064ccb54757b582c867347570db5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void link( Char ch ) {\n\t\tsuper.link( ch );\n\t\tupdateArmor( ((MirrorImage)ch).armTier );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void link( Char ch ) {\n\t\tsuper.link( ch );\n\t\tupdateArmor();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateArmor(){\n\t\tupdateArmor( ((MirrorImage)ch).armTier );\n\t}",
          "uniqueId": "36edb9c87db5064ccb54757b582c867347570db5_42_46_54_56_43_47"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "a97bfd0c196c72f60dde740d8ca482d84f956d32",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/a97bfd0c196c72f60dde740d8ca482d84f956d32",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean teleportChar( Char ch ) {\n\n\t\tif (!(Dungeon.level instanceof RegularLevel)){\n\t\t\treturn teleportInNonRegularLevel( ch, false );\n\t\t}\n\n\t\tif (Char.hasProp(ch, Char.Property.IMMOVABLE)){\n\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint count = 20;\n\t\tint pos;\n\t\tdo {\n\t\t\tpos = Dungeon.level.randomRespawnCell( ch );\n\t\t\tif (count-- <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (pos == -1 || Dungeon.level.secret[pos]);\n\t\t\n\t\tif (pos == -1) {\n\t\t\t\n\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\treturn false;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tappear( ch, pos );\n\t\t\tDungeon.level.occupyCell( ch );\n\t\t\t\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tGLog.i( Messages.get(ScrollOfTeleportation.class, \"tele\") );\n\t\t\t\t\n\t\t\t\tDungeon.observe();\n\t\t\t\tGameScene.updateFog();\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean teleportChar( Char ch ) {\n\t\treturn teleportChar( ch, ScrollOfTeleportation.class );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean teleportChar( Char ch, Class source ) {\n\n\t\tif (!(Dungeon.level instanceof RegularLevel)){\n\t\t\treturn teleportInNonRegularLevel( ch, false );\n\t\t}\n\n\t\tif (Char.hasProp(ch, Char.Property.IMMOVABLE) || ch.isImmune(source)){\n\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint count = 20;\n\t\tint pos;\n\t\tdo {\n\t\t\tpos = Dungeon.level.randomRespawnCell( ch );\n\t\t\tif (count-- <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (pos == -1 || Dungeon.level.secret[pos]);\n\t\t\n\t\tif (pos == -1) {\n\t\t\t\n\t\t\tGLog.w( Messages.get(ScrollOfTeleportation.class, \"no_tele\") );\n\t\t\treturn false;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tappear( ch, pos );\n\t\t\tDungeon.level.occupyCell( ch );\n\t\t\t\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tGLog.i( Messages.get(ScrollOfTeleportation.class, \"tele\") );\n\t\t\t\t\n\t\t\t\tDungeon.observe();\n\t\t\t\tGameScene.updateFog();\n\t\t\t\tDungeon.hero.interrupt();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t}",
          "uniqueId": "a97bfd0c196c72f60dde740d8ca482d84f956d32_92_132_92_132_88_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b7d580c0bc7df2a1b4e1f3388ce0183def582b72",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b7d580c0bc7df2a1b4e1f3388ce0183def582b72",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void duelistAbility(Hero hero, Integer target) {\n\t\tif (target == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tChar enemy = Actor.findChar(target);\n\t\tif (enemy == null || enemy == hero || hero.isCharmedBy(enemy) || !Dungeon.level.heroFOV[target]) {\n\t\t\tGLog.w(Messages.get(this, \"ability_no_target\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hero.canAttack(enemy) || Dungeon.level.adjacent(hero.pos, enemy.pos)){\n\t\t\tGLog.w(Messages.get(this, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\thero.sprite.attack(enemy.pos, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\thero.attack(enemy, 0.75f, 0, Char.INFINITE_ACCURACY);\n\t\t\t\tonAbilityUsed(hero);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\n\t\t\t\tif (enemy.isAlive()){\n\t\t\t\t\t//trace a ballistica to our target (which will also extend past them\n\t\t\t\t\tBallistica trajectory = new Ballistica(hero.pos, enemy.pos, Ballistica.STOP_TARGET);\n\t\t\t\t\t//trim it to just be the part that goes past them\n\t\t\t\t\ttrajectory = new Ballistica(trajectory.collisionPos, trajectory.path.get(trajectory.path.size() - 1), Ballistica.PROJECTILE);\n\t\t\t\t\t//knock them back along that ballistica\n\t\t\t\t\tWandOfBlastWave.throwChar(enemy, trajectory, 1, true, false, hero.getClass());\n\t\t\t\t}\n\t\t\t\thero.spendAndNext(hero.attackDelay());\n\t\t\t}\n\t\t});\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void duelistAbility(Hero hero, Integer target) {\n\t\tSpear.spikeAbility(hero, target, 0.75f, this);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void spikeAbility(Hero hero, Integer target, float dmgMulti, MeleeWeapon wep){\n\t\tif (target == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tChar enemy = Actor.findChar(target);\n\t\tif (enemy == null || enemy == hero || hero.isCharmedBy(enemy) || !Dungeon.level.heroFOV[target]) {\n\t\t\tGLog.w(Messages.get(wep, \"ability_no_target\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hero.canAttack(enemy) || Dungeon.level.adjacent(hero.pos, enemy.pos)){\n\t\t\tGLog.w(Messages.get(wep, \"ability_bad_position\"));\n\t\t\treturn;\n\t\t}\n\n\t\thero.sprite.attack(enemy.pos, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\thero.attack(enemy, dmgMulti, 0, Char.INFINITE_ACCURACY);\n\t\t\t\twep.onAbilityUsed(hero);\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_STRONG);\n\n\t\t\t\tif (enemy.isAlive()){\n\t\t\t\t\t//trace a ballistica to our target (which will also extend past them\n\t\t\t\t\tBallistica trajectory = new Ballistica(hero.pos, enemy.pos, Ballistica.STOP_TARGET);\n\t\t\t\t\t//trim it to just be the part that goes past them\n\t\t\t\t\ttrajectory = new Ballistica(trajectory.collisionPos, trajectory.path.get(trajectory.path.size() - 1), Ballistica.PROJECTILE);\n\t\t\t\t\t//knock them back along that ballistica\n\t\t\t\t\tWandOfBlastWave.throwChar(enemy, trajectory, 1, true, false, hero.getClass());\n\t\t\t\t}\n\t\t\t\thero.spendAndNext(hero.attackDelay());\n\t\t\t}\n\t\t});\n\t}",
          "uniqueId": "b7d580c0bc7df2a1b4e1f3388ce0183def582b72_63_99_68_102_63_66"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c6d7a06eacaa6106beb06ef479a3959991b0b296",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c6d7a06eacaa6106beb06ef479a3959991b0b296",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected float procChanceMultiplier( Char defender ){\n\t\t\treturn RingOfArcana.enchantPowerMultiplier(defender);\n\t\t}",
          "sourceCodeAfterRefactoring": "protected float procChanceMultiplier( Char defender ){\n\t\t\treturn genericProcChanceMultiplier( defender );\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static float genericProcChanceMultiplier( Char defender ){\n\t\t\treturn RingOfArcana.enchantPowerMultiplier(defender);\n\t\t}",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_650_652_654_656_650_652"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected float procChanceMultiplier( Char attacker ){\n\t\t\tfloat multi = RingOfArcana.enchantPowerMultiplier(attacker);\n\t\t\tBerserk rage = attacker.buff(Berserk.class);\n\t\t\tif (rage != null) {\n\t\t\t\tmulti = rage.enchantFactor(multi);\n\t\t\t}\n\n\t\t\tif (attacker.buff(Talent.SpiritBladesTracker.class) != null\n\t\t\t\t\t&& ((Hero)attacker).pointsInTalent(Talent.SPIRIT_BLADES) == 4){\n\t\t\t\tmulti += 0.1f;\n\t\t\t}\n\t\t\tif (attacker.buff(Talent.StrikingWaveTracker.class) != null\n\t\t\t\t\t&& ((Hero)attacker).pointsInTalent(Talent.STRIKING_WAVE) == 4){\n\t\t\t\tmulti += 0.2f;\n\t\t\t}\n\t\t\treturn multi;\n\t\t}",
          "sourceCodeAfterRefactoring": "protected float procChanceMultiplier( Char attacker ){\n\t\t\treturn genericProcChanceMultiplier( attacker );\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static float genericProcChanceMultiplier( Char attacker ){\n\t\t\tfloat multi = RingOfArcana.enchantPowerMultiplier(attacker);\n\t\t\tBerserk rage = attacker.buff(Berserk.class);\n\t\t\tif (rage != null) {\n\t\t\t\tmulti = rage.enchantFactor(multi);\n\t\t\t}\n\n\t\t\tif (attacker.buff(RunicBlade.RunicSlashTracker.class) != null){\n\t\t\t\tmulti += 2f;\n\t\t\t}\n\n\t\t\tif (attacker.buff(Talent.SpiritBladesTracker.class) != null\n\t\t\t\t\t&& ((Hero)attacker).pointsInTalent(Talent.SPIRIT_BLADES) == 4){\n\t\t\t\tmulti += 0.1f;\n\t\t\t}\n\t\t\tif (attacker.buff(Talent.StrikingWaveTracker.class) != null\n\t\t\t\t\t&& ((Hero)attacker).pointsInTalent(Talent.STRIKING_WAVE) == 4){\n\t\t\t\tmulti += 0.2f;\n\t\t\t}\n\t\t\treturn multi;\n\t\t}",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_370_386_375_395_371_373"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\t\tdmg = (int)Math.ceil(dmg / AscensionChallenge.statModifier(this));\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tch.damage(dmg, link);\n\t\t\t\tif (!ch.isAlive()){\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 2;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t//TODO improve this when I have proper damage source logic\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tEndure.EndureTracker endure = buff(Endure.EndureTracker.class);\n\t\tif (endure != null){\n\t\t\tdmg = endure.enforceDamagetakenLimit(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t//FIXME: when I add proper damage properties, should add an IGNORES_SHIELDS property to use here.\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP < 0 && src instanceof Char){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * RingOfArcana.enchantPowerMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\tsprite.showStatus(HP > HT / 2 ?\n\t\t\t\t\t\t\tCharSprite.WARNING :\n\t\t\t\t\t\t\tCharSprite.NEGATIVE,\n\t\t\t\t\tInteger.toString(dmg + shielded));\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void damage( int dmg, Object src ) {\n\t\t\n\t\tif (!isAlive() || dmg < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif(isInvulnerable(src.getClass())){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (ChampionEnemy buff : buffs(ChampionEnemy.class)){\n\t\t\tdmg = (int) Math.ceil(dmg * buff.damageTakenFactor());\n\t\t}\n\t\tdmg = (int)Math.ceil(dmg / AscensionChallenge.statModifier(this));\n\n\t\tif (!(src instanceof LifeLink) && buff(LifeLink.class) != null){\n\t\t\tHashSet<LifeLink> links = buffs(LifeLink.class);\n\t\t\tfor (LifeLink link : links.toArray(new LifeLink[0])){\n\t\t\t\tif (Actor.findById(link.object) == null){\n\t\t\t\t\tlinks.remove(link);\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdmg = (int)Math.ceil(dmg / (float)(links.size()+1));\n\t\t\tfor (LifeLink link : links){\n\t\t\t\tChar ch = (Char)Actor.findById(link.object);\n\t\t\t\tch.damage(dmg, link);\n\t\t\t\tif (!ch.isAlive()){\n\t\t\t\t\tlink.detach();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tTerror t = buff(Terror.class);\n\t\tif (t != null){\n\t\t\tt.recover();\n\t\t}\n\t\tDread d = buff(Dread.class);\n\t\tif (d != null){\n\t\t\td.recover();\n\t\t}\n\t\tCharm c = buff(Charm.class);\n\t\tif (c != null){\n\t\t\tc.recover(src);\n\t\t}\n\t\tif (this.buff(Frost.class) != null){\n\t\t\tBuff.detach( this, Frost.class );\n\t\t}\n\t\tif (this.buff(MagicalSleep.class) != null){\n\t\t\tBuff.detach(this, MagicalSleep.class);\n\t\t}\n\t\tif (this.buff(Doom.class) != null && !isImmune(Doom.class)){\n\t\t\tdmg *= 2;\n\t\t}\n\t\tif (alignment != Alignment.ALLY && this.buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tdmg *= 1.25f;\n\t\t}\n\t\t\n\t\tClass<?> srcClass = src.getClass();\n\t\tif (isImmune( srcClass )) {\n\t\t\tdmg = 0;\n\t\t} else {\n\t\t\tdmg = Math.round( dmg * resist( srcClass ));\n\t\t}\n\t\t\n\t\t//TODO improve this when I have proper damage source logic\n\t\tif (AntiMagic.RESISTS.contains(src.getClass()) && buff(ArcaneArmor.class) != null){\n\t\t\tdmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}\n\t\t\n\t\tif (buff( Paralysis.class ) != null) {\n\t\t\tbuff( Paralysis.class ).processDamage(dmg);\n\t\t}\n\n\t\tEndure.EndureTracker endure = buff(Endure.EndureTracker.class);\n\t\tif (endure != null){\n\t\t\tdmg = endure.enforceDamagetakenLimit(dmg);\n\t\t}\n\n\t\tint shielded = dmg;\n\t\t//FIXME: when I add proper damage properties, should add an IGNORES_SHIELDS property to use here.\n\t\tif (!(src instanceof Hunger)){\n\t\t\tfor (ShieldBuff s : buffs(ShieldBuff.class)){\n\t\t\t\tdmg = s.absorbDamage(dmg);\n\t\t\t\tif (dmg == 0) break;\n\t\t\t}\n\t\t}\n\t\tshielded -= dmg;\n\t\tHP -= dmg;\n\n\t\tif (HP < 0 && src instanceof Char){\n\t\t\tif (((Char) src).buff(Kinetic.KineticTracker.class) != null){\n\t\t\t\tint dmgToAdd = -HP;\n\t\t\t\tdmgToAdd -= ((Char) src).buff(Kinetic.KineticTracker.class).conservedDamage;\n\t\t\t\tdmgToAdd = Math.round(dmgToAdd * Weapon.Enchantment.genericProcChanceMultiplier((Char) src));\n\t\t\t\tif (dmgToAdd > 0) {\n\t\t\t\t\tBuff.affect((Char) src, Kinetic.ConservedDamage.class).setBonus(dmgToAdd);\n\t\t\t\t}\n\t\t\t\t((Char) src).buff(Kinetic.KineticTracker.class).detach();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\tsprite.showStatus(HP > HT / 2 ?\n\t\t\t\t\t\t\tCharSprite.WARNING :\n\t\t\t\t\t\t\tCharSprite.NEGATIVE,\n\t\t\t\t\tInteger.toString(dmg + shielded));\n\t\t}\n\n\t\tif (HP < 0) HP = 0;\n\n\t\tif (!isAlive()) {\n\t\t\tdie( src );\n\t\t} else if (HP == 0 && buff(DeathMark.DeathMarkTracker.class) != null){\n\t\t\tDeathMark.processFearTheReaper(this);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\ndmg -= Random.NormalIntRange(0, buff(ArcaneArmor.class).level());\n\t\t\tif (dmg < 0) dmg = 0;\n\t\t}",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_589_707_654_656_586_704"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void reignite( Char ch, float duration ) {\n\t\tif (ch.isImmune(Burning.class)){\n\t\t\t//TODO this only works for the hero, not others who can have brimstone+arcana effect\n\t\t\t// e.g. prismatic image, shadow clone\n\t\t\tif (ch instanceof Hero\n\t\t\t\t\t&& ((Hero) ch).belongings.armor() != null\n\t\t\t\t\t&& ((Hero) ch).belongings.armor().hasGlyph(Brimstone.class, ch)){\n\t\t\t\t//has a 2*boost/50% chance to generate 1 shield per turn, to a max of 4x boost\n\t\t\t\tfloat shieldChance = 2*(RingOfArcana.enchantPowerMultiplier(ch) - 1f);\n\t\t\t\tint shieldCap = Math.round(shieldChance*4f);\n\t\t\t\tif (shieldCap > 0 && Random.Float() < shieldChance){\n\t\t\t\t\tBarrier barrier = Buff.affect(ch, Barrier.class);\n\t\t\t\t\tif (barrier.shielding() < shieldCap){\n\t\t\t\t\t\tbarrier.incShield(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tleft = duration;\n\t}",
          "sourceCodeAfterRefactoring": "public void reignite( Char ch, float duration ) {\n\t\tif (ch.isImmune(Burning.class)){\n\t\t\t//TODO this only works for the hero, not others who can have brimstone+arcana effect\n\t\t\t// e.g. prismatic image, shadow clone\n\t\t\tif (ch instanceof Hero\n\t\t\t\t\t&& ((Hero) ch).belongings.armor() != null\n\t\t\t\t\t&& ((Hero) ch).belongings.armor().hasGlyph(Brimstone.class, ch)){\n\t\t\t\t//has a 2*boost/50% chance to generate 1 shield per turn, to a max of 4x boost\n\t\t\t\tfloat shieldChance = 2*(Armor.Glyph.genericProcChanceMultiplier(ch) - 1f);\n\t\t\t\tint shieldCap = Math.round(shieldChance*4f);\n\t\t\t\tif (shieldCap > 0 && Random.Float() < shieldChance){\n\t\t\t\t\tBarrier barrier = Buff.affect(ch, Barrier.class);\n\t\t\t\t\tif (barrier.shielding() < shieldCap){\n\t\t\t\t\t\tbarrier.incShield(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tleft = duration;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_174_193_654_656_175_194"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static int drRoll( Char ch, int level ){\n\t\treturn Random.NormalIntRange(\n\t\t\t\tMath.round(level * RingOfArcana.enchantPowerMultiplier(ch)),\n\t\t\t\tMath.round((3 + (level*1.5f)) * RingOfArcana.enchantPowerMultiplier(ch)));\n\t}",
          "sourceCodeAfterRefactoring": "public static int drRoll( Char ch, int level ){\n\t\treturn Random.NormalIntRange(\n\t\t\t\tMath.round(level * genericProcChanceMultiplier(ch)),\n\t\t\t\tMath.round((3 + (level*1.5f)) * genericProcChanceMultiplier(ch)));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_119_123_654_656_119_123"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void activate(Char ch, int level){\n\t\tBuff.prolong(ch, Invisibility.class, Math.round((3 + level/2f)* RingOfArcana.enchantPowerMultiplier(ch)));\n\t\tif ( Dungeon.level.heroFOV[ch.pos] ) {\n\t\t\tSample.INSTANCE.play( Assets.Sounds.MELD );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void activate(Char ch, int level){\n\t\tBuff.prolong(ch, Invisibility.class, Math.round((3 + level/2f)* genericProcChanceMultiplier(ch)));\n\t\tif ( Dungeon.level.heroFOV[ch.pos] ) {\n\t\t\tSample.INSTANCE.play( Assets.Sounds.MELD );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_44_49_654_656_44_49"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int proc(Armor armor, Char attacker, Char defender, int damage) {\n\t\t\n\t\ttesting = true;\n\t\tfloat evasion = defender.defenseSkill(attacker);\n\t\tfloat accuracy = attacker.attackSkill(defender);\n\t\ttesting = false;\n\n\t\tevasion *= RingOfArcana.enchantPowerMultiplier(defender);\n\t\t\n\t\tfloat hitChance;\n\t\tif (evasion >= accuracy){\n\t\t\thitChance = (accuracy/evasion)/2f;\n\t\t} else {\n\t\t\thitChance = 1f - (evasion/accuracy)/2f;\n\t\t}\n\t\t\n\t\t//75% of dodge chance is applied as damage reduction\n\t\t// we clamp in case accuracy or evasion were negative\n\t\thitChance = GameMath.gate(0.25f, (1f + 3f*hitChance)/4f, 1f);\n\t\t\n\t\tdamage = (int)Math.ceil(damage * hitChance);\n\t\t\n\t\treturn damage;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int proc(Armor armor, Char attacker, Char defender, int damage) {\n\t\t\n\t\ttesting = true;\n\t\tfloat evasion = defender.defenseSkill(attacker);\n\t\tfloat accuracy = attacker.attackSkill(defender);\n\t\ttesting = false;\n\n\t\tevasion *= genericProcChanceMultiplier(defender);\n\t\t\n\t\tfloat hitChance;\n\t\tif (evasion >= accuracy){\n\t\t\thitChance = (accuracy/evasion)/2f;\n\t\t} else {\n\t\t\thitChance = 1f - (evasion/accuracy)/2f;\n\t\t}\n\t\t\n\t\t//75% of dodge chance is applied as damage reduction\n\t\t// we clamp in case accuracy or evasion were negative\n\t\thitChance = GameMath.gate(0.25f, (1f + 3f*hitChance)/4f, 1f);\n\t\t\n\t\tdamage = (int)Math.ceil(damage * hitChance);\n\t\t\n\t\treturn damage;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_34_58_654_656_34_58"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int deferDamage(int dmg){\n\t\t\t//account for icon stomach (just skip the glyph)\n\t\t\tif (target.buff(Talent.WarriorFoodImmunity.class) != null){\n\t\t\t\treturn dmg;\n\t\t\t}\n\n\t\t\tint level = Math.max( 0, this.level );\n\n\t\t\tfloat percent = (level+1)/(float)(level+6);\n\t\t\tpercent *= RingOfArcana.enchantPowerMultiplier(target);\n\n\t\t\tint amount;\n\t\t\tif (percent > 1f){\n\t\t\t\tdmg = Math.round(dmg / percent);\n\t\t\t\tamount = dmg;\n\t\t\t} else {\n\t\t\t\tamount = (int)Math.ceil(dmg * percent);\n\t\t\t}\n\n\t\t\tif (amount > 0){\n\t\t\t\tDeferedDamage deferred = Buff.affect( target, DeferedDamage.class );\n\t\t\t\tdeferred.prolong( amount );\n\n\t\t\t\ttarget.sprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", amount) );\n\t\t\t}\n\n\t\t\treturn dmg - amount;\n\t\t}",
          "sourceCodeAfterRefactoring": "public int deferDamage(int dmg){\n\t\t\t//account for icon stomach (just skip the glyph)\n\t\t\tif (target.buff(Talent.WarriorFoodImmunity.class) != null){\n\t\t\t\treturn dmg;\n\t\t\t}\n\n\t\t\tint level = Math.max( 0, this.level );\n\n\t\t\tfloat percent = (level+1)/(float)(level+6);\n\t\t\tpercent *= genericProcChanceMultiplier(target);\n\n\t\t\tint amount;\n\t\t\tif (percent > 1f){\n\t\t\t\tdmg = Math.round(dmg / percent);\n\t\t\t\tamount = dmg;\n\t\t\t} else {\n\t\t\t\tamount = (int)Math.ceil(dmg * percent);\n\t\t\t}\n\n\t\t\tif (amount > 0){\n\t\t\t\tDeferedDamage deferred = Buff.affect( target, DeferedDamage.class );\n\t\t\t\tdeferred.prolong( amount );\n\n\t\t\t\ttarget.sprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", amount) );\n\t\t\t}\n\n\t\t\treturn dmg - amount;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "c6d7a06eacaa6106beb06ef479a3959991b0b296_71_98_654_656_71_98"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f87170b2f898d3a68edddf073ed9763f3ac6702f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f87170b2f898d3a68edddf073ed9763f3ac6702f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean actMove( HeroAction.Move action ) {\n\n\t\tif (getCloser( action.dst )) {\n\t\t\treturn true;\n\n\t\t//Hero moves in place if there is high grass to trample\n\t\t} else if (!rooted && !flying && Dungeon.level.map[pos] == Terrain.HIGH_GRASS){\n\t\t\tDungeon.level.pressCell(pos);\n\t\t\tspendAndNext( 1 / speed() );\n\t\t\treturn false;\n\t\t} else {\n\t\t\tready();\n\t\t\treturn false;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private boolean actMove( HeroAction.Move action ) {\n\n\t\tif (getCloser( action.dst )) {\n\t\t\treturn true;\n\n\t\t//Hero moves in place if there is grass to trample\n\t\t} else if (isStandingOnTrampleableGrass()){\n\t\t\tDungeon.level.pressCell(pos);\n\t\t\tspendAndNext( 1 / speed() );\n\t\t\treturn false;\n\t\t} else {\n\t\t\tready();\n\t\t\treturn false;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean isStandingOnTrampleableGrass(){\n\t\treturn !rooted && !flying &&\n\t\t\t\t(Dungeon.level.map[pos] == Terrain.HIGH_GRASS || (heroClass != HeroClass.HUNTRESS && Dungeon.level.map[pos] == Terrain.FURROWED_GRASS));\n\t}",
          "uniqueId": "f87170b2f898d3a68edddf073ed9763f3ac6702f_770_784_770_773_775_789"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3c34c2790927276149c170be1446f0c49ddddd4a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3c34c2790927276149c170be1446f0c49ddddd4a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public String unlockMsg() {\n\t\tswitch (this){\n\t\t\tcase WARRIOR: default:\n\t\t\t\treturn \"\";\n\t\t\tcase MAGE:\n\t\t\t\treturn Messages.get(HeroClass.class, \"mage_unlock\");\n\t\t\tcase ROGUE:\n\t\t\t\treturn Messages.get(HeroClass.class, \"rogue_unlock\");\n\t\t\tcase HUNTRESS:\n\t\t\t\treturn Messages.get(HeroClass.class, \"huntress_unlock\");\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public String unlockMsg() {\n\t\treturn shortDesc() + \"\\n\\n\" + Messages.get(HeroClass.class, name()+\"_unlock\");\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String shortDesc(){\n\t\treturn Messages.get(HeroClass.class, name()+\"_desc_short\");\n\t}",
          "uniqueId": "3c34c2790927276149c170be1446f0c49ddddd4a_304_315_207_209_270_272"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\t\tbtnExit.visible = btnExit.active = !SPDSettings.intro();\n\t\t//do not fade when a window is open\n\t\tfor (Object v : members){\n\t\t\tif (v instanceof Window) resetFade();\n\t\t}\n\t\tif (GamesInProgress.selectedClass != null) {\n\t\t\tif (uiAlpha > 0f){\n\t\t\t\tuiAlpha -= Game.elapsed/4f;\n\t\t\t}\n\t\t\tfloat alpha = GameMath.gate(0f, uiAlpha, 1f);\n\t\t\tfor (StyledButton b : heroBtns){\n\t\t\t\tb.alpha(alpha);\n\t\t\t}\n\t\t\tstartBtn.alpha(alpha);\n\t\t\tbtnExit.icon().alpha(alpha);\n\t\t\toptionsPane.alpha(alpha);\n\t\t\tbtnOptions.icon().alpha(alpha);\n\t\t\tinfoButton.icon().alpha(alpha);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\t\tbtnExit.visible = btnExit.active = !SPDSettings.intro();\n\t\t//do not fade when a window is open\n\t\tfor (Object v : members){\n\t\t\tif (v instanceof Window) resetFade();\n\t\t}\n\t\tif (!PixelScene.landscape() && GamesInProgress.selectedClass != null) {\n\t\t\tif (uiAlpha > 0f){\n\t\t\t\tuiAlpha -= Game.elapsed/4f;\n\t\t\t}\n\t\t\tupdateFade();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateFade(){\n\t\tfloat alpha = GameMath.gate(0f, uiAlpha, 1f);\n\t\ttitle.alpha(alpha);\n\t\tfor (StyledButton b : heroBtns){\n\t\t\tb.enable(alpha != 0);\n\t\t\tb.alpha(alpha);\n\t\t}\n\t\tif (heroName != null){\n\t\t\theroName.alpha(alpha);\n\t\t\theroDesc.alpha(alpha);\n\t\t\tbtnFade.enable(alpha != 0);\n\t\t\tbtnFade.icon().alpha(alpha);\n\t\t}\n\t\tstartBtn.enable(alpha != 0);\n\t\tstartBtn.alpha(alpha);\n\t\tbtnExit.enable(alpha != 0);\n\t\tbtnExit.icon().alpha(alpha);\n\t\toptionsPane.active = optionsPane.visible && alpha != 0;\n\t\toptionsPane.alpha(alpha);\n\t\tbtnOptions.enable(alpha != 0);\n\t\tbtnOptions.icon().alpha(alpha);\n\t\tinfoButton.enable(alpha != 0);\n\t\tinfoButton.icon().alpha(alpha);\n\n\t\tif (landscape()){\n\n\t\t\tbackground.x = (Camera.main.width - background.width())/2f + (40*alpha);\n\n\t\t\tfloat fadeLeftScale = 47 * (80 - background.x)/80f;\n\t\t\tfadeLeft.scale.x = 3 + Math.max(fadeLeftScale, 0)*alpha;\n\t\t\tfadeLeft.x = background.x-4;\n\t\t\tfadeRight.x = background.x + background.width() + 4;\n\t\t}\n\n\t\tfadeLeft.x = background.x-5;\n\t\tfadeRight.x = background.x + background.width() + 5;\n\n\t\tfadeLeft.visible = background.x > 0 || (alpha > 0 && landscape());\n\t\tfadeRight.visible = background.x + background.width() < Camera.main.width;\n\t}",
          "uniqueId": "3c34c2790927276149c170be1446f0c49ddddd4a_282_304_431_470_415_429"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "168911efdac8e3a45abb418d6b996582ae64cf0d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/168911efdac8e3a45abb418d6b996582ae64cf0d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\tint ofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + ofs, 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "sourceCodeAfterRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + runTypeOfs(), 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static int runTypeOfs(){\n\t\tif (Dungeon.daily){\n\t\t\tif (Dungeon.dailyReplay){\n\t\t\t\treturn 24;\n\t\t\t} else {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t} else if (!Dungeon.customSeedText.isEmpty()){\n\t\t\treturn 8;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}",
          "uniqueId": "168911efdac8e3a45abb418d6b996582ae64cf0d_125_383_377_389_125_375"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\tint ofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + ofs, 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "sourceCodeAfterRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + runTypeOfs(), 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static int runTypeOfs(){\n\t\tif (Dungeon.daily){\n\t\t\tif (Dungeon.dailyReplay){\n\t\t\t\treturn 24;\n\t\t\t} else {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t} else if (!Dungeon.customSeedText.isEmpty()){\n\t\t\treturn 8;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}",
          "uniqueId": "168911efdac8e3a45abb418d6b996582ae64cf0d_125_383_377_389_125_375"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\tint ofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + ofs, 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\tofs = Dungeon.daily ? 16 : (!Dungeon.customSeedText.isEmpty() ? 8 : 0);\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + ofs, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "sourceCodeAfterRefactoring": "public static Image get( Icons type ) {\n\t\tImage icon = new Image( Assets.Interfaces.ICONS );\n\t\tswitch (type) {\n\n\t\t\tcase ENTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase GOLD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 17, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase RANKINGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 34, 0, 17, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase BADGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 51, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase NEWS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 68, 0, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHANGES:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 85, 0, 15, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase PREFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 102, 0, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SHPX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 119, 0, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase STAIRS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 16, 13, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARRIOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 16, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 16, 9, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 16, 16, 16 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase EXIT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 32, 15, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY:\n\t\t\t\tif (!PixelScene.landscape()){\n\t\t\t\t\treturn get(DISPLAY_PORT);\n\t\t\t\t} else {\n\t\t\t\t\treturn get(DISPLAY_LAND);\n\t\t\t\t}\n\t\t\tcase DISPLAY_PORT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 32, 12, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase DISPLAY_LAND:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase DATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 32, 14, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase AUDIO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 32, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase LANGS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 32, 14, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase CONTROLLER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 32, 16, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase KEYBOARD:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase STATS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 32, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHALLENGE_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 32, 15, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_OFF:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase RENAME_ON:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 32, 15, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 32, 15, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase LEFTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 224, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase RIGHTARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 32, 14, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase CALENDAR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 240, 16, 15, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase UNCHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHECKED:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 48, 12, 12 ) );\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase PLUS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase ARROW:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 48, 11, 11 ) );\n\t\t\t\tbreak;\n\t\t\tcase INFO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase WARNING:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK_LRG:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase TALENT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase MAGNIFY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 144, 48, 14, 14 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUFFS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 48, 16, 15 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 176, 48, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase COPY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase PASTE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 208, 48, 13, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase COIN_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase ENERGY_SML:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 192, 72, 8, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase BACKPACK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 201, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SCROLL_HOLDER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 211, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase SEED_POUCH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 221, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase WAND_HOLSTER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 231, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\t\t\tcase POTION_BANDOLIER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 241, 64, 10, 10 ) );\n\t\t\t\tbreak;\n\n\t\t\tcase TARGET:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 64, 16, 16 ) );\n\t\t\t\tbreak;\n\t\t\tcase SKULL:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase BUSY:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 24, 64, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase COMPASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 72, 7, 5 ) );\n\t\t\t\tbreak;\n\t\t\tcase SLEEP:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 64, 9, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALERT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase LOST:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 40, 72, 8, 8 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 48, 64 + runTypeOfs(), 6, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_CHASM:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 56, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_WATER:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_GRASS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 72, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_DARK:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 80, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_LARGE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 88, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_TRAPS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase DEPTH_SECRETS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 104, 64 + runTypeOfs(), 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\tcase CHAL_COUNT:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 112, 64, 7, 7 ) );\n\t\t\t\tbreak;\n\t\t\n\t\t\tcase LIBGDX:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase ALEKS:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 16, 96, 16, 13 ) );\n\t\t\t\tbreak;\n\t\t\tcase WATA:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 0, 112, 17, 12 ) );\n\t\t\t\tbreak;\n\n\t\t\t//large icons are scaled down to match game's size\n\t\t\tcase CELESTI:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 32, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase KRISTJAN:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 64, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase ARCNOR:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 96, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase PURIGRO:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 128, 96, 32, 32 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\t\t\tcase CUBE_CODE:\n\t\t\t\ticon.frame( icon.texture.uvRectBySize( 160, 96, 27, 30 ) );\n\t\t\t\ticon.scale.set(PixelScene.align(0.49f));\n\t\t\t\tbreak;\n\n\t\t}\n\t\treturn icon;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static int runTypeOfs(){\n\t\tif (Dungeon.daily){\n\t\t\tif (Dungeon.dailyReplay){\n\t\t\t\treturn 24;\n\t\t\t} else {\n\t\t\t\treturn 16;\n\t\t\t}\n\t\t} else if (!Dungeon.customSeedText.isEmpty()){\n\t\t\treturn 8;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}",
          "uniqueId": "168911efdac8e3a45abb418d6b996582ae64cf0d_125_383_377_389_125_375"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8a4efb0903b0f33a9903168b1ca6e387b0d46619",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8a4efb0903b0f33a9903168b1ca6e387b0d46619",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Image pageSprite(){\n\t\tif (pageIcon != null){\n\t\t\treturn Icons.get(pageIcon);\n\t\t} else {\n\t\t\treturn new ItemSprite(pageSprite);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Image pageSprite(){\n\t\treturn pageSprite(\"\");\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Image pageSprite(String page){\n\t\tif (page.isEmpty() || !isPageFound(page) || this != ADVENTURERS_GUIDE){\n\t\t\tif (pageIcon != null){\n\t\t\t\treturn Icons.get(pageIcon);\n\t\t\t} else {\n\t\t\t\treturn new ItemSprite(pageSprite);\n\t\t\t}\n\t\t} else {\n\t\t\t//special per-page visuals for guidebook\n\t\t\tswitch (page){\n\t\t\t\tcase Document.GUIDE_INTRO: default:\n\t\t\t\t\treturn new ItemSprite(ItemSpriteSheet.MASTERY);\n\t\t\t\tcase \"Examining\":\n\t\t\t\t\treturn Icons.get(Icons.MAGNIFY);\n\t\t\t\tcase \"Surprise_Attacks\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.ASSASSINS_BLADE );\n\t\t\t\tcase \"Identifying\":\n\t\t\t\t\treturn new ItemSprite( new ScrollOfIdentify() );\n\t\t\t\tcase \"Food\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.PASTY );\n\t\t\t\tcase \"Dieing\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.TOMB );\n\t\t\t\tcase Document.GUIDE_SEARCHING:\n\t\t\t\t\treturn Icons.get(Icons.MAGNIFY);\n\t\t\t\tcase \"Strength\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.GREATAXE );\n\t\t\t\tcase \"Upgrades\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.RING_EMERALD );\n\t\t\t\tcase \"Looting\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.CRYSTAL_KEY );\n\t\t\t\tcase \"Levelling\":\n\t\t\t\t\treturn Icons.get(Icons.TALENT);\n\t\t\t\tcase \"Positioning\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.SPIRIT_BOW );\n\t\t\t\tcase \"Magic\":\n\t\t\t\t\treturn new ItemSprite( ItemSpriteSheet.WAND_FIREBOLT );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "8a4efb0903b0f33a9903168b1ca6e387b0d46619_127_133_132_170_128_130"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ef9c47639b7f432987921d4474a15e56d4f9993b",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ef9c47639b7f432987921d4474a15e56d4f9993b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v1_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v1.3.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"UI Adjustments\",\n\t\t\t\t\"As promised, I'm making a few UI improvements in v1.3.2. Unfortunately, these ended up being smaller than expected due to some design troubles:\\n\\n\" +\n\t\t\t\t\"_-_ Boss health bars have been expanded to show current health and active buffs/debuffs.\\n\" +\n\t\t\t\t\"_-_ The Changes scene has been expanded on large enough displays. This is the first of several UI expansions I'd like to make over time.\\n\\n\" +\n\t\t\t\t\"I've mentioned more detailed enemy info at the top-left for desktop users a few times now (each enemy getting a small info pane with health and buffs/debuffs), but have unfortunately decided to scrap that feature. After playtesting it the additional UI elements just added clutter. Most critically, when many enemies were present at once (the exact situation that extra enemy info was supposed to help with) it became impossible to tell which enemy was which. Instead, in a future update I'm going to look into giving enemies expanded health bar info if you hover over them.\"));\n\n\t\tImage ic = Icons.get(Icons.SEED);\n\t\tic.hardlight(1f, 1.5f, 0.67f);\n\t\tchanges.addButton( new ChangeButton(ic, \"Seeded Run Bugfixes\",\n\t\t\t\t\"I have identified and fixed a couple of bugs which made levelgen of seeded runs with the same seed not always identical.\\n\\n\" +\n\t\t\t\t\"Unfortunately, the fixes for this will mean that some of the items generated by a particular seed will be different on v1.3.2 than v1.3.1 or v1.3.0. I generally want to avoid smaller updates changing seeded runs like this.\\n\\n\" +\n\t\t\t\t\"_-_ Fixed a bug where colors of potions, glyphs on scrolls, and gems on rings could vary between runs with the same seed.\\n\" +\n\t\t\t\t\"_-_ Fixed a bug where the number of enemies spawned over time could affect item generation on the next floor.\\n\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Characters with guaranteed dodges (e.g. spirit hawk) can now evade Yog's laser beam\\n\\n\" +\n\t\t\t\t\"_-_ Dates and countdowns for daily runs are now language neutral (only use numbers)\\n\" +\n\t\t\t\t\"_-_ The rankings scene now automatically opens the daily run window if you just ended a daily\\n\\n\" +\n\t\t\t\t\"_-_ Minor visual improvements to the amulet scene\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.3.0):\\n\" +\n\t\t\t\t\"_-_ Various rare hang and crash bugs\\n\" +\n\t\t\t\t\"_-_ Game unintentionally requesting AD ID permissions on Google Play\\n\" +\n\t\t\t\t\"_-_ Various cases of incorrect or missing controller button prompts\\n\" +\n\t\t\t\t\"_-_ Enraged brutes not being killed by cleansing darts\\n\" +\n\t\t\t\t\"_-_ Minor visual bugs in one specific floor 5 layout type\\n\" +\n\t\t\t\t\"_-_ Lit bombs being preserved with other items when defeating Tengu\\n\" +\n\t\t\t\t\"_-_ Some badges not being properly saved to a run during ascension\\n\" +\n\t\t\t\t\"_-_ Sheep spawned by woolly bomb not being dismissable in some cases\\n\" +\n\t\t\t\t\"_-_ Various rare cases where boss challenge badges wouldn't unlock\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v1.3.0):\\n\" +\n\t\t\t\t\"_-_ Gateway traps being able to teleport containers\"));\n\n\t\tchanges = new ChangeInfo(\"v1.3.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Wards and Sentries are now immune to sleep, vertigo and fear\\n\" +\n\t\t\t\t\"_-_ Updated translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.3.0):\\n\" +\n\t\t\t\t\"_-_ Runs ended by debuffs not appearing in rankings\\n\" +\n\t\t\t\t\"_-_ Bugs with new hero armor transferring ability\\n\" +\n\t\t\t\t\"_-_ Text for daily run dates not being language-neutral\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ v1.3.0 Released July 6th, 2022\\n\" +\n\t\t\t\t\"_-_ 105 days after Shattered v1.2.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tic = Icons.get(Icons.SEED);\n\t\tic.hardlight(1f, 1.5f, 0.67f);\n\t\tchanges.addButton( new ChangeButton(ic, \"Seeded Runs!\",\n\t\t\t\t\"_It's now possible to enter a custom seed when starting a new game!_\\n\\n\" +\n\t\t\t\t\"Seeds are used to determine dungeon generation, and two runs with the same seed and game version will produce the exact same dungeon to play though.\\n\\n\" +\n\t\t\t\t\"If you don't enter a custom seed, the game will use a random one to generate a random dungeon, just like it did prior to this update.\\n\\n\" +\n\t\t\t\t\"Note that only players who have won at least once can enter custom seeds, and games with custom seeds are not eligible to appear in rankings.\"));\n\n\t\tic = Icons.get(Icons.CALENDAR);\n\t\tic.hardlight(0.5f, 1f, 2f);\n\t\tchanges.addButton( new ChangeButton(ic, \"Daily Runs!\",\n\t\t\t\t\"_Every day there is a specific seeded run that's available to all players!_\\n\\n\" +\n\t\t\t\t\"The daily run makes it easy to compete again friends or other folks on the internet, without having to coordinate and share a specific seed.\\n\\n\" +\n\t\t\t\t\"The game does keep track of your previous daily scores, but at the moment there is no leaderboard. You must win at least once to have access to daily runs.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.HIGH_SCORE_2.image ), \"New Score System!\",\n\t\t\t\t\"_The game's scoring system has been overhauled to go along with seeded runs and dailies!_\\n\\n\" +\n\t\t\t\t\"The score system now factors in a bunch of new criteria like exploration, performance during boss fights, quest completions, and enabled challenges. This should make score a much better measure of player performance.\\n\\n\" +\n\t\t\t\t\"A score breakdown page has also been added to the rankings screen. This page even works for old games, and retroactively applies the challenge bonus!\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AMULET), \"Harder Ascension Route!\",\n\t\t\t\t\"_A bunch of adjustments have been made to the ascension route to make it a proper challenge!_\\n\\n\" +\n\t\t\t\t\"Enemies will get much stronger as you ascend, and it's impossible to teleport back up or flee and avoid all combat. Expect to have to work a little bit more for an ascension win!\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"UI/UX Improvements!\",\n\t\t\t\t\"_Several UI and UX Improvements have been made for desktop and mobile users_\\n\\n\" +\n\t\t\t\t\"_-_ The settings menu has been adjusted with a few new and rearranged options.\\n\" +\n\t\t\t\t\"_-_ Added radial menus for controller users, and redid default controller bindings.\\n\" +\n\t\t\t\t\"_-_ Added a quickslot swapper option for mobile portrait users.\\n\" +\n\t\t\t\t\"_-_ Keyboard and controller key bindings now have separate windows\\n\" +\n\t\t\t\t\"_-_ Added a few new key/button bindings actions\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.BOSS_CHALLENGE_5.image ), \"New Badges!\",\n\t\t\t\t\"_14 new badges have been added to the game!_\\n\\n\" +\n\t\t\t\t\"_-_ Five of these badges are 'high score' badges, meant to tie into the new score system.\\n\" +\n\t\t\t\t\"_-_ Another five of these badges are 'boss challenge' badges, which each require you to defeat a boss in a particular way.\\n\" +\n\t\t\t\t\"_-_ Four new 'cause of death' badges have also been added, which should be a little trickier than the existing ones.\\n\\n\" +\n\t\t\t\t\"Several of these badges are on the harder end, in particular the final high score and boss challenge badge should be a real challenge, even for veteran players.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SHORTSWORD, new ItemSprite.Glowing(0x000000)), \"Curse Redesigns\",\n\t\t\t\t\"_Three of the most annoying curses have been replaced or redesigned, and two more have been adjusted._\\n\\n\" +\n\t\t\t\t\"_- Fragile_ has been replaced by _explosive,_ which builds power and then explodes!\\n\" +\n\t\t\t\t\"_- Wayward_ has been redesigned to sometimes apply an accuracy reducing debuff, instead of always reducing accuracy.\\n\" +\n\t\t\t\t\"_- Exhausting_ has been replaced by _dazzling,_ which can blind both the attacker and defender.\\n\\n\" +\n\t\t\t\t\"_Anti-entropy_ and _sacrifice_ have also been nerfed (i.e. made less harsh), look at the nerfs section for more details on that.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_ODAL), Messages.get(ScrollOfMetamorphosis.class, \"name\"),\n\t\t\t\t\"The scroll of metamorphosis has been adjusted to allow more of the game's talents to work with its effect.\\n\\n\" +\n\t\t\t\t\"Several talents that were previously exempt from being chosen by the scroll now have alternative effects that let them be used by any hero.\\n\\n\" +\n\t\t\t\t\"These alternative effects only appear when getting these talents via metamorphosis.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.MONSTERS_SLAIN_5.image ), \"Badge Changes\",\n\t\t\t\t\"I'm making several changes to existing badges, based on feedback and data from Steam players:\\n\\n\" +\n\t\t\t\t\"_-_ Several gold tier badges have been bumped up to platinum tier to better reflect their difficulty\\n\" +\n\t\t\t\t\"_-_ The 'grim reaper' badge has been bumped up to gold tier, from silver\\n\\n\" +\n\t\t\t\t\"_-_ The master and grandmaster 'monsters hunter' and 'treasure hunter' badges have been made more difficult\\n\" +\n\t\t\t\t\"_-_ The alchemist badges have been rebalanced to start out easier and end up harder\\n\\n\" +\n\t\t\t\t\"_-_ The 'dungeoneer' badges have been made easier to unlock with wins or games played. The master and grandmaster versions still require a lot of games played though.\"));\n\n\t\tchanges.addButton( new ChangeButton(new BuffIcon(BuffIndicator.TARGETED, true), \"Buff and Spell Icons\",\n\t\t\t\t\"Several buffs have been given icons when they didn't have any, or have had their icons adjusted to prevent icon duplication. This should improve buff clarity in a few cases, and ensure that two active buffs can never have the exact same icon (recolored icons are still present though).\\n\\n\" +\n\t\t\t\t\"A few new overhead spell effects have been added as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Updated translations, translator credits, and added a new language: Dutch!\\n\" +\n\t\t\t\t\"_-_ Made the Huntress a bit easier to unlock again\\n\" +\n\t\t\t\t\"_-_ Dreamfoil has been renamed to Mageroyal, to better fit its lack of sleeping functionality since 1.2\\n\" +\n\t\t\t\t\"_-_ Updated various code dependencies\\n\" +\n\t\t\t\t\"_-_ Made major internal changes in prep for quest improvements in v1.4\\n\" +\n\t\t\t\t\"_-_ Added a slight delay to chasm jump confirmation window, to prevent mistaps\\n\" +\n\t\t\t\t\"_-_ Progress is now shown for badges that need to be unlocked with multiple heroes\\n\" +\n\t\t\t\t\"_-_ Multiple unlocked badges can now be shown at once\\n\" +\n\t\t\t\t\"_-_ Various minor tweaks to item and level generation to support seeded runs\\n\" +\n\t\t\t\t\"_-_ Keys now appear on top of other items in pit rooms\\n\" +\n\t\t\t\t\"_-_ Large floors now spawn two torches with the 'into darkness' challenge enabled\\n\" +\n\t\t\t\t\"_-_ Blazing champions no longer explode if they are killed by chasms\\n\" +\n\t\t\t\t\"_-_ Red sentries no longer fire on players with lost inventories\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual bugs\\n\" +\n\t\t\t\t\"_-_ Final boss's summons being slightly weaker than intended when badder bosses is enabled\\n\" +\n\t\t\t\t\"_-_ Great crab not blocking right after loading a save\\n\" +\n\t\t\t\t\"_-_ Exploits that could force DM-300 to dig outside of its arena\\n\" +\n\t\t\t\t\"_-_ Various 'cause of death' badges not being awarded if death occurred with an ankh.\\n\" +\n\t\t\t\t\"_-_ Wraiths from spectral necromancers not always dying when the necromancer dies\\n\" +\n\t\t\t\t\"_-_ The mystical charge talent giving more charge than intended\\n\" +\n\t\t\t\t\"_-_ Ring of might HP bonus not applying in specific cases\\n\" +\n\t\t\t\t\"_-_ Stones of blink disappearing if they fail to teleport\\n\" +\n\t\t\t\t\"_-_ Beacon of returning not working at all in boss arenas\\n\" +\n\t\t\t\t\"_-_ Earthen guardian not being immune to poison, gas, and bleed\\n\" +\n\t\t\t\t\"_-_ Transmogrified enemies awarding exp when the effect ends\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Buffs\",\n\t\t\t\t\"_- Endure_ damage bonus increased to 1/2 of damage taken from 1/3\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ base wand boost and max boost increased by 1\\n\" +\n\t\t\t\t\"_- Fire Everything_ now has a 25% chance per point to let a wand be usable 3 times\\n\" +\n\t\t\t\t\"_- Conserved Magic_ no longer lets a wand be usable 3 times, now grants a chance for wild magic to take 0 turns instead\\n\\n\" +\n\t\t\t\t\"_- Elemental power_ boost per point up to 25%, from 20%\\n\" +\n\t\t\t\t\"_- Reactive Barrier_ shielding per point up to 2.5, from 2, and max targets now increases by 1 per point.\\n\\n\" +\n\t\t\t\t\"_- Shadow Clone_ now costs 35 energy, down from 50. Initial HP down to 80 from 100\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per point up to 8%, from 7.5%\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per point down to 12%, from 15%\\n\\n\" +\n\t\t\t\t\"_- Eagle Eye_ now grants 9 and 10 vision range at 3 and 4 points\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now cripples at ranks 3 and 4\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now grants 2/4/6/8 dodges, up from 2/3/4/5\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.WAND_PRESERVATION), Talent.WAND_PRESERVATION.title(),\n\t\t\t\t\"Only one isolated talent change in this update:\\n\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance to preserve at +1 reverted to 67% from 50%, still grants 1 arcane resin if it fails to preserve\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CRYSTAL_KEY), \"Crystal Path Rooms\",\n\t\t\t\t\"Loot from crystal path rooms (the rooms with a sequence of 3 crystal doors) has been buffed to make their value closer to other crystal key rooms.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CLEANSING_DART), \"Alchemy Item Buffs\",\n\t\t\t\t\"I'm giving woolly bomb's a big buff to help make them more distinct from other sheep-spawning items:\\n\\n\" +\n\t\t\t\t\"_- Woolly Bombs_ now summon sheep for 200 turns, or 20 turns during boss fights, up from 12-16 turns. However, sheep no longer totally prevent bosses from summoning minions.\\n\\n\" +\n\t\t\t\t\"I've given some alternative functions to three darts that would previously only help allies:\\n\\n\" +\n\t\t\t\t\"_- Holy Dart_ turns of bless reverted to 30 from 100, now heavily damages undead or demonic enemies, instead of blessing them\\n\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ turns of adrenaline reverted to 10 from 30, now cripples enemies for 5 turns, instead of giving them adrenaline\\n\\n\" +\n\t\t\t\t\"_- Cleansing Dart_ now clears positive buffs from enemies, and causes them to start wandering (note that they may immediately re-aggro if they are close enough)\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Nerfs\",\n\t\t\t\t\"Along with several armor ability buffs, two have received energy cost nerfs, mainly to reduce the uptime of positioning/escape abilities. Some compensation buffs have been given for the energy cost change as well:\\n\\n\" +\n\t\t\t\t\"_- Heroic Leap_ energy cost up to 35 from 25\\n\" +\n\t\t\t\t\"_- Body Slam_ now adds 1-4 base damage per point in talent\\n\" +\n\t\t\t\t\"_- Impact Wave_ now applies vulnerable for 5 turns, up from 3\\n\" +\n\t\t\t\t\"_- Double jump_ energy cost reduction increased by 20%\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ energy cost up to 50 from 35\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range up to 10 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_LEATHER, new ItemSprite.Glowing(0x000000)), \"Curse Nerfs\",\n\t\t\t\t\"Two of the most harsh curses have been nerfed (i.e. made better for the player):\\n\\n\" +\n\t\t\t\t\"_- Anti-Entropy_ now spreads less fire to the player, and freezes all adjacent tiles instead of just the enemy.\\n\\n\" +\n\t\t\t\t\"_- Sacrifice_ now more heavily scales on current HP, bleeding for a bit more at high health, and very little at medium to low health.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ElementalSprite.Fire()), \"Floor 16 Adjustments\",\n\t\t\t\t\"Floor 16's spawn rates have been adjusted:\\n\\n\" +\n\t\t\t\t\"Ghouls up to 60% from 40%\\n\" +\n\t\t\t\t\"Elementals down to 20% from 40%\\n\" +\n\t\t\t\t\"Warlocks unchanged at 20%\\n\\n\" +\n\t\t\t\t\"This is to help smooth over a slight difficulty spike on that floor.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v1_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ v1.3.0 Released July 6th, 2022\\n\" +\n\t\t\t\t\"_-_ 105 days after Shattered v1.2.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tImage ic;\n\t\tic = Icons.get(Icons.SEED);\n\t\tic.hardlight(1f, 1.5f, 0.67f);\n\t\tchanges.addButton( new ChangeButton(ic, \"Seeded Runs!\",\n\t\t\t\t\"_It's now possible to enter a custom seed when starting a new game!_\\n\\n\" +\n\t\t\t\t\"Seeds are used to determine dungeon generation, and two runs with the same seed and game version will produce the exact same dungeon to play though.\\n\\n\" +\n\t\t\t\t\"If you don't enter a custom seed, the game will use a random one to generate a random dungeon, just like it did prior to this update.\\n\\n\" +\n\t\t\t\t\"Note that only players who have won at least once can enter custom seeds, and games with custom seeds are not eligible to appear in rankings.\"));\n\n\t\tic = Icons.get(Icons.CALENDAR);\n\t\tic.hardlight(0.5f, 1f, 2f);\n\t\tchanges.addButton( new ChangeButton(ic, \"Daily Runs!\",\n\t\t\t\t\"_Every day there is a specific seeded run that's available to all players!_\\n\\n\" +\n\t\t\t\t\"The daily run makes it easy to compete again friends or other folks on the internet, without having to coordinate and share a specific seed.\\n\\n\" +\n\t\t\t\t\"The game does keep track of your previous daily scores, but at the moment there is no leaderboard. You must win at least once to have access to daily runs.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.HIGH_SCORE_2.image ), \"New Score System!\",\n\t\t\t\t\"_The game's scoring system has been overhauled to go along with seeded runs and dailies!_\\n\\n\" +\n\t\t\t\t\"The score system now factors in a bunch of new criteria like exploration, performance during boss fights, quest completions, and enabled challenges. This should make score a much better measure of player performance.\\n\\n\" +\n\t\t\t\t\"A score breakdown page has also been added to the rankings screen. This page even works for old games, and retroactively applies the challenge bonus!\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AMULET), \"Harder Ascension Route!\",\n\t\t\t\t\"_A bunch of adjustments have been made to the ascension route to make it a proper challenge!_\\n\\n\" +\n\t\t\t\t\"Enemies will get much stronger as you ascend, and it's impossible to teleport back up or flee and avoid all combat. Expect to have to work a little bit more for an ascension win!\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"UI/UX Improvements!\",\n\t\t\t\t\"_Several UI and UX Improvements have been made for desktop and mobile users_\\n\\n\" +\n\t\t\t\t\"_-_ The settings menu has been adjusted with a few new and rearranged options.\\n\" +\n\t\t\t\t\"_-_ Added radial menus for controller users, and redid default controller bindings.\\n\" +\n\t\t\t\t\"_-_ Added a quickslot swapper option for mobile portrait users.\\n\" +\n\t\t\t\t\"_-_ Keyboard and controller key bindings now have separate windows\\n\" +\n\t\t\t\t\"_-_ Added a few new key/button bindings actions\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.BOSS_CHALLENGE_5.image ), \"New Badges!\",\n\t\t\t\t\"_14 new badges have been added to the game!_\\n\\n\" +\n\t\t\t\t\"_-_ Five of these badges are 'high score' badges, meant to tie into the new score system.\\n\" +\n\t\t\t\t\"_-_ Another five of these badges are 'boss challenge' badges, which each require you to defeat a boss in a particular way.\\n\" +\n\t\t\t\t\"_-_ Four new 'cause of death' badges have also been added, which should be a little trickier than the existing ones.\\n\\n\" +\n\t\t\t\t\"Several of these badges are on the harder end, in particular the final high score and boss challenge badge should be a real challenge, even for veteran players.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SHORTSWORD, new ItemSprite.Glowing(0x000000)), \"Curse Redesigns\",\n\t\t\t\t\"_Three of the most annoying curses have been replaced or redesigned, and two more have been adjusted._\\n\\n\" +\n\t\t\t\t\"_- Fragile_ has been replaced by _explosive,_ which builds power and then explodes!\\n\" +\n\t\t\t\t\"_- Wayward_ has been redesigned to sometimes apply an accuracy reducing debuff, instead of always reducing accuracy.\\n\" +\n\t\t\t\t\"_- Exhausting_ has been replaced by _dazzling,_ which can blind both the attacker and defender.\\n\\n\" +\n\t\t\t\t\"_Anti-entropy_ and _sacrifice_ have also been nerfed (i.e. made less harsh), look at the nerfs section for more details on that.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_ODAL), Messages.get(ScrollOfMetamorphosis.class, \"name\"),\n\t\t\t\t\"The scroll of metamorphosis has been adjusted to allow more of the game's talents to work with its effect.\\n\\n\" +\n\t\t\t\t\"Several talents that were previously exempt from being chosen by the scroll now have alternative effects that let them be used by any hero.\\n\\n\" +\n\t\t\t\t\"These alternative effects only appear when getting these talents via metamorphosis.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.MONSTERS_SLAIN_5.image ), \"Badge Changes\",\n\t\t\t\t\"I'm making several changes to existing badges, based on feedback and data from Steam players:\\n\\n\" +\n\t\t\t\t\"_-_ Several gold tier badges have been bumped up to platinum tier to better reflect their difficulty\\n\" +\n\t\t\t\t\"_-_ The 'grim reaper' badge has been bumped up to gold tier, from silver\\n\\n\" +\n\t\t\t\t\"_-_ The master and grandmaster 'monsters hunter' and 'treasure hunter' badges have been made more difficult\\n\" +\n\t\t\t\t\"_-_ The alchemist badges have been rebalanced to start out easier and end up harder\\n\\n\" +\n\t\t\t\t\"_-_ The 'dungeoneer' badges have been made easier to unlock with wins or games played. The master and grandmaster versions still require a lot of games played though.\"));\n\n\t\tchanges.addButton( new ChangeButton(new BuffIcon(BuffIndicator.TARGETED, true), \"Buff and Spell Icons\",\n\t\t\t\t\"Several buffs have been given icons when they didn't have any, or have had their icons adjusted to prevent icon duplication. This should improve buff clarity in a few cases, and ensure that two active buffs can never have the exact same icon (recolored icons are still present though).\\n\\n\" +\n\t\t\t\t\"A few new overhead spell effects have been added as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 1\",\n\t\t\t\t\"_-_ Updated translations, translator credits, and added a new language: Dutch!\\n\" +\n\t\t\t\t\"_-_ Made the Huntress a bit easier to unlock again\\n\" +\n\t\t\t\t\"_-_ Dreamfoil has been renamed to Mageroyal, to better fit its lack of sleeping functionality since 1.2\\n\" +\n\t\t\t\t\"_-_ Updated various code dependencies\\n\" +\n\t\t\t\t\"_-_ Made major internal changes in prep for quest improvements in v1.4\\n\" +\n\t\t\t\t\"_-_ Added a slight delay to chasm jump confirmation window, to prevent mistaps\\n\" +\n\t\t\t\t\"_-_ Progress is now shown for badges that need to be unlocked with multiple heroes\\n\" +\n\t\t\t\t\"_-_ Multiple unlocked badges can now be shown at once\\n\" +\n\t\t\t\t\"_-_ Various minor tweaks to item and level generation to support seeded runs\\n\" +\n\t\t\t\t\"_-_ Keys now appear on top of other items in pit rooms\\n\" +\n\t\t\t\t\"_-_ Large floors now spawn two torches with the 'into darkness' challenge enabled\\n\" +\n\t\t\t\t\"_-_ Blazing champions no longer explode if they are killed by chasms\\n\" +\n\t\t\t\t\"_-_ Red sentries no longer fire on players with lost inventories\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 2\",\n\t\t\t\t\"_-_ Wards and Sentries are now immune to sleep, vertigo and fear\\n\" +\n\t\t\t\t\"_-_ Characters with guaranteed dodges (e.g. spirit hawk) can now evade Yog's laser beam\\n\" +\n\t\t\t\t\"_-_ Boss health bars have been expanded to show current health and active buffs/debuffs.\\n\" +\n\t\t\t\t\"_-_ The Changes scene has been expanded on large enough displays. This is the first of several UI expansions I'd like to make over time.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual bugs\\n\" +\n\t\t\t\t\"_-_ Final boss's summons being slightly weaker than intended when badder bosses is enabled\\n\" +\n\t\t\t\t\"_-_ Great crab not blocking right after loading a save\\n\" +\n\t\t\t\t\"_-_ Exploits that could force DM-300 to dig outside of its arena\\n\" +\n\t\t\t\t\"_-_ Various 'cause of death' badges not being awarded if death occurred with an ankh.\\n\" +\n\t\t\t\t\"_-_ Wraiths from spectral necromancers not always dying when the necromancer dies\\n\" +\n\t\t\t\t\"_-_ The mystical charge talent giving more charge than intended\\n\" +\n\t\t\t\t\"_-_ Ring of might HP bonus not applying in specific cases\\n\" +\n\t\t\t\t\"_-_ Stones of blink disappearing if they fail to teleport\\n\" +\n\t\t\t\t\"_-_ Beacon of returning not working at all in boss arenas\\n\" +\n\t\t\t\t\"_-_ Earthen guardian not being immune to poison, gas, and bleed\\n\" +\n\t\t\t\t\"_-_ Transmogrified enemies awarding exp when the effect ends\\n\" +\n\t\t\t\t\"_-_ Gateway traps being able to teleport containers\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Buffs\",\n\t\t\t\t\"_- Endure_ damage bonus increased to 1/2 of damage taken from 1/3\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ base wand boost and max boost increased by 1\\n\" +\n\t\t\t\t\"_- Fire Everything_ now has a 25% chance per point to let a wand be usable 3 times\\n\" +\n\t\t\t\t\"_- Conserved Magic_ no longer lets a wand be usable 3 times, now grants a chance for wild magic to take 0 turns instead\\n\\n\" +\n\t\t\t\t\"_- Elemental power_ boost per point up to 25%, from 20%\\n\" +\n\t\t\t\t\"_- Reactive Barrier_ shielding per point up to 2.5, from 2, and max targets now increases by 1 per point.\\n\\n\" +\n\t\t\t\t\"_- Shadow Clone_ now costs 35 energy, down from 50. Initial HP down to 80 from 100\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per point up to 8%, from 7.5%\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per point down to 12%, from 15%\\n\\n\" +\n\t\t\t\t\"_- Eagle Eye_ now grants 9 and 10 vision range at 3 and 4 points\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now cripples at ranks 3 and 4\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now grants 2/4/6/8 dodges, up from 2/3/4/5\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.WAND_PRESERVATION), Talent.WAND_PRESERVATION.title(),\n\t\t\t\t\"Only one isolated talent change in this update:\\n\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance to preserve at +1 reverted to 67% from 50%, still grants 1 arcane resin if it fails to preserve\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CRYSTAL_KEY), \"Crystal Path Rooms\",\n\t\t\t\t\"Loot from crystal path rooms (the rooms with a sequence of 3 crystal doors) has been buffed to make their value closer to other crystal key rooms.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CLEANSING_DART), \"Alchemy Item Buffs\",\n\t\t\t\t\"I'm giving woolly bomb's a big buff to help make them more distinct from other sheep-spawning items:\\n\\n\" +\n\t\t\t\t\"_- Woolly Bombs_ now summon sheep for 200 turns, or 20 turns during boss fights, up from 12-16 turns. However, sheep no longer totally prevent bosses from summoning minions.\\n\\n\" +\n\t\t\t\t\"I've given some alternative functions to three darts that would previously only help allies:\\n\\n\" +\n\t\t\t\t\"_- Holy Dart_ turns of bless reverted to 30 from 100, now heavily damages undead or demonic enemies, instead of blessing them\\n\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ turns of adrenaline reverted to 10 from 30, now cripples enemies for 5 turns, instead of giving them adrenaline\\n\\n\" +\n\t\t\t\t\"_- Cleansing Dart_ now clears positive buffs from enemies, and causes them to start wandering (note that they may immediately re-aggro if they are close enough)\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Nerfs\",\n\t\t\t\t\"Along with several armor ability buffs, two have received energy cost nerfs, mainly to reduce the uptime of positioning/escape abilities. Some compensation buffs have been given for the energy cost change as well:\\n\\n\" +\n\t\t\t\t\"_- Heroic Leap_ energy cost up to 35 from 25\\n\" +\n\t\t\t\t\"_- Body Slam_ now adds 1-4 base damage per point in talent\\n\" +\n\t\t\t\t\"_- Impact Wave_ now applies vulnerable for 5 turns, up from 3\\n\" +\n\t\t\t\t\"_- Double jump_ energy cost reduction increased by 20%\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ energy cost up to 50 from 35\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range up to 10 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_LEATHER, new ItemSprite.Glowing(0x000000)), \"Curse Nerfs\",\n\t\t\t\t\"Two of the most harsh curses have been nerfed (i.e. made better for the player):\\n\\n\" +\n\t\t\t\t\"_- Anti-Entropy_ now spreads less fire to the player, and freezes all adjacent tiles instead of just the enemy.\\n\\n\" +\n\t\t\t\t\"_- Sacrifice_ now more heavily scales on current HP, bleeding for a bit more at high health, and very little at medium to low health.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ElementalSprite.Fire()), \"Floor 16 Adjustments\",\n\t\t\t\t\"Floor 16's spawn rates have been adjusted:\\n\\n\" +\n\t\t\t\t\"Ghouls up to 60% from 40%\\n\" +\n\t\t\t\t\"Elementals down to 20% from 40%\\n\" +\n\t\t\t\t\"Warlocks unchanged at 20%\\n\\n\" +\n\t\t\t\t\"This is to help smooth over a slight difficulty spike on that floor.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v1_4_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.4-ALPHA\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"To-Do\",\n\t\t\t\t\"The following still needs to be implemented for v1.4 to release:\\n\\n\" +\n\t\t\t\t\"_-_ Expansions to the game's lore, which will include multiple document pages spread through the dungeon\\n\" +\n\t\t\t\t\"_-_ A new short tutorial  at the start of the game\\n\" +\n\t\t\t\t\"_-_ Improvements to various game interfaces for desktop users\\n\" +\n\t\t\t\t\"_-_ other balance tweaks.\\n\" +\n\t\t\t\t\"_-_ other small tweaks and bugfixes\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.GUIDE_PAGE), \"Lore Additions\",\n\t\t\t\t\"More coming here soon, but for now I have slightly adjusted some of the region introduction text, and added them to the document system so they are considered lore entries like the documents coming soon.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_TOURMALINE), new RingOfArcana().trueName(),\n\t\t\t\t\"_A new ring has been added that enhances enchantments and glyphs!_\\n\\n\" +\n\t\t\t\t\"The Ring of Arcana lets the player directly power up their enchantments and glyphs, instead of only being able to power them up by upgrading the item they are attached to. This can lead to be some really potent enchant/glyph effects at high ring levels.\"));\n\n\t\tchanges.addButton(new ChangeButton(new SandalsOfNature(),\n\t\t\t\t\"_The Sandals of Nature have been given a new active ability!_\\n\\n\" +\n\t\t\t\t\"Rather than just using the effect of earthroot, the footwear of nature now use the effect of the seed most recently fed to them! These effects can be triggered on nearby enemies instead of just on you, opening up a bunch of tactical potential for this artifact.\\n\\n\" +\n\t\t\t\t\"For balance, the amount of extra seeds/dew the footwear gives has been reduced, and 1 additional seed is needed for each upgrade level.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.WARRIOR, 0, 90, 12, 15), HeroSubClass.BERSERKER.title(),\n\t\t\t\t\"_The Berserker's berserk ability is now manually activated, but has a much lower cooldown._\\n\\n\" +\n\t\t\t\t\"I'm doing this to try and make the subclass a bit more engaging, players can now trigger berserk at any point when they have 100% or more rage. Berserking still gives a big bonus shield, letting the Berserker survive normally fatal encounters. The lower the Berserker's health, the more shielding he gets.\\n\\n\" +\n\t\t\t\t\"The Berserker's talents have been adjusted as well:\\n\" +\n\t\t\t\t\"_- Endless Rage_ Now grants bonuses to berserk duration and cooldown when above 100% rage.\\n\" +\n\t\t\t\t\"_- Berserking Stamina_ has been replaced with _Deathless Fury_, which lets berserking automatically trigger just like before, but at a high cooldown cost.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.MASTERY), \"Tutorial Changes\",\n\t\t\t\t\"_-_ Adjusted story text at the very start of the game\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.DISPLAY), \"Interface Changes\",\n\t\t\t\t\"_-_ Added a new tab to the journal window for lore documents\\n\" +\n\t\t\t\t\"_-_ Added a popup window on the first game screen to explain controller pointer functionality\"));\n\n\t\tchanges.addButton(new ChangeButton( new TalentIcon(Talent.EMPOWERED_STRIKE), \"T3 Talent Redesigns\",\n\t\t\t\t\"I've made some pretty significant changes to three T3 talents that were either unpopular or too simplistic:\\n\\n\" +\n\t\t\t\t\"_- Empowered Strike_ now gives a little less direct staff damage, but also boosts the staff's on-hit effect. This should make it more interesting while still encouraging staff melee play.\\n\" +\n\t\t\t\t\"_- Excess Charge_ now triggers when the Mage's staff is zapped at full charge, instead of on-hit, but the barrier effect is a bit stronger. This should encourage a mix of staff melee and zapping, instead of just pure melee at full charge.\\n\\n\" +\n\t\t\t\t\"_- Bounty Hunter_ now increases enemy drop chance, instead of providing gold. This should make it more varied and interesting. The bonus also gets notably higher at high preparation charge, instead of scaling linearly.\"));\n\t\t//Talent changes\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 1\",\n\t\t\t\t\"_-_ Adjusted default controller bindings slightly\\n\" +\n\t\t\t\t\"_-_ The 'switch enemy' keybind now also switches tabs on tabbed windows\\n\" +\n\t\t\t\t\"_-_ On desktop, the game now attempts to keep mouse and controller pointer potions in sync\\n\" +\n\t\t\t\t\"_-_ Slightly improved the marsupial rat attacking animation\\n\" +\n\t\t\t\t\"_-_ Item boosts from potion of mastery or curse infusion now change the color of text in that item's item slot\\n\" +\n\t\t\t\t\"_-_ Improved chains vfx, especially for prison guards\\n\" +\n\t\t\t\t\"_-_ Antimagic now applies to more items\\n\" +\n\t\t\t\t\"_-_ Waiting now always takes exactly 1 turn, regardless of hero speed\\n\" +\n\t\t\t\t\"_-_ Wand of Disintegration no longer harms undiscovered neutral characters\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 2\",\n\t\t\t\t\"_-_ Improved room merging logic in a few specific situations\\n\" +\n\t\t\t\t\"_-_ Goo's pump up attack now always gives the hero at least 1 action to react\\n\" +\n\t\t\t\t\"_-_ Improved behaviour of ally AI when told to hold a position\\n\" +\n\t\t\t\t\"_-_ Added sacrifical fire and demon spawners to the landmarks page\\n\" +\n\t\t\t\t\"_-_ Added a copy and paste button to text input windows\\n\" +\n\t\t\t\t\"_-_ The scroll holder can now hold arcane resin\\n\" +\n\t\t\t\t\"_-_ Added more achievements to Shattered on Google Play Games\\n\" +\n\t\t\t\t\"_-_ Slightly adjusted enemy stats on ascension to smooth out difficulty\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 1\",\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Victory and Champion badges not be awarded in some cases\\n\" +\n\t\t\t\t\"_-_ Various rare crash and hang bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual/textual errors\\n\" +\n\t\t\t\t\"_-_ Characters rarely managing to enter eternal fire\\n\" +\n\t\t\t\t\"_-_ Invisibility effects not working on enemies\\n\" +\n\t\t\t\t\"_-_ Confusing text when a weapon or armor is partly uncursed\\n\" +\n\t\t\t\t\"_-_ 'No Weapons in His Presence' badge not stating that ring of force counts as a weapon\\n\" +\n\t\t\t\t\"_-_ Various cases where the friendly fire badge was not correctly awarded\\n\" +\n\t\t\t\t\"_-_ 13th armor ability incorrectly clearing champion enemy buffs\\n\" +\n\t\t\t\t\"_-_ Cases where piranhas could live for a turn on land\\n\" +\n\t\t\t\t\"_-_ Rare cases where lost inventory and items on stairs could softlock the game\\n\" +\n\t\t\t\t\"_-_ Hero armor transferring rarely deleting the Warrior's broken seal\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 2\",\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Scrolls of Mirror Image not identifying in rare cases\\n\" +\n\t\t\t\t\"_-_ Various incorrect interaction between kinetic/viscosity and damage mitigating effects\\n\" +\n\t\t\t\t\"_-_ Wand of Fireblast sometimes not igniting adjacent item or barricades\\n\" +\n\t\t\t\t\"_-_ Ring of Furor not affecting Sniper special abilities\\n\" +\n\t\t\t\t\"_-_ Armband not breaking invisibility\\n\" +\n\t\t\t\t\"_-_ Chalice of Blood benefitting from recharging while hero is starving\\n\" +\n\t\t\t\t\"_-_ Cases where explosive curse would create explosions at the wrong location\\n\" +\n\t\t\t\t\"_-_ Rare cases where ranged allies would refuse to target nearby enemies\\n\" +\n\t\t\t\t\"_-_ Rare cases where items would not correctly appear in the rankings screen\\n\" +\n\t\t\t\t\"_-_ Errors with wild magic or flurry and knockback effects\\n\" +\n\t\t\t\t\"_-_ Magical Sight not making the hero immune to blindness\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 3\",\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Additional cases where magical spellbook could generate scrolls of lullaby\\n\" +\n\t\t\t\t\"_-_ Targeting logic sometimes being incorrect on armor abilities\\n\" +\n\t\t\t\t\"_-_ Shadow clone not benefiting from certain glyphs\\n\" +\n\t\t\t\t\"_-_ Heavy boomerangs getting an accuracy penalty when returning\\n\" +\n\t\t\t\t\"_-_ Various rare cases where characters might stack on each other\\n\" +\n\t\t\t\t\"_-_ Dailies using seeds that are also user-enterable\\n\" +\n\t\t\t\t\"_-_ Knockback effects paralyzing dead characters\\n\" +\n\t\t\t\t\"_-_ Death to aqua blast counting as death to a geyser trap\\n\" +\n\t\t\t\t\"_-_ Albino rats causing bleed when hitting for 0 damage\\n\" +\n\t\t\t\t\"_-_ Prizes from sacrifice rooms now always being the same with the same dungeon seed\\n\" +\n\t\t\t\t\"_-_ Necromancers being able to summon through crystal doors\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.SHORTSWORD, new ItemSprite.Glowing( 0x000000 )), \"Annoying Curse\",\n\t\t\t\t\"A very critical buff has been given to the annoying curse:\\n\\n\" +\n\t\t\t\t\"_-_ Added 5 new regular dialogue lines, for 10 total\\n\" +\n\t\t\t\t\"_-_ Added 3 additional new lines that trigger rarely\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST), new RingOfWealth().trueName(),\n\t\t\t\t\"I'm making a few improvements to the ring of wealth, mainly to make it more worth upgrading:\\n\\n\" +\n\t\t\t\t\"_-_ Now gives a rare drop every 0-20 kills, up from every 0-25\\n\" +\n\t\t\t\t\"_-_ Now gives an equipment drop every 5-10 rare drops, down from every 4-8\\n\" +\n\t\t\t\t\"_-_ Equipment drops are now guaranteed to be at least level 1/2/3/4/5/6 at ring level 1/3/5/7/9/11, up from 1/3/6/10/15/21\"));\n\n\t\tchanges.addButton(new ChangeButton( new WandOfTransfusion(),\n\t\t\t\t\"I'm boosting the wand of transfusion's damage scaling versus undead enemies slightly:\\n\\n\" +\n\t\t\t\t\"_-_ Damage vs. undead scaling up to 1-2 per level, from 0.5-1\"));\n\n\t\tchanges.addButton(new ChangeButton( new TelekineticGrab(),\n\t\t\t\t\"I'm enhancing the value of telekinetic grab a bit for users with multiple thrown weapons:\\n\\n\" +\n\t\t\t\t\"_-_ now grabs all items at a location or stuck to an enemy, not just the first one.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t}",
          "uniqueId": "ef9c47639b7f432987921d4474a15e56d4f9993b_82_304_89_234_236_413"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "fd18ebdb47371fabbb1f428e0382e16206a88a1d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fd18ebdb47371fabbb1f428e0382e16206a88a1d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean berserking(){\n\t\tif (target.HP == 0 && state == State.NORMAL && power >= 1f){\n\n\t\t\tWarriorShield shield = target.buff(WarriorShield.class);\n\t\t\tif (shield != null){\n\t\t\t\tstate = State.BERSERK;\n\t\t\t\tint shieldAmount = shield.maxShield() * 8;\n\t\t\t\tshieldAmount = Math.round(shieldAmount * (1f + Dungeon.hero.pointsInTalent(Talent.BERSERKING_STAMINA)/4f));\n\t\t\t\tshield.supercharge(shieldAmount);\n\n\t\t\t\tSpellSprite.show(target, SpellSprite.BERSERK);\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.CHALLENGE );\n\t\t\t\tGameScene.flash(0xFF0000);\n\t\t\t}\n\n\t\t}\n\n\t\treturn state == State.BERSERK && target.shielding() > 0;\n\t}",
          "sourceCodeAfterRefactoring": "public boolean berserking(){\n\t\tif (target.HP == 0\n\t\t\t\t&& state == State.NORMAL\n\t\t\t\t&& power >= 1f\n\t\t\t\t&& target.buff(WarriorShield.class) != null\n\t\t\t\t&& ((Hero)target).hasTalent(Talent.DEATHLESS_FURY)){\n\t\t\tstartBerserking();\n\t\t\tActionIndicator.clearAction(this);\n\t\t}\n\n\t\treturn state == State.BERSERK && target.shielding() > 0;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void startBerserking(){\n\t\tstate = State.BERSERK;\n\t\tSpellSprite.show(target, SpellSprite.BERSERK);\n\t\tSample.INSTANCE.play( Assets.Sounds.CHALLENGE );\n\t\tGameScene.flash(0xFF0000);\n\n\t\tif (target.HP > 0) {\n\t\t\tturnRecovery = TURN_RECOVERY_START;\n\t\t\tlevelRecovery = 0;\n\t\t} else {\n\t\t\tlevelRecovery = LEVEL_RECOVER_START - ((Hero)target).pointsInTalent(Talent.DEATHLESS_FURY);\n\t\t\tturnRecovery = 0;\n\t\t}\n\n\t\t//base multiplier scales at 2/3/4/5/6x at 100/37/20/9/0% HP\n\t\tfloat shieldMultiplier = 2f + 4*(float)Math.pow((1f-(target.HP/(float)target.HT)), 3);\n\n\t\t//Endless rage effect on shield and cooldown\n\t\tif (power > 1f){\n\t\t\tshieldMultiplier *= power;\n\t\t\tlevelRecovery *= 2f - power;\n\t\t\tturnRecovery *= 2f - power;\n\t\t}\n\n\t\tWarriorShield shield = target.buff(WarriorShield.class);\n\t\tint shieldAmount = Math.round(shield.maxShield() * shieldMultiplier);\n\t\tshield.supercharge(shieldAmount);\n\n\t\tBuffIndicator.refreshHero();\n\t}",
          "uniqueId": "fd18ebdb47371fabbb1f428e0382e16206a88a1d_129_147_177_206_164_175"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "630bc0291d09e522b4970fb7375cbbdb40643ae3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/630bc0291d09e522b4970fb7375cbbdb40643ae3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void spend( float time ) {\n\t\tthis.time += time;\n\t\t//if time is very close to a whole number, round to a whole number to fix errors\n\t\tfloat ex = Math.abs(this.time % 1f);\n\t\tif (ex < .001f){\n\t\t\tthis.time = Math.round(this.time);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void spend( float time ) {\n\t\tspendConstant( time );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected final void spendConstant( float time ){\n\t\tthis.time += time;\n\t\t//if time is very close to a whole number, round to a whole number to fix errors\n\t\tfloat ex = Math.abs(this.time % 1f);\n\t\tif (ex < .001f){\n\t\t\tthis.time = Math.round(this.time);\n\t\t}\n\t}",
          "uniqueId": "630bc0291d09e522b4970fb7375cbbdb40643ae3_58_65_59_66_69_71"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "397bc0bbbea4701b9a257c291860cc45f14c921c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/397bc0bbbea4701b9a257c291860cc45f14c921c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void dispel() {\n\t\tif (Dungeon.hero == null) return;\n\n\t\tfor ( Buff invis : Dungeon.hero.buffs( Invisibility.class )){\n\t\t\tinvis.detach();\n\t\t}\n\t\tCloakOfShadows.cloakStealth cloakBuff = Dungeon.hero.buff( CloakOfShadows.cloakStealth.class );\n\t\tif (cloakBuff != null) {\n\t\t\tcloakBuff.dispel();\n\t\t}\n\t\t\n\t\t//these aren't forms of invisibilty, but do dispel at the same time as it.\n\t\tTimekeepersHourglass.timeFreeze timeFreeze = Dungeon.hero.buff( TimekeepersHourglass.timeFreeze.class );\n\t\tif (timeFreeze != null) {\n\t\t\ttimeFreeze.detach();\n\t\t}\n\t\t\n\t\tPreparation prep = Dungeon.hero.buff( Preparation.class );\n\t\tif (prep != null){\n\t\t\tprep.detach();\n\t\t}\n\t\t\n\t\tSwiftthistle.TimeBubble bubble =  Dungeon.hero.buff( Swiftthistle.TimeBubble.class );\n\t\tif (bubble != null){\n\t\t\tbubble.detach();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void dispel() {\n\t\tif (Dungeon.hero == null) return;\n\n\t\tdispel(Dungeon.hero);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void dispel(Char ch){\n\n\t\tfor ( Buff invis : ch.buffs( Invisibility.class )){\n\t\t\tinvis.detach();\n\t\t}\n\t\tCloakOfShadows.cloakStealth cloakBuff = ch.buff( CloakOfShadows.cloakStealth.class );\n\t\tif (cloakBuff != null) {\n\t\t\tcloakBuff.dispel();\n\t\t}\n\n\t\t//these aren't forms of invisibility, but do dispel at the same time as it.\n\t\tTimekeepersHourglass.timeFreeze timeFreeze = ch.buff( TimekeepersHourglass.timeFreeze.class );\n\t\tif (timeFreeze != null) {\n\t\t\ttimeFreeze.detach();\n\t\t}\n\n\t\tPreparation prep = ch.buff( Preparation.class );\n\t\tif (prep != null){\n\t\t\tprep.detach();\n\t\t}\n\n\t\tSwiftthistle.TimeBubble bubble =  ch.buff( Swiftthistle.TimeBubble.class );\n\t\tif (bubble != null){\n\t\t\tbubble.detach();\n\t\t}\n\t}",
          "uniqueId": "397bc0bbbea4701b9a257c291860cc45f14c921c_94_120_100_125_94_98"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "848a2270dfa33c07901ef4c2f247d98890ebcfbf",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/848a2270dfa33c07901ef4c2f247d98890ebcfbf",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tDungeon.hero = null;\n\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\n\t\tbackground = new Image(HeroClass.WARRIOR.splashArt()){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif (rm > 1f){\n\t\t\t\t\trm -= Game.elapsed;\n\t\t\t\t\tgm = bm = rm;\n\t\t\t\t} else {\n\t\t\t\t\trm = gm = bm = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tbackground.visible = false;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tif (background.x > 0){\n\t\t\tImage fadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0x00000000));\n\t\t\tfadeLeft.x = background.x-2;\n\t\t\tfadeLeft.scale.set(4, background.height());\n\t\t\tadd(fadeLeft);\n\n\t\t\tImage fadeRight = new Image(fadeLeft);\n\t\t\tfadeRight.x = background.x + background.width() + 2;\n\t\t\tfadeRight.y = background.y + background.height();\n\t\t\tfadeRight.angle = 180;\n\t\t\tadd(fadeRight);\n\t\t}\n\n\t\tstartBtn = new StyledButton(Chrome.Type.GREY_BUTTON_TR, \"\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (GamesInProgress.selectedClass == null) return;\n\n\t\t\t\tDungeon.hero = null;\n\t\t\t\tActionIndicator.action = null;\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\n\t\t\t\tif (SPDSettings.intro()) {\n\t\t\t\t\tSPDSettings.intro( false );\n\t\t\t\t\tGame.switchScene( IntroScene.class );\n\t\t\t\t} else {\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstartBtn.icon(Icons.get(Icons.ENTER));\n\t\tstartBtn.setSize(80, 21);\n\t\tstartBtn.setPos((Camera.main.width - startBtn.width())/2f, (Camera.main.height - HeroBtn.HEIGHT + 2 - startBtn.height()));\n\t\tadd(startBtn);\n\t\tstartBtn.visible = false;\n\n\t\tinfoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(GamesInProgress.selectedClass));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t}\n\t\t};\n\t\tinfoButton.visible = false;\n\t\tinfoButton.setSize(20, 21);\n\t\tadd(infoButton);\n\n\t\tHeroClass[] classes = HeroClass.values();\n\n\t\tint btnWidth = HeroBtn.MIN_WIDTH;\n\t\tint curX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\tif (curX > 0){\n\t\t\tbtnWidth += Math.min(curX/(classes.length/2), 15);\n\t\t\tcurX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\t}\n\n\t\tint heroBtnleft = curX;\n\t\tfor (HeroClass cl : classes){\n\t\t\tHeroBtn button = new HeroBtn(cl);\n\t\t\tbutton.setRect(curX, Camera.main.height-HeroBtn.HEIGHT+3, btnWidth, HeroBtn.HEIGHT);\n\t\t\tcurX += btnWidth;\n\t\t\tadd(button);\n\t\t\theroBtns.add(button);\n\t\t}\n\n\t\tchallengeButton = new IconButton(\n\t\t\t\tIcons.get( SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON :Icons.CHALLENGE_OFF)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndChallenges(SPDSettings.challenges(), true) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\ticon(Icons.get(SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON : Icons.CHALLENGE_OFF));\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif( !visible && GamesInProgress.selectedClass != null){\n\t\t\t\t\tvisible = true;\n\t\t\t\t}\n\t\t\t\tsuper.update();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndChallenges.class, \"title\"));\n\t\t\t}\n\t\t};\n\t\tchallengeButton.setRect(heroBtnleft + 16, Camera.main.height-HeroBtn.HEIGHT-16, 20, 21);\n\t\tchallengeButton.visible = false;\n\n\t\tseedButton = new IconButton( Icons.get(Icons.SEED)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tString existingSeedtext = SPDSettings.customSeed();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront( new WndTextInput(Messages.get(HeroSelectScene.class, \"custom_seed_title\"),\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_desc\"),\n\t\t\t\t\t\texistingSeedtext,\n\t\t\t\t\t\t20,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_set\"),\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_clear\")){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSelect(boolean positive, String text) {\n\t\t\t\t\t\ttext = DungeonSeed.formatText(text);\n\t\t\t\t\t\tlong seed = DungeonSeed.convertFromText(text);\n\n\t\t\t\t\t\tif (positive && seed != -1){\n\n\t\t\t\t\t\t\tfor (GamesInProgress.Info info : GamesInProgress.checkAll()){\n\t\t\t\t\t\t\t\tif (info.customSeed.isEmpty() && info.seed == seed){\n\t\t\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndMessage(Messages.get(HeroSelectScene.class, \"custom_seed_duplicate\")));\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSPDSettings.customSeed(text);\n\t\t\t\t\t\t\ticon.hardlight(1f, 1.5f, 0.67f);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerUp() {\n\t\t\t\tif (!SPDSettings.customSeed().isEmpty()){\n\t\t\t\t\ticon.hardlight(1f, 1.5f, 0.67f);\n\t\t\t\t} else {\n\t\t\t\t\ticon.resetColor();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif( !visible && GamesInProgress.selectedClass != null){\n\t\t\t\t\tvisible = true;\n\t\t\t\t}\n\t\t\t\tsuper.update();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.get(HeroSelectScene.class, \"custom_seed_title\");\n\t\t\t}\n\t\t};\n\t\tif (!SPDSettings.customSeed().isEmpty()) seedButton.icon().hardlight(1f, 1.5f, 0.67f);\n\t\tseedButton.setRect(challengeButton.left()-16, challengeButton.top(), 16, 21);\n\t\tseedButton.visible = false;\n\n\t\tif (DeviceCompat.isDebug() || Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\tadd(seedButton);\n\t\t\tadd(challengeButton);\n\t\t} else {\n\t\t\tDungeon.challenges = 0;\n\t\t\tSPDSettings.challenges(0);\n\t\t\tSPDSettings.customSeed(\"\");\n\t\t}\n\n\t\tbtnExit = new ExitButton();\n\t\tbtnExit.setPos( Camera.main.width - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\t\tbtnExit.visible = !SPDSettings.intro() || Rankings.INSTANCE.totalNumber > 0;\n\n\t\tprompt = PixelScene.renderTextBlock(Messages.get(this, \"title\"), 12);\n\t\tprompt.hardlight(Window.TITLE_COLOR);\n\t\tprompt.setPos( (Camera.main.width - prompt.width())/2f, (Camera.main.height - HeroBtn.HEIGHT - prompt.height() - 4));\n\t\tPixelScene.align(prompt);\n\t\tadd(prompt);\n\n\t\tPointerArea fadeResetter = new PointerArea(0, 0, Camera.main.width, Camera.main.height){\n\t\t\t@Override\n\t\t\tpublic boolean onSignal(PointerEvent event) {\n\t\t\t\tresetFade();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tadd(fadeResetter);\n\t\tresetFade();\n\n\t\tif (GamesInProgress.selectedClass != null){\n\t\t\tsetSelectedHero(GamesInProgress.selectedClass);\n\t\t}\n\n\t\tfadeIn();\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tDungeon.hero = null;\n\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\n\t\tbackground = new Image(HeroClass.WARRIOR.splashArt()){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif (rm > 1f){\n\t\t\t\t\trm -= Game.elapsed;\n\t\t\t\t\tgm = bm = rm;\n\t\t\t\t} else {\n\t\t\t\t\trm = gm = bm = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tbackground.visible = false;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tif (background.x > 0){\n\t\t\tImage fadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0x00000000));\n\t\t\tfadeLeft.x = background.x-2;\n\t\t\tfadeLeft.scale.set(4, background.height());\n\t\t\tadd(fadeLeft);\n\n\t\t\tImage fadeRight = new Image(fadeLeft);\n\t\t\tfadeRight.x = background.x + background.width() + 2;\n\t\t\tfadeRight.y = background.y + background.height();\n\t\t\tfadeRight.angle = 180;\n\t\t\tadd(fadeRight);\n\t\t}\n\n\t\tstartBtn = new StyledButton(Chrome.Type.GREY_BUTTON_TR, \"\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (GamesInProgress.selectedClass == null) return;\n\n\t\t\t\tDungeon.hero = null;\n\t\t\t\tActionIndicator.action = null;\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\n\t\t\t\tif (SPDSettings.intro()) {\n\t\t\t\t\tSPDSettings.intro( false );\n\t\t\t\t\tGame.switchScene( IntroScene.class );\n\t\t\t\t} else {\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstartBtn.icon(Icons.get(Icons.ENTER));\n\t\tstartBtn.setSize(80, 21);\n\t\tstartBtn.setPos((Camera.main.width - startBtn.width())/2f, (Camera.main.height - HeroBtn.HEIGHT + 2 - startBtn.height()));\n\t\tadd(startBtn);\n\t\tstartBtn.visible = false;\n\n\t\tinfoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(GamesInProgress.selectedClass));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t}\n\t\t};\n\t\tinfoButton.visible = false;\n\t\tinfoButton.setSize(20, 21);\n\t\tadd(infoButton);\n\n\t\tHeroClass[] classes = HeroClass.values();\n\n\t\tint btnWidth = HeroBtn.MIN_WIDTH;\n\t\tint curX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\tif (curX > 0){\n\t\t\tbtnWidth += Math.min(curX/(classes.length/2), 15);\n\t\t\tcurX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\t}\n\n\t\tint heroBtnleft = curX;\n\t\tfor (HeroClass cl : classes){\n\t\t\tHeroBtn button = new HeroBtn(cl);\n\t\t\tbutton.setRect(curX, Camera.main.height-HeroBtn.HEIGHT+3, btnWidth, HeroBtn.HEIGHT);\n\t\t\tcurX += btnWidth;\n\t\t\tadd(button);\n\t\t\theroBtns.add(button);\n\t\t}\n\n\t\toptionsPane = new GameOptions();\n\t\toptionsPane.visible = optionsPane.active = false;\n\t\toptionsPane.layout();\n\t\toptionsPane.setPos(heroBtnleft, 0);\n\t\tadd(optionsPane);\n\n\t\tbtnOptions = new IconButton(Icons.get(Icons.PREFS)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\toptionsPane.visible = !optionsPane.visible;\n\t\t\t\toptionsPane.active = !optionsPane.active;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerDown() {\n\t\t\t\tsuper.onPointerDown();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerUp() {\n\t\t\t\tupdateOptionsColor();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.get(HeroSelectScene.class, \"options\");\n\t\t\t}\n\t\t};\n\t\tbtnOptions.setRect(heroBtnleft + 16, Camera.main.height-HeroBtn.HEIGHT-16, 20, 21);\n\t\tupdateOptionsColor();\n\t\tbtnOptions.visible = false;\n\n\t\tif (DeviceCompat.isDebug() || Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\tadd(btnOptions);\n\t\t} else {\n\t\t\tDungeon.challenges = 0;\n\t\t\tSPDSettings.challenges(0);\n\t\t\tSPDSettings.customSeed(\"\");\n\t\t}\n\n\t\tbtnExit = new ExitButton();\n\t\tbtnExit.setPos( Camera.main.width - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\t\tbtnExit.visible = !SPDSettings.intro() || Rankings.INSTANCE.totalNumber > 0;\n\n\t\tprompt = PixelScene.renderTextBlock(Messages.get(this, \"title\"), 12);\n\t\tprompt.hardlight(Window.TITLE_COLOR);\n\t\tprompt.setPos( (Camera.main.width - prompt.width())/2f, (Camera.main.height - HeroBtn.HEIGHT - prompt.height() - 4));\n\t\tPixelScene.align(prompt);\n\t\tadd(prompt);\n\n\t\tPointerArea fadeResetter = new PointerArea(0, 0, Camera.main.width, Camera.main.height){\n\t\t\t@Override\n\t\t\tpublic boolean onSignal(PointerEvent event) {\n\t\t\t\tresetFade();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tadd(fadeResetter);\n\t\tresetFade();\n\n\t\tif (GamesInProgress.selectedClass != null){\n\t\t\tsetSelectedHero(GamesInProgress.selectedClass);\n\t\t}\n\n\t\tfadeIn();\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateOptionsColor(){\n\t\tif (!SPDSettings.customSeed().isEmpty() || SPDSettings.challenges() != 0) {\n\t\t\tbtnOptions.icon().hardlight(1f, 1.5f, 0.67f);\n\t\t} else {\n\t\t\tbtnOptions.icon().resetColor();\n\t\t}\n\t}",
          "uniqueId": "848a2270dfa33c07901ef4c2f247d98890ebcfbf_71_298_244_250_74_242"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tDungeon.hero = null;\n\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\n\t\tbackground = new Image(HeroClass.WARRIOR.splashArt()){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif (rm > 1f){\n\t\t\t\t\trm -= Game.elapsed;\n\t\t\t\t\tgm = bm = rm;\n\t\t\t\t} else {\n\t\t\t\t\trm = gm = bm = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tbackground.visible = false;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tif (background.x > 0){\n\t\t\tImage fadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0x00000000));\n\t\t\tfadeLeft.x = background.x-2;\n\t\t\tfadeLeft.scale.set(4, background.height());\n\t\t\tadd(fadeLeft);\n\n\t\t\tImage fadeRight = new Image(fadeLeft);\n\t\t\tfadeRight.x = background.x + background.width() + 2;\n\t\t\tfadeRight.y = background.y + background.height();\n\t\t\tfadeRight.angle = 180;\n\t\t\tadd(fadeRight);\n\t\t}\n\n\t\tstartBtn = new StyledButton(Chrome.Type.GREY_BUTTON_TR, \"\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (GamesInProgress.selectedClass == null) return;\n\n\t\t\t\tDungeon.hero = null;\n\t\t\t\tActionIndicator.action = null;\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\n\t\t\t\tif (SPDSettings.intro()) {\n\t\t\t\t\tSPDSettings.intro( false );\n\t\t\t\t\tGame.switchScene( IntroScene.class );\n\t\t\t\t} else {\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstartBtn.icon(Icons.get(Icons.ENTER));\n\t\tstartBtn.setSize(80, 21);\n\t\tstartBtn.setPos((Camera.main.width - startBtn.width())/2f, (Camera.main.height - HeroBtn.HEIGHT + 2 - startBtn.height()));\n\t\tadd(startBtn);\n\t\tstartBtn.visible = false;\n\n\t\tinfoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(GamesInProgress.selectedClass));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t}\n\t\t};\n\t\tinfoButton.visible = false;\n\t\tinfoButton.setSize(20, 21);\n\t\tadd(infoButton);\n\n\t\tHeroClass[] classes = HeroClass.values();\n\n\t\tint btnWidth = HeroBtn.MIN_WIDTH;\n\t\tint curX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\tif (curX > 0){\n\t\t\tbtnWidth += Math.min(curX/(classes.length/2), 15);\n\t\t\tcurX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\t}\n\n\t\tint heroBtnleft = curX;\n\t\tfor (HeroClass cl : classes){\n\t\t\tHeroBtn button = new HeroBtn(cl);\n\t\t\tbutton.setRect(curX, Camera.main.height-HeroBtn.HEIGHT+3, btnWidth, HeroBtn.HEIGHT);\n\t\t\tcurX += btnWidth;\n\t\t\tadd(button);\n\t\t\theroBtns.add(button);\n\t\t}\n\n\t\tchallengeButton = new IconButton(\n\t\t\t\tIcons.get( SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON :Icons.CHALLENGE_OFF)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndChallenges(SPDSettings.challenges(), true) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\ticon(Icons.get(SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON : Icons.CHALLENGE_OFF));\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif( !visible && GamesInProgress.selectedClass != null){\n\t\t\t\t\tvisible = true;\n\t\t\t\t}\n\t\t\t\tsuper.update();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndChallenges.class, \"title\"));\n\t\t\t}\n\t\t};\n\t\tchallengeButton.setRect(heroBtnleft + 16, Camera.main.height-HeroBtn.HEIGHT-16, 20, 21);\n\t\tchallengeButton.visible = false;\n\n\t\tseedButton = new IconButton( Icons.get(Icons.SEED)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tString existingSeedtext = SPDSettings.customSeed();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront( new WndTextInput(Messages.get(HeroSelectScene.class, \"custom_seed_title\"),\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_desc\"),\n\t\t\t\t\t\texistingSeedtext,\n\t\t\t\t\t\t20,\n\t\t\t\t\t\tfalse,\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_set\"),\n\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_clear\")){\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSelect(boolean positive, String text) {\n\t\t\t\t\t\ttext = DungeonSeed.formatText(text);\n\t\t\t\t\t\tlong seed = DungeonSeed.convertFromText(text);\n\n\t\t\t\t\t\tif (positive && seed != -1){\n\n\t\t\t\t\t\t\tfor (GamesInProgress.Info info : GamesInProgress.checkAll()){\n\t\t\t\t\t\t\t\tif (info.customSeed.isEmpty() && info.seed == seed){\n\t\t\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndMessage(Messages.get(HeroSelectScene.class, \"custom_seed_duplicate\")));\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSPDSettings.customSeed(text);\n\t\t\t\t\t\t\ticon.hardlight(1f, 1.5f, 0.67f);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerUp() {\n\t\t\t\tif (!SPDSettings.customSeed().isEmpty()){\n\t\t\t\t\ticon.hardlight(1f, 1.5f, 0.67f);\n\t\t\t\t} else {\n\t\t\t\t\ticon.resetColor();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif( !visible && GamesInProgress.selectedClass != null){\n\t\t\t\t\tvisible = true;\n\t\t\t\t}\n\t\t\t\tsuper.update();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.get(HeroSelectScene.class, \"custom_seed_title\");\n\t\t\t}\n\t\t};\n\t\tif (!SPDSettings.customSeed().isEmpty()) seedButton.icon().hardlight(1f, 1.5f, 0.67f);\n\t\tseedButton.setRect(challengeButton.left()-16, challengeButton.top(), 16, 21);\n\t\tseedButton.visible = false;\n\n\t\tif (DeviceCompat.isDebug() || Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\tadd(seedButton);\n\t\t\tadd(challengeButton);\n\t\t} else {\n\t\t\tDungeon.challenges = 0;\n\t\t\tSPDSettings.challenges(0);\n\t\t\tSPDSettings.customSeed(\"\");\n\t\t}\n\n\t\tbtnExit = new ExitButton();\n\t\tbtnExit.setPos( Camera.main.width - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\t\tbtnExit.visible = !SPDSettings.intro() || Rankings.INSTANCE.totalNumber > 0;\n\n\t\tprompt = PixelScene.renderTextBlock(Messages.get(this, \"title\"), 12);\n\t\tprompt.hardlight(Window.TITLE_COLOR);\n\t\tprompt.setPos( (Camera.main.width - prompt.width())/2f, (Camera.main.height - HeroBtn.HEIGHT - prompt.height() - 4));\n\t\tPixelScene.align(prompt);\n\t\tadd(prompt);\n\n\t\tPointerArea fadeResetter = new PointerArea(0, 0, Camera.main.width, Camera.main.height){\n\t\t\t@Override\n\t\t\tpublic boolean onSignal(PointerEvent event) {\n\t\t\t\tresetFade();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tadd(fadeResetter);\n\t\tresetFade();\n\n\t\tif (GamesInProgress.selectedClass != null){\n\t\t\tsetSelectedHero(GamesInProgress.selectedClass);\n\t\t}\n\n\t\tfadeIn();\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tDungeon.hero = null;\n\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\n\t\tbackground = new Image(HeroClass.WARRIOR.splashArt()){\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tif (rm > 1f){\n\t\t\t\t\trm -= Game.elapsed;\n\t\t\t\t\tgm = bm = rm;\n\t\t\t\t} else {\n\t\t\t\t\trm = gm = bm = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tbackground.scale.set(Camera.main.height/background.height);\n\n\t\tbackground.x = (Camera.main.width - background.width())/2f;\n\t\tbackground.y = (Camera.main.height - background.height())/2f;\n\t\tbackground.visible = false;\n\t\tPixelScene.align(background);\n\t\tadd(background);\n\n\t\tif (background.x > 0){\n\t\t\tImage fadeLeft = new Image(TextureCache.createGradient(0xFF000000, 0x00000000));\n\t\t\tfadeLeft.x = background.x-2;\n\t\t\tfadeLeft.scale.set(4, background.height());\n\t\t\tadd(fadeLeft);\n\n\t\t\tImage fadeRight = new Image(fadeLeft);\n\t\t\tfadeRight.x = background.x + background.width() + 2;\n\t\t\tfadeRight.y = background.y + background.height();\n\t\t\tfadeRight.angle = 180;\n\t\t\tadd(fadeRight);\n\t\t}\n\n\t\tstartBtn = new StyledButton(Chrome.Type.GREY_BUTTON_TR, \"\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (GamesInProgress.selectedClass == null) return;\n\n\t\t\t\tDungeon.hero = null;\n\t\t\t\tActionIndicator.action = null;\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\n\t\t\t\tif (SPDSettings.intro()) {\n\t\t\t\t\tSPDSettings.intro( false );\n\t\t\t\t\tGame.switchScene( IntroScene.class );\n\t\t\t\t} else {\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tstartBtn.icon(Icons.get(Icons.ENTER));\n\t\tstartBtn.setSize(80, 21);\n\t\tstartBtn.setPos((Camera.main.width - startBtn.width())/2f, (Camera.main.height - HeroBtn.HEIGHT + 2 - startBtn.height()));\n\t\tadd(startBtn);\n\t\tstartBtn.visible = false;\n\n\t\tinfoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(GamesInProgress.selectedClass));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t}\n\t\t};\n\t\tinfoButton.visible = false;\n\t\tinfoButton.setSize(20, 21);\n\t\tadd(infoButton);\n\n\t\tHeroClass[] classes = HeroClass.values();\n\n\t\tint btnWidth = HeroBtn.MIN_WIDTH;\n\t\tint curX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\tif (curX > 0){\n\t\t\tbtnWidth += Math.min(curX/(classes.length/2), 15);\n\t\t\tcurX = (Camera.main.width - btnWidth * classes.length)/2;\n\t\t}\n\n\t\tint heroBtnleft = curX;\n\t\tfor (HeroClass cl : classes){\n\t\t\tHeroBtn button = new HeroBtn(cl);\n\t\t\tbutton.setRect(curX, Camera.main.height-HeroBtn.HEIGHT+3, btnWidth, HeroBtn.HEIGHT);\n\t\t\tcurX += btnWidth;\n\t\t\tadd(button);\n\t\t\theroBtns.add(button);\n\t\t}\n\n\t\toptionsPane = new GameOptions();\n\t\toptionsPane.visible = optionsPane.active = false;\n\t\toptionsPane.layout();\n\t\toptionsPane.setPos(heroBtnleft, 0);\n\t\tadd(optionsPane);\n\n\t\tbtnOptions = new IconButton(Icons.get(Icons.PREFS)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\toptionsPane.visible = !optionsPane.visible;\n\t\t\t\toptionsPane.active = !optionsPane.active;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerDown() {\n\t\t\t\tsuper.onPointerDown();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onPointerUp() {\n\t\t\t\tupdateOptionsColor();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected String hoverText() {\n\t\t\t\treturn Messages.get(HeroSelectScene.class, \"options\");\n\t\t\t}\n\t\t};\n\t\tbtnOptions.setRect(heroBtnleft + 16, Camera.main.height-HeroBtn.HEIGHT-16, 20, 21);\n\t\tupdateOptionsColor();\n\t\tbtnOptions.visible = false;\n\n\t\tif (DeviceCompat.isDebug() || Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\tadd(btnOptions);\n\t\t} else {\n\t\t\tDungeon.challenges = 0;\n\t\t\tSPDSettings.challenges(0);\n\t\t\tSPDSettings.customSeed(\"\");\n\t\t}\n\n\t\tbtnExit = new ExitButton();\n\t\tbtnExit.setPos( Camera.main.width - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\t\tbtnExit.visible = !SPDSettings.intro() || Rankings.INSTANCE.totalNumber > 0;\n\n\t\tprompt = PixelScene.renderTextBlock(Messages.get(this, \"title\"), 12);\n\t\tprompt.hardlight(Window.TITLE_COLOR);\n\t\tprompt.setPos( (Camera.main.width - prompt.width())/2f, (Camera.main.height - HeroBtn.HEIGHT - prompt.height() - 4));\n\t\tPixelScene.align(prompt);\n\t\tadd(prompt);\n\n\t\tPointerArea fadeResetter = new PointerArea(0, 0, Camera.main.width, Camera.main.height){\n\t\t\t@Override\n\t\t\tpublic boolean onSignal(PointerEvent event) {\n\t\t\t\tresetFade();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tadd(fadeResetter);\n\t\tresetFade();\n\n\t\tif (GamesInProgress.selectedClass != null){\n\t\t\tsetSelectedHero(GamesInProgress.selectedClass);\n\t\t}\n\n\t\tfadeIn();\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tprotected void createChildren() {\n\n\t\t\tbg = Chrome.get(Chrome.Type.GREY_BUTTON_TR);\n\t\t\tadd(bg);\n\n\t\t\tbuttons = new ArrayList<>();\n\t\t\tspacers = new ArrayList<>();\n\t\t\tif (DeviceCompat.isDebug() || Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\t\tStyledButton seedButton = new StyledButton(Chrome.Type.BLANK, Messages.get(HeroSelectScene.class, \"custom_seed\"), 6){\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\tString existingSeedtext = SPDSettings.customSeed();\n\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront( new WndTextInput(Messages.get(HeroSelectScene.class, \"custom_seed_title\"),\n\t\t\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_desc\"),\n\t\t\t\t\t\t\t\texistingSeedtext,\n\t\t\t\t\t\t\t\t20,\n\t\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_set\"),\n\t\t\t\t\t\t\t\tMessages.get(HeroSelectScene.class, \"custom_seed_clear\")){\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void onSelect(boolean positive, String text) {\n\t\t\t\t\t\t\t\ttext = DungeonSeed.formatText(text);\n\t\t\t\t\t\t\t\tlong seed = DungeonSeed.convertFromText(text);\n\n\t\t\t\t\t\t\t\tif (positive && seed != -1){\n\n\t\t\t\t\t\t\t\t\tfor (GamesInProgress.Info info : GamesInProgress.checkAll()){\n\t\t\t\t\t\t\t\t\t\tif (info.customSeed.isEmpty() && info.seed == seed){\n\t\t\t\t\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndMessage(Messages.get(HeroSelectScene.class, \"custom_seed_duplicate\")));\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tSPDSettings.customSeed(text);\n\t\t\t\t\t\t\t\t\ticon.hardlight(1f, 1.5f, 0.67f);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tSPDSettings.customSeed(\"\");\n\t\t\t\t\t\t\t\t\ticon.resetColor();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tupdateOptionsColor();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tseedButton.leftJustify = true;\n\t\t\t\tseedButton.icon(Icons.get(Icons.SEED));\n\t\t\t\tif (!SPDSettings.customSeed().isEmpty()) seedButton.icon().hardlight(1f, 1.5f, 0.67f);;\n\t\t\t\tbuttons.add(seedButton);\n\t\t\t\tadd(seedButton);\n\n\t\t\t\t//TODO does nothing atm\n\t\t\t\tStyledButton dailyButton = new StyledButton(Chrome.Type.BLANK, Messages.get(HeroSelectScene.class, \"daily\"), 6);\n\t\t\t\tdailyButton.leftJustify = true;\n\t\t\t\tdailyButton.icon(Icons.get(Icons.CALENDAR));\n\t\t\t\tadd(dailyButton);\n\t\t\t\tbuttons.add(dailyButton);\n\n\t\t\t\tStyledButton challengeButton = new StyledButton(Chrome.Type.BLANK, Messages.get(WndChallenges.class, \"title\"), 6){\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndChallenges(SPDSettings.challenges(), true) {\n\t\t\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\t\t\ticon(Icons.get(SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON : Icons.CHALLENGE_OFF));\n\t\t\t\t\t\t\t\tupdateOptionsColor();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tchallengeButton.leftJustify = true;\n\t\t\t\tchallengeButton.icon(Icons.get(SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON : Icons.CHALLENGE_OFF));\n\t\t\t\tadd(challengeButton);\n\t\t\t\tbuttons.add(challengeButton);\n\t\t\t}\n\n\t\t\tfor (int i = 1; i < buttons.size(); i++){\n\t\t\t\tColorBlock spc = new ColorBlock(1, 1, 0xFF000000);\n\t\t\t\tadd(spc);\n\t\t\t\tspacers.add(spc);\n\t\t\t}\n\t\t}",
          "uniqueId": "848a2270dfa33c07901ef4c2f247d98890ebcfbf_71_298_368_451_74_242"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2ccfe6f7e2bee6c96c565274320b1e3eda339c4a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2ccfe6f7e2bee6c96c565274320b1e3eda339c4a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v1_2_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.2\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v1.2.3\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Swarms that were spawned by splitting now give a little sacrifice progress if sacrificed, instead of 0.\\n\\n\" +\n\t\t\t\t\"_-_ Updated Translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.2.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Textual errors with talents and 13th armor ability\\n\" +\n\t\t\t\t\"_-_ Armband not benefiting from ring of energy\\n\" +\n\t\t\t\t\"_-_ v1.2.0 light cloak buff not applying in all cases\\n\" +\n\t\t\t\t\"_-_ Inconsistencies in freezing logic\\n\" +\n\t\t\t\t\"_-_ Cached rations talent not capping at 4/6 rations as intended\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v1.2.0)\\n\" +\n\t\t\t\t\"_-_ An exploit where unblessed ankhs could be used with a lost inventory\" ));\n\n\t\tchanges = new ChangeInfo(\"v1.2.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Sacrifice rooms now require slightly fewer enemies at lower depths\\n\" +\n\t\t\t\t\"_-_ Sacrifice rooms now accept sacrifices that are adjacent to the fire\\n\\n\" +\n\t\t\t\t\"_-_ The game can now only spawn one room that requires a solution potion per floor\\n\\n\" +\n\t\t\t\t\"_-_ Moved Steam notification location to bottom-left from top-left\\n\\n\" +\n\t\t\t\t\"_-_ Updated Translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.2.0):\\n\" +\n\t\t\t\t\"_-_ Some crashes on launch for Steam users\\n\" +\n\t\t\t\t\"_-_ Transmuted mage's staff not recharging\\n\" +\n\t\t\t\t\"_-_ Great crab being able to block attacks from invisible heroes\\n\" +\n\t\t\t\t\"_-_ Wand of frost not clearing magical fire\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v1.2.0)\\n\" +\n\t\t\t\t\"_-_ Various minor visual bugs\\n\" +\n\t\t\t\t\"_-_ Ring of might health boost not being affected by lost inventory debuff\\n\" +\n\t\t\t\t\"_-_ Cases where ghoul sprites could become glitched\\n\" +\n\t\t\t\t\"_-_ Items that spawn identified counting as being IDed by the player\\n\" +\n\t\t\t\t\"_-_ Cases where heroic energy talent would use the wrong name/icon\\n\" +\n\t\t\t\t\"_-_ Curse status of quickslot items not showing in rankings\\n\" +\n\t\t\t\t\"_-_ Some sources of artifact recharging affecting cursed artifacts\\n\" +\n\t\t\t\t\"_-_ Blacksmith not refusing to work with cursed items in specific cases\" ));\n\n\t\tchanges = new ChangeInfo(\"v1.2.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Added a 'new game' and 'menu' button when the player gets a game over\\n\" +\n\t\t\t\t\"_-_ The game now tries to preserve quickslot placement when items are transmuted\\n\" +\n\t\t\t\t\"_-_ Mouse 4 and 5 (aka forward and back mouse keys) can now be bound to game actions\\n\\n\" +\n\t\t\t\t\"_-_ Reduced huntress unlock requirement to 10 enemies hit with thrown weapons from 15\\n\" +\n\t\t\t\t\"_-_ Made surprise attack VFX a bit more obvious\\n\\n\" +\n\t\t\t\t\"_-_ Removed gold as a possible random loot from crystal choice rooms\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translators credits\\n\" +\n\t\t\t\t\"_-_ Added a new language: Galician!\\n\" +\n\t\t\t\t\"_-_ Removed the Catalan translation as it was below 70% complete\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.2.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor audiovisual, interface, and textual bugs\\n\" +\n\t\t\t\t\"_-_ Steam achievements not unlocking for some players\\n\" +\n\t\t\t\t\"_-_ Rankings not showing 5th and 6th quickslot\\n\" +\n\t\t\t\t\"_-_ Various minor issues with full UI inventory\\n\" +\n\t\t\t\t\"_-_ Back button not properly closing cell or item selection interfaces\\n\" +\n\t\t\t\t\"_-_ Succubi dealing much less damage than intended\\n\" +\n\t\t\t\t\"_-_ Various errors with magical fire\\n\" +\n\t\t\t\t\"_-_ Armband steal ability working on enemies that can no longer give loot\\n\" +\n\t\t\t\t\"_-_ Save corruption for linux users when importing old save data\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (existed prior to v1.2.0)\\n\" +\n\t\t\t\t\"_-_ Very rare cases where dried rose becomes unusable\\n\" +\n\t\t\t\t\"_-_ Corruption debuff affecting smoke bomb decoy\\n\" +\n\t\t\t\t\"_-_ Character mind vision persisting after a character dies\\n\" +\n\t\t\t\t\"_-_ Dwarf King not being targeted by wands or thrown weapons while on his throne\\n\" +\n\t\t\t\t\"_-_ Food 5 entrance rooms sometimes being smaller than intended\\n\" +\n\t\t\t\t\"_-_ Exploits involving corruption and the 13th armor ability\\n\" +\n\t\t\t\t\"_-_ Rare cases where lullaby scrolls were generated by the Unstable Spellbook\\n\" +\n\t\t\t\t\"_-_ Red flash effects stacking on each other in some cases\\n\" +\n\t\t\t\t\"_-_ Game forgetting previous window size when maximized and restarted\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released March 23rd, 2022\\n\" +\n\t\t\t\t\"_-_ 103 days after Shattered v1.1.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY_LAND), \"Desktop Enhancements and Steam Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon has received a bunch of new features in preparation for its release on Steam!_\\n\\n\" +\n\t\t\t\t\"These features include:\\n\" +\n\t\t\t\t\"_-_ A new main UI for larger displays, which places the inventory in the main game screen\\n\" +\n\t\t\t\t\"_-_ Full controller support, including button bindings and an analog stick cursor.\\n\" +\n\t\t\t\t\"_-_ Better keyboard controls, including combining keys to move diagonally.\\n\" +\n\t\t\t\t\"_-_ Better mouse support, including hover tooltips and right-click menus.\\n\" +\n\t\t\t\t\"_-_ Two additional quickslots on the new UI, and on mobile UI if there is enough space.\\n\" +\n\t\t\t\t\"_-_ Integration with Steamworks for achievements and cloud sync.\\n\\n\" +\n\t\t\t\t\"Users on mobile devices will be able to benefit from most of these features as well! (some feature require a large enough display)\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TILES_SEWERS, 48, 80, 16, 16 ), \"Special Rooms Additions!\",\n\t\t\t\t\"_Six new special rooms have been added!_\\n\\n\" +\n\t\t\t\t\"Two of these rooms (and one existing room) use new crystal doors, which let you see through them before you find a crystal key to unlock them.\\n\\n\" +\n\t\t\t\t\"Three of these rooms include new terrain hazards, which will require the right tools to get past.\\n\\n\" +\n\t\t\t\t\"The final new room is the sacrificial room from the original Pixel Dungeon! It returns with a few tweaks to its mechanics and loot (sorry, no scroll of wipe out).\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_ARMBAND), \"Armband Rework!\",\n\t\t\t\t\"_The Master Thieves' Armband has been reworked!_\\n\\n\" +\n\t\t\t\t\"This rework focuses on giving the armband usefulness outside of shops. You can now use it to steal from enemies as well as shopkeepers, and it gains charge as you gain exp, instead of when you collect gold.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image(Badges.Badge.MONSTERS_SLAIN_5.image), \"New Badges!\",\n\t\t\t\t\"_Badges now have names, and 8 new badges have been added!_\\n\\n\" +\n\t\t\t\t\"These new badges are all part of the existing series badges (e.g. defeat X enemies), and primarily exist around the gold badge level.\\n\\n\" +\n\t\t\t\t\"The 'games played' badges have also been adjusted to unlock either on a large number of games played, or a smaller number of games won.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"New Boss Music!\",\n\t\t\t\t\"_Each of the game's five bosses now have their own music track!_\\n\\n\" +\n\t\t\t\t\"Just as before, these tracks are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"All of the boss tracks take cues from the region tracks, but add enough to be more than simple remixes.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Improved the blinking behaviour of the journal button, to make it easier to notice on desktop displays.\\n\" +\n\t\t\t\t\"_-_ Improved the depth display to include icons for level feelings\\n\" +\n\t\t\t\t\"_-_ Added an icon next to depth display showing enabled challenges\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted the secrets level feeling to be less extreme in what rooms it can hide\\n\\n\" +\n\t\t\t\t\"_-_ Improved the resilience of the game's save system\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 1\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare cases of save corruption on Android\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual errors\\n\" +\n\t\t\t\t\"_-_ Unidentified wands being usable in alchemy\\n\" +\n\t\t\t\t\"_-_ Various rare cases where the hero could perform two actions at once\\n\" +\n\t\t\t\t\"_-_ Pharmacophobia challenge incorrectly blocking some alchemy recipes\\n\" +\n\t\t\t\t\"_-_ Various rare cases where giant enemies could enter enclosed spaces\\n\" +\n\t\t\t\t\"_-_ Wild energy spell not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ Rare cases where the Freerunner could gain momentum while freerunninng\\n\" +\n\t\t\t\t\"_-_ Gladiator's parry move not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ On-hit effects still triggering when the great crab blocks\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with the timekeeper's hourglass\\n\" +\n\t\t\t\t\"_-_ Various bugs with the potion of dragon's breath\\n\" +\n\t\t\t\t\"_-_ Assassinate killing enemies right after they were corrupted by a corrupting weapon\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 2\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Layout issues with the loot indicator\\n\" +\n\t\t\t\t\"_-_ Artifact recharging not charging the horn of plenty in some cases when it should\\n\" +\n\t\t\t\t\"_-_ Some items rarely not being consumed when they should be\\n\" +\n\t\t\t\t\"_-_ Player being able to self-target with assassinate ability\\n\" +\n\t\t\t\t\"_-_ Arcane catalysts not being able to be turned into energy\\n\" +\n\t\t\t\t\"_-_ Fog of War not properly updating when warp beacon is used\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.FIRE_BOMB), \"Recipe Cost Reductions\",\n\t\t\t\t\"I've made a bunch of cost adjustments to alchemy recipes to help counteract energy becoming more expensive after v1.1.0:\\n\\n\" +\n\t\t\t\t\"_- Bomb Recipe_ energy costs down across the board\\n\\n\" +\n\t\t\t\t\"_- Infernal, Blizzard, and Caustic Brew_ energy costs down by 1\\n\\n\" +\n\t\t\t\t\"_- Telekinetic Grab_ energy cost down to 2 from 4, liquid metal cost reduced to 10 from 15\\n\" +\n\t\t\t\t\"_- Phase Shift_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Wild Energy_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Beacon of Returning_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Summon Elemental_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Alchemize_ energy cost down to 2 from 3\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AQUA_BLAST), \"Alchemy Buffs\",\n\t\t\t\t\"Several recipes have also been buffed, in addition to the cost reductions:\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ duration up to 400 from 250\\n\" +\n\t\t\t\t\"_- Scroll of Dread_ now grants 1/2 exp for defeated enemies\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ gas quantity increased by 50%\\n\\n\" +\n\t\t\t\t\"_-_ Items and effects which create water now douse fire\\n\\n\" +\n\t\t\t\t\"_- Caustic Brew_ damage per turn increased by 1\\n\" +\n\t\t\t\t\"_- Infernal and Blizzard Brew_ now start their gas in a 3x3 AOE\\n\" +\n\t\t\t\t\"_- Shocking Brew_ AOE up to 7x7 from 5x5\\n\\n\" +\n\t\t\t\t\"_- Phase Shift_ now stuns whatever it teleports\\n\" +\n\t\t\t\t\"_- Summon Elemental_ quantity up to 5 from 3, elemental's stats now scale with depth, and elementals can be re-summoned\\n\" +\n\t\t\t\t\"_- Aqua Blast_ now acts like a geyser trap, quantity down to 8 from 12\\n\" +\n\t\t\t\t\"_- Reclaim Trap_ quantity up to 4 from 3\\n\" +\n\t\t\t\t\"_- Curse Infusion_ now boosts highly levelled gear by more than +1, quantity up to 4 from 3.\\n\" +\n\t\t\t\t\"_- Recycle_ quantity up to 12 from 8, cost up to 8 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ROT_DART), \"Dart Buffs\",\n\t\t\t\t\"While they don't tie into v1.1.0's energy changes in particular, I am also handing out several buffs to tipped darts:\\n\\n\" +\n\t\t\t\t\"_- Rot Dart_ uses increased to 5 from 1\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ duration up to 30 from 10\\n\" +\n\t\t\t\t\"_- Shocking Dart_ damage now slightly scales with depth\\n\" +\n\t\t\t\t\"_- Poison Dart_ damage scaling increased\\n\" +\n\t\t\t\t\"_- Sleep Dart_ is now _Cleansing Dart_, makes allies immune to debuffs for several turns\\n\" +\n\t\t\t\t\"_- Holy Dart_ duration up to 100 from 30\\n\" +\n\t\t\t\t\"_- Displacing Dart_ now much more consistently teleports enemies away\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.LIGHT_CLOAK.icon()), \"Talent Buffs\",\n\t\t\t\t\"I'm handing out a few buffs to help better balance the Mage's T2 talents and the Rogue's class-based T3 talents. I'm also making one bugfix that counts as a buff:\\n\\n\" +\n\t\t\t\t\"_- Energizing Upgrade_ charge boost up to 4/6, from 3/5\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance at +1 reduced to 50%, but now grants 1 arcane resin if it fails to preserve\\n\" +\n\t\t\t\t\"_- Wand Preservation_ max uses up to 5 from 3\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now grants +3 on the next 1/2/3 wand zaps\\n\\n\" +\n\t\t\t\t\"_- Light Cloak_ charging rate boosted to 25%/50%/75%, from 17%/33%/50%\\n\\n\" +\n\t\t\t\t\"_- Shared Upgrades_ bugfixed to give the bonus damage stated in the description, instead of slightly less.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.MAGIC_INFUSE), \"Alchemy Nerfs\",\n\t\t\t\t\"v1.2.0 is mostly about alchemy buffs, but a few alchemy items have had their power reduced as well:\\n\\n\" +\n\t\t\t\t\"_- Magical Infusion_ energy cost up to 4 from 3\\n\" +\n\t\t\t\t\"_- Holy Bomb_ bonus damage reduced to 50% from 67%\\n\" +\n\t\t\t\t\"_- Goo Blob and Metal Shard_ energy value reduced to 3\\n\" +\n\t\t\t\t\"_- Alchemize_ quantity in shops reduced by 1\\n\\n\" +\n\t\t\t\t\"While not a direct alchemy item nerf, I've also made some of the final bosses' fists less susceptible to certain mechanics:\\n\" +\n\t\t\t\t\"_- Soiled Fist_ is now immune to burning, but the grass it generates still burns\\n\" +\n\t\t\t\t\"_- Burning Fist_ is now immune to freezing, but it can still be chilled\\n\" +\n\t\t\t\t\"_- Rotting and Rusted Fists_ now take less damage from retribution, grim, and psionic blast\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Environment.TERRAIN_FEATURES, 112, 112, 16, 16), new Dreamfoil().name(),\n\t\t\t\t\"Dreamfoil has always had great utility as a debuff-cleanser, and with the recent addition of stones of deep sleep its enemy sleeping functionality was feeling a bit unnecessary:\\n\\n\" +\n\t\t\t\t\"_- Dreamfoil_ no longer puts enemies into magical sleep\\n\\n\" +\n\t\t\t\t\"Sleep darts (made from dreamfoil) have also been changed into cleansing darts to go along with this change. These darts will make an ally temporarily immune to harmful effects.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.SHIELD_BATTERY.icon()), \"Talent Nerfs\",\n\t\t\t\t\"I'm making a few talent nerfs to better balance the Mage's T2 talents, and to pull in the power of the Berserker a little:\\n\\n\" +\n\t\t\t\t\"_- Shield Battery_ shielding per charge down to 4%/6%, from 5%/7.5%\\n\\n\" +\n\t\t\t\t\"_- Endless Rage_ max rage boost reduced to 10%/20%/30% from 15%/30%/45%\\n\" +\n\t\t\t\t\"_- Enraged Catalyst_ proc rate boost reduced to 15%/30%/45% from 17%/33%/50%\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v1_2_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.2\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ v1.2.0 Released March 23rd, 2022\\n\" +\n\t\t\t\t\"_-_ 103 days after Shattered v1.1.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY_LAND), \"Desktop Enhancements and Steam Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon has received a bunch of new features in preparation for its release on Steam!_\\n\\n\" +\n\t\t\t\t\"These features include:\\n\" +\n\t\t\t\t\"_-_ A new main UI for larger displays, which places the inventory in the main game screen\\n\" +\n\t\t\t\t\"_-_ Full controller support, including button bindings and an analog stick cursor.\\n\" +\n\t\t\t\t\"_-_ Better keyboard controls, including combining keys to move diagonally.\\n\" +\n\t\t\t\t\"_-_ Better mouse support, including hover tooltips and right-click menus.\\n\" +\n\t\t\t\t\"_-_ Two additional quickslots on the new UI, and on mobile UI if there is enough space.\\n\" +\n\t\t\t\t\"_-_ Integration with Steamworks for achievements and cloud sync.\\n\\n\" +\n\t\t\t\t\"Users on mobile devices will be able to benefit from most of these features as well! (some feature require a large enough display)\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TILES_SEWERS, 48, 80, 16, 16 ), \"Special Rooms Additions!\",\n\t\t\t\t\"_Six new special rooms have been added!_\\n\\n\" +\n\t\t\t\t\"Two of these rooms (and one existing room) use new crystal doors, which let you see through them before you find a crystal key to unlock them.\\n\\n\" +\n\t\t\t\t\"Three of these rooms include new terrain hazards, which will require the right tools to get past.\\n\\n\" +\n\t\t\t\t\"The final new room is the sacrificial room from the original Pixel Dungeon! It returns with a few tweaks to its mechanics and loot (sorry, no scroll of wipe out).\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_ARMBAND), \"Armband Rework!\",\n\t\t\t\t\"_The Master Thieves' Armband has been reworked!_\\n\\n\" +\n\t\t\t\t\"This rework focuses on giving the armband usefulness outside of shops. You can now use it to steal from enemies as well as shopkeepers, and it gains charge as you gain exp, instead of when you collect gold.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image(Badges.Badge.MONSTERS_SLAIN_5.image), \"New Badges!\",\n\t\t\t\t\"_Badges now have names, and 8 new badges have been added!_\\n\\n\" +\n\t\t\t\t\"These new badges are all part of the existing series badges (e.g. defeat X enemies), and primarily exist around the gold badge level.\\n\\n\" +\n\t\t\t\t\"The 'games played' badges have also been adjusted to unlock either on a large number of games played, or a smaller number of games won.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"New Boss Music!\",\n\t\t\t\t\"_Each of the game's five bosses now have their own music track!_\\n\\n\" +\n\t\t\t\t\"Just as before, these tracks are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"All of the boss tracks take cues from the region tracks, but add enough to be more than simple remixes.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Reduced cases of multiple rooms that require a solution potion per floor\\n\" +\n\t\t\t\t\"_-_ Reduced the huntress unlock requirement\\n\" +\n\t\t\t\t\"_-_ Adjusted the secrets level feeling to be less harsh\\n\\n\" +\n\t\t\t\t\"_-_ Added a 'new game' and 'menu' button after game over\\n\" +\n\t\t\t\t\"_-_ Made the blinking behaviour of the journal button easier to notice\\n\" +\n\t\t\t\t\"_-_ quickslot placement is now preserved when items are transmuted\\n\" +\n\t\t\t\t\"_-_ Improved the depth display to include icons for level feelings\\n\" +\n\t\t\t\t\"_-_ Added an icon next to depth display showing enabled challenges\\n\" +\n\t\t\t\t\"_-_ Made surprise attack VFX a bit more obvious\\n\" +\n\t\t\t\t\"_-_ Improved the resilience of the game's save system\\n\\n\" +\n\t\t\t\t\"_-_ Added a new language: Galician!\\n\" +\n\t\t\t\t\"_-_ Removed the Catalan translation as it was below 70% complete\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 1\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare cases of save corruption on Android\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual errors\\n\\n\" +\n\t\t\t\t\"_-_ Various rare cases where the hero could perform two actions at once\\n\" +\n\t\t\t\t\"_-_ Rare cases where the Freerunner could gain momentum while freerunninng\\n\" +\n\t\t\t\t\"_-_ Gladiator's parry move not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ Assassinate killing enemies right after they were corrupted by a corrupting weapon\\n\" +\n\t\t\t\t\"_-_ Player being able to self-target with assassinate ability\\n\" +\n\t\t\t\t\"_-_ Exploits involving corruption and the 13th armor ability\\n\\n\" +\n\t\t\t\t\"_-_ Various rare cases where giant enemies could enter enclosed spaces\\n\" +\n\t\t\t\t\"_-_ On-hit effects still triggering when the great crab blocks\\n\" +\n\t\t\t\t\"_-_ Corruption debuff affecting smoke bomb decoy\\n\" +\n\t\t\t\t\"_-_ Character mind vision persisting after a character dies\\n\" +\n\t\t\t\t\"_-_ Dwarf King not being targeted by wands or thrown weapons while on his throne\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 2\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Pharmacophobia challenge incorrectly blocking some alchemy recipes\\n\" +\n\t\t\t\t\"_-_ Unidentified wands being usable in alchemy\\n\" +\n\t\t\t\t\"_-_ Wild energy spell not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with the timekeeper's hourglass\\n\" +\n\t\t\t\t\"_-_ Various bugs with the potion of dragon's breath\\n\" +\n\t\t\t\t\"_-_ Artifact recharging not charging the horn of plenty in some cases when it should\\n\" +\n\t\t\t\t\"_-_ Some items rarely not being consumed when they should be\\n\" +\n\t\t\t\t\"_-_ Arcane catalysts not being able to be turned into energy\\n\" +\n\t\t\t\t\"_-_ Fog of War not properly updating when warp beacon is used\\n\" +\n\t\t\t\t\"_-_ Very rare cases where dried rose becomes unusable\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 3\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Rare cases where lullaby scrolls were generated by the Unstable Spellbook\\n\" +\n\t\t\t\t\"_-_ Ring of might health boost not being affected by lost inventory debuff\\n\" +\n\t\t\t\t\"_-_ Items that spawn identified counting as being IDed by the player\\n\" +\n\t\t\t\t\"_-_ Some sources of artifact recharging affecting cursed artifacts\\n\" +\n\t\t\t\t\"_-_ Blacksmith not refusing to work with cursed items in specific cases\\n\" +\n\t\t\t\t\"_-_ An exploit where unblessed ankhs could be used with a lost inventory\\n\\n\" +\n\t\t\t\t\"_-_ Layout issues with the loot indicator\\n\" +\n\t\t\t\t\"_-_ Floor 5 entrance rooms sometimes being smaller than intended\\n\" +\n\t\t\t\t\"_-_ Red flash effects stacking on each other in some cases\\n\" +\n\t\t\t\t\"_-_ Game forgetting previous window size when maximized and restarted\\n\" +\n\t\t\t\t\"_-_ Cases where ghoul sprites could become glitched\\n\" +\n\t\t\t\t\"_-_ Cases where heroic energy talent would use the wrong name/icon\\n\" +\n\t\t\t\t\"_-_ Curse status of quickslot items not showing in rankings\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.FIRE_BOMB), \"Recipe Cost Reductions\",\n\t\t\t\t\"I've made a bunch of cost adjustments to alchemy recipes to help counteract energy becoming more expensive after v1.1.0:\\n\\n\" +\n\t\t\t\t\"_- Bomb Recipe_ energy costs down across the board\\n\\n\" +\n\t\t\t\t\"_- Infernal, Blizzard, and Caustic Brew_ energy costs down by 1\\n\\n\" +\n\t\t\t\t\"_- Telekinetic Grab_ energy cost down to 2 from 4, liquid metal cost reduced to 10 from 15\\n\" +\n\t\t\t\t\"_- Phase Shift_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Wild Energy_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Beacon of Returning_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Summon Elemental_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Alchemize_ energy cost down to 2 from 3\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AQUA_BLAST), \"Alchemy Buffs\",\n\t\t\t\t\"Several recipes have also been buffed, in addition to the cost reductions:\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ duration up to 400 from 250\\n\" +\n\t\t\t\t\"_- Scroll of Dread_ now grants 1/2 exp for defeated enemies\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ gas quantity increased by 50%\\n\\n\" +\n\t\t\t\t\"_-_ Items and effects which create water now douse fire\\n\\n\" +\n\t\t\t\t\"_- Caustic Brew_ damage per turn increased by 1\\n\" +\n\t\t\t\t\"_- Infernal and Blizzard Brew_ now start their gas in a 3x3 AOE\\n\" +\n\t\t\t\t\"_- Shocking Brew_ AOE up to 7x7 from 5x5\\n\\n\" +\n\t\t\t\t\"_- Phase Shift_ now stuns whatever it teleports\\n\" +\n\t\t\t\t\"_- Summon Elemental_ quantity up to 5 from 3, elemental's stats now scale with depth, and elementals can be re-summoned\\n\" +\n\t\t\t\t\"_- Aqua Blast_ now acts like a geyser trap, quantity down to 8 from 12\\n\" +\n\t\t\t\t\"_- Reclaim Trap_ quantity up to 4 from 3\\n\" +\n\t\t\t\t\"_- Curse Infusion_ now boosts highly levelled gear by more than +1, quantity up to 4 from 3.\\n\" +\n\t\t\t\t\"_- Recycle_ quantity up to 12 from 8, cost up to 8 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ROT_DART), \"Dart Buffs\",\n\t\t\t\t\"While they don't tie into v1.1.0's energy changes in particular, I am also handing out several buffs to tipped darts:\\n\\n\" +\n\t\t\t\t\"_- Rot Dart_ uses increased to 5 from 1\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ duration up to 30 from 10\\n\" +\n\t\t\t\t\"_- Shocking Dart_ damage now slightly scales with depth\\n\" +\n\t\t\t\t\"_- Poison Dart_ damage scaling increased\\n\" +\n\t\t\t\t\"_- Sleep Dart_ is now _Cleansing Dart_, makes allies immune to debuffs for several turns\\n\" +\n\t\t\t\t\"_- Holy Dart_ duration up to 100 from 30\\n\" +\n\t\t\t\t\"_- Displacing Dart_ now much more consistently teleports enemies away\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.LIGHT_CLOAK.icon()), \"Talent Buffs\",\n\t\t\t\t\"I'm handing out a few buffs to help better balance the Mage's T2 talents and the Rogue's class-based T3 talents. I'm also making one bugfix that counts as a buff:\\n\\n\" +\n\t\t\t\t\"_- Energizing Upgrade_ charge boost up to 4/6, from 3/5\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance at +1 reduced to 50%, but now grants 1 arcane resin if it fails to preserve\\n\" +\n\t\t\t\t\"_- Wand Preservation_ max uses up to 5 from 3\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now grants +3 on the next 1/2/3 wand zaps\\n\\n\" +\n\t\t\t\t\"_- Light Cloak_ charging rate boosted to 25%/50%/75%, from 17%/33%/50%\\n\\n\" +\n\t\t\t\t\"_- Shared Upgrades_ bugfixed to give the bonus damage stated in the description, instead of slightly less.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.MAGIC_INFUSE), \"Alchemy Nerfs\",\n\t\t\t\t\"v1.2.0 is mostly about alchemy buffs, but a few alchemy items have had their power reduced as well:\\n\\n\" +\n\t\t\t\t\"_- Magical Infusion_ energy cost up to 4 from 3\\n\" +\n\t\t\t\t\"_- Holy Bomb_ bonus damage reduced to 50% from 67%\\n\" +\n\t\t\t\t\"_- Goo Blob and Metal Shard_ energy value reduced to 3\\n\" +\n\t\t\t\t\"_- Alchemize_ quantity in shops reduced by 1\\n\\n\" +\n\t\t\t\t\"While not a direct alchemy item nerf, I've also made some of the final bosses' fists less susceptible to certain mechanics:\\n\" +\n\t\t\t\t\"_- Soiled Fist_ is now immune to burning, but the grass it generates still burns\\n\" +\n\t\t\t\t\"_- Burning Fist_ is now immune to freezing, but it can still be chilled\\n\" +\n\t\t\t\t\"_- Rotting and Rusted Fists_ now take less damage from retribution, grim, and psionic blast\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Environment.TERRAIN_FEATURES, 112, 112, 16, 16), \"Dreamfoil\",\n\t\t\t\t\"Dreamfoil has always had great utility as a debuff-cleanser, and with the recent addition of stones of deep sleep its enemy sleeping functionality was feeling a bit unnecessary:\\n\\n\" +\n\t\t\t\t\"_- Dreamfoil_ no longer puts enemies into magical sleep\\n\\n\" +\n\t\t\t\t\"Sleep darts (made from dreamfoil) have also been changed into cleansing darts to go along with this change. These darts will make an ally temporarily immune to harmful effects.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.SHIELD_BATTERY.icon()), \"Talent Nerfs\",\n\t\t\t\t\"I'm making a few talent nerfs to better balance the Mage's T2 talents, and to pull in the power of the Berserker a little:\\n\\n\" +\n\t\t\t\t\"_- Shield Battery_ shielding per charge down to 4%/6%, from 5%/7.5%\\n\\n\" +\n\t\t\t\t\"_- Endless Rage_ max rage boost reduced to 10%/20%/30% from 15%/30%/45%\\n\" +\n\t\t\t\t\"_- Enraged Catalyst_ proc rate boost reduced to 15%/30%/45% from 17%/33%/50%\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v1_3_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.3\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\t/*changes.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ v1.3.0 Released XX, 2022\\n\" +\n\t\t\t\t\"_-_ XX days after Shattered v1.2.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));*/\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"To-Do\",\n\t\t\t\t\"There are still a few bits and pieces left to finish up before v1.3 is released:\\n\\n\" +\n\t\t\t\t\"_-_ Final work on daily seeded runs\\n\" +\n\t\t\t\t\"_-_ A new radial selection menu to make using quickslots and the inventory easier on controller\\n\" +\n\t\t\t\t\"_-_ Additional enemy info on the top-left of the screen on full UI mode\\n\" +\n\t\t\t\t\"_-_ Improvements to some of the game's interfaces on full UI mode\" +\n\t\t\t\t\"_-_ Translation work, from volunteers on the game's Transifex project.\\n\" +\n\t\t\t\t\"_-_ Fixes for any bugs that gat reported\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SEED), \"Seeded Runs!\",\n\t\t\t\t\"_It's now possible to enter a custom seed when starting a new game!_\\n\\n\" +\n\t\t\t\t\"Seeds are used to determine dungeon generation, and two runs with the same seed and game version will produce the exact same dungeon to play though.\\n\\n\" +\n\t\t\t\t\"If you don't enter a custom seed, the game will use a random one to generate a random dungeon, just like it did prior to this update.\\n\\n\" +\n\t\t\t\t\"Note that only players who have won at least once can enter custom seeds, and games with custom seeds are not eligible to appear in rankings.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.CALENDAR), \"Daily Runs!\",\n\t\t\t\t\"_Every day there is a specific seeded run that's available to all players!_\\n\\n\" +\n\t\t\t\t\"The daily run makes it easy to compete again friends or other folks on the internet, without having to coordinate and share a specific seed. Note that dailies currently do not have online leaderboard functionality, but I am open to adding it in the future.\\n\\n\" +\n\t\t\t\t\"_Note that daily runs have not yet been implemented._\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.HIGH_SCORE_2.image ), \"New Score System!\",\n\t\t\t\t\"_The game's scoring system has been overhauled to go along with seeded runs and dailies!_\\n\\n\" +\n\t\t\t\t\"The score system now factors in a bunch of new criteria like exploration, performance during boss fights, quest completions, and enabled challenges. This should make score a much better measure of player performance.\\n\\n\" +\n\t\t\t\t\"A score breakdown page has also been added to the rankings screen. This page even works for old games, and retroactively applies the challenge bonus!\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AMULET), \"Harder Ascension Route!\",\n\t\t\t\t\"_A bunch of adjustments have been made to the ascension route to make it a proper challenge!_\\n\\n\" +\n\t\t\t\t\"Enemies will get much stronger as you ascend, and it's impossible to teleport back up or flee and avoid all combat. Expect to have to work a little bit more for an ascension win!\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"UI Improvements!\",\n\t\t\t\t\"_Several UI and UX Improvements have been made for desktop and mobile users_\\n\\n\" +\n\t\t\t\t\"_-_ The settings menu has been adjusted with a few new and rearranged options.\\n\" +\n\t\t\t\t\"_-_ Added a quickslot swapper option for mobile portrait users.\\n\" +\n\t\t\t\t\"_-_ Keyboard and controller key bindings now have separate windows\\n\" +\n\t\t\t\t//\"_-_ \" +\n\t\t\t\t\"_Several more UI improvements will be implemented before v1.3.0 goes live.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.BOSS_CHALLENGE_5.image ), \"New Badges!\",\n\t\t\t\t\"_14 new badges have been added to the game!_\\n\\n\" +\n\t\t\t\t\"_-_ Five of these badges are 'high score' badges, meant to tie into the new score system.\\n\" +\n\t\t\t\t\"_-_ Another five of these badges are 'boss challenge' badges, which each require you to defeat a boss in a particular way.\\n\" +\n\t\t\t\t\"_-_ Four new 'cause of death' badges have also been added, which should be a little trickier than the existing ones.\\n\\n\" +\n\t\t\t\t\"Several of these badges are on the harder end, in particular the final high score and boss challenge badge should be a real challenge, even for veteran players.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SHORTSWORD, new ItemSprite.Glowing(0x000000)), \"Curse Redesigns\",\n\t\t\t\t\"_Three of the most annoying curses have been replaced or redesigned, and two more have been adjusted._\\n\\n\" +\n\t\t\t\t\"_- Fragile_ has been replaced by _explosive,_ which builds power and then explodes!\\n\" +\n\t\t\t\t\"_- Wayward_ has been redesigned to sometimes apply an accuracy reducing debuff, instead of always reducing accuracy.\\n\" +\n\t\t\t\t\"_- Exhausting_ has been replaced by _dazzling,_ which can blind both the attacker and defender.\\n\\n\" +\n\t\t\t\t\"_Anti-entropy_ and _sacrifice_ have also been nerfed (i.e. made less harsh), look at the nerfs section for more details on that.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_ODAL), Messages.get(ScrollOfMetamorphosis.class, \"name\"),\n\t\t\t\t\"The scroll of metamorphosis has been adjusted to allow more of the game's talents to work with its effect.\\n\\n\" +\n\t\t\t\t\"Several talents that were previously exempt from being chosen by the scroll now have alternative effects that let them be used by any hero.\\n\\n\" +\n\t\t\t\t\"These alternative effects only appear when getting these talents via metamorphosis.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image( Badges.Badge.MONSTERS_SLAIN_5.image ), \"Badge Changes\",\n\t\t\t\t\"I'm making several changes to existing badges, based on feedback and data from Steam players:\\n\\n\" +\n\t\t\t\t\"_-_ Several gold tier badges have been bumped up to platinum tier to better reflect their difficulty\\n\" +\n\t\t\t\t\"_-_ The 'grim reaper' badge has been bumped up to gold tier, from silver\\n\\n\" +\n\t\t\t\t\"_-_ The master and grandmaster 'monsters hunter' and 'treasure hunter' badges have been made more difficult\\n\" +\n\t\t\t\t\"_-_ The alchemist badges have been rebalanced to start out easier and end up harder\\n\\n\" +\n\t\t\t\t\"_-_ The 'dungeoneer' badges have been made easier to unlock with wins or games played. The master and grandmaster versions still require a lot of games played though.\"));\n\n\t\tchanges.addButton( new ChangeButton(new BuffIcon(BuffIndicator.TARGETED, true), \"Buff and Spell Icons\",\n\t\t\t\t\"Several buffs have been given icons when they didn't have any, or have had their icons adjusted to prevent icon duplication. This should improve buff clarity in a few cases, and ensure that two active buffs can never have the exact same icon (recolored icons are still present though).\\n\\n\" +\n\t\t\t\t\"A few new overhead spell effects have been added as well.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Made the Huntress a bit easier to unlock again\\n\" +\n\t\t\t\t\"_-_ Dreamfoil has been renamed to Mageroyal, to better fit its lack of sleeping functionality since 1.2\\n\" +\n\t\t\t\t\"_-_ Updated various code dependencies\\n\" +\n\t\t\t\t\"_-_ Made major internal changes in prep for quest improvements in v1.4\\n\" +\n\t\t\t\t\"_-_ Added a slight delay to chasm jump confirmation window, to prevent mistaps\\n\" +\n\t\t\t\t\"_-_ Progress is now shown for badges that need to be unlocked with multiple heroes\\n\" +\n\t\t\t\t\"_-_ Multiple unlocked badges can now be shown at once\\n\" +\n\t\t\t\t\"_-_ Various minor tweaks to item and level generation to support seeded runs\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual bugs\\n\" +\n\t\t\t\t\"_-_ Final boss's summons being slightly weaker than intended when badder bosses is enabled\\n\" +\n\t\t\t\t\"_-_ Great crab not blocking right after loading a save\\n\" +\n\t\t\t\t\"_-_ Exploits that could force DM-300 to dig outside of its arena\\n\" +\n\t\t\t\t\"_-_ Wraiths from spectral necromancers not always dying when the necromancer dies\\n\" +\n\t\t\t\t\"_-_ The mystical charge talent giving more charge than intended\\n\" +\n\t\t\t\t\"_-_ Ring of might HP bonus not applying in specific cases\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Buffs\",\n\t\t\t\t\"_- Endure_ damage bonus increased to 1/2 of damage taken from 1/3\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ base wand boost and max boost increased by 1\\n\" +\n\t\t\t\t\"_- Fire Everything_ now has a 25% chance per point to let a wand be usable 3 times\\n\" +\n\t\t\t\t\"_- Conserved Magic_ no longer lets a wand be usable 3 times, now grants a chance for wild magic to take 0 turns instead\\n\\n\" +\n\t\t\t\t\"_- Elemental power_ boost per point up to 25%, from 25%\\n\" +\n\t\t\t\t\"_- Reactive Barrier_ shielding per point up to 2.5, from 20, and max targets now increases by 1 per point.\\n\\n\" +\n\t\t\t\t\"_- Shadow Clone_ now costs 35 energy, down from 50. Initial HP down to 80 from 100\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per point up to 8%, from 7.5%\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per point down to 12%, from 15%\\n\\n\" +\n\t\t\t\t\"_- Eagle Eye_ now grants 9 and 10 vision range at 3 and 4 points\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now cripples at ranks 3 and 4\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now grants 2/4/6/8 dodges, up from 2/3/4/5\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.WAND_PRESERVATION), Talent.WAND_PRESERVATION.title(),\n\t\t\t\t\"Only one isolated talent change in this update:\\n\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance to preserve at +1 reverted to 67% from 50%, still grants 1 arcane resin if it fails to preserve\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CRYSTAL_KEY), \"Crystal Path Rooms\",\n\t\t\t\t\"Loot from crystal path rooms (the rooms with a sequence of 3 crystal doors) has been buffed to make their value closer to other crystal key rooms.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CLEANSING_DART), \"Alchemy Item Buffs\",\n\t\t\t\t\"I'm giving woolly bomb's a big buff to help make them more distinct from other sheep-spawning items:\\n\\n\" +\n\t\t\t\t\"_- Woolly Bombs_ now summon sheep for 200 turns, or 20 turns during boss fights, up from 12-16 turns\\n\\n\" +\n\t\t\t\t\"I've given some alternative functions to three darts that would previously only help allies:\\n\\n\" +\n\t\t\t\t\"_- Holy Dart_ turns of bless reverted to 30 from 100, now heavily damages undead or demonic enemies, instead of blessing them\\n\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ turns of adrenaline reverted to 10 from 30, now cripples enemies for 5 turns, instead of giving them adrenaline\\n\\n\" +\n\t\t\t\t\"_- Cleansing Dart_ now clears positive buffs from enemies, and causes them to start wandering (note that they may immediately re-aggro if they are close enough)\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN), \"Armor Ability Nerfs\",\n\t\t\t\t\"Along with several armor ability buffs, two have received energy cost nerfs, mainly to reduce the uptime of positioning/escape abilities. Some compensation buffs have been given for the energy cost change as well:\\n\\n\" +\n\t\t\t\t\"_- Heroic Leap_ energy cost up to 35 from 25\\n\" +\n\t\t\t\t\"_- Body Slam_ now adds 1-4 base damage per point in talent\\n\" +\n\t\t\t\t\"_- Impact Wave_ now applies vulnerable for 5 turns, up from 3\\n\" +\n\t\t\t\t\"_- Double jump_ energy cost reduction increased by 20%\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ energy cost up to 50 from 35\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range up to 10 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_LEATHER, new ItemSprite.Glowing(0x000000)), \"Curse Buffs\",\n\t\t\t\t\"Two of the most harsh curses have been nerfed (i.e. made better for the player):\\n\\n\" +\n\t\t\t\t\"_- Anti-Entopy_ now spreads less fire to the player, and freezes all adjacent tiles instead of just the enemy.\\n\\n\" +\n\t\t\t\t\"_- Sacrifice_ now more heavily scales on current HP, bleeding for a bit more at high health, and very little at medium to low health.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ElementalSprite.Fire()), \"Floor 16 Adjustments\",\n\t\t\t\t\"Floor 16's spawn rates have been adjusted:\\n\\n\" +\n\t\t\t\t\"Ghouls up to 60% from 40%\\n\" +\n\t\t\t\t\"Elementals down to 20% from 40%\\n\" +\n\t\t\t\t\"Warlocks unchanged at 20%\\n\\n\" +\n\t\t\t\t\"This is to help smooth over a slight difficulty spike on that floor.\"));\n\n\t}",
          "uniqueId": "2ccfe6f7e2bee6c96c565274320b1e3eda339c4a_81_328_82_246_248_432"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8ce4b87f13909f5e42da6ff4e2c7e88e02662dee",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8ce4b87f13909f5e42da6ff4e2c7e88e02662dee",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public CorrosiveGas setStrength(int str){\n\t\tif (str > strength) {\n\t\t\tstrength = str;\n\t\t}\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "public CorrosiveGas setStrength(int str){\n\t\treturn setStrength(str, null);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic CorrosiveGas setStrength(int str, Class source){\n\t\tif (str > strength) {\n\t\t\tstrength = str;\n\t\t\tthis.source = source;\n\t\t}\n\t\treturn this;\n\t}",
          "uniqueId": "8ce4b87f13909f5e42da6ff4e2c7e88e02662dee_61_66_69_75_65_67"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void set(float duration, int damage) {\n\t\tthis.left = Math.max(duration, left);\n\t\tif (this.damage < damage) this.damage = damage;\n\t}",
          "sourceCodeAfterRefactoring": "public void set(float duration, int damage){\n\t\tset(duration, damage, null);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void set(float duration, int damage, Class source) {\n\t\tthis.left = Math.max(duration, left);\n\t\tif (this.damage < damage) this.damage = damage;\n\t\tthis.source = source;\n\t}",
          "uniqueId": "8ce4b87f13909f5e42da6ff4e2c7e88e02662dee_59_62_71_75_67_69"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8e348b56693ae9ad75a396a6bba249c2bd010df1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8e348b56693ae9ad75a396a6bba249c2bd010df1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void set( float level ) {\n\t\tthis.level = Math.max(this.level, level);\n\t}",
          "sourceCodeAfterRefactoring": "public void set( float level ) {\n\t\tset( level, null );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void set( float level, Class source ){\n\t\tif (this.level < level) {\n\t\t\tthis.level = Math.max(this.level, level);\n\t\t\tthis.source = source;\n\t\t}\n\t}",
          "uniqueId": "8e348b56693ae9ad75a396a6bba249c2bd010df1_62_64_74_79_70_72"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5b05e453da3c294bacc506481222e8bc9a7d5d6b",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5b05e453da3c294bacc506481222e8bc9a7d5d6b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void validateYASD() {\n\t\tif (isUnlocked( Badge.DEATH_FROM_FIRE ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_POISON ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_GAS ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_HUNGER) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_GLYPH) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_FALLING)) {\n\n\t\t\tBadge badge = Badge.YASD;\n\t\t\tif (!isUnlocked( badge )) {\n\t\t\t\tdisplayBadge( badge );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void validateDeathFromSacrifice() {\n\t\tBadge badge = Badge.DEATH_FROM_SACRIFICE;\n\t\tlocal.add( badge );\n\t\tdisplayBadge( badge );\n\n\t\tvalidateDeathFromAll();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void validateDeathFromAll() {\n\t\tif (isUnlocked( Badge.DEATH_FROM_FIRE ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_POISON ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_GAS ) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_HUNGER) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_FALLING) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_ENEMY_MAGIC) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_FRIENDLY_MAGIC) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_SACRIFICE) &&\n\t\t\t\tisUnlocked( Badge.DEATH_FROM_GRIM_TRAP)) {\n\n\t\t\tBadge badge = Badge.DEATH_FROM_ALL;\n\t\t\tif (!isUnlocked( badge )) {\n\t\t\t\tdisplayBadge( badge );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "5b05e453da3c294bacc506481222e8bc9a7d5d6b_605_618_647_663_631_637"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ede0439ab88324d5b9287c19ab18fb4c2b50a90a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ede0439ab88324d5b9287c19ab18fb4c2b50a90a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void show( Char ch, int index ) {\n\t\t\n\t\tif (!ch.sprite.visible) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSpellSprite old = all.get( ch );\n\t\tif (old != null) {\n\t\t\told.kill();\n\t\t}\n\t\t\n\t\tSpellSprite sprite = GameScene.spellSprite();\n\t\tsprite.target = ch;\n\t\tsprite.reset( index );\n\t\tsprite.revive();\n\t\tall.put( ch, sprite );\n\t}",
          "sourceCodeAfterRefactoring": "public static void show( Char ch, int index ) {\n\t\tshow(ch, index, 1, 1, 1);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void show( Char ch, int index, float r, float g, float b ) {\n\t\t\n\t\tif (!ch.sprite.visible) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSpellSprite old = all.get( ch );\n\t\tif (old != null) {\n\t\t\told.kill();\n\t\t}\n\t\t\n\t\tSpellSprite sprite = GameScene.spellSprite();\n\t\tsprite.target = ch;\n\t\tsprite.reset( index );\n\t\tsprite.hardlight(r, g, b);\n\t\tsprite.revive();\n\t\tall.put( ch, sprite );\n\t}",
          "uniqueId": "ede0439ab88324d5b9287c19ab18fb4c2b50a90a_131_147_137_154_133_135"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4e98ea86da5445d6ccbf0b393c5677636a88ee14",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4e98ea86da5445d6ccbf0b393c5677636a88ee14",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public String desc(){\n\t\treturn Messages.get(this, name() + \".desc\");\n\t}",
          "sourceCodeAfterRefactoring": "public final String desc(){\n\t\treturn desc(false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String desc(boolean metamorphed){\n\t\tif (metamorphed){\n\t\t\tString metaDesc = Messages.get(this, name() + \".meta_desc\");\n\t\t\tif (!metaDesc.equals(Messages.NO_TEXT_FOUND)){\n\t\t\t\treturn Messages.get(this, name() + \".desc\") + \"\\n\\n\" + metaDesc;\n\t\t\t}\n\t\t}\n\t\treturn Messages.get(this, name() + \".desc\");\n\t}",
          "uniqueId": "4e98ea86da5445d6ccbf0b393c5677636a88ee14_228_230_270_278_266_268"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9c92ab8154f71b657c4a55d8426ef2870de626c2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9c92ab8154f71b657c4a55d8426ef2870de626c2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Item identify() {\n\n\t\tif (Dungeon.hero != null && Dungeon.hero.isAlive()){\n\t\t\tCatalog.setSeen(getClass());\n\t\t\tif (!isIdentified()) Talent.onItemIdentified(Dungeon.hero, this);\n\t\t}\n\n\t\tlevelKnown = true;\n\t\tcursedKnown = true;\n\t\tItem.updateQuickslot();\n\t\t\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "public final Item identify(){\n\t\treturn identify(true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Item identify( boolean byHero ) {\n\n\t\tif (byHero && Dungeon.hero != null && Dungeon.hero.isAlive()){\n\t\t\tCatalog.setSeen(getClass());\n\t\t\tif (!isIdentified()) Talent.onItemIdentified(Dungeon.hero, this);\n\t\t}\n\n\t\tlevelKnown = true;\n\t\tcursedKnown = true;\n\t\tItem.updateQuickslot();\n\t\t\n\t\treturn this;\n\t}",
          "uniqueId": "9c92ab8154f71b657c4a55d8426ef2870de626c2_399_411_406_418_402_404"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c5e6f056ce5863eefed8ecdc245f4189fa89c5dd",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c5e6f056ce5863eefed8ecdc245f4189fa89c5dd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public StatsTab() {\n\t\t\t\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\tIconTitle title = new IconTitle();\n\t\t\ttitle.icon( HeroSprite.avatar(hero.heroClass, hero.tier()) );\n\t\t\tif (hero.name().equals(hero.className()))\n\t\t\t\ttitle.label( Messages.get(this, \"title\", hero.lvl, hero.className() ).toUpperCase( Locale.ENGLISH ) );\n\t\t\telse\n\t\t\t\ttitle.label((hero.name() + \"\\n\" + Messages.get(this, \"title\", hero.lvl, hero.className())).toUpperCase(Locale.ENGLISH));\n\t\t\ttitle.color(Window.TITLE_COLOR);\n\t\t\ttitle.setRect( 0, 0, WIDTH-16, 0 );\n\t\t\tadd(title);\n\n\t\t\tIconButton infoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tsuper.onClick();\n\t\t\t\t\tif (ShatteredPixelDungeon.scene() instanceof GameScene){\n\t\t\t\t\t\tGameScene.show(new WndHeroInfo(hero.heroClass));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(hero.heroClass));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected String hoverText() {\n\t\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tinfoButton.setRect(title.right(), 0, 16, 16);\n\t\t\tadd(infoButton);\n\n\t\t\tpos = title.bottom() + 2*GAP;\n\n\t\t\tint strBonus = hero.STR() - hero.STR;\n\t\t\tif (strBonus > 0)           statSlot( Messages.get(this, \"str\"), hero.STR + \" + \" + strBonus );\n\t\t\telse if (strBonus < 0)      statSlot( Messages.get(this, \"str\"), hero.STR + \" - \" + -strBonus );\n\t\t\telse                        statSlot( Messages.get(this, \"str\"), hero.STR() );\n\t\t\tif (hero.shielding() > 0)   statSlot( Messages.get(this, \"health\"), hero.HP + \"+\" + hero.shielding() + \"/\" + hero.HT );\n\t\t\telse                        statSlot( Messages.get(this, \"health\"), (hero.HP) + \"/\" + hero.HT );\n\t\t\tstatSlot( Messages.get(this, \"exp\"), hero.exp + \"/\" + hero.maxExp() );\n\n\t\t\tpos += GAP;\n\n\t\t\tstatSlot( Messages.get(this, \"gold\"), Statistics.goldCollected );\n\t\t\tstatSlot( Messages.get(this, \"depth\"), Statistics.deepestFloor );\n\n\t\t\tpos += GAP;\n\t\t}",
          "sourceCodeAfterRefactoring": "public StatsTab() {\n\t\t\tinitialize();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void initialize(){\n\n\t\t\tfor (Gizmo g : members){\n\t\t\t\tif (g != null) g.destroy();\n\t\t\t}\n\t\t\tclear();\n\t\t\t\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\tIconTitle title = new IconTitle();\n\t\t\ttitle.icon( HeroSprite.avatar(hero.heroClass, hero.tier()) );\n\t\t\tif (hero.name().equals(hero.className()))\n\t\t\t\ttitle.label( Messages.get(this, \"title\", hero.lvl, hero.className() ).toUpperCase( Locale.ENGLISH ) );\n\t\t\telse\n\t\t\t\ttitle.label((hero.name() + \"\\n\" + Messages.get(this, \"title\", hero.lvl, hero.className())).toUpperCase(Locale.ENGLISH));\n\t\t\ttitle.color(Window.TITLE_COLOR);\n\t\t\ttitle.setRect( 0, 0, WIDTH-16, 0 );\n\t\t\tadd(title);\n\n\t\t\tIconButton infoButton = new IconButton(Icons.get(Icons.INFO)){\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tsuper.onClick();\n\t\t\t\t\tif (ShatteredPixelDungeon.scene() instanceof GameScene){\n\t\t\t\t\t\tGameScene.show(new WndHeroInfo(hero.heroClass));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tShatteredPixelDungeon.scene().addToFront(new WndHeroInfo(hero.heroClass));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected String hoverText() {\n\t\t\t\t\treturn Messages.titleCase(Messages.get(WndKeyBindings.class, \"hero_info\"));\n\t\t\t\t}\n\n\t\t\t};\n\t\t\tinfoButton.setRect(title.right(), 0, 16, 16);\n\t\t\tadd(infoButton);\n\n\t\t\tpos = title.bottom() + 2*GAP;\n\n\t\t\tint strBonus = hero.STR() - hero.STR;\n\t\t\tif (strBonus > 0)           statSlot( Messages.get(this, \"str\"), hero.STR + \" + \" + strBonus );\n\t\t\telse if (strBonus < 0)      statSlot( Messages.get(this, \"str\"), hero.STR + \" - \" + -strBonus );\n\t\t\telse                        statSlot( Messages.get(this, \"str\"), hero.STR() );\n\t\t\tif (hero.shielding() > 0)   statSlot( Messages.get(this, \"health\"), hero.HP + \"+\" + hero.shielding() + \"/\" + hero.HT );\n\t\t\telse                        statSlot( Messages.get(this, \"health\"), (hero.HP) + \"/\" + hero.HT );\n\t\t\tstatSlot( Messages.get(this, \"exp\"), hero.exp + \"/\" + hero.maxExp() );\n\n\t\t\tpos += GAP;\n\n\t\t\tstatSlot( Messages.get(this, \"gold\"), Statistics.goldCollected );\n\t\t\tstatSlot( Messages.get(this, \"depth\"), Statistics.deepestFloor );\n\n\t\t\tpos += GAP;\n\t\t}",
          "uniqueId": "c5e6f056ce5863eefed8ecdc245f4189fa89c5dd_128_178_138_193_134_136"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "47d9f3219d5eb0f3f7482b78b9e05334f3de0040",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47d9f3219d5eb0f3f7482b78b9e05334f3de0040",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v1_1_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v1.1\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v1.1.2\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"Various small improvements for iOS Devices:\\n\" +\n\t\t\t\t\"_-_ Game can now run at higher framerates than 60\\n\" +\n\t\t\t\t\"_-_ Ingame UI elements now move inward if notched devices are used in landscape\\n\" +\n\t\t\t\t\"_-_ There is now an option to override silent mode\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.1.0):\\n\" +\n\t\t\t\t\"_-_ Further rare cases of save corruption on Android 12\\n\" +\n\t\t\t\t\"_-_ Quickslotted bags freezing the game if used while empty\\n\" +\n\t\t\t\t\"_-_ Potions of Dragon's Breath and Mastery not being IDed if they were cancelled\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v1.1.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual errors\\n\" +\n\t\t\t\t\"_-_ Gateway traps rarely teleporting immovable characters\\n\" +\n\t\t\t\t\"_-_ Monks never losing focus if attacked out of hero vision range\\n\" +\n\t\t\t\t\"_-_ Wild magic continuing to activate if the hero dies during it\"));\n\n\t\tchanges = new ChangeInfo(\"v1.1.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v1.1.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various rare cases of save corruption on Android\\n\" +\n\t\t\t\t\"_-_ Holding keys to move not working on Desktop\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v1.1.0):\\n\" +\n\t\t\t\t\"_-_ Specific cases where guidebook windows could be stacked\\n\" +\n\t\t\t\t\"_-_ Remove curse stating nothing was cleansed when it removed the degrade debuff\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released December 10th, 2021\\n\" +\n\t\t\t\t\"_-_ 115 days after Shattered v1.0.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ENERGY), \"Alchemical Energy Overhaul\",\n\t\t\t\t\"_The role of Alchemical Energy in the alchemy system has been totally overhauled!_\\n\\n\" +\n\t\t\t\t\"Energy is now a resource that the player carries with themselves, like gold. The game also generates much less energy for free, but more can be created by scrapping consumable items.\\n\\n\" +\n\t\t\t\t\"Many recipes have been adjusted to compensate for this. Exotic potions and scrolls now require energy instead of seeds/stones, and several of them have been buffed or totally redesigned (see buffs and changes sections for more details).\\n\\n\" +\n\t\t\t\t\"Other recipes have received relatively minor changes for now (mostly energy cost tweaks), but I'll likely be giving them more attention soon in future updates.\\n\\n\" +\n\t\t\t\t\"This repositions energy as the primary driving force for alchemy, and should make the system both more flexible and better at recycling consumables the player doesn't want into ones that they do.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SUMMON_ELE), \"New and Reworked Spells\",\n\t\t\t\t\"While this update mostly focused changes on exotic potions and scrolls, there are _two new spells, and one totally redesigned spell:_\\n\\n\" +\n\t\t\t\t\"_Summon Elemental_ requires fresh embers and an arcane catalyst. It can be used to summon a friendly elemental to fight for you, and can even be powered up with other items!\\n\\n\" +\n\t\t\t\t\"_Telekinetic Grab_ requires some liquid metal and an arcane catalyst. It can be used to grab items remotely, even thrown items that are stuck to an enemy!\\n\\n\" +\n\t\t\t\t\"_Alchemize_ has been totally redesigned. It now only requires an arcane catalyst, and is used to convert items into gold or alchemical energy on the go. I'm really hoping this spell helps with inventory management.\\n\\n\" +\n\t\t\t\t\"Because of the redesign to alchemize, the merchant's beacon and magical porter are made mostly redundant and have been removed from the game. Shops now sell a few uses of alchemize instead.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"more new music!\",\n\t\t\t\t\"_The game now has a music track for each of the five dungeon regions!_\\n\\n\" +\n\t\t\t\t\"Just like the remastered tracks from v1.0.0, they are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"Each of these tracks use a similar variable looping method to the sewers track, to try and reduce repetitiveness.\\n\\n\" +\n\t\t\t\t\"There have also been some small tweaks made to the existing sewers and title theme tracks.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_ISAZ), \"Exotic Reworks\",\n\t\t\t\t\"Several exotic potions and scrolls have been redesigned to be more powerful and worth using:\\n\\n\" +\n\t\t\t\t\"_- Potion of Holy Furor_ is now _Potion of Divine Inspiration_, which gives bonus talent points.\\n\" +\n\t\t\t\t\"_- Potion of Adrenaline Surge_ is now _Potion of Mastery_, which reduces the strength requirement of one item by 2.\\n\\n\" +\n\t\t\t\t\"_- Scroll of Petrification_ is now _Scroll of Dread_, which causes enemies to flee the dungeon entirely.\\n\" +\n\t\t\t\t\"_- Scroll of Affection_ is now _Scroll of Siren's Song_, which permanently makes an enemy into an ally.\\n\" +\n\t\t\t\t\"_- Scroll of Confusion_ is now _Scroll of Challenge_, which attracts enemies but creates an arena where you take reduced damage.\\n\" +\n\t\t\t\t\"_- Scroll of Polymorph_ is now _Scroll of Metamorphosis_, which lets you swap out a talent to one from another class.\" ));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Item drops and special room spawns are now more consistent. Getting loads of the same item is now much less likely.\\n\" +\n\t\t\t\t\"_-_ Items present on boss floors are now preserved if the hero is revived from an unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Teleport mechanics now work on boss levels\\n\" +\n\t\t\t\t\"_-_ Traps that teleport no longer work on items in chests or similar containers\\n\" +\n\t\t\t\t\"_-_ Rewards from piranha and trap rooms now always appear in chests\\n\\n\" +\n\n\t\t\t\t\"_-_ Tipped darts can now be transmuted and recycled\\n\" +\n\t\t\t\t\"_-_ Thrown weapons no longer stick to allies\\n\" +\n\t\t\t\t\"_-_ Liquid metal production from upgraded thrown weapons now caps at +3\\n\\n\" +\n\n\t\t\t\t\"_-_ Updated game icons on Android and Desktop platforms\\n\" +\n\t\t\t\t\"_-_ Tabs in rankings and hero info windows now use icons, not text\\n\" +\n\t\t\t\t\"_-_ 'potions cooked' badge and stats are now 'items crafted'\\n\\n\" +\n\n\t\t\t\t\"_-_ Newborn elementals no longer have a ranged attack\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor/rare visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Cases where pausing/resuming the game at precise moments would cancel animations or attacks\\n\" +\n\t\t\t\t\"_-_ Endure damage reduction applying after some specific other damage-reducing effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh resurrection windows disappearing in some cases\\n\" +\n\t\t\t\t\"_-_ Lucky enchantment rarely not trigger in some cases\\n\" +\n\t\t\t\t\"_-_ Artifacts spawning upgraded from golden mimics\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival cancelling corpse dust curse\\n\" +\n\t\t\t\t\"_-_ Unstable spellbook letting the player select unidentified scrolls\\n\" +\n\t\t\t\t\"_-_ Desktop version not working correctly with FreeBSD\\n\" +\n\t\t\t\t\"_-_ Liquid metal being usable on darts\\n\" +\n\t\t\t\t\"_-_ Teleportation working on immovable characters in some cases\\n\" +\n\t\t\t\t\"_-_ Various quirks with thrown weapon durability\\n\" +\n\t\t\t\t\"_-_ Rare cases where ghouls would get many extra turns when reviving\\n\" +\n\t\t\t\t\"_-_ Magical infusion not preserving curses on armor\\n\" +\n\t\t\t\t\"_-_ Vertigo and teleportation effects rarely interfering\\n\" +\n\t\t\t\t\"_-_ Layout issues in the hero info window with long buff names\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Cursed wands being usable to create arcane resin\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival rarely causing crashes or placing the player on hazards\\n\" +\n\t\t\t\t\"_-_ Some glyphs not working for armored statues or the ghost hero\\n\" +\n\t\t\t\t\"_-_ Various oddities with inferno gas logic\\n\" +\n\t\t\t\t\"_-_ Spirit bow having negative damage values in rare cases\\n\" +\n\t\t\t\t\"_-_ Artifact recharging buff working on cursed artifacts\\n\" +\n\t\t\t\t\"_-_ Scrolls of upgrade revealing whether unidentified rings/wands were cursed\\n\" +\n\t\t\t\t\"_-_ Ring of Might not updating hero health total in rare cases\\n\" +\n\t\t\t\t\"_-_ Specific cases where darts would not recognize an equipped crossbow\\n\" +\n\t\t\t\t\"_-_ Cap on regrowth wand being affect by level boosts\\n\" +\n\t\t\t\t\"_-_ Some on-hit effects not triggering on ghost or armored statues\\n\" +\n\t\t\t\t\"_-_ Rare errors when gateway traps teleported multiple things at once\\n\" +\n\t\t\t\t\"_-_ Various rare errors when multiple inputs were given in the same frame\\n\" +\n\t\t\t\t\"_-_ Fog of War errors in Tengu's arena\\n\" +\n\t\t\t\t\"_-_ Rare errors with sheep spawning items and traps\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_AMBER), \"Exotic Buffs\",\n\t\t\t\t\"Some exotic potions and scrolls have received more minor buffs, and not total redesigns:\\n\\n\" +\n\t\t\t\t\"_- Potions of Storm Clouds, Shrouding Fog, and Corrosion_ initial gas AOE up to 3x3 from 1x1\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ now only blocks enemy vision\\n\" +\n\t\t\t\t\"_- Potion of Corrosion_ starting damage increased by 1\\n\" +\n\t\t\t\t\"_- Potion of Magical Sight_ vision range up to 12 from 8\\n\" +\n\t\t\t\t\"_- Potion of Cleansing_ now applies debuff immunity for 5 turns\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ now increases detection range to 8 (from 2), but lasts 250 turns (from 600)\\n\" +\n\t\t\t\t\"_- Scroll of Prismatic Image_ hp +2 and damage +20%\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_TOOLKIT), \"Artifact Buffs\",\n\t\t\t\t\"The _Alchemist's Toolkit_ has received some minor changes to go along with the energy system adjustments:\\n\" +\n\t\t\t\t\"_-_ Toolkit indirectly buffed by energy now being more valuable\\n\" +\n\t\t\t\t\"_-_ Energy required to level up toolkit halved, kit can now be levelled anywhere\\n\" +\n\t\t\t\t\"_-_ Toolkit warmup is now based on time, and gets faster as it levels up\\n\" +\n\t\t\t\t\"_-_ Toolkit can now be used when enemies are near\\n\\n\" +\n\t\t\t\t\"The _Horn of Plenty_ is getting a change to increase its flexibility, and to make it better synergize with food eating talents:\\n\" +\n\t\t\t\t\"_-_ The horn now has a 'snack' option that always consumes 1 charge\\n\" +\n\t\t\t\t\"_-_ To counterbalance this, the total number of charges and charge speed have been halved, but each charge is worth twice as much as before.\\n\\n\" +\n\t\t\t\t\"I'm giving a mild buff to the _Dried Rose_ to fix an odd inconsistency where it was better to kill the ghost off than let them heal:\\n\" +\n\t\t\t\t\"_-_ Ghost HP regen doubled, to match the roses recharge speed (500 turns to full HP)\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.WARRIOR, 0, 90, 12, 15), HeroSubClass.BERSERKER.title(),\n\t\t\t\t\"The berserker is getting a small QOL buff to make it easier to hold onto rage in combat:\\n\\n\" +\n\t\t\t\t\"_-_ Rage now starts expiring after not taking damage for 2 turns, instead of immediately.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Talent and Ability Buffs\",\n\t\t\t\t\"Talent and ability balance is becoming more stable now, but I've still got a few buffs to hand out, some are quite significant:\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ Charge cost reduced to 25, from 35.\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ Duration up to 100 turns, from 60.\\n\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now lasts for 2 wand zaps, up from 1.\\n\" +\n\t\t\t\t\"_- Light Cloak_ now grants 16.6% charge speed per rank, up from 13.3%\\n\" +\n\t\t\t\t\"_- Shrug it Off_ now caps damage taken at 20% at +4, up from 25%.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The reduction to the Mage's starting melee damage in v1.0.0 had a good effect on his early game winrate, but it's still notably higher than other heroes. So, I'm nudging his early melee power down one more time:\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-6 from 1-7.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), HeroSubClass.ASSASSIN.title(),\n\t\t\t\t\"The Assassin is doing very well right now, especially after the power boost he can receive from smoke bomb or death mark. I'm scaling back his core power a little to try and reign him in a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Preparation bonus damage at power level 1/2/3/4 reduced to 10/20/35/50%, from 15/30/45/60%\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.DOUBLE_JUMP.icon()), Talent.DOUBLE_JUMP.title(),\n\t\t\t\t\"Just one talent/ability nerf this time! I'm scaling double jump back a bit to put it more in line with the other heroic leap talents:\\n\\n\" +\n\t\t\t\t\"_-_ Charge cost reduction now caps at 50%, down from 60%\\n\" +\n\t\t\t\t\"_-_ The warrior must now jump again within 3 turns, down from 5\\n\\n\" +\n\t\t\t\t\"I'll likely making more balance tweaks (including nerfs) to abilities and talents in the future, but at the moment double jump is the only major standout.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v1_1_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v1.1\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ v1.1.0 released December 10th, 2021\\n\" +\n\t\t\t\t\"_-_ 115 days after Shattered v1.0.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ENERGY), \"Alchemical Energy Overhaul\",\n\t\t\t\t\"_The role of Alchemical Energy in the alchemy system has been totally overhauled!_\\n\\n\" +\n\t\t\t\t\"Energy is now a resource that the player carries with themselves, like gold. The game also generates much less energy for free, but more can be created by scrapping consumable items.\\n\\n\" +\n\t\t\t\t\"Many recipes have been adjusted to compensate for this. Exotic potions and scrolls now require energy instead of seeds/stones, and several of them have been buffed or totally redesigned (see buffs and changes sections for more details).\\n\\n\" +\n\t\t\t\t\"Other recipes have received relatively minor changes for now (mostly energy cost tweaks), but I'll likely be giving them more attention soon in future updates.\\n\\n\" +\n\t\t\t\t\"This repositions energy as the primary driving force for alchemy, and should make the system both more flexible and better at recycling consumables the player doesn't want into ones that they do.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SUMMON_ELE), \"New and Reworked Spells\",\n\t\t\t\t\"While this update mostly focused changes on exotic potions and scrolls, there are _two new spells, and one totally redesigned spell:_\\n\\n\" +\n\t\t\t\t\"_Summon Elemental_ requires fresh embers and an arcane catalyst. It can be used to summon a friendly elemental to fight for you, and can even be powered up with other items!\\n\\n\" +\n\t\t\t\t\"_Telekinetic Grab_ requires some liquid metal and an arcane catalyst. It can be used to grab items remotely, even thrown items that are stuck to an enemy!\\n\\n\" +\n\t\t\t\t\"_Alchemize_ has been totally redesigned. It now only requires an arcane catalyst, and is used to convert items into gold or alchemical energy on the go. I'm really hoping this spell helps with inventory management.\\n\\n\" +\n\t\t\t\t\"Because of the redesign to alchemize, the merchant's beacon and magical porter are made mostly redundant and have been removed from the game. Shops now sell a few uses of alchemize instead.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"more new music!\",\n\t\t\t\t\"_The game now has a music track for each of the five dungeon regions!_\\n\\n\" +\n\t\t\t\t\"Just like the remastered tracks from v1.0.0, they are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"Each of these tracks use a similar variable looping method to the sewers track, to try and reduce repetitiveness.\\n\\n\" +\n\t\t\t\t\"There have also been some small tweaks made to the existing sewers and title theme tracks.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_ISAZ), \"Exotic Reworks\",\n\t\t\t\t\"Several exotic potions and scrolls have been redesigned to be more powerful and worth using:\\n\\n\" +\n\t\t\t\t\"_- Potion of Holy Furor_ is now _Potion of Divine Inspiration_, which gives bonus talent points.\\n\" +\n\t\t\t\t\"_- Potion of Adrenaline Surge_ is now _Potion of Mastery_, which reduces the strength requirement of one item by 2.\\n\\n\" +\n\t\t\t\t\"_- Scroll of Petrification_ is now _Scroll of Dread_, which causes enemies to flee the dungeon entirely.\\n\" +\n\t\t\t\t\"_- Scroll of Affection_ is now _Scroll of Siren's Song_, which permanently makes an enemy into an ally.\\n\" +\n\t\t\t\t\"_- Scroll of Confusion_ is now _Scroll of Challenge_, which attracts enemies but creates an arena where you take reduced damage.\\n\" +\n\t\t\t\t\"_- Scroll of Polymorph_ is now _Scroll of Metamorphosis_, which lets you swap out a talent to one from another class.\" ));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 1\",\n\t\t\t\t\"_-_ Item drops and special room spawns are now more consistent. Getting loads of the same item is now much less likely.\\n\" +\n\t\t\t\t\"_-_ Items present on boss floors are now preserved if the hero is revived from an unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Teleport mechanics now work on boss levels\\n\" +\n\t\t\t\t\"_-_ Traps that teleport no longer work on items in chests or similar containers\\n\" +\n\t\t\t\t\"_-_ Rewards from piranha and trap rooms now always appear in chests\\n\\n\" +\n\n\t\t\t\t\"_-_ Tipped darts can now be transmuted and recycled\\n\" +\n\t\t\t\t\"_-_ Thrown weapons no longer stick to allies\\n\" +\n\t\t\t\t\"_-_ Liquid metal production from upgraded thrown weapons now caps at +3\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\") + \" 2\",\n\t\t\t\t\"_-_ Updated game icons on Android and Desktop platforms\\n\" +\n\t\t\t\t\"_-_ Tabs in rankings and hero info windows now use icons, not text\\n\" +\n\t\t\t\t\"_-_ 'potions cooked' badge and stats are now 'items crafted'\\n\\n\" +\n\n\t\t\t\t\"_-_ Newborn elementals no longer have a ranged attack\\n\\n\" +\n\n\t\t\t\t\"Various small improvements for iOS Devices:\\n\" +\n\t\t\t\t\"_-_ Game can now run at higher framerates than 60\\n\" +\n\t\t\t\t\"_-_ Ingame UI elements now move inward if notched devices are used in landscape\\n\" +\n\t\t\t\t\"_-_ There is now an option to override silent mode\\n\\n\" +\n\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\t//TODO condense to two bugfix entries\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 1\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor/rare visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Cases where pausing/resuming the game at precise moments would cancel animations or attacks\\n\" +\n\t\t\t\t\"_-_ Endure damage reduction applying after some specific other damage-reducing effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh resurrection windows disappearing in some cases\\n\" +\n\t\t\t\t\"_-_ Lucky enchantment rarely not trigger in some cases\\n\" +\n\t\t\t\t\"_-_ Artifacts spawning upgraded from golden mimics\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival cancelling corpse dust curse\\n\" +\n\t\t\t\t\"_-_ Unstable spellbook letting the player select unidentified scrolls\\n\" +\n\t\t\t\t\"_-_ Desktop version not working correctly with FreeBSD\\n\" +\n\t\t\t\t\"_-_ Liquid metal being usable on darts\\n\" +\n\t\t\t\t\"_-_ Teleportation working on immovable characters in some cases\\n\" +\n\t\t\t\t\"_-_ Various quirks with thrown weapon durability\\n\" +\n\t\t\t\t\"_-_ Rare cases where ghouls would get many extra turns when reviving\\n\" +\n\t\t\t\t\"_-_ Magical infusion not preserving curses on armor\\n\" +\n\t\t\t\t\"_-_ Vertigo and teleportation effects rarely interfering\\n\" +\n\t\t\t\t\"_-_ Layout issues in the hero info window with long buff names\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 2\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Cursed wands being usable to create arcane resin\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival rarely causing crashes or placing the player on hazards\\n\" +\n\t\t\t\t\"_-_ Some glyphs not working for armored statues or the ghost hero\\n\" +\n\t\t\t\t\"_-_ Various oddities with inferno gas logic\\n\" +\n\t\t\t\t\"_-_ Spirit bow having negative damage values in rare cases\\n\" +\n\t\t\t\t\"_-_ Artifact recharging buff working on cursed artifacts\\n\" +\n\t\t\t\t\"_-_ Scrolls of upgrade revealing whether unidentified rings/wands were cursed\\n\" +\n\t\t\t\t\"_-_ Ring of Might not updating hero health total in rare cases\\n\" +\n\t\t\t\t\"_-_ Specific cases where darts would not recognize an equipped crossbow\\n\" +\n\t\t\t\t\"_-_ Cap on regrowth wand being affect by level boosts\\n\" +\n\t\t\t\t\"_-_ Some on-hit effects not triggering on ghost or armored statues\\n\" +\n\t\t\t\t\"_-_ Rare errors when gateway traps teleported multiple things at once\\n\" +\n\t\t\t\t\"_-_ Various rare errors when multiple inputs were given in the same frame\\n\" +\n\t\t\t\t\"_-_ Fog of War errors in Tengu's arena\\n\" +\n\t\t\t\t\"_-_ Rare errors with sheep spawning items and traps\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 3\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual errors\\n\" +\n\t\t\t\t\"_-_ Gateway traps rarely teleporting immovable characters\\n\" +\n\t\t\t\t\"_-_ Monks never losing focus if attacked out of hero vision range\\n\" +\n\t\t\t\t\"_-_ Wild magic continuing to activate if the hero dies during it\\n\" +\n\t\t\t\t\"_-_ Specific cases where guidebook windows could be stacked\\n\" +\n\t\t\t\t\"_-_ Remove curse stating nothing was cleansed when it removed the degrade debuff\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_AMBER), \"Exotic Buffs\",\n\t\t\t\t\"Some exotic potions and scrolls have received more minor buffs, and not total redesigns:\\n\\n\" +\n\t\t\t\t\"_- Potions of Storm Clouds, Shrouding Fog, and Corrosion_ initial gas AOE up to 3x3 from 1x1\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ now only blocks enemy vision\\n\" +\n\t\t\t\t\"_- Potion of Corrosion_ starting damage increased by 1\\n\" +\n\t\t\t\t\"_- Potion of Magical Sight_ vision range up to 12 from 8\\n\" +\n\t\t\t\t\"_- Potion of Cleansing_ now applies debuff immunity for 5 turns\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ now increases detection range to 8 (from 2), but lasts 250 turns (from 600)\\n\" +\n\t\t\t\t\"_- Scroll of Prismatic Image_ hp +2 and damage +20%\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_TOOLKIT), \"Artifact Buffs\",\n\t\t\t\t\"The _Alchemist's Toolkit_ has received some minor changes to go along with the energy system adjustments:\\n\" +\n\t\t\t\t\"_-_ Toolkit indirectly buffed by energy now being more valuable\\n\" +\n\t\t\t\t\"_-_ Energy required to level up toolkit halved, kit can now be levelled anywhere\\n\" +\n\t\t\t\t\"_-_ Toolkit warmup is now based on time, and gets faster as it levels up\\n\" +\n\t\t\t\t\"_-_ Toolkit can now be used when enemies are near\\n\\n\" +\n\t\t\t\t\"The _Horn of Plenty_ is getting a change to increase its flexibility, and to make it better synergize with food eating talents:\\n\" +\n\t\t\t\t\"_-_ The horn now has a 'snack' option that always consumes 1 charge\\n\" +\n\t\t\t\t\"_-_ To counterbalance this, the total number of charges and charge speed have been halved, but each charge is worth twice as much as before.\\n\\n\" +\n\t\t\t\t\"I'm giving a mild buff to the _Dried Rose_ to fix an odd inconsistency where it was better to kill the ghost off than let them heal:\\n\" +\n\t\t\t\t\"_-_ Ghost HP regen doubled, to match the roses recharge speed (500 turns to full HP)\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.WARRIOR, 0, 90, 12, 15), HeroSubClass.BERSERKER.title(),\n\t\t\t\t\"The berserker is getting a small QOL buff to make it easier to hold onto rage in combat:\\n\\n\" +\n\t\t\t\t\"_-_ Rage now starts expiring after not taking damage for 2 turns, instead of immediately.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Talent and Ability Buffs\",\n\t\t\t\t\"Talent and ability balance is becoming more stable now, but I've still got a few buffs to hand out, some are quite significant:\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ Charge cost reduced to 25, from 35.\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ Duration up to 100 turns, from 60.\\n\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now lasts for 2 wand zaps, up from 1.\\n\" +\n\t\t\t\t\"_- Light Cloak_ now grants 16.6% charge speed per rank, up from 13.3%\\n\" +\n\t\t\t\t\"_- Shrug it Off_ now caps damage taken at 20% at +4, up from 25%.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The reduction to the Mage's starting melee damage in v1.0.0 had a good effect on his early game winrate, but it's still notably higher than other heroes. So, I'm nudging his early melee power down one more time:\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-6 from 1-7.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), HeroSubClass.ASSASSIN.title(),\n\t\t\t\t\"The Assassin is doing very well right now, especially after the power boost he can receive from smoke bomb or death mark. I'm scaling back his core power a little to try and reign him in a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Preparation bonus damage at power level 1/2/3/4 reduced to 10/20/35/50%, from 15/30/45/60%\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.DOUBLE_JUMP.icon()), Talent.DOUBLE_JUMP.title(),\n\t\t\t\t\"Just one talent/ability nerf this time! I'm scaling double jump back a bit to put it more in line with the other heroic leap talents:\\n\\n\" +\n\t\t\t\t\"_-_ Charge cost reduction now caps at 50%, down from 60%\\n\" +\n\t\t\t\t\"_-_ The warrior must now jump again within 3 turns, down from 5\\n\\n\" +\n\t\t\t\t\"I'll likely making more balance tweaks (including nerfs) to abilities and talents in the future, but at the moment double jump is the only major standout.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v1_2_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v1.2\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released March 23rd, 2022\\n\" +\n\t\t\t\t\"_-_ 103 days after Shattered v1.1.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY_LAND), \"Desktop Enhancements and Steam Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon has received a bunch of new features in preparation for its release on Steam!_\\n\\n\" +\n\t\t\t\t\"These features include:\\n\" +\n\t\t\t\t\"_-_ A new main UI for larger displays, which places the inventory in the main game screen\\n\" +\n\t\t\t\t\"_-_ Full controller support, including button bindings and an analog stick cursor.\\n\" +\n\t\t\t\t\"_-_ Better keyboard controls, including combining keys to move diagonally.\\n\" +\n\t\t\t\t\"_-_ Better mouse support, including hover tooltips and right-click menus.\\n\" +\n\t\t\t\t\"_-_ Two additional quickslots on the new UI, and on mobile UI if there is enough space.\\n\" +\n\t\t\t\t\"_-_ Integration with Steamworks for achievements and cloud sync.\\n\\n\" +\n\t\t\t\t\"Users on mobile devices will be able to benefit from most of these features as well! (some feature require a large enough display)\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TILES_SEWERS, 48, 80, 16, 16 ), \"Special Rooms Additions!\",\n\t\t\t\t\"_Six new special rooms have been added!_\\n\\n\" +\n\t\t\t\t\"Two of these rooms (and one existing room) use new crystal doors, which let you see through them before you find a crystal key to unlock them.\\n\\n\" +\n\t\t\t\t\"Three of these rooms include new terrain hazards, which will require the right tools to get past.\\n\\n\" +\n\t\t\t\t\"The final new room is the sacrificial room from the original Pixel Dungeon! It returns with a few tweaks to its mechanics and loot (sorry, no scroll of wipe out).\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_ARMBAND), \"Armband Rework!\",\n\t\t\t\t\"_The Master Thieves' Armband has been reworked!_\\n\\n\" +\n\t\t\t\t\"This rework focuses on giving the armband usefulness outside of shops. You can now use it to steal from enemies as well as shopkeepers, and it gains charge as you gain exp, instead of when you collect gold.\"));\n\n\t\tchanges.addButton( new ChangeButton(BadgeBanner.image(Badges.Badge.MONSTERS_SLAIN_5.image), \"New Badges!\",\n\t\t\t\t\"_Badges now have names, and 8 new badges have been added!_\\n\\n\" +\n\t\t\t\t\"These new badges are all part of the existing series badges (e.g. defeat X enemies), and primarily exist around the gold badge level.\\n\\n\" +\n\t\t\t\t\"The 'games played' badges have also been adjusted to unlock either on a large number of games played, or a smaller number of games won.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"New Boss Music!\",\n\t\t\t\t\"_Each of the game's five bosses now have their own music track!_\\n\\n\" +\n\t\t\t\t\"Just as before, these tracks are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"All of the boss tracks take cues from the region tracks, but add enough to be more than simple remixes.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Improved the blinking behaviour of the journal button, to make it easier to notice on desktop displays.\\n\" +\n\t\t\t\t\"_-_ Improved the depth display to include icons for level feelings\\n\" +\n\t\t\t\t\"_-_ Added an icon next to depth display showing enabled challenges\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted the secrets level feeling to be less extreme in what rooms it can hide\\n\\n\" +\n\t\t\t\t\"_-_ Improved the resilience of the game's save system\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 1\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare cases of save corruption on Android\\n\" +\n\t\t\t\t\"_-_ Various minor textual and visual errors\\n\" +\n\t\t\t\t\"_-_ Unidentified wands being usable in alchemy\\n\" +\n\t\t\t\t\"_-_ Various rare cases where the hero could perform two actions at once\\n\" +\n\t\t\t\t\"_-_ Pharmacophobia challenge incorrectly blocking some alchemy recipes\\n\" +\n\t\t\t\t\"_-_ Various rare cases where giant enemies could enter enclosed spaces\\n\" +\n\t\t\t\t\"_-_ Wild energy spell not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ Rare cases where the Freerunner could gain momentum while freerunninng\\n\" +\n\t\t\t\t\"_-_ Gladiator's parry move not cancelling invisibility or time freeze\\n\" +\n\t\t\t\t\"_-_ On-hit effects still triggering when the great crab blocks\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with the timekeeper's hourglass\\n\" +\n\t\t\t\t\"_-_ Various bugs with the potion of dragon's breath\\n\" +\n\t\t\t\t\"_-_ Assassinate killing enemies right after they were corrupted by a corrupting weapon\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\") + \" 2\",\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Layout issues with the loot indicator\\n\" +\n\t\t\t\t\"_-_ Artifact recharging not charging the horn of plenty in some cases when it should\\n\" +\n\t\t\t\t\"_-_ Some items rarely not being consumed when they should be\\n\" +\n\t\t\t\t\"_-_ Player being able to self-target with assassinate ability\\n\" +\n\t\t\t\t\"_-_ Arcane catalysts not being able to be turned into energy\\n\" +\n\t\t\t\t\"_-_ Fog of War not properly updating when warp beacon is used\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.FIRE_BOMB), \"Recipe Cost Reductions\",\n\t\t\t\t\"I've made a bunch of cost adjustments to alchemy recipes to help counteract energy becoming more expensive after v1.1.0:\\n\\n\" +\n\t\t\t\t\"_- Bomb Recipe_ energy costs down across the board\\n\\n\" +\n\t\t\t\t\"_- Infernal, Blizzard, and Caustic Brew_ energy costs down by 1\\n\\n\" +\n\t\t\t\t\"_- Telekinetic Grab_ energy cost down to 2 from 4, liquid metal cost reduced to 10 from 15\\n\" +\n\t\t\t\t\"_- Phase Shift_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Wild Energy_ energy cost down to 4 from 6\\n\" +\n\t\t\t\t\"_- Beacon of Returning_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Summon Elemental_ energy cost down to 6 from 8\\n\" +\n\t\t\t\t\"_- Alchemize_ energy cost down to 2 from 3\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.AQUA_BLAST), \"Alchemy Buffs\",\n\t\t\t\t\"Several recipes have also been buffed, in addition to the cost reductions:\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ duration up to 400 from 250\\n\" +\n\t\t\t\t\"_- Scroll of Dread_ now grants 1/2 exp for defeated enemies\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ gas quantity increased bt 50%\\n\\n\" +\n\t\t\t\t\"_-_ Items and effects which create water now douse fire\\n\\n\" +\n\t\t\t\t\"_- Caustic Brew_ damage per turn increased by 1\\n\" +\n\t\t\t\t\"_- Infernal and Blizzard Brew_ now start their gas in a 3x3 AOE\\n\" +\n\t\t\t\t\"_- Shocking Brew_ AOE up to 7x7 from 5x5\\n\\n\" +\n\t\t\t\t\"_- Phase Shift_ now stuns whatever it teleports\\n\" +\n\t\t\t\t\"_- Summon Elemental_ quantity up to 5 from 3, elemental's stats now scale with depth, and elementals can be re-summoned\\n\" +\n\t\t\t\t\"_- Aqua Blast_ now acts like a geyser trap, quantity down to 8 from 12\\n\" +\n\t\t\t\t\"_- Reclaim Trap_ quantity up to 4 from 3\\n\" +\n\t\t\t\t\"_- Curse Infusion_ now boosts highly levelled gear by more than +1, quantity up to 4 from 3.\\n\" +\n\t\t\t\t\"_- Recycle_ quantity up to 12 from 8, cost up to 8 from 6\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ROT_DART), \"Dart Buffs\",\n\t\t\t\t\"While they don't tie into v1.1.0's energy changes in particular, I am also handing out several buffs to tipped darts:\\n\\n\" +\n\t\t\t\t\"_- Rot Dart_ uses increased to 5 from 1\\n\" +\n\t\t\t\t\"_- Adrenaline Dart_ duration up to 30 from 10\\n\" +\n\t\t\t\t\"_- Shocking Dart_ damage now slightly scales with depth\\n\" +\n\t\t\t\t\"_- Poison Dart_ damage scaling increased\\n\" +\n\t\t\t\t\"_- Sleep Dart_ is now _Cleansing Dart_, makes allies immune to debuffs for several turns\\n\" +\n\t\t\t\t\"_- Holy Dart_ duration up to 100 from 30\\n\" +\n\t\t\t\t\"_- Displacing Dart_ now much more consistently teleports enemies away\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.LIGHT_CLOAK.icon()), \"Talent Buffs\",\n\t\t\t\t\"I'm handing out a few buffs to help better balance the Mage's T2 talents and the Rogue's class-based T3 talents. I'm also making one bugfix that counts as a buff:\\n\\n\" +\n\t\t\t\t\"_- Energizing Upgrade_ charge boost up to 4/6, from 3/5\\n\" +\n\t\t\t\t\"_- Wand Preservation_ chance at +1 reduced to 50%, but now grants 1 arcane resin if it fails to preserve\\n\" +\n\t\t\t\t\"_- Wand Preservation_ max uses up to 5 from 3\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now grants +3 on the next 1/2/3 wand zaps\\n\\n\" +\n\t\t\t\t\"_- Light Cloak_ charging rate boosted to 25%/50%/75%, from 17%/33%/50%\\n\\n\" +\n\t\t\t\t\"_- Shared Enchantments_ bugfixed to give the bonus damage stated in the description, instead of slightly less.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.MAGIC_INFUSE), \"Alchemy Nerfs\",\n\t\t\t\t\"v1.2.0 is mostly about alchemy buffs, but a few alchemy items have had their power reduced as well:\\n\\n\" +\n\t\t\t\t\"_- Magical Infusion_ energy cost up to 4 from 3\\n\" +\n\t\t\t\t\"_- Holy Bomb_ bonus damage reduced to 50% from 67%\\n\" +\n\t\t\t\t\"_- Goo Blob and Metal Shard_ energy value reduced to 3\\n\" +\n\t\t\t\t\"_- Alchemize_ quantity in shops reduced by 1\\n\\n\" +\n\t\t\t\t\"While not a direct alchemy item nerf, I've also made some of the final bosses' fists less susceptible to certain mechanics:\\n\" +\n\t\t\t\t\"_- Soiled Fist_ is now immune to burning, but the grass it generates still burns\\n\" +\n\t\t\t\t\"_- Burning Fist_ is now immune to freezing, but it can still be chilled\\n\" +\n\t\t\t\t\"_- Rotting and Rusted Fists_ now take less damage from retribution, grim, and psionic blast\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Environment.TERRAIN_FEATURES, 112, 112, 16, 16), new Dreamfoil().name(),\n\t\t\t\t\"Dreamfoil has always had great utility as a debuff-cleanser, and with the recent addition of stones of deep sleep its enemy sleeping functionality was feeling a bit unnecessary:\\n\\n\" +\n\t\t\t\t\"_- Dreamfoil_ no longer puts enemies into magical sleep\\n\\n\" +\n\t\t\t\t\"Sleep darts (made from dreamfoil) have also been changed into cleansing darts to go along with this change. These darts will make an ally temporarily immune to harmful effects.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.SHIELD_BATTERY.icon()), \"Talent Nerfs\",\n\t\t\t\t\"I'm making a few talent nerfs to better balance the Mage's T2 talents, and to pull in the power of the Berserker a little:\\n\\n\" +\n\t\t\t\t\"_- Shield Battery_ shielding per charge down to 4%/6%, from 5%/7.5%\\n\\n\" +\n\t\t\t\t\"_- Endless Rage_ max rage boost reduced to 10%/20%/30% from 15%/30%/45%\\n\" +\n\t\t\t\t\"_- Enraged Catalyst_ proc rate boost reduced to 15%/30%/45% from 17%/33%/50%\"));\n\n\t}",
          "uniqueId": "47d9f3219d5eb0f3f7482b78b9e05334f3de0040_77_274_81_238_240_417"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "1f45564487eb997d28efabeb3bbca74685e23e19",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/1f45564487eb997d28efabeb3bbca74685e23e19",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean surprisedBy( Char enemy ){\n\t\treturn enemy == Dungeon.hero\n\t\t\t\t&& (enemy.invisible > 0 || !enemySeen)\n\t\t\t\t&& ((Hero)enemy).canSurpriseAttack();\n\t}",
          "sourceCodeAfterRefactoring": "public final boolean surprisedBy( Char enemy ){\n\t\treturn surprisedBy( enemy, true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean surprisedBy( Char enemy, boolean attacking ){\n\t\treturn enemy == Dungeon.hero\n\t\t\t\t&& (enemy.invisible > 0 || !enemySeen)\n\t\t\t\t&& (!attacking || ((Hero)enemy).canSurpriseAttack());\n\t}",
          "uniqueId": "1f45564487eb997d28efabeb3bbca74685e23e19_634_638_638_642_634_636"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void rollToDropLoot(){\n\t\tif (Dungeon.hero.lvl > maxLvl + 2) return;\n\t\t\n\t\tfloat lootChance = this.lootChance;\n\t\tlootChance *= RingOfWealth.dropChanceMultiplier( Dungeon.hero );\n\t\t\n\t\tif (Random.Float() < lootChance) {\n\t\t\tItem loot = createLoot();\n\t\t\tif (loot != null) {\n\t\t\t\tDungeon.level.drop(loot, pos).sprite.drop();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ring of wealth logic\n\t\tif (Ring.getBuffedBonus(Dungeon.hero, RingOfWealth.Wealth.class) > 0) {\n\t\t\tint rolls = 1;\n\t\t\tif (properties.contains(Property.BOSS)) rolls = 15;\n\t\t\telse if (properties.contains(Property.MINIBOSS)) rolls = 5;\n\t\t\tArrayList<Item> bonus = RingOfWealth.tryForBonusDrop(Dungeon.hero, rolls);\n\t\t\tif (bonus != null && !bonus.isEmpty()) {\n\t\t\t\tfor (Item b : bonus) Dungeon.level.drop(b, pos).sprite.drop();\n\t\t\t\tRingOfWealth.showFlareForBonusDrop(sprite);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//lucky enchant logic\n\t\tif (buff(Lucky.LuckProc.class) != null){\n\t\t\tDungeon.level.drop(Lucky.genLoot(), pos).sprite.drop();\n\t\t\tLucky.showFlare(sprite);\n\t\t}\n\n\t\t//soul eater talent\n\t\tif (buff(SoulMark.class) != null &&\n\t\t\t\tRandom.Int(10) < Dungeon.hero.pointsInTalent(Talent.SOUL_EATER)){\n\t\t\tTalent.onFoodEaten(Dungeon.hero, 0, null);\n\t\t}\n\n\t\t//bounty hunter talent\n\t\tif (Dungeon.hero.buff(Talent.BountyHunterTracker.class) != null) {\n\t\t\tPreparation prep = Dungeon.hero.buff(Preparation.class);\n\t\t\tif (prep != null && Random.Float() < 0.25f * prep.attackLevel()) {\n\t\t\t\tDungeon.level.drop(new Gold(15 * Dungeon.hero.pointsInTalent(Talent.BOUNTY_HUNTER)), pos).sprite.drop();\n\t\t\t}\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "public void rollToDropLoot(){\n\t\tif (Dungeon.hero.lvl > maxLvl + 2) return;\n\n\t\tMasterThievesArmband.StolenTracker stolen = buff(MasterThievesArmband.StolenTracker.class);\n\t\tif (stolen == null || !stolen.itemWasStolen()) {\n\t\t\tif (Random.Float() < lootChance()) {\n\t\t\t\tItem loot = createLoot();\n\t\t\t\tif (loot != null) {\n\t\t\t\t\tDungeon.level.drop(loot, pos).sprite.drop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ring of wealth logic\n\t\tif (Ring.getBuffedBonus(Dungeon.hero, RingOfWealth.Wealth.class) > 0) {\n\t\t\tint rolls = 1;\n\t\t\tif (properties.contains(Property.BOSS)) rolls = 15;\n\t\t\telse if (properties.contains(Property.MINIBOSS)) rolls = 5;\n\t\t\tArrayList<Item> bonus = RingOfWealth.tryForBonusDrop(Dungeon.hero, rolls);\n\t\t\tif (bonus != null && !bonus.isEmpty()) {\n\t\t\t\tfor (Item b : bonus) Dungeon.level.drop(b, pos).sprite.drop();\n\t\t\t\tRingOfWealth.showFlareForBonusDrop(sprite);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//lucky enchant logic\n\t\tif (buff(Lucky.LuckProc.class) != null){\n\t\t\tDungeon.level.drop(Lucky.genLoot(), pos).sprite.drop();\n\t\t\tLucky.showFlare(sprite);\n\t\t}\n\n\t\t//soul eater talent\n\t\tif (buff(SoulMark.class) != null &&\n\t\t\t\tRandom.Int(10) < Dungeon.hero.pointsInTalent(Talent.SOUL_EATER)){\n\t\t\tTalent.onFoodEaten(Dungeon.hero, 0, null);\n\t\t}\n\n\t\t//bounty hunter talent\n\t\tif (Dungeon.hero.buff(Talent.BountyHunterTracker.class) != null) {\n\t\t\tPreparation prep = Dungeon.hero.buff(Preparation.class);\n\t\t\tif (prep != null && Random.Float() < 0.25f * prep.attackLevel()) {\n\t\t\t\tDungeon.level.drop(new Gold(15 * Dungeon.hero.pointsInTalent(Talent.BOUNTY_HUNTER)), pos).sprite.drop();\n\t\t\t}\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic float lootChance(){\n\t\tfloat lootChance = this.lootChance;\n\n\t\tlootChance *= RingOfWealth.dropChanceMultiplier( Dungeon.hero );\n\n\t\treturn lootChance;\n\t}",
          "uniqueId": "1f45564487eb997d28efabeb3bbca74685e23e19_729_774_733_739_741_786"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "946f17a09a18d43a169e5694197f46e685ad7859",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/946f17a09a18d43a169e5694197f46e685ad7859",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void cleanse(Char ch){\n\t\tfor (Buff b : ch.buffs()){\n\t\t\tif (b.type == Buff.buffType.NEGATIVE\n\t\t\t\t\t&& !(b instanceof AllyBuff)\n\t\t\t\t\t&& !(b instanceof LostInventory)){\n\t\t\t\tb.detach();\n\t\t\t}\n\t\t\tif (b instanceof Hunger){\n\t\t\t\t((Hunger) b).satisfy(Hunger.STARVING);\n\t\t\t}\n\t\t}\n\t\tBuff.affect(ch, Cleanse.class, Cleanse.DURATION);\n\t}",
          "sourceCodeAfterRefactoring": "public static void cleanse(Char ch){\n\t\tcleanse(ch, Cleanse.DURATION);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void cleanse(Char ch, float duration){\n\t\tfor (Buff b : ch.buffs()){\n\t\t\tif (b.type == Buff.buffType.NEGATIVE\n\t\t\t\t\t&& !(b instanceof AllyBuff)\n\t\t\t\t\t&& !(b instanceof LostInventory)){\n\t\t\t\tb.detach();\n\t\t\t}\n\t\t\tif (b instanceof Hunger){\n\t\t\t\t((Hunger) b).satisfy(Hunger.STARVING);\n\t\t\t}\n\t\t}\n\t\tBuff.affect(ch, Cleanse.class, duration);\n\t}",
          "uniqueId": "946f17a09a18d43a169e5694197f46e685ad7859_70_82_74_86_70_72"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "033d0f725cc2704f13fe889f39960046a8b68dea",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/033d0f725cc2704f13fe889f39960046a8b68dea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean interfaceBlockingHero(){\n\t\tif (scene == null) return false;\n\n\t\tfor (Gizmo g : scene.members){\n\t\t\tif (g instanceof Window) return true;\n\t\t}\n\n\t\tif (scene.inventory != null && scene.inventory.isSelecting()){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean interfaceBlockingHero(){\n\t\tif (scene == null) return false;\n\n\t\tif (showingWindow()) return true;\n\n\t\tif (scene.inventory != null && scene.inventory.isSelecting()){\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean showingWindow(){\n\t\tif (scene == null) return false;\n\n\t\tfor (Gizmo g : scene.members){\n\t\t\tif (g instanceof Window) return true;\n\t\t}\n\n\t\treturn false;\n\t}",
          "uniqueId": "033d0f725cc2704f13fe889f39960046a8b68dea_1113_1125_1113_1121_1123_1133"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "28f289e55e4f93b843e604474fa656c25548a16f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/28f289e55e4f93b843e604474fa656c25548a16f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean moveFromAction(GameAction action){\n\t\tif (Dungeon.hero == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tint cell = Dungeon.hero.pos;\n\n\t\tif (action == SPDAction.N)  cell += -Dungeon.level.width();\n\t\tif (action == SPDAction.NE) cell += +1-Dungeon.level.width();\n\t\tif (action == SPDAction.E)  cell += +1;\n\t\tif (action == SPDAction.SE) cell += +1+Dungeon.level.width();\n\t\tif (action == SPDAction.S)  cell += +Dungeon.level.width();\n\t\tif (action == SPDAction.SW) cell += -1+Dungeon.level.width();\n\t\tif (action == SPDAction.W)  cell += -1;\n\t\tif (action == SPDAction.NW) cell += -1-Dungeon.level.width();\n\t\t\n\t\tif (cell != Dungeon.hero.pos){\n\t\t\t//each step when keyboard moving takes 0.15s, 0.125s, 0.1s, 0.1s, ...\n\t\t\t// this is to make it easier to move 1 or 2 steps without overshooting\n\t\t\tCharSprite.setMoveInterval( CharSprite.DEFAULT_MOVE_INTERVAL +\n\t\t\t                            Math.max(0, 0.05f - heldTurns *0.025f));\n\t\t\tselect(cell, PointerEvent.LEFT);\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "private boolean moveFromActions(GameAction... actions){\n\t\tif (Dungeon.hero == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tint cell = Dungeon.hero.pos;\n\t\tfor (GameAction action : actions) {\n\t\t\tcell += directionFromAction(action);\n\t\t}\n\t\t\n\t\tif (cell != Dungeon.hero.pos){\n\t\t\tselect(cell, PointerEvent.LEFT);\n\t\t\treturn true;\n\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int directionFromAction(GameAction action){\n\t\tif (action == SPDAction.N)  return -Dungeon.level.width();\n\t\tif (action == SPDAction.NE) return +1-Dungeon.level.width();\n\t\tif (action == SPDAction.E)  return +1;\n\t\tif (action == SPDAction.SE) return +1+Dungeon.level.width();\n\t\tif (action == SPDAction.S)  return +Dungeon.level.width();\n\t\tif (action == SPDAction.SW) return -1+Dungeon.level.width();\n\t\tif (action == SPDAction.W)  return -1;\n\t\tif (action == SPDAction.NW) return -1-Dungeon.level.width();\n\t\telse                        return 0;\n\t}",
          "uniqueId": "28f289e55e4f93b843e604474fa656c25548a16f_274_302_358_368_338_356"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f10b112161e2ef92aa77fcd144cefa3b09198a2a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f10b112161e2ef92aa77fcd144cefa3b09198a2a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null\n\t\t\t\t|| cell < 0\n\t\t\t\t|| cell > Dungeon.level.length()\n\t\t\t\t|| (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<String> names = new ArrayList<>();\n\t\tfinal ArrayList<Object> objects = new ArrayList<>();\n\n\t\tif (cell == Dungeon.hero.pos) {\n\t\t\tobjects.add(Dungeon.hero);\n\t\t\tnames.add(Dungeon.hero.className().toUpperCase(Locale.ENGLISH));\n\t\t} else {\n\t\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\t\tMob mob = (Mob) Actor.findChar(cell);\n\t\t\t\tif (mob != null) {\n\t\t\t\t\tobjects.add(mob);\n\t\t\t\t\tnames.add(Messages.titleCase( mob.name() ));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get(cell);\n\t\tif (heap != null && heap.seen) {\n\t\t\tobjects.add(heap);\n\t\t\tnames.add(Messages.titleCase( heap.toString() ));\n\t\t}\n\n\t\tPlant plant = Dungeon.level.plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tobjects.add(plant);\n\t\t\tnames.add(Messages.titleCase( plant.plantName ));\n\t\t}\n\n\t\tTrap trap = Dungeon.level.traps.get( cell );\n\t\tif (trap != null && trap.visible) {\n\t\t\tobjects.add(trap);\n\t\t\tnames.add(Messages.titleCase( trap.name() ));\n\t\t}\n\n\t\tif (objects.isEmpty()) {\n\t\t\tGameScene.show(new WndInfoCell(cell));\n\t\t} else if (objects.size() == 1){\n\t\t\texamineObject(objects.get(0));\n\t\t} else {\n\t\t\tGameScene.show(new WndOptions(Icons.get(Icons.INFO),\n\t\t\t\t\tMessages.get(GameScene.class, \"choose_examine\"),\n\t\t\t\t\tMessages.get(GameScene.class, \"multiple_examine\"),\n\t\t\t\t\tnames.toArray(new String[names.size()])){\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\texamineObject(objects.get(index));\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null\n\t\t\t\t|| cell < 0\n\t\t\t\t|| cell > Dungeon.level.length()\n\t\t\t\t|| (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<Object> objects = getObjectsAtCell(cell);\n\n\t\tif (objects.isEmpty()) {\n\t\t\tGameScene.show(new WndInfoCell(cell));\n\t\t} else if (objects.size() == 1){\n\t\t\texamineObject(objects.get(0));\n\t\t} else {\n\t\t\tString[] names = getObjectNames(objects).toArray(new String[0]);\n\n\t\t\tGameScene.show(new WndOptions(Icons.get(Icons.INFO),\n\t\t\t\t\tMessages.get(GameScene.class, \"choose_examine\"),\n\t\t\t\t\tMessages.get(GameScene.class, \"multiple_examine\"),\n\t\t\t\t\tnames){\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\texamineObject(objects.get(index));\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static ArrayList<Object> getObjectsAtCell( int cell ){\n\t\tArrayList<Object> objects = new ArrayList<>();\n\n\t\tif (cell == Dungeon.hero.pos) {\n\t\t\tobjects.add(Dungeon.hero);\n\n\t\t} else if (Dungeon.level.heroFOV[cell]) {\n\t\t\tMob mob = (Mob) Actor.findChar(cell);\n\t\t\tif (mob != null) objects.add(mob);\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get(cell);\n\t\tif (heap != null && heap.seen) objects.add(heap);\n\n\t\tPlant plant = Dungeon.level.plants.get( cell );\n\t\tif (plant != null) objects.add(plant);\n\n\t\tTrap trap = Dungeon.level.traps.get( cell );\n\t\tif (trap != null && trap.visible) objects.add(trap);\n\n\t\treturn objects;\n\t}",
          "uniqueId": "f10b112161e2ef92aa77fcd144cefa3b09198a2a_1267_1325_1302_1323_1272_1300"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null\n\t\t\t\t|| cell < 0\n\t\t\t\t|| cell > Dungeon.level.length()\n\t\t\t\t|| (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<String> names = new ArrayList<>();\n\t\tfinal ArrayList<Object> objects = new ArrayList<>();\n\n\t\tif (cell == Dungeon.hero.pos) {\n\t\t\tobjects.add(Dungeon.hero);\n\t\t\tnames.add(Dungeon.hero.className().toUpperCase(Locale.ENGLISH));\n\t\t} else {\n\t\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\t\tMob mob = (Mob) Actor.findChar(cell);\n\t\t\t\tif (mob != null) {\n\t\t\t\t\tobjects.add(mob);\n\t\t\t\t\tnames.add(Messages.titleCase( mob.name() ));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get(cell);\n\t\tif (heap != null && heap.seen) {\n\t\t\tobjects.add(heap);\n\t\t\tnames.add(Messages.titleCase( heap.toString() ));\n\t\t}\n\n\t\tPlant plant = Dungeon.level.plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tobjects.add(plant);\n\t\t\tnames.add(Messages.titleCase( plant.plantName ));\n\t\t}\n\n\t\tTrap trap = Dungeon.level.traps.get( cell );\n\t\tif (trap != null && trap.visible) {\n\t\t\tobjects.add(trap);\n\t\t\tnames.add(Messages.titleCase( trap.name() ));\n\t\t}\n\n\t\tif (objects.isEmpty()) {\n\t\t\tGameScene.show(new WndInfoCell(cell));\n\t\t} else if (objects.size() == 1){\n\t\t\texamineObject(objects.get(0));\n\t\t} else {\n\t\t\tGameScene.show(new WndOptions(Icons.get(Icons.INFO),\n\t\t\t\t\tMessages.get(GameScene.class, \"choose_examine\"),\n\t\t\t\t\tMessages.get(GameScene.class, \"multiple_examine\"),\n\t\t\t\t\tnames.toArray(new String[names.size()])){\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\texamineObject(objects.get(index));\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null\n\t\t\t\t|| cell < 0\n\t\t\t\t|| cell > Dungeon.level.length()\n\t\t\t\t|| (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<Object> objects = getObjectsAtCell(cell);\n\n\t\tif (objects.isEmpty()) {\n\t\t\tGameScene.show(new WndInfoCell(cell));\n\t\t} else if (objects.size() == 1){\n\t\t\texamineObject(objects.get(0));\n\t\t} else {\n\t\t\tString[] names = getObjectNames(objects).toArray(new String[0]);\n\n\t\t\tGameScene.show(new WndOptions(Icons.get(Icons.INFO),\n\t\t\t\t\tMessages.get(GameScene.class, \"choose_examine\"),\n\t\t\t\t\tMessages.get(GameScene.class, \"multiple_examine\"),\n\t\t\t\t\tnames){\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\texamineObject(objects.get(index));\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static ArrayList<String> getObjectNames( ArrayList<Object> objects ){\n\t\tArrayList<String> names = new ArrayList<>();\n\t\tfor (Object obj : objects){\n\t\t\tif (obj instanceof Hero)        names.add(((Hero) obj).className().toUpperCase(Locale.ENGLISH));\n\t\t\telse if (obj instanceof Mob)    names.add(Messages.titleCase( ((Mob)obj).name() ));\n\t\t\telse if (obj instanceof Heap)   names.add(Messages.titleCase( ((Heap)obj).toString() ));\n\t\t\telse if (obj instanceof Plant)  names.add(Messages.titleCase( ((Plant) obj).plantName ));\n\t\t\telse if (obj instanceof Trap)   names.add(Messages.titleCase( ((Trap) obj).name() ));\n\t\t}\n\t\treturn names;\n\t}",
          "uniqueId": "f10b112161e2ef92aa77fcd144cefa3b09198a2a_1267_1325_1325_1335_1272_1300"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndInfoCell( int cell ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tint tile = Dungeon.level.map[cell];\n\t\tif (Dungeon.level.water[cell]) {\n\t\t\ttile = Terrain.WATER;\n\t\t} else if (Dungeon.level.pit[cell]) {\n\t\t\ttile = Terrain.CHASM;\n\t\t}\n\n\t\tCustomTilemap customTile = null;\n\t\tImage customImage = null;\n\t\tint x = cell % Dungeon.level.width();\n\t\tint y = cell / Dungeon.level.width();\n\t\tfor (CustomTilemap i : Dungeon.level.customTiles){\n\t\t\tif ((x >= i.tileX && x < i.tileX+i.tileW) &&\n\t\t\t\t\t(y >= i.tileY && y < i.tileY+i.tileH)){\n\t\t\t\tif ((customImage = i.image(x - i.tileX, y - i.tileY)) != null) {\n\t\t\t\t\tx -= i.tileX;\n\t\t\t\t\ty -= i.tileY;\n\t\t\t\t\tcustomTile = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tString desc = \"\";\n\n\t\tIconTitle titlebar = new IconTitle();\n\t\tif (customTile != null){\n\t\t\ttitlebar.icon(customImage);\n\n\t\t\tString customName = customTile.name(x, y);\n\t\t\tif (customName != null) {\n\t\t\t\ttitlebar.label(customName);\n\t\t\t} else {\n\t\t\t\ttitlebar.label(Dungeon.level.tileName(tile));\n\t\t\t}\n\n\t\t\tString customDesc = customTile.desc(x, y);\n\t\t\tif (customDesc != null) {\n\t\t\t\tdesc += customDesc;\n\t\t\t} else {\n\t\t\t\tdesc += Dungeon.level.tileDesc(tile);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif (tile == Terrain.WATER) {\n\t\t\t\tImage water = new Image(Dungeon.level.waterTex());\n\t\t\t\twater.frame(0, 0, DungeonTilemap.SIZE, DungeonTilemap.SIZE);\n\t\t\t\ttitlebar.icon(water);\n\t\t\t} else {\n\t\t\t\ttitlebar.icon(DungeonTerrainTilemap.tile( cell, tile ));\n\t\t\t}\n\t\t\ttitlebar.label(Dungeon.level.tileName(tile));\n\t\t\tdesc += Dungeon.level.tileDesc(tile);\n\n\t\t}\n\t\ttitlebar.setRect(0, 0, WIDTH, 0);\n\t\tadd(titlebar);\n\n\t\tRenderedTextBlock info = PixelScene.renderTextBlock(6);\n\t\tadd(info);\n\n\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\tfor (Blob blob : Dungeon.level.blobs.values()) {\n\t\t\t\tif (blob.volume > 0 && blob.cur[cell] > 0 && blob.tileDesc() != null) {\n\t\t\t\t\tif (desc.length() > 0) {\n\t\t\t\t\t\tdesc += \"\\n\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tdesc += blob.tileDesc();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tinfo.text( desc.length() == 0 ? Messages.get(this, \"nothing\") : desc );\n\t\tinfo.maxWidth(WIDTH);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + 2*GAP);\n\t\t\n\t\tresize( WIDTH, (int)info.bottom()+2 );\n\t}",
          "sourceCodeAfterRefactoring": "public WndInfoCell( int cell ) {\n\t\t\n\t\tsuper();\n\n\t\tCustomTilemap customTile = null;\n\t\tint x = cell % Dungeon.level.width();\n\t\tint y = cell / Dungeon.level.width();\n\t\tfor (CustomTilemap i : Dungeon.level.customTiles){\n\t\t\tif ((x >= i.tileX && x < i.tileX+i.tileW) &&\n\t\t\t\t\t(y >= i.tileY && y < i.tileY+i.tileH)){\n\t\t\t\tif (i.image(x - i.tileX, y - i.tileY) != null) {\n\t\t\t\t\tx -= i.tileX;\n\t\t\t\t\ty -= i.tileY;\n\t\t\t\t\tcustomTile = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tString desc = \"\";\n\n\t\tIconTitle titlebar = new IconTitle();\n\t\ttitlebar.icon(cellImage(cell));\n\t\ttitlebar.label(cellName(cell));\n\n\t\tif (customTile != null){\n\t\t\tString customDesc = customTile.desc(x, y);\n\t\t\tif (customDesc != null) {\n\t\t\t\tdesc += customDesc;\n\t\t\t} else {\n\t\t\t\tdesc += Dungeon.level.tileDesc(Dungeon.level.map[cell]);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdesc += Dungeon.level.tileDesc(Dungeon.level.map[cell]);\n\t\t}\n\t\ttitlebar.setRect(0, 0, WIDTH, 0);\n\t\tadd(titlebar);\n\n\t\tRenderedTextBlock info = PixelScene.renderTextBlock(6);\n\t\tadd(info);\n\n\t\tif (Dungeon.level.heroFOV[cell]) {\n\t\t\tfor (Blob blob : Dungeon.level.blobs.values()) {\n\t\t\t\tif (blob.volume > 0 && blob.cur[cell] > 0 && blob.tileDesc() != null) {\n\t\t\t\t\tif (desc.length() > 0) {\n\t\t\t\t\t\tdesc += \"\\n\\n\";\n\t\t\t\t\t}\n\t\t\t\t\tdesc += blob.tileDesc();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tinfo.text( desc.length() == 0 ? Messages.get(this, \"nothing\") : desc );\n\t\tinfo.maxWidth(WIDTH);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + 2*GAP);\n\t\t\n\t\tresize( WIDTH, (int)info.bottom()+2 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Image cellImage( int cell ){\n\t\tint tile = Dungeon.level.map[cell];\n\t\tif (Dungeon.level.water[cell]) {\n\t\t\ttile = Terrain.WATER;\n\t\t} else if (Dungeon.level.pit[cell]) {\n\t\t\ttile = Terrain.CHASM;\n\t\t}\n\n\t\tImage customImage = null;\n\t\tint x = cell % Dungeon.level.width();\n\t\tint y = cell / Dungeon.level.width();\n\t\tfor (CustomTilemap i : Dungeon.level.customTiles){\n\t\t\tif ((x >= i.tileX && x < i.tileX+i.tileW) &&\n\t\t\t\t\t(y >= i.tileY && y < i.tileY+i.tileH)){\n\t\t\t\tif ((customImage = i.image(x - i.tileX, y - i.tileY)) != null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (customImage != null){\n\t\t\treturn customImage;\n\t\t} else {\n\n\t\t\tif (tile == Terrain.WATER) {\n\t\t\t\tImage water = new Image(Dungeon.level.waterTex());\n\t\t\t\twater.frame(0, 0, DungeonTilemap.SIZE, DungeonTilemap.SIZE);\n\t\t\t\treturn water;\n\t\t\t} else {\n\t\t\t\treturn DungeonTerrainTilemap.tile(cell, tile);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "f10b112161e2ef92aa77fcd144cefa3b09198a2a_42_125_42_74_100_160"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "a1a5ff3de855670a218dc2c53503279301898520",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/a1a5ff3de855670a218dc2c53503279301898520",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public PointerEvent( int x, int y, int id, Type type){\n\t\tstart = current = new PointF(x, y);\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\thandled = false;\n\t}",
          "sourceCodeAfterRefactoring": "public PointerEvent( int x, int y, int id, Type type){\n\t\tthis(x, y, id, type, NONE);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic PointerEvent( int x, int y, int id, Type type, int button){\n\t\tstart = current = new PointF(x, y);\n\t\tthis.id = id;\n\t\tthis.type = type;\n\t\thandled = false;\n\t\tthis.button = button;\n\t}",
          "uniqueId": "a1a5ff3de855670a218dc2c53503279301898520_44_49_56_62_52_54"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void createChildren() {\n\t\thotArea = new PointerArea( 0, 0, 0, 0 ) {\n\t\t\t@Override\n\t\t\tprotected void onPointerDown( PointerEvent event ) {\n\t\t\t\tpressed = true;\n\t\t\t\tpressTime = 0;\n\t\t\t\tprocessed = false;\n\t\t\t\tButton.this.onPointerDown();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onPointerUp( PointerEvent event ) {\n\t\t\t\tpressed = false;\n\t\t\t\tButton.this.onPointerUp();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\tif (!processed) {\n\t\t\t\t\tButton.this.onClick();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverStart(PointerEvent event) {\n\t\t\t\tString text = hoverText();\n\t\t\t\tif (text != null){\n\t\t\t\t\tif (keyAction() != null){\n\t\t\t\t\t\tArrayList<Integer> bindings = KeyBindings.getBoundKeysForAction(keyAction());\n\t\t\t\t\t\tif (!bindings.isEmpty()){\n\t\t\t\t\t\t\ttext += \" _(\" + KeyBindings.getKeyName(bindings.get(0)) + \")_\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thoverTip = new Tooltip(text, 80);\n\t\t\t\t\tButton.this.parent.addToFront(hoverTip);\n\t\t\t\t\thoverTip.camera = camera();\n\t\t\t\t\talignTooltip(hoverTip);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverEnd(PointerEvent event) {\n\t\t\t\tkillTooltip();\n\t\t\t}\n\t\t};\n\t\tadd( hotArea );\n\t\t\n\t\tKeyEvent.addKeyListener( keyListener = new Signal.Listener<KeyEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean onSignal ( KeyEvent event ) {\n\t\t\t\tif ( active && event.pressed && KeyBindings.getActionForKey( event ) == keyAction()){\n\t\t\t\t\tonClick();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void createChildren() {\n\t\thotArea = new PointerArea( 0, 0, 0, 0 ) {\n\t\t\t@Override\n\t\t\tprotected void onPointerDown( PointerEvent event ) {\n\t\t\t\tpressed = true;\n\t\t\t\tpressTime = 0;\n\t\t\t\tprocessed = false;\n\t\t\t\tButton.this.onPointerDown();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onPointerUp( PointerEvent event ) {\n\t\t\t\tpressed = false;\n\t\t\t\tButton.this.onPointerUp();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\tif (!processed) {\n\t\t\t\t\tkillTooltip();\n\t\t\t\t\tswitch (event.button){\n\t\t\t\t\t\tcase PointerEvent.LEFT: default:\n\t\t\t\t\t\t\tButton.this.onClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PointerEvent.RIGHT:\n\t\t\t\t\t\t\tButton.this.onRightClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PointerEvent.MIDDLE:\n\t\t\t\t\t\t\tButton.this.onMiddleClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverStart(PointerEvent event) {\n\t\t\t\tString text = hoverText();\n\t\t\t\tif (text != null){\n\t\t\t\t\tif (keyAction() != null){\n\t\t\t\t\t\tArrayList<Integer> bindings = KeyBindings.getBoundKeysForAction(keyAction());\n\t\t\t\t\t\tif (!bindings.isEmpty()){\n\t\t\t\t\t\t\ttext += \" _(\" + KeyBindings.getKeyName(bindings.get(0)) + \")_\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thoverTip = new Tooltip(text, 80);\n\t\t\t\t\tButton.this.parent.addToFront(hoverTip);\n\t\t\t\t\thoverTip.camera = camera();\n\t\t\t\t\talignTooltip(hoverTip);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverEnd(PointerEvent event) {\n\t\t\t\tkillTooltip();\n\t\t\t}\n\t\t};\n\t\tadd( hotArea );\n\t\t\n\t\tKeyEvent.addKeyListener( keyListener = new Signal.Listener<KeyEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean onSignal ( KeyEvent event ) {\n\t\t\t\tif ( active && event.pressed && KeyBindings.getActionForKey( event ) == keyAction()){\n\t\t\t\t\tonClick();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void onRightClick() {\n\t\tonClick();\n\t}",
          "uniqueId": "a1a5ff3de855670a218dc2c53503279301898520_47_103_147_149_47_115"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void createChildren() {\n\t\thotArea = new PointerArea( 0, 0, 0, 0 ) {\n\t\t\t@Override\n\t\t\tprotected void onPointerDown( PointerEvent event ) {\n\t\t\t\tpressed = true;\n\t\t\t\tpressTime = 0;\n\t\t\t\tprocessed = false;\n\t\t\t\tButton.this.onPointerDown();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onPointerUp( PointerEvent event ) {\n\t\t\t\tpressed = false;\n\t\t\t\tButton.this.onPointerUp();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\tif (!processed) {\n\t\t\t\t\tButton.this.onClick();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverStart(PointerEvent event) {\n\t\t\t\tString text = hoverText();\n\t\t\t\tif (text != null){\n\t\t\t\t\tif (keyAction() != null){\n\t\t\t\t\t\tArrayList<Integer> bindings = KeyBindings.getBoundKeysForAction(keyAction());\n\t\t\t\t\t\tif (!bindings.isEmpty()){\n\t\t\t\t\t\t\ttext += \" _(\" + KeyBindings.getKeyName(bindings.get(0)) + \")_\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thoverTip = new Tooltip(text, 80);\n\t\t\t\t\tButton.this.parent.addToFront(hoverTip);\n\t\t\t\t\thoverTip.camera = camera();\n\t\t\t\t\talignTooltip(hoverTip);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverEnd(PointerEvent event) {\n\t\t\t\tkillTooltip();\n\t\t\t}\n\t\t};\n\t\tadd( hotArea );\n\t\t\n\t\tKeyEvent.addKeyListener( keyListener = new Signal.Listener<KeyEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean onSignal ( KeyEvent event ) {\n\t\t\t\tif ( active && event.pressed && KeyBindings.getActionForKey( event ) == keyAction()){\n\t\t\t\t\tonClick();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void createChildren() {\n\t\thotArea = new PointerArea( 0, 0, 0, 0 ) {\n\t\t\t@Override\n\t\t\tprotected void onPointerDown( PointerEvent event ) {\n\t\t\t\tpressed = true;\n\t\t\t\tpressTime = 0;\n\t\t\t\tprocessed = false;\n\t\t\t\tButton.this.onPointerDown();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onPointerUp( PointerEvent event ) {\n\t\t\t\tpressed = false;\n\t\t\t\tButton.this.onPointerUp();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\tif (!processed) {\n\t\t\t\t\tkillTooltip();\n\t\t\t\t\tswitch (event.button){\n\t\t\t\t\t\tcase PointerEvent.LEFT: default:\n\t\t\t\t\t\t\tButton.this.onClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PointerEvent.RIGHT:\n\t\t\t\t\t\t\tButton.this.onRightClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase PointerEvent.MIDDLE:\n\t\t\t\t\t\t\tButton.this.onMiddleClick();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverStart(PointerEvent event) {\n\t\t\t\tString text = hoverText();\n\t\t\t\tif (text != null){\n\t\t\t\t\tif (keyAction() != null){\n\t\t\t\t\t\tArrayList<Integer> bindings = KeyBindings.getBoundKeysForAction(keyAction());\n\t\t\t\t\t\tif (!bindings.isEmpty()){\n\t\t\t\t\t\t\ttext += \" _(\" + KeyBindings.getKeyName(bindings.get(0)) + \")_\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thoverTip = new Tooltip(text, 80);\n\t\t\t\t\tButton.this.parent.addToFront(hoverTip);\n\t\t\t\t\thoverTip.camera = camera();\n\t\t\t\t\talignTooltip(hoverTip);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onHoverEnd(PointerEvent event) {\n\t\t\t\tkillTooltip();\n\t\t\t}\n\t\t};\n\t\tadd( hotArea );\n\t\t\n\t\tKeyEvent.addKeyListener( keyListener = new Signal.Listener<KeyEvent>() {\n\t\t\t@Override\n\t\t\tpublic boolean onSignal ( KeyEvent event ) {\n\t\t\t\tif ( active && event.pressed && KeyBindings.getActionForKey( event ) == keyAction()){\n\t\t\t\t\tonClick();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void onMiddleClick() {\n\t\tonClick();\n\t}",
          "uniqueId": "a1a5ff3de855670a218dc2c53503279301898520_47_103_150_152_47_115"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "7f29a03078647ea503d3c866476568511aa5af84",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/7f29a03078647ea503d3c866476568511aa5af84",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v1_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"Coming Soon\", true, \"\");\n\t\tchanges.hardlight(0xCCCCCC);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Overview\",\n\t\t\t\"The next Shattered update will be v1.1.0, and will focus heavily on alchemy! I want to make alchemy more cohesive, simple, and make it better at recycling items the player doesn’t want into items that they do want.\\n\\n\" +\n\t\t\t\"Expect to hear more details about v1.1.0 in a future news post, likely sometime in September.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TILES_SEWERS, 48, 96, 16, 16 ), \"Alchemical Energy\",\n\t\t\t\t\"The most major change will be an overhaul to how alchemy energy works. Currently energy sort of sits on top of the system and acts as a limiter on how much advanced alchemy a player can perform, but otherwise does nothing. I have some plans to make energy a much more integral part of the system, and for it to tie directly into recycling consumable items. \"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ALCHEMIZE), \"Alchemy Recipes\",\n\t\t\t\t\"With alchemical energy changing, I'll naturally be looking at many of the game's higher end alchemy recipes as well! I can't promise that every single recipe will be perfect, but I hope to make some major changes in the next update that will substantially improve on many recipes. \"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"More New Music\",\n\t\t\t\t\"So far the early reception to the new music has been extremely positive! Kristjan and I are already working on some new tracks, and we might be ready to add more music in the next update. The current plan is to have a unique track for every region of the dungeon! \"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"Lastly, there will be some smaller miscellaneous changes v1.1.0 as well. I plan to continue keeping an eye on game balance and making tweaks to the new hero abilities added in the v0.9 updates. I might have enough time spare to rework an item or two as well! \"));\n\n\t\tchanges = new ChangeInfo(\"v1.0.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v1.0.3\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.2):\\n\" +\n\t\t\t\t\"_-_ Reclaim Trap spells incorrectly starting with a summoning trap reclaimed\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.1):\\n\" +\n\t\t\t\t\"_-_ Music corruption and crashes for Desktop users\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Various rare game crashes\\n\" +\n\t\t\t\t\"_-_ Some items being treated as equipped after save/load with lost inventory\\n\" +\n\t\t\t\t\"_-_ Cases where liquid metal could be applied to items at full durability\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Minor text and vfx corrections\"));\n\n\t\tchanges = new ChangeInfo(\"v1.0.2 & v1.0.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.1):\\n\" +\n\t\t\t\t\"_-_ Additional crashes caused by the new music system\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Negative STR bonuses not displaying separately\\n\" +\n\t\t\t\t\"_-_ Elemental Power talent not being buffed as intended\\n\" +\n\t\t\t\t\"_-_ Geyser traps rarely knocking the hero into other characters\\n\" +\n\t\t\t\t\"_-_ Unbreakable traps breaking in more rare cases\\n\" +\n\t\t\t\t\"_-_ Hasty Retreat talent giving fewer turns of haste/invis than intended\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ minor vfx corrections\\n\" +\n\t\t\t\t\"_-_ Time stasis sometimes not preventing harmful effects in its last turn.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Added info buttons to the scroll of enchantment window\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Graphics hitching when music was enabled\\n\" +\n\t\t\t\t\"_-_ Pressing enter not confirming single line text input\\n\" +\n\t\t\t\t\"_-_ Enemies attacking the golden lotus, despite it being neutral\\n\" +\n\t\t\t\t\"_-_ Remote Beacon talent not actually being buffed\\n\" +\n\t\t\t\t\"_-_ Ankhs still resurrecting the hero even if they lost their inventory\\n\" +\n\t\t\t\t\"_-_ Unbreakable traps breaking in rare cases\\n\" +\n\t\t\t\t\"_-_ Transmogrified enemies dropping items where they were transmogrified\\n\" +\n\t\t\t\t\"_-_ Potions/Scrolls never breaking due to frost/fire\\n\" +\n\t\t\t\t\"_-_ Sheep triggering traps before occupying space on them\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Rings not being renamable if they weren't IDed\\n\" +\n\t\t\t\t\"_-_ Disarming traps opening chests\\n\" +\n\t\t\t\t\"_-_ Rogue's body replacement ally being vulnerable to various AI-related debuffs\\n\" +\n\t\t\t\t\"_-_ Some ranged enemies becoming frozen if they were attacked from out of their vision\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released August 17th, 2021\\n\" +\n\t\t\t\t\"_-_ 71 days after Shattered v0.9.3\\n\" +\n\t\t\t\t\"_-_ 316 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"_-_ A bit more than 7 years after v0.1.0!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_That's right, we've hit v1.0.0!_ This update was previously called v0.9.4 while in beta.\\n\\n\" +\n\t\t\t\t\"Shattered will also now use the _major.minor.patch_ version naming scheme moving forward. So, the next patch will be v1.0.1, and the next update will be v1.1.0. _This change does not affect my plans for future updates!_\\n\\n\" +\n\t\t\t\t\"Expect more dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"iOS Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon is now available on the iOS App Store!_\\n\\n\" +\n\t\t\t\t\"After years of requests, Shattered is finally available on Apple devices! The iOS version of the game will release in lockstep with the Android version moving forward, with some small variance due to different update approval processes.\\n\\n\" +\n\t\t\t\t\"Note that the iOS version costs $5, but comes with some supporter features built-in. I have no plans to make any changes to the monetization of the Android version.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"new music!\",\n\t\t\t\t\"_The game's music tracks has been remastered!_\\n\\n\" +\n\t\t\t\t\"The new music is composed by Kristjan Harristo, check the about scene for more details on them. Currently we have only replaced the existing tracks, but we are working on tracks for each of the dungeons regions as well!\\n\\n\" +\n\t\t\t\t\"The new in-game track in particular is also an experiment in variable music looping. The track has an intro and a main segment and can play the main segment once or twice before looping back to the intro. This makes the track notably less repetative, and we intend to use similar techniques in other tracks.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.LIQUID_METAL), \"new alchemy recipes!\",\n\t\t\t\t\"Two new alchemy recipes have been added! They're focused on helping you recycle thrown weapons and wands that you don't want to use.\\n\\n\" +\n\t\t\t\t\"_Liquid metal_ lets you sacrifice thrown weapons to repair other ones.\\n\\n\" +\n\t\t\t\t\"_Arcane resin_ lets you sacrifice a wand to upgrade other low level wands.\\n\\n\" +\n\t\t\t\t\"A new page has been added to the alchemy guide for these recipes, and it's now possible to find later guidebook pages in the prison.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 64, 16, 16)), \"new traps\",\n\t\t\t\t\"Two new traps have been added! They are both less common traps that have a higher potential to be helpful.\\n\\n\" +\n\t\t\t\t\"_Geyser traps_ convert surrounding terrain to water and throw back anything near them.\\n\\n\" +\n\t\t\t\t\"_Gateway traps_ are a special teleportation trap which never expire, and always teleport to the same location.\\n\\n\" +\n\t\t\t\t\"All teleportation traps now also affect characters and items next to them.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.MASTERY), \"new player experience improvements\",\n\t\t\t\t\"_The adventurer's guidebook is now the Tome of Dungeon Mastery!_\\n\\n\" +\n\t\t\t\t\"This is partly as a reference to the tome of mastery, which I removed in the previous update, and partly because the game's tutorial functionality has been improved.\\n\\n\" +\n\t\t\t\t\"Guidebook pages are now a bit shorter and more plentiful, and some of them are now given to the player right at the start of the game. These automatic pages are suggested to the player to read at crucial moments. This way the guidebook does a better job of highlighting info right when it's needed.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new SpectralNecromancerSprite()), \"spectral necromancers\",\n\t\t\t\t\"A new rare variant has been added for necromancers: _Spectral Necromancers!_\\n\\n\" +\n\t\t\t\t\"These necromancers don't care for skeletons, and prefer to summon a bunch of wraiths instead! Dealing with their horde might be tricky, but you'll be rewarded with a scroll of remove curse.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ANKH), \"new ankh mechanics\",\n\t\t\t\t\"_Regular Ankhs_ have been totally redesigned, and now give the player a chance to save all of their equipment! Be careful though, you'll have to fight your way back to your lost gear.\\n\\n\" +\n\t\t\t\t\"_Blessed Ankhs_ have received comparatively minor changes. In addition to the resurrection effect, these ankhs now also give the player 3 turns of invulnerability. This should help give players a moment to heal up after being revived.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.STONE_FEAR), \"runestones\",\n\t\t\t\t\"All Scrolls now produce 2 runestones, instead of some scrolls producing 3. The stones that used to be given in higher quantities have received buffs in compensation:\\n\\n\" +\n\t\t\t\t\"_- Stone of Intuition_ can now be used a second time if the guess was correct.\\n\" +\n\t\t\t\t\"_- Stone of Flock_ AOE up to 5x5 from 3x3, sheep duration increased slightly.\\n\" +\n\t\t\t\t\"_- Stone of Deepened Sleep_ is now stone of deep sleep, instantly puts one enemy into magical sleep.\\n\" +\n\t\t\t\t\"_- Stone of Clairvoyance_ AOE up to 20x20, from 12x12.\\n\" +\n\t\t\t\t\"_- Stone of Aggression_ duration against enemies up 5, now works on bosses, and always forces attacking.\\n\" +\n\t\t\t\t\"_- Stone of Affection_ is now stone of fear, it fears one target for 20 turns.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Various tech and stability improvements.\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported Android version to 4.0, from 2.3.\\n\" +\n\t\t\t\t\"_-_ Game versions that use github for update checking can now opt-in to beta updates within the game.\\n\\n\" +\n\n\t\t\t\t\"_-_ Item renaming functionality has been moved to within the item info window.\\n\" +\n\t\t\t\t\"_-_ Various minor UI improvements to the intro, welcome and about scenes.\\n\" +\n\t\t\t\t\"_-_ Adjusted settings windows, removed some unnecessary elements.\\n\" +\n\t\t\t\t\"_-_ Armor with the warrior's seal on it now states max shielding.\\n\" +\n\t\t\t\t\"_-_ Bonus strength is now shown separately from base strength.\\n\\n\" +\n\n\t\t\t\t\"_-_ Improved the exit visuals on floor 10.\\n\" +\n\t\t\t\t\"_-_ Becoming magic immune now also cleanses existing magical buffs and debuffs.\\n\" +\n\t\t\t\t\"_-_ Traps that spawn visible or that never deactivate can no longer appear in enclosed spaces\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and text errors\\n\" +\n\t\t\t\t\"_-_ damage warn triggering when hero gains HP from being hit\\n\" +\n\t\t\t\t\"_-_ various rare bugs involving pitfall traps\\n\\n\" +\n\n\t\t\t\t\"_-_ statues not becoming aggressive when debuffed\\n\" +\n\t\t\t\t\"_-_ swapping places with allies reducing momentum\\n\" +\n\t\t\t\t\"_-_ DK minions dropping imp quest tokens\\n\" +\n\t\t\t\t\"_-_ giant succubi teleporting into enclosed spaces\\n\" +\n\t\t\t\t\"_-_ spectral blades being blocked by allies\\n\" +\n\t\t\t\t\"_-_ Spirit Hawk and Shadow Clone being corruptible\\n\\n\" +\n\n\t\t\t\t\"_-_ wands losing max charge on save/load in rare cases\\n\" +\n\t\t\t\t\"_-_ magical infusion clearing curses\\n\" +\n\t\t\t\t\"_-_ dewdrops stacking on each other in rare cases\\n\" +\n\t\t\t\t\"_-_ exploding skeletons not being blocked by transfusion shield in rare cases\\n\" +\n\t\t\t\t\"_-_ rare incorrect interactions between swiftthistle and golden lotus\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ various minor errors with electricity effects\\n\" +\n\t\t\t\t\"_-_ soul mark not working properly on low HP enemies with shielding\\n\" +\n\t\t\t\t\"_-_ various rare errors with shadows buff\\n\" +\n\t\t\t\t\"_-_ errors with time freeze and inter-floor teleportation mechanics\\n\" +\n\t\t\t\t\"_-_ rooted characters not being immune to knockback effects\\n\\n\" +\n\n\t\t\t\t\"_-_ gladiator combos dealing much more damage than intended in certain cases\\n\" +\n\t\t\t\t\"_-_ magical charge and scroll empower interacting incorrectly\\n\" +\n\t\t\t\t\"_-_ magical sight not working with farsight talent\\n\" +\n\t\t\t\t\"_-_ perfect copy talent giving very slightly more HP than intended\\n\" +\n\t\t\t\t\"_-_ wild magic using cursed wands as if they're normal\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.1\",\n\t\t\t\t\"Based on balance data and feedback, I'm making a bunch of buffs and adjustments to armor abilities and their related talents!\\n\\n\" +\n\t\t\t\t\"_- Endure_ bonus damage conversion rate up to 1/3 from 1/4.\\n\\n\" +\n\t\t\t\t\"_- Striking Wave_ effectiveness increased by 20%.\\n\" +\n\t\t\t\t\"_- Shock Force_ now actually adds 20% damage per level as stated. Previously it only added 15%.\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ now boosts wand levels, instead of overriding them.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ now has a chance to give each wand a 3rd shot.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ charge cost reduction down to 33/55/70/80% from 44/69/82/90%.\\n\\n\" +\n\t\t\t\t\"_- Elemental Blast_ base damage increased to 15-25 from 10-20.\\n\" +\n\t\t\t\t\"_- Elemental Power_ now boosts power by 20% per level, up from 15%.\\n\\n\" +\n\t\t\t\t\"_- Remote Beacon_ range per level increased to 4, from 3.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.2\",\n\t\t\t\t\"_- Shadow Clone_ now follows the hero at 2x speed.\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per level increased to 7.5% from 6.25%.\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per level increased to 15% from 12.5%.\\n\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ evasion, accuracy, and duration increased by 20%.\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now gives 2/3/4/5 dodges, up from 1/2/3/4.\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now gives 2/4/6/8 turns of blind, up from 2/3/4/5.\\n\\n\" +\n\t\t\t\t\"_- Spirit Blades_ effectiveness increased by 20%.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WoollyBomb(),\n\t\t\t\t\"As stones of flock were buffed, I thought it was only fair to give woolly bombs some compensation buffs as well:\\n\\n\" +\n\t\t\t\t\"_-_ AOE size up to 9x9 from 5x5\\n\" +\n\t\t\t\t\"_-_ Sheep duration up to 12-16 from 8-16\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The Mage continues to do too well in the early game since the talent changes in v0.9.1. Rather than weakening his talents and other magical abilities more, I've decided to make him more reliant on them instead by reducing his melee damage.\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-7 from 1-8.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Nerfs\",\n\t\t\t\t\"I focused mostly on buffs this update, but a few abilities and talents do need to be scaled back a little:\\n\\n\" +\n\t\t\t\t\"_- Double Jump_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Telefrag_ self damage increased to a flat 5 per level.\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range reduced to 6 tiles from 8.\\n\" +\n\t\t\t\t\"_- Body Replacement_ armor reduced to 1-3 per level, from 1-5.\\n\" +\n\t\t\t\t\"_- Hasty Retreat_ turns of haste/invis reduced to 1/2/3/4 from 2/3/4/5\\n\" +\n\t\t\t\t\"_- Shadow Step_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Double Mark_ charge cost reduction down to 30/50/65/75%, from 33/55/70/80%.\\n\\n\" +\n\t\t\t\t\"_- 13th armor ability_ now only lasts for 6 turns, but also no longer prevents EXP or item drops. I'm trying to retain the ability's core theme while making it a bit less effective at totally removing enemies.\\n\" +\n\t\t\t\t\"_- resistance talent_ damage reduction reduced to 10/19/27/35%, from 10/20/30/40%.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v1_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v1.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released August 17th, 2021\\n\" +\n\t\t\t\t\"_-_ 71 days after Shattered v0.9.3\\n\" +\n\t\t\t\t\"_-_ 316 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"_-_ A bit more than 7 years after v0.1.0!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_That's right, we've hit v1.0.0!_ This update was previously called v0.9.4 while in beta.\\n\\n\" +\n\t\t\t\t\"Shattered will also now use the _major.minor.patch_ version naming scheme moving forward. So, the next patch will be v1.0.1, and the next update will be v1.1.0. _This change does not affect my plans for future updates!_\\n\\n\" +\n\t\t\t\t\"Expect more dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"iOS Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon is now available on the iOS App Store!_\\n\\n\" +\n\t\t\t\t\"After years of requests, Shattered is finally available on Apple devices! The iOS version of the game will release in lockstep with the Android version moving forward, with some small variance due to different update approval processes.\\n\\n\" +\n\t\t\t\t\"Note that the iOS version costs $5, but comes with some supporter features built-in. I have no plans to make any changes to the monetization of the Android version.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"new music!\",\n\t\t\t\t\"_The game's music tracks has been remastered!_\\n\\n\" +\n\t\t\t\t\"The new music is composed by Kristjan Harristo, check the about scene for more details on them. Currently we have only replaced the existing tracks, but we are working on tracks for each of the dungeons regions as well!\\n\\n\" +\n\t\t\t\t\"The new in-game track in particular is also an experiment in variable music looping. The track has an intro and a main segment and can play the main segment once or twice before looping back to the intro. This makes the track notably less repetative, and we intend to use similar techniques in other tracks.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.LIQUID_METAL), \"new alchemy recipes!\",\n\t\t\t\t\"Two new alchemy recipes have been added! They're focused on helping you recycle thrown weapons and wands that you don't want to use.\\n\\n\" +\n\t\t\t\t\"_Liquid metal_ lets you sacrifice thrown weapons to repair other ones.\\n\\n\" +\n\t\t\t\t\"_Arcane resin_ lets you sacrifice a wand to upgrade other low level wands.\\n\\n\" +\n\t\t\t\t\"A new page has been added to the alchemy guide for these recipes, and it's now possible to find later guidebook pages in the prison.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 64, 16, 16)), \"new traps\",\n\t\t\t\t\"Two new traps have been added! They are both less common traps that have a higher potential to be helpful.\\n\\n\" +\n\t\t\t\t\"_Geyser traps_ convert surrounding terrain to water and throw back anything near them.\\n\\n\" +\n\t\t\t\t\"_Gateway traps_ are a special teleportation trap which never expire, and always teleport to the same location.\\n\\n\" +\n\t\t\t\t\"All teleportation traps now also affect characters and items next to them.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.MASTERY), \"new player experience improvements\",\n\t\t\t\t\"_The adventurer's guidebook is now the Tome of Dungeon Mastery!_\\n\\n\" +\n\t\t\t\t\"This is partly as a reference to the tome of mastery, which I removed in the previous update, and partly because the game's tutorial functionality has been improved.\\n\\n\" +\n\t\t\t\t\"Guidebook pages are now a bit shorter and more plentiful, and some of them are now given to the player right at the start of the game. These automatic pages are suggested to the player to read at crucial moments. This way the guidebook does a better job of highlighting info right when it's needed.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new SpectralNecromancerSprite()), \"spectral necromancers\",\n\t\t\t\t\"A new rare variant has been added for necromancers: _Spectral Necromancers!_\\n\\n\" +\n\t\t\t\t\"These necromancers don't care for skeletons, and prefer to summon a bunch of wraiths instead! Dealing with their horde might be tricky, but you'll be rewarded with a scroll of remove curse.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ANKH), \"new ankh mechanics\",\n\t\t\t\t\"_Regular Ankhs_ have been totally redesigned, and now give the player a chance to save all of their equipment! Be careful though, you'll have to fight your way back to your lost gear.\\n\\n\" +\n\t\t\t\t\"_Blessed Ankhs_ have received comparatively minor changes. In addition to the resurrection effect, these ankhs now also give the player 3 turns of invulnerability. This should help give players a moment to heal up after being revived.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.STONE_FEAR), \"runestones\",\n\t\t\t\t\"All Scrolls now produce 2 runestones, instead of some scrolls producing 3. The stones that used to be given in higher quantities have received buffs in compensation:\\n\\n\" +\n\t\t\t\t\"_- Stone of Intuition_ can now be used a second time if the guess was correct.\\n\" +\n\t\t\t\t\"_- Stone of Flock_ AOE up to 5x5 from 3x3, sheep duration increased slightly.\\n\" +\n\t\t\t\t\"_- Stone of Deepened Sleep_ is now stone of deep sleep, instantly puts one enemy into magical sleep.\\n\" +\n\t\t\t\t\"_- Stone of Clairvoyance_ AOE up to 20x20, from 12x12.\\n\" +\n\t\t\t\t\"_- Stone of Aggression_ duration against enemies up 5, now works on bosses, and always forces attacking.\\n\" +\n\t\t\t\t\"_- Stone of Affection_ is now stone of fear, it fears one target for 20 turns.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Various tech and stability improvements.\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported Android version to 4.0, from 2.3.\\n\" +\n\t\t\t\t\"_-_ Game versions that use github for update checking can now opt-in to beta updates within the game.\\n\\n\" +\n\n\t\t\t\t\"_-_ Item renaming functionality has been moved to within the item info window.\\n\" +\n\t\t\t\t\"_-_ Various minor UI improvements to the intro, welcome and about scenes.\\n\" +\n\t\t\t\t\"_-_ Adjusted settings windows, removed some unnecessary elements.\\n\" +\n\t\t\t\t\"_-_ Added info buttons to the scroll of enchantment window\\n\"+\n\t\t\t\t\"_-_ Armor with the warrior's seal on it now states max shielding.\\n\" +\n\t\t\t\t\"_-_ Bonus strength is now shown separately from base strength.\\n\\n\" +\n\n\t\t\t\t\"_-_ Improved the exit visuals on floor 10.\\n\" +\n\t\t\t\t\"_-_ Becoming magic immune now also cleanses existing magical buffs and debuffs.\\n\" +\n\t\t\t\t\"_-_ Traps that spawn visible or that never deactivate can no longer appear in enclosed spaces\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and text errors\\n\" +\n\t\t\t\t\"_-_ damage warn triggering when hero gains HP from being hit\\n\" +\n\t\t\t\t\"_-_ various rare bugs involving pitfall traps\\n\" +\n\t\t\t\t\"_-_ disarming traps opening chests\\n\\n\" +\n\n\t\t\t\t\"_-_ various minor errors with electricity effects\\n\" +\n\t\t\t\t\"_-_ soul mark not working properly on low HP enemies with shielding\\n\" +\n\t\t\t\t\"_-_ various rare errors with shadows buff\\n\" +\n\t\t\t\t\"_-_ errors with time freeze and inter-floor teleportation mechanics\\n\" +\n\t\t\t\t\"_-_ rooted characters not being immune to knockback effects\\n\" +\n\t\t\t\t\"_-_ time stasis sometimes not preventing harmful effects in its last turn.\\n\\n\" +\n\n\t\t\t\t\"_-_ wands losing max charge on save/load in rare cases\\n\" +\n\t\t\t\t\"_-_ magical infusion clearing curses\\n\" +\n\t\t\t\t\"_-_ dewdrops stacking on each other in rare cases\\n\" +\n\t\t\t\t\"_-_ exploding skeletons not being blocked by transfusion shield in rare cases\\n\" +\n\t\t\t\t\"_-_ rare incorrect interactions between swiftthistle and golden lotus\\n\" +\n\t\t\t\t\"_-_ Rings not being renamable if they weren't IDed\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ statues not becoming aggressive when debuffed\\n\" +\n\t\t\t\t\"_-_ swapping places with allies reducing momentum\\n\" +\n\t\t\t\t\"_-_ DK minions dropping imp quest tokens\\n\" +\n\t\t\t\t\"_-_ giant succubi teleporting into enclosed spaces\\n\" +\n\t\t\t\t\"_-_ spectral blades being blocked by allies\\n\" +\n\t\t\t\t\"_-_ Spirit Hawk and Shadow Clone being corruptible\\n\" +\n\t\t\t\t\"_-_ Rogue's body replacement ally being vulnerable to various AI-related debuffs\\n\" +\n\t\t\t\t\"_-_ some ranged enemies becoming frozen if they were attacked from out of their vision\\n\\n\" +\n\n\t\t\t\t\"_-_ gladiator combos dealing much more damage than intended in certain cases\\n\" +\n\t\t\t\t\"_-_ magical charge and scroll empower interacting incorrectly\\n\" +\n\t\t\t\t\"_-_ magical sight not working with farsight talent\\n\" +\n\t\t\t\t\"_-_ perfect copy talent giving very slightly more HP than intended\\n\" +\n\t\t\t\t\"_-_ wild magic using cursed wands as if they're normal\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.1\",\n\t\t\t\t\"Based on balance data and feedback, I'm making a bunch of buffs and adjustments to armor abilities and their related talents!\\n\\n\" +\n\t\t\t\t\"_- Endure_ bonus damage conversion rate up to 1/3 from 1/4.\\n\\n\" +\n\t\t\t\t\"_- Striking Wave_ effectiveness increased by 20%.\\n\" +\n\t\t\t\t\"_- Shock Force_ now actually adds 20% damage per level as stated. Previously it only added 15%.\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ now boosts wand levels, instead of overriding them.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ now has a chance to give each wand a 3rd shot.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ charge cost reduction down to 33/55/70/80% from 44/69/82/90%.\\n\\n\" +\n\t\t\t\t\"_- Elemental Blast_ base damage increased to 15-25 from 10-20.\\n\" +\n\t\t\t\t\"_- Elemental Power_ now boosts power by 20% per level, up from 15%.\\n\\n\" +\n\t\t\t\t\"_- Remote Beacon_ range per level increased to 4, from 3.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.2\",\n\t\t\t\t\"_- Shadow Clone_ now follows the hero at 2x speed.\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per level increased to 7.5% from 6.25%.\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per level increased to 15% from 12.5%.\\n\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ evasion, accuracy, and duration increased by 20%.\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now gives 2/3/4/5 dodges, up from 1/2/3/4.\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now gives 2/4/6/8 turns of blind, up from 2/3/4/5.\\n\\n\" +\n\t\t\t\t\"_- Spirit Blades_ effectiveness increased by 20%.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WoollyBomb(),\n\t\t\t\t\"As stones of flock were buffed, I thought it was only fair to give woolly bombs some compensation buffs as well:\\n\\n\" +\n\t\t\t\t\"_-_ AOE size up to 9x9 from 5x5\\n\" +\n\t\t\t\t\"_-_ Sheep duration up to 12-16 from 8-16\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The Mage continues to do too well in the early game since the talent changes in v0.9.1. Rather than weakening his talents and other magical abilities more, I've decided to make him more reliant on them instead by reducing his melee damage.\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-7 from 1-8.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Nerfs\",\n\t\t\t\t\"I focused mostly on buffs this update, but a few abilities and talents do need to be scaled back a little:\\n\\n\" +\n\t\t\t\t\"_- Double Jump_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Telefrag_ self damage increased to a flat 5 per level.\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range reduced to 6 tiles from 8.\\n\" +\n\t\t\t\t\"_- Body Replacement_ armor reduced to 1-3 per level, from 1-5.\\n\" +\n\t\t\t\t\"_- Hasty Retreat_ turns of haste/invis reduced to 1/2/3/4 from 2/3/4/5\\n\" +\n\t\t\t\t\"_- Shadow Step_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Double Mark_ charge cost reduction down to 30/50/65/75%, from 33/55/70/80%.\\n\\n\" +\n\t\t\t\t\"_- 13th armor ability_ now only lasts for 6 turns, but also no longer prevents EXP or item drops. I'm trying to retain the ability's core theme while making it a bit less effective at totally removing enemies.\\n\" +\n\t\t\t\t\"_- resistance talent_ damage reduction reduced to 10/19/27/35%, from 10/20/30/40%.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_Coming_Soon( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"Coming Soon\", true, \"\");\n\t\tchanges.hardlight(0xCCCCCC);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Overview\",\n\t\t\t\"The next Shattered update will be v1.2.0, and will focus on a variety of smaller improvements, including working on proper support for desktop users in anticipation of the game's upcoming Steam release. Unfortunately I'm spread a bit thin right now with Steam and real-life obligations, so v1.2.0 will be light on content additions. I do hope to release it in less than 4 months though!\\n\\n\" +\n\t\t\t\"Expect to hear more details about v1.2.0 in a future news post, likely in January.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ENERGY), \"Further Alchemy Tweaks\",\n\t\t\t\t\"v1.1.0 focused pretty heavily on the alchemy system itself and exotic potions/scrolls, but there are definitely improvements to be made to other alchemy items too! Once the dust has settled a bit from 1.1.0 I intend to do a full evaluation and balance pass on alchemy produce. That may mean some nerfs, but I expect the majority of item changes from this will be buffs.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"Desktop Enhancements\",\n\t\t\t\t\"The other major focus for v1.2.0 will be new and enhanced features for desktop users! I wrote a blog post about this in detail already, but in summary I want to make it easier to install and run the desktop game, and improve the interface to better take advantage of mice, controllers, and larger screens.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"Boss Music\",\n\t\t\t\t\"v1.1.0 includes a bunch of new music, but Kristjan and I aren't finished yet! We're currently working on a boss track for Yog-Dzewa, and might add some music for the other bosses too.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"Lastly, there will be some smaller miscellaneous changes in v1.2.0 as well. Alchemy items will get the most adjustments, but I also plan to look into improvements to a few other items, such as the master thieves' armband. There will be the usual round of balance improvements too.\"));\n\n\t}",
          "uniqueId": "7f29a03078647ea503d3c866476568511aa5af84_24_268_32_54_216_389"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v1_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"Coming Soon\", true, \"\");\n\t\tchanges.hardlight(0xCCCCCC);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Overview\",\n\t\t\t\"The next Shattered update will be v1.1.0, and will focus heavily on alchemy! I want to make alchemy more cohesive, simple, and make it better at recycling items the player doesn’t want into items that they do want.\\n\\n\" +\n\t\t\t\"Expect to hear more details about v1.1.0 in a future news post, likely sometime in September.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TILES_SEWERS, 48, 96, 16, 16 ), \"Alchemical Energy\",\n\t\t\t\t\"The most major change will be an overhaul to how alchemy energy works. Currently energy sort of sits on top of the system and acts as a limiter on how much advanced alchemy a player can perform, but otherwise does nothing. I have some plans to make energy a much more integral part of the system, and for it to tie directly into recycling consumable items. \"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ALCHEMIZE), \"Alchemy Recipes\",\n\t\t\t\t\"With alchemical energy changing, I'll naturally be looking at many of the game's higher end alchemy recipes as well! I can't promise that every single recipe will be perfect, but I hope to make some major changes in the next update that will substantially improve on many recipes. \"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"More New Music\",\n\t\t\t\t\"So far the early reception to the new music has been extremely positive! Kristjan and I are already working on some new tracks, and we might be ready to add more music in the next update. The current plan is to have a unique track for every region of the dungeon! \"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"Lastly, there will be some smaller miscellaneous changes v1.1.0 as well. I plan to continue keeping an eye on game balance and making tweaks to the new hero abilities added in the v0.9 updates. I might have enough time spare to rework an item or two as well! \"));\n\n\t\tchanges = new ChangeInfo(\"v1.0.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v1.0.3\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.2):\\n\" +\n\t\t\t\t\"_-_ Reclaim Trap spells incorrectly starting with a summoning trap reclaimed\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.1):\\n\" +\n\t\t\t\t\"_-_ Music corruption and crashes for Desktop users\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Various rare game crashes\\n\" +\n\t\t\t\t\"_-_ Some items being treated as equipped after save/load with lost inventory\\n\" +\n\t\t\t\t\"_-_ Cases where liquid metal could be applied to items at full durability\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Minor text and vfx corrections\"));\n\n\t\tchanges = new ChangeInfo(\"v1.0.2 & v1.0.1\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.1):\\n\" +\n\t\t\t\t\"_-_ Additional crashes caused by the new music system\\n\\n\" +\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Negative STR bonuses not displaying separately\\n\" +\n\t\t\t\t\"_-_ Elemental Power talent not being buffed as intended\\n\" +\n\t\t\t\t\"_-_ Geyser traps rarely knocking the hero into other characters\\n\" +\n\t\t\t\t\"_-_ Unbreakable traps breaking in more rare cases\\n\" +\n\t\t\t\t\"_-_ Hasty Retreat talent giving fewer turns of haste/invis than intended\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ minor vfx corrections\\n\" +\n\t\t\t\t\"_-_ Time stasis sometimes not preventing harmful effects in its last turn.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Added info buttons to the scroll of enchantment window\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Graphics hitching when music was enabled\\n\" +\n\t\t\t\t\"_-_ Pressing enter not confirming single line text input\\n\" +\n\t\t\t\t\"_-_ Enemies attacking the golden lotus, despite it being neutral\\n\" +\n\t\t\t\t\"_-_ Remote Beacon talent not actually being buffed\\n\" +\n\t\t\t\t\"_-_ Ankhs still resurrecting the hero even if they lost their inventory\\n\" +\n\t\t\t\t\"_-_ Unbreakable traps breaking in rare cases\\n\" +\n\t\t\t\t\"_-_ Transmogrified enemies dropping items where they were transmogrified\\n\" +\n\t\t\t\t\"_-_ Potions/Scrolls never breaking due to frost/fire\\n\" +\n\t\t\t\t\"_-_ Sheep triggering traps before occupying space on them\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (existed prior to 1.0.0):\\n\" +\n\t\t\t\t\"_-_ Rings not being renamable if they weren't IDed\\n\" +\n\t\t\t\t\"_-_ Disarming traps opening chests\\n\" +\n\t\t\t\t\"_-_ Rogue's body replacement ally being vulnerable to various AI-related debuffs\\n\" +\n\t\t\t\t\"_-_ Some ranged enemies becoming frozen if they were attacked from out of their vision\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released August 17th, 2021\\n\" +\n\t\t\t\t\"_-_ 71 days after Shattered v0.9.3\\n\" +\n\t\t\t\t\"_-_ 316 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"_-_ A bit more than 7 years after v0.1.0!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_That's right, we've hit v1.0.0!_ This update was previously called v0.9.4 while in beta.\\n\\n\" +\n\t\t\t\t\"Shattered will also now use the _major.minor.patch_ version naming scheme moving forward. So, the next patch will be v1.0.1, and the next update will be v1.1.0. _This change does not affect my plans for future updates!_\\n\\n\" +\n\t\t\t\t\"Expect more dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"iOS Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon is now available on the iOS App Store!_\\n\\n\" +\n\t\t\t\t\"After years of requests, Shattered is finally available on Apple devices! The iOS version of the game will release in lockstep with the Android version moving forward, with some small variance due to different update approval processes.\\n\\n\" +\n\t\t\t\t\"Note that the iOS version costs $5, but comes with some supporter features built-in. I have no plans to make any changes to the monetization of the Android version.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"new music!\",\n\t\t\t\t\"_The game's music tracks has been remastered!_\\n\\n\" +\n\t\t\t\t\"The new music is composed by Kristjan Harristo, check the about scene for more details on them. Currently we have only replaced the existing tracks, but we are working on tracks for each of the dungeons regions as well!\\n\\n\" +\n\t\t\t\t\"The new in-game track in particular is also an experiment in variable music looping. The track has an intro and a main segment and can play the main segment once or twice before looping back to the intro. This makes the track notably less repetative, and we intend to use similar techniques in other tracks.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.LIQUID_METAL), \"new alchemy recipes!\",\n\t\t\t\t\"Two new alchemy recipes have been added! They're focused on helping you recycle thrown weapons and wands that you don't want to use.\\n\\n\" +\n\t\t\t\t\"_Liquid metal_ lets you sacrifice thrown weapons to repair other ones.\\n\\n\" +\n\t\t\t\t\"_Arcane resin_ lets you sacrifice a wand to upgrade other low level wands.\\n\\n\" +\n\t\t\t\t\"A new page has been added to the alchemy guide for these recipes, and it's now possible to find later guidebook pages in the prison.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 64, 16, 16)), \"new traps\",\n\t\t\t\t\"Two new traps have been added! They are both less common traps that have a higher potential to be helpful.\\n\\n\" +\n\t\t\t\t\"_Geyser traps_ convert surrounding terrain to water and throw back anything near them.\\n\\n\" +\n\t\t\t\t\"_Gateway traps_ are a special teleportation trap which never expire, and always teleport to the same location.\\n\\n\" +\n\t\t\t\t\"All teleportation traps now also affect characters and items next to them.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.MASTERY), \"new player experience improvements\",\n\t\t\t\t\"_The adventurer's guidebook is now the Tome of Dungeon Mastery!_\\n\\n\" +\n\t\t\t\t\"This is partly as a reference to the tome of mastery, which I removed in the previous update, and partly because the game's tutorial functionality has been improved.\\n\\n\" +\n\t\t\t\t\"Guidebook pages are now a bit shorter and more plentiful, and some of them are now given to the player right at the start of the game. These automatic pages are suggested to the player to read at crucial moments. This way the guidebook does a better job of highlighting info right when it's needed.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new SpectralNecromancerSprite()), \"spectral necromancers\",\n\t\t\t\t\"A new rare variant has been added for necromancers: _Spectral Necromancers!_\\n\\n\" +\n\t\t\t\t\"These necromancers don't care for skeletons, and prefer to summon a bunch of wraiths instead! Dealing with their horde might be tricky, but you'll be rewarded with a scroll of remove curse.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ANKH), \"new ankh mechanics\",\n\t\t\t\t\"_Regular Ankhs_ have been totally redesigned, and now give the player a chance to save all of their equipment! Be careful though, you'll have to fight your way back to your lost gear.\\n\\n\" +\n\t\t\t\t\"_Blessed Ankhs_ have received comparatively minor changes. In addition to the resurrection effect, these ankhs now also give the player 3 turns of invulnerability. This should help give players a moment to heal up after being revived.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.STONE_FEAR), \"runestones\",\n\t\t\t\t\"All Scrolls now produce 2 runestones, instead of some scrolls producing 3. The stones that used to be given in higher quantities have received buffs in compensation:\\n\\n\" +\n\t\t\t\t\"_- Stone of Intuition_ can now be used a second time if the guess was correct.\\n\" +\n\t\t\t\t\"_- Stone of Flock_ AOE up to 5x5 from 3x3, sheep duration increased slightly.\\n\" +\n\t\t\t\t\"_- Stone of Deepened Sleep_ is now stone of deep sleep, instantly puts one enemy into magical sleep.\\n\" +\n\t\t\t\t\"_- Stone of Clairvoyance_ AOE up to 20x20, from 12x12.\\n\" +\n\t\t\t\t\"_- Stone of Aggression_ duration against enemies up 5, now works on bosses, and always forces attacking.\\n\" +\n\t\t\t\t\"_- Stone of Affection_ is now stone of fear, it fears one target for 20 turns.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Various tech and stability improvements.\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported Android version to 4.0, from 2.3.\\n\" +\n\t\t\t\t\"_-_ Game versions that use github for update checking can now opt-in to beta updates within the game.\\n\\n\" +\n\n\t\t\t\t\"_-_ Item renaming functionality has been moved to within the item info window.\\n\" +\n\t\t\t\t\"_-_ Various minor UI improvements to the intro, welcome and about scenes.\\n\" +\n\t\t\t\t\"_-_ Adjusted settings windows, removed some unnecessary elements.\\n\" +\n\t\t\t\t\"_-_ Armor with the warrior's seal on it now states max shielding.\\n\" +\n\t\t\t\t\"_-_ Bonus strength is now shown separately from base strength.\\n\\n\" +\n\n\t\t\t\t\"_-_ Improved the exit visuals on floor 10.\\n\" +\n\t\t\t\t\"_-_ Becoming magic immune now also cleanses existing magical buffs and debuffs.\\n\" +\n\t\t\t\t\"_-_ Traps that spawn visible or that never deactivate can no longer appear in enclosed spaces\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and text errors\\n\" +\n\t\t\t\t\"_-_ damage warn triggering when hero gains HP from being hit\\n\" +\n\t\t\t\t\"_-_ various rare bugs involving pitfall traps\\n\\n\" +\n\n\t\t\t\t\"_-_ statues not becoming aggressive when debuffed\\n\" +\n\t\t\t\t\"_-_ swapping places with allies reducing momentum\\n\" +\n\t\t\t\t\"_-_ DK minions dropping imp quest tokens\\n\" +\n\t\t\t\t\"_-_ giant succubi teleporting into enclosed spaces\\n\" +\n\t\t\t\t\"_-_ spectral blades being blocked by allies\\n\" +\n\t\t\t\t\"_-_ Spirit Hawk and Shadow Clone being corruptible\\n\\n\" +\n\n\t\t\t\t\"_-_ wands losing max charge on save/load in rare cases\\n\" +\n\t\t\t\t\"_-_ magical infusion clearing curses\\n\" +\n\t\t\t\t\"_-_ dewdrops stacking on each other in rare cases\\n\" +\n\t\t\t\t\"_-_ exploding skeletons not being blocked by transfusion shield in rare cases\\n\" +\n\t\t\t\t\"_-_ rare incorrect interactions between swiftthistle and golden lotus\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ various minor errors with electricity effects\\n\" +\n\t\t\t\t\"_-_ soul mark not working properly on low HP enemies with shielding\\n\" +\n\t\t\t\t\"_-_ various rare errors with shadows buff\\n\" +\n\t\t\t\t\"_-_ errors with time freeze and inter-floor teleportation mechanics\\n\" +\n\t\t\t\t\"_-_ rooted characters not being immune to knockback effects\\n\\n\" +\n\n\t\t\t\t\"_-_ gladiator combos dealing much more damage than intended in certain cases\\n\" +\n\t\t\t\t\"_-_ magical charge and scroll empower interacting incorrectly\\n\" +\n\t\t\t\t\"_-_ magical sight not working with farsight talent\\n\" +\n\t\t\t\t\"_-_ perfect copy talent giving very slightly more HP than intended\\n\" +\n\t\t\t\t\"_-_ wild magic using cursed wands as if they're normal\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.1\",\n\t\t\t\t\"Based on balance data and feedback, I'm making a bunch of buffs and adjustments to armor abilities and their related talents!\\n\\n\" +\n\t\t\t\t\"_- Endure_ bonus damage conversion rate up to 1/3 from 1/4.\\n\\n\" +\n\t\t\t\t\"_- Striking Wave_ effectiveness increased by 20%.\\n\" +\n\t\t\t\t\"_- Shock Force_ now actually adds 20% damage per level as stated. Previously it only added 15%.\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ now boosts wand levels, instead of overriding them.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ now has a chance to give each wand a 3rd shot.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ charge cost reduction down to 33/55/70/80% from 44/69/82/90%.\\n\\n\" +\n\t\t\t\t\"_- Elemental Blast_ base damage increased to 15-25 from 10-20.\\n\" +\n\t\t\t\t\"_- Elemental Power_ now boosts power by 20% per level, up from 15%.\\n\\n\" +\n\t\t\t\t\"_- Remote Beacon_ range per level increased to 4, from 3.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.2\",\n\t\t\t\t\"_- Shadow Clone_ now follows the hero at 2x speed.\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per level increased to 7.5% from 6.25%.\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per level increased to 15% from 12.5%.\\n\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ evasion, accuracy, and duration increased by 20%.\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now gives 2/3/4/5 dodges, up from 1/2/3/4.\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now gives 2/4/6/8 turns of blind, up from 2/3/4/5.\\n\\n\" +\n\t\t\t\t\"_- Spirit Blades_ effectiveness increased by 20%.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WoollyBomb(),\n\t\t\t\t\"As stones of flock were buffed, I thought it was only fair to give woolly bombs some compensation buffs as well:\\n\\n\" +\n\t\t\t\t\"_-_ AOE size up to 9x9 from 5x5\\n\" +\n\t\t\t\t\"_-_ Sheep duration up to 12-16 from 8-16\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The Mage continues to do too well in the early game since the talent changes in v0.9.1. Rather than weakening his talents and other magical abilities more, I've decided to make him more reliant on them instead by reducing his melee damage.\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-7 from 1-8.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Nerfs\",\n\t\t\t\t\"I focused mostly on buffs this update, but a few abilities and talents do need to be scaled back a little:\\n\\n\" +\n\t\t\t\t\"_- Double Jump_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Telefrag_ self damage increased to a flat 5 per level.\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range reduced to 6 tiles from 8.\\n\" +\n\t\t\t\t\"_- Body Replacement_ armor reduced to 1-3 per level, from 1-5.\\n\" +\n\t\t\t\t\"_- Hasty Retreat_ turns of haste/invis reduced to 1/2/3/4 from 2/3/4/5\\n\" +\n\t\t\t\t\"_- Shadow Step_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Double Mark_ charge cost reduction down to 30/50/65/75%, from 33/55/70/80%.\\n\\n\" +\n\t\t\t\t\"_- 13th armor ability_ now only lasts for 6 turns, but also no longer prevents EXP or item drops. I'm trying to retain the ability's core theme while making it a bit less effective at totally removing enemies.\\n\" +\n\t\t\t\t\"_- resistance talent_ damage reduction reduced to 10/19/27/35%, from 10/20/30/40%.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v1_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v1.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released August 17th, 2021\\n\" +\n\t\t\t\t\"_-_ 71 days after Shattered v0.9.3\\n\" +\n\t\t\t\t\"_-_ 316 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"_-_ A bit more than 7 years after v0.1.0!\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_That's right, we've hit v1.0.0!_ This update was previously called v0.9.4 while in beta.\\n\\n\" +\n\t\t\t\t\"Shattered will also now use the _major.minor.patch_ version naming scheme moving forward. So, the next patch will be v1.0.1, and the next update will be v1.1.0. _This change does not affect my plans for future updates!_\\n\\n\" +\n\t\t\t\t\"Expect more dev commentary here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"iOS Release!\",\n\t\t\t\t\"_Shattered Pixel Dungeon is now available on the iOS App Store!_\\n\\n\" +\n\t\t\t\t\"After years of requests, Shattered is finally available on Apple devices! The iOS version of the game will release in lockstep with the Android version moving forward, with some small variance due to different update approval processes.\\n\\n\" +\n\t\t\t\t\"Note that the iOS version costs $5, but comes with some supporter features built-in. I have no plans to make any changes to the monetization of the Android version.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"new music!\",\n\t\t\t\t\"_The game's music tracks has been remastered!_\\n\\n\" +\n\t\t\t\t\"The new music is composed by Kristjan Harristo, check the about scene for more details on them. Currently we have only replaced the existing tracks, but we are working on tracks for each of the dungeons regions as well!\\n\\n\" +\n\t\t\t\t\"The new in-game track in particular is also an experiment in variable music looping. The track has an intro and a main segment and can play the main segment once or twice before looping back to the intro. This makes the track notably less repetative, and we intend to use similar techniques in other tracks.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.LIQUID_METAL), \"new alchemy recipes!\",\n\t\t\t\t\"Two new alchemy recipes have been added! They're focused on helping you recycle thrown weapons and wands that you don't want to use.\\n\\n\" +\n\t\t\t\t\"_Liquid metal_ lets you sacrifice thrown weapons to repair other ones.\\n\\n\" +\n\t\t\t\t\"_Arcane resin_ lets you sacrifice a wand to upgrade other low level wands.\\n\\n\" +\n\t\t\t\t\"A new page has been added to the alchemy guide for these recipes, and it's now possible to find later guidebook pages in the prison.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 64, 16, 16)), \"new traps\",\n\t\t\t\t\"Two new traps have been added! They are both less common traps that have a higher potential to be helpful.\\n\\n\" +\n\t\t\t\t\"_Geyser traps_ convert surrounding terrain to water and throw back anything near them.\\n\\n\" +\n\t\t\t\t\"_Gateway traps_ are a special teleportation trap which never expire, and always teleport to the same location.\\n\\n\" +\n\t\t\t\t\"All teleportation traps now also affect characters and items next to them.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.MASTERY), \"new player experience improvements\",\n\t\t\t\t\"_The adventurer's guidebook is now the Tome of Dungeon Mastery!_\\n\\n\" +\n\t\t\t\t\"This is partly as a reference to the tome of mastery, which I removed in the previous update, and partly because the game's tutorial functionality has been improved.\\n\\n\" +\n\t\t\t\t\"Guidebook pages are now a bit shorter and more plentiful, and some of them are now given to the player right at the start of the game. These automatic pages are suggested to the player to read at crucial moments. This way the guidebook does a better job of highlighting info right when it's needed.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(new SpectralNecromancerSprite()), \"spectral necromancers\",\n\t\t\t\t\"A new rare variant has been added for necromancers: _Spectral Necromancers!_\\n\\n\" +\n\t\t\t\t\"These necromancers don't care for skeletons, and prefer to summon a bunch of wraiths instead! Dealing with their horde might be tricky, but you'll be rewarded with a scroll of remove curse.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ANKH), \"new ankh mechanics\",\n\t\t\t\t\"_Regular Ankhs_ have been totally redesigned, and now give the player a chance to save all of their equipment! Be careful though, you'll have to fight your way back to your lost gear.\\n\\n\" +\n\t\t\t\t\"_Blessed Ankhs_ have received comparatively minor changes. In addition to the resurrection effect, these ankhs now also give the player 3 turns of invulnerability. This should help give players a moment to heal up after being revived.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.STONE_FEAR), \"runestones\",\n\t\t\t\t\"All Scrolls now produce 2 runestones, instead of some scrolls producing 3. The stones that used to be given in higher quantities have received buffs in compensation:\\n\\n\" +\n\t\t\t\t\"_- Stone of Intuition_ can now be used a second time if the guess was correct.\\n\" +\n\t\t\t\t\"_- Stone of Flock_ AOE up to 5x5 from 3x3, sheep duration increased slightly.\\n\" +\n\t\t\t\t\"_- Stone of Deepened Sleep_ is now stone of deep sleep, instantly puts one enemy into magical sleep.\\n\" +\n\t\t\t\t\"_- Stone of Clairvoyance_ AOE up to 20x20, from 12x12.\\n\" +\n\t\t\t\t\"_- Stone of Aggression_ duration against enemies up 5, now works on bosses, and always forces attacking.\\n\" +\n\t\t\t\t\"_- Stone of Affection_ is now stone of fear, it fears one target for 20 turns.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Various tech and stability improvements.\\n\" +\n\t\t\t\t\"_-_ Increased the minimum supported Android version to 4.0, from 2.3.\\n\" +\n\t\t\t\t\"_-_ Game versions that use github for update checking can now opt-in to beta updates within the game.\\n\\n\" +\n\n\t\t\t\t\"_-_ Item renaming functionality has been moved to within the item info window.\\n\" +\n\t\t\t\t\"_-_ Various minor UI improvements to the intro, welcome and about scenes.\\n\" +\n\t\t\t\t\"_-_ Adjusted settings windows, removed some unnecessary elements.\\n\" +\n\t\t\t\t\"_-_ Added info buttons to the scroll of enchantment window\\n\"+\n\t\t\t\t\"_-_ Armor with the warrior's seal on it now states max shielding.\\n\" +\n\t\t\t\t\"_-_ Bonus strength is now shown separately from base strength.\\n\\n\" +\n\n\t\t\t\t\"_-_ Improved the exit visuals on floor 10.\\n\" +\n\t\t\t\t\"_-_ Becoming magic immune now also cleanses existing magical buffs and debuffs.\\n\" +\n\t\t\t\t\"_-_ Traps that spawn visible or that never deactivate can no longer appear in enclosed spaces\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual and text errors\\n\" +\n\t\t\t\t\"_-_ damage warn triggering when hero gains HP from being hit\\n\" +\n\t\t\t\t\"_-_ various rare bugs involving pitfall traps\\n\" +\n\t\t\t\t\"_-_ disarming traps opening chests\\n\\n\" +\n\n\t\t\t\t\"_-_ various minor errors with electricity effects\\n\" +\n\t\t\t\t\"_-_ soul mark not working properly on low HP enemies with shielding\\n\" +\n\t\t\t\t\"_-_ various rare errors with shadows buff\\n\" +\n\t\t\t\t\"_-_ errors with time freeze and inter-floor teleportation mechanics\\n\" +\n\t\t\t\t\"_-_ rooted characters not being immune to knockback effects\\n\" +\n\t\t\t\t\"_-_ time stasis sometimes not preventing harmful effects in its last turn.\\n\\n\" +\n\n\t\t\t\t\"_-_ wands losing max charge on save/load in rare cases\\n\" +\n\t\t\t\t\"_-_ magical infusion clearing curses\\n\" +\n\t\t\t\t\"_-_ dewdrops stacking on each other in rare cases\\n\" +\n\t\t\t\t\"_-_ exploding skeletons not being blocked by transfusion shield in rare cases\\n\" +\n\t\t\t\t\"_-_ rare incorrect interactions between swiftthistle and golden lotus\\n\" +\n\t\t\t\t\"_-_ Rings not being renamable if they weren't IDed\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ statues not becoming aggressive when debuffed\\n\" +\n\t\t\t\t\"_-_ swapping places with allies reducing momentum\\n\" +\n\t\t\t\t\"_-_ DK minions dropping imp quest tokens\\n\" +\n\t\t\t\t\"_-_ giant succubi teleporting into enclosed spaces\\n\" +\n\t\t\t\t\"_-_ spectral blades being blocked by allies\\n\" +\n\t\t\t\t\"_-_ Spirit Hawk and Shadow Clone being corruptible\\n\" +\n\t\t\t\t\"_-_ Rogue's body replacement ally being vulnerable to various AI-related debuffs\\n\" +\n\t\t\t\t\"_-_ some ranged enemies becoming frozen if they were attacked from out of their vision\\n\\n\" +\n\n\t\t\t\t\"_-_ gladiator combos dealing much more damage than intended in certain cases\\n\" +\n\t\t\t\t\"_-_ magical charge and scroll empower interacting incorrectly\\n\" +\n\t\t\t\t\"_-_ magical sight not working with farsight talent\\n\" +\n\t\t\t\t\"_-_ perfect copy talent giving very slightly more HP than intended\\n\" +\n\t\t\t\t\"_-_ wild magic using cursed wands as if they're normal\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.1\",\n\t\t\t\t\"Based on balance data and feedback, I'm making a bunch of buffs and adjustments to armor abilities and their related talents!\\n\\n\" +\n\t\t\t\t\"_- Endure_ bonus damage conversion rate up to 1/3 from 1/4.\\n\\n\" +\n\t\t\t\t\"_- Striking Wave_ effectiveness increased by 20%.\\n\" +\n\t\t\t\t\"_- Shock Force_ now actually adds 20% damage per level as stated. Previously it only added 15%.\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ now boosts wand levels, instead of overriding them.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ now has a chance to give each wand a 3rd shot.\\n\" +\n\t\t\t\t\"_- Conserved Magic_ charge cost reduction down to 33/55/70/80% from 44/69/82/90%.\\n\\n\" +\n\t\t\t\t\"_- Elemental Blast_ base damage increased to 15-25 from 10-20.\\n\" +\n\t\t\t\t\"_- Elemental Power_ now boosts power by 20% per level, up from 15%.\\n\\n\" +\n\t\t\t\t\"_- Remote Beacon_ range per level increased to 4, from 3.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Buffs pt.2\",\n\t\t\t\t\"_- Shadow Clone_ now follows the hero at 2x speed.\\n\" +\n\t\t\t\t\"_- Shadow Blade_ damage per level increased to 7.5% from 6.25%.\\n\" +\n\t\t\t\t\"_- Cloned Armor_ armor per level increased to 15% from 12.5%.\\n\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ evasion, accuracy, and duration increased by 20%.\\n\" +\n\t\t\t\t\"_- Swift Spirit_ now gives 2/3/4/5 dodges, up from 1/2/3/4.\\n\" +\n\t\t\t\t\"_- Go for the Eyes_ now gives 2/4/6/8 turns of blind, up from 2/3/4/5.\\n\\n\" +\n\t\t\t\t\"_- Spirit Blades_ effectiveness increased by 20%.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WoollyBomb(),\n\t\t\t\t\"As stones of flock were buffed, I thought it was only fair to give woolly bombs some compensation buffs as well:\\n\\n\" +\n\t\t\t\t\"_-_ AOE size up to 9x9 from 5x5\\n\" +\n\t\t\t\t\"_-_ Sheep duration up to 12-16 from 8-16\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The Mage continues to do too well in the early game since the talent changes in v0.9.1. Rather than weakening his talents and other magical abilities more, I've decided to make him more reliant on them instead by reducing his melee damage.\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-7 from 1-8.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Armor Ability Nerfs\",\n\t\t\t\t\"I focused mostly on buffs this update, but a few abilities and talents do need to be scaled back a little:\\n\\n\" +\n\t\t\t\t\"_- Double Jump_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Telefrag_ self damage increased to a flat 5 per level.\\n\\n\" +\n\t\t\t\t\"_- Smoke Bomb_ max range reduced to 6 tiles from 8.\\n\" +\n\t\t\t\t\"_- Body Replacement_ armor reduced to 1-3 per level, from 1-5.\\n\" +\n\t\t\t\t\"_- Hasty Retreat_ turns of haste/invis reduced to 1/2/3/4 from 2/3/4/5\\n\" +\n\t\t\t\t\"_- Shadow Step_ charge cost reduction down to 20/36/50/60%, from 24/42/56/67%.\\n\\n\" +\n\t\t\t\t\"_- Double Mark_ charge cost reduction down to 30/50/65/75%, from 33/55/70/80%.\\n\\n\" +\n\t\t\t\t\"_- 13th armor ability_ now only lasts for 6 turns, but also no longer prevents EXP or item drops. I'm trying to retain the ability's core theme while making it a bit less effective at totally removing enemies.\\n\" +\n\t\t\t\t\"_- resistance talent_ damage reduction reduced to 10/19/27/35%, from 10/20/30/40%.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v1_1_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v1.1\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released December 10th, 2021\\n\" +\n\t\t\t\t\"_-_ 115 days after Shattered v1.0.0\\n\" +\n\t\t\t\t\"Expect dev commentary here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ENERGY), \"Alchemical Energy Overhaul\",\n\t\t\t\t\"_The role of Alchemical Energy in the alchemy system has been totally overhauled!_\\n\\n\" +\n\t\t\t\t\"Energy is now a resource that the player carries with themselves, like gold. The game also generates much less energy for free, but more can be created by scrapping consumable items.\\n\\n\" +\n\t\t\t\t\"Many recipes have been adjusted to compensate for this. Exotic potions and scrolls now require energy instead of seeds/stones, and several of them have been buffed or totally redesigned (see buffs and changes sections for more details).\\n\\n\" +\n\t\t\t\t\"Other recipes have received relatively minor changes for now (mostly energy cost tweaks), but I'll likely be giving them more attention soon in future updates.\\n\\n\" +\n\t\t\t\t\"This repositions energy as the primary driving force for alchemy, and should make the system both more flexible and better at recycling consumables the player doesn't want into ones that they do.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.SUMMON_ELE), \"New and Reworked Spells\",\n\t\t\t\t\"While this update mostly focused changes on exotic potions and scrolls, there are _two new spells, and one totally redesigned spell:_\\n\\n\" +\n\t\t\t\t\"_Summon Elemental_ requires fresh embers and an arcane catalyst. It can be used to summon a friendly elemental to fight for you, and can even be powered up with other items!\\n\\n\" +\n\t\t\t\t\"_Telekinetic Grab_ requires some liquid metal and an arcane catalyst. It can be used to grab items remotely, even thrown items that are stuck to an enemy!\\n\\n\" +\n\t\t\t\t\"_Alchemize_ has been totally redesigned. It now only requires an arcane catalyst, and is used to convert items into gold or alchemical energy on the go. I'm really hoping this spell helps with inventory management.\\n\\n\" +\n\t\t\t\t\"Because of the redesign to alchemize, the merchant's beacon and magical porter are made mostly redundant and have been removed from the game. Shops now sell a few uses of alchemize instead.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"more new music!\",\n\t\t\t\t\"_The game now has a music track for each of the five dungeon regions!_\\n\\n\" +\n\t\t\t\t\"Just like the remastered tracks from v1.0.0, they are all composed by Kristjan Harristo, check the about scene for more details on them.\\n\\n\" +\n\t\t\t\t\"Each of these tracks use a similar variable looping method to the sewers track, to try and reduce repetitiveness.\\n\\n\" +\n\t\t\t\t\"There have also been some small tweaks made to the existing sewers and title theme tracks.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_ISAZ), \"Exotic Reworks\",\n\t\t\t\t\"Several exotic potions and scrolls have been redesigned to be more powerful and worth using:\\n\\n\" +\n\t\t\t\t\"_- Potion of Holy Furor_ is now _Potion of Divine Inspiration_, which gives bonus talent points.\\n\" +\n\t\t\t\t\"_- Potion of Adrenaline Surge_ is now _Potion of Mastery_, which reduces the strength requirement of one item by 2.\\n\\n\" +\n\t\t\t\t\"_- Scroll of Petrification_ is now _Scroll of Dread_, which causes enemies to flee the dungeon entirely.\\n\" +\n\t\t\t\t\"_- Scroll of Affection_ is now _Scroll of Siren's Song_, which permanently makes an enemy into an ally.\\n\" +\n\t\t\t\t\"_- Scroll of Confusion_ is now _Scroll of Challenge_, which attracts enemies but creates an arena where you take reduced damage.\\n\" +\n\t\t\t\t\"_- Scroll of Polymorph_ is now _Scroll of Metamorphosis_, which lets you swap out a talent to one from another class.\" ));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Item drops and special room spawns are now more consistent. Getting loads of the same item is now much less likely.\\n\" +\n\t\t\t\t\"_-_ Items present on boss floors are now preserved if the hero is revived from an unblessed ankh\\n\" +\n\t\t\t\t\"_-_ Teleport mechanics now work on boss levels\\n\" +\n\t\t\t\t\"_-_ Traps that teleport no longer work on items in chests or similar containers\\n\" +\n\t\t\t\t\"_-_ Rewards from piranha and trap rooms now always appear in chests\\n\\n\" +\n\n\t\t\t\t\"_-_ Tipped darts can now be transmuted and recycled\\n\" +\n\t\t\t\t\"_-_ Thrown weapons no longer stick to allies\\n\" +\n\t\t\t\t\"_-_ Liquid metal production from upgraded thrown weapons now caps at +3\\n\\n\" +\n\n\t\t\t\t\"_-_ Updated game icons on Android and Desktop platforms\\n\" +\n\t\t\t\t\"_-_ Tabs in rankings and hero info windows now use icons, not text\\n\" +\n\t\t\t\t\"_-_ 'potions cooked' badge and stats are now 'items crafted'\\n\\n\" +\n\n\t\t\t\t\"_-_ Newborn elementals no longer have a ranged attack\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor/rare visual and textual errors\\n\" +\n\t\t\t\t\"_-_ Cases where pausing/resuming the game at precise moments would cancel animations or attacks\\n\" +\n\t\t\t\t\"_-_ Endure damage reduction applying after some specific other damage-reducing effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh resurrection windows disappearing in some cases\\n\" +\n\t\t\t\t\"_-_ Lucky enchantment rarely not trigger in some cases\\n\" +\n\t\t\t\t\"_-_ Artifacts spawning upgraded from golden mimics\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival cancelling corpse dust curse\\n\" +\n\t\t\t\t\"_-_ Unstable spellbook letting the player select unidentified scrolls\\n\" +\n\t\t\t\t\"_-_ Desktop version not working correctly with FreeBSD\\n\" +\n\t\t\t\t\"_-_ Liquid metal being usable on darts\\n\" +\n\t\t\t\t\"_-_ Teleportation working on immovable characters in some cases\\n\" +\n\t\t\t\t\"_-_ Various quirks with thrown weapon durability\\n\" +\n\t\t\t\t\"_-_ Rare cases where ghouls would get many extra turns when reviving\\n\" +\n\t\t\t\t\"_-_ Magical infusion not preserving curses on armor\\n\" +\n\t\t\t\t\"_-_ Vertigo and teleportation effects rarely interfering\\n\" +\n\t\t\t\t\"_-_ Layout issues in the hero info window with long buff names\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Cursed wands being usable to create arcane resin\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revival rarely causing crashes or placing the player on hazards\\n\" +\n\t\t\t\t\"_-_ Some glyphs not working for armored statues or the ghost hero\\n\" +\n\t\t\t\t\"_-_ Various oddities with inferno gas logic\\n\" +\n\t\t\t\t\"_-_ Spirit bow having negative damage values in rare cases\\n\" +\n\t\t\t\t\"_-_ Artifact recharging buff working on cursed artifacts\\n\" +\n\t\t\t\t\"_-_ Scrolls of upgrade revealing whether unidentified rings/wands were cursed\\n\" +\n\t\t\t\t\"_-_ Ring of Might not updating hero health total in rare cases\\n\" +\n\t\t\t\t\"_-_ Specific cases where darts would not recognize an equipped crossbow\\n\" +\n\t\t\t\t\"_-_ Cap on regrowth wand being affect by level boosts\\n\" +\n\t\t\t\t\"_-_ Some on-hit effects not triggering on ghost or armored statues\\n\" +\n\t\t\t\t\"_-_ Rare errors when gateway traps teleported multiple things at once\\n\" +\n\t\t\t\t\"_-_ Various rare errors when multiple inputs were given in the same frame\\n\" +\n\t\t\t\t\"_-_ Fog of War errors in Tengu's arena\\n\" +\n\t\t\t\t\"_-_ Rare errors with sheep spawning items and traps\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.EXOTIC_AMBER), \"Exotic Buffs\",\n\t\t\t\t\"Some exotic potions and scrolls have received more minor buffs, and not total redesigns:\\n\\n\" +\n\t\t\t\t\"_- Potions of Storm Clouds, Shrouding Fog, and Corrosion_ initial gas AOE up to 3x3 from 1x1\\n\" +\n\t\t\t\t\"_- Potion of Shrouding Fog_ now only blocks enemy vision\\n\" +\n\t\t\t\t\"_- Potion of Corrosion_ starting damage increased by 1\\n\" +\n\t\t\t\t\"_- Potion of Magical Sight_ vision range up to 12 from 8\\n\" +\n\t\t\t\t\"_- Potion of Cleansing_ now applies debuff immunity for 5 turns\\n\\n\" +\n\t\t\t\t\"_- Scroll of Foresight_ now increases detection range to 8 (from 2), but lasts 250 turns (from 600)\\n\" +\n\t\t\t\t\"_- Scroll of Prismatic Image_ hp +2 and damage +20%\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_TOOLKIT), \"Artifact Buffs\",\n\t\t\t\t\"The _Alchemist's Toolkit_ has received some minor changes to go along with the energy system adjustments:\\n\" +\n\t\t\t\t\"_-_ Toolkit indirectly buffed by energy now being more valuable\\n\" +\n\t\t\t\t\"_-_ Energy required to level up toolkit halved, kit can now be levelled anywhere\\n\" +\n\t\t\t\t\"_-_ Toolkit warmup is now based on time, and gets faster as it levels up\\n\" +\n\t\t\t\t\"_-_ Toolkit can now be used when enemies are near\\n\\n\" +\n\t\t\t\t\"The _Horn of Plenty_ is getting a change to increase its flexibility, and to make it better synergize with food eating talents:\\n\" +\n\t\t\t\t\"_-_ The horn now has a 'snack' option that always consumes 1 charge\\n\" +\n\t\t\t\t\"_-_ To counterbalance this, the total number of charges and charge speed have been halved, but each charge is worth twice as much as before.\\n\\n\" +\n\t\t\t\t\"I'm giving a mild buff to the _Dried Rose_ to fix an odd inconsistency where it was better to kill the ghost off than let them heal:\\n\" +\n\t\t\t\t\"_-_ Ghost HP regen doubled, to match the roses recharge speed (500 turns to full HP)\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.WARRIOR, 0, 90, 12, 15), HeroSubClass.BERSERKER.title(),\n\t\t\t\t\"The berserker is getting a small QOL buff to make it easier to hold onto rage in combat:\\n\\n\" +\n\t\t\t\t\"_-_ Rage now starts expiring after not taking damage for 2 turns, instead of immediately.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CROWN, null), \"Talent and Ability Buffs\",\n\t\t\t\t\"Talent and ability balance is becoming more stable now, but I've still got a few buffs to hand out, some are quite significant:\\n\\n\" +\n\t\t\t\t\"_- Wild Magic_ Charge cost reduced to 25, from 35.\\n\" +\n\t\t\t\t\"_- Spirit Hawk_ Duration up to 100 turns, from 60.\\n\\n\" +\n\t\t\t\t\"_- Empowering Scrolls_ now lasts for 2 wand zaps, up from 1.\\n\" +\n\t\t\t\t\"_- Light Cloak_ now grants 16.6% charge speed per rank, up from 13.3%\\n\" +\n\t\t\t\t\"_- Shrug it Off_ now caps damage taken at 20% at +4, up from 25%.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new MagesStaff(),\n\t\t\t\t\"The reduction to the Mage's starting melee damage in v1.0.0 had a good effect on his early game winrate, but it's still notably higher than other heroes. So, I'm nudging his early melee power down one more time:\\n\\n\" +\n\t\t\t\t\"_- Mage's Staff_ base damage reduced to 1-6 from 1-7.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), HeroSubClass.ASSASSIN.title(),\n\t\t\t\t\"The Assassin is doing very well right now, especially after the power boost he can receive from smoke bomb or death mark. I'm scaling back his core power a little to try and reign him in a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Preparation bonus damage at power level 1/2/3/4 reduced to 10/20/35/50%, from 15/30/45/60%\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalentIcon(Talent.DOUBLE_JUMP.icon()), Talent.DOUBLE_JUMP.title(),\n\t\t\t\t\"Just one talent/ability nerf this time! I'm scaling double jump back a bit to put it more in line with the other heroic leap talents:\\n\\n\" +\n\t\t\t\t\"_-_ Charge cost reduction now caps at 50%, down from 60%\\n\" +\n\t\t\t\t\"_-_ The warrior must now jump again within 3 turns, down from 5\\n\\n\" +\n\t\t\t\t\"I'll likely making more balance tweaks (including nerfs) to abilities and talents in the future, but at the moment double jump is the only major standout.\"));\n\n\t}",
          "uniqueId": "7f29a03078647ea503d3c866476568511aa5af84_24_268_56_214_216_389"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b1b887f2645e6dc20183f029b6c670562049e2b8",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b1b887f2645e6dc20183f029b6c670562049e2b8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void move( int step ) {\n\n\t\tif (Dungeon.level.adjacent( step, pos ) && buff( Vertigo.class ) != null) {\n\t\t\tsprite.interruptMotion();\n\t\t\tint newPos = pos + PathFinder.NEIGHBOURS8[Random.Int( 8 )];\n\t\t\tif (!(Dungeon.level.passable[newPos] || Dungeon.level.avoid[newPos])\n\t\t\t\t\t|| (properties().contains(Property.LARGE) && !Dungeon.level.openSpace[newPos])\n\t\t\t\t\t|| Actor.findChar( newPos ) != null)\n\t\t\t\treturn;\n\t\t\telse {\n\t\t\t\tsprite.move(pos, newPos);\n\t\t\t\tstep = newPos;\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.level.map[pos] == Terrain.OPEN_DOOR) {\n\t\t\tDoor.leave( pos );\n\t\t}\n\n\t\tpos = step;\n\t\t\n\t\tif (this != Dungeon.hero) {\n\t\t\tsprite.visible = Dungeon.level.heroFOV[pos];\n\t\t}\n\t\t\n\t\tDungeon.level.occupyCell(this );\n\t}",
          "sourceCodeAfterRefactoring": "public void move( int step ) {\n\t\tmove( step, true );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void move( int step, boolean travelling ) {\n\n\t\tif (travelling && Dungeon.level.adjacent( step, pos ) && buff( Vertigo.class ) != null) {\n\t\t\tsprite.interruptMotion();\n\t\t\tint newPos = pos + PathFinder.NEIGHBOURS8[Random.Int( 8 )];\n\t\t\tif (!(Dungeon.level.passable[newPos] || Dungeon.level.avoid[newPos])\n\t\t\t\t\t|| (properties().contains(Property.LARGE) && !Dungeon.level.openSpace[newPos])\n\t\t\t\t\t|| Actor.findChar( newPos ) != null)\n\t\t\t\treturn;\n\t\t\telse {\n\t\t\t\tsprite.move(pos, newPos);\n\t\t\t\tstep = newPos;\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.level.map[pos] == Terrain.OPEN_DOOR) {\n\t\t\tDoor.leave( pos );\n\t\t}\n\n\t\tpos = step;\n\t\t\n\t\tif (this != Dungeon.hero) {\n\t\t\tsprite.visible = Dungeon.level.heroFOV[pos];\n\t\t}\n\t\t\n\t\tDungeon.level.occupyCell(this );\n\t}",
          "uniqueId": "b1b887f2645e6dc20183f029b6c670562049e2b8_793_819_798_824_793_795"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "816d5fcd0e719d2d56deec0fb54b1fbf11886939",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/816d5fcd0e719d2d56deec0fb54b1fbf11886939",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void initClassTalents( HeroClass cls, ArrayList<LinkedHashMap<Talent, Integer>> talents ){\n\t\twhile (talents.size() < MAX_TALENT_TIERS){\n\t\t\ttalents.add(new LinkedHashMap<>());\n\t\t}\n\n\t\tArrayList<Talent> tierTalents = new ArrayList<>();\n\n\t\t//tier 1\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HEARTY_MEAL, ARMSMASTERS_INTUITION, TEST_SUBJECT, IRON_WILL);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, EMPOWERING_MEAL, SCHOLARS_INTUITION, TESTED_HYPOTHESIS, BACKUP_BARRIER);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, CACHED_RATIONS, THIEFS_INTUITION, SUCKER_PUNCH, PROTECTIVE_SHADOWS);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, NATURES_BOUNTY, SURVIVALISTS_INTUITION, FOLLOWUP_STRIKE, NATURES_AID);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\ttalents.get(0).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 2\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, IRON_STOMACH, RESTORED_WILLPOWER, RUNIC_TRANSFERENCE, LETHAL_MOMENTUM, IMPROVISED_PROJECTILES);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, ENERGIZING_MEAL, ENERGIZING_UPGRADE, WAND_PRESERVATION, ARCANE_VISION, SHIELD_BATTERY);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, MYSTICAL_MEAL, MYSTICAL_UPGRADE, WIDE_SEARCH, SILENT_STEPS, ROGUES_FORESIGHT);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, INVIGORATING_MEAL, RESTORED_NATURE, REJUVENATING_STEPS, HEIGHTENED_SENSES, DURABLE_PROJECTILES);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\ttalents.get(1).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 3\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HOLD_FAST, STRONGMAN);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, EMPOWERING_SCROLLS, ALLY_WARP);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, ENHANCED_RINGS, LIGHT_CLOAK);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, POINT_BLANK, SEER_SHOT);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\ttalents.get(2).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier4\n\t\t//TBD\n\t}",
          "sourceCodeAfterRefactoring": "public static void initClassTalents( HeroClass cls, ArrayList<LinkedHashMap<Talent, Integer>> talents){\n\t\tinitClassTalents( cls, talents, new LinkedHashMap<>());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void initClassTalents( HeroClass cls, ArrayList<LinkedHashMap<Talent, Integer>> talents, LinkedHashMap<Talent, Talent> replacements ){\n\t\twhile (talents.size() < MAX_TALENT_TIERS){\n\t\t\ttalents.add(new LinkedHashMap<>());\n\t\t}\n\n\t\tArrayList<Talent> tierTalents = new ArrayList<>();\n\n\t\t//tier 1\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HEARTY_MEAL, ARMSMASTERS_INTUITION, TEST_SUBJECT, IRON_WILL);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, EMPOWERING_MEAL, SCHOLARS_INTUITION, TESTED_HYPOTHESIS, BACKUP_BARRIER);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, CACHED_RATIONS, THIEFS_INTUITION, SUCKER_PUNCH, PROTECTIVE_SHADOWS);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, NATURES_BOUNTY, SURVIVALISTS_INTUITION, FOLLOWUP_STRIKE, NATURES_AID);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\tif (replacements.containsKey(talent)){\n\t\t\t\ttalent = replacements.get(talent);\n\t\t\t}\n\t\t\ttalents.get(0).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 2\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, IRON_STOMACH, RESTORED_WILLPOWER, RUNIC_TRANSFERENCE, LETHAL_MOMENTUM, IMPROVISED_PROJECTILES);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, ENERGIZING_MEAL, ENERGIZING_UPGRADE, WAND_PRESERVATION, ARCANE_VISION, SHIELD_BATTERY);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, MYSTICAL_MEAL, MYSTICAL_UPGRADE, WIDE_SEARCH, SILENT_STEPS, ROGUES_FORESIGHT);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, INVIGORATING_MEAL, RESTORED_NATURE, REJUVENATING_STEPS, HEIGHTENED_SENSES, DURABLE_PROJECTILES);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\tif (replacements.containsKey(talent)){\n\t\t\t\ttalent = replacements.get(talent);\n\t\t\t}\n\t\t\ttalents.get(1).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 3\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HOLD_FAST, STRONGMAN);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, EMPOWERING_SCROLLS, ALLY_WARP);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, ENHANCED_RINGS, LIGHT_CLOAK);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, POINT_BLANK, SEER_SHOT);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\tif (replacements.containsKey(talent)){\n\t\t\t\ttalent = replacements.get(talent);\n\t\t\t}\n\t\t\ttalents.get(2).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier4\n\t\t//TBD\n\t}",
          "uniqueId": "816d5fcd0e719d2d56deec0fb54b1fbf11886939_473_542_477_555_473_475"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d81141bd8bad459c0b3d867907d0ad38f48ec7c2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d81141bd8bad459c0b3d867907d0ad38f48ec7c2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean doPickUp( Hero hero ) {\n\t\tif (collect( hero.belongings.backpack )) {\n\t\t\t\n\t\t\tGameScene.pickUp( this, hero.pos );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.ITEM );\n\t\t\thero.spendAndNext( TIME_TO_PICK_UP );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public final boolean doPickUp( Hero hero ) {\n\t\treturn doPickUp( hero, hero.pos );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean doPickUp(Hero hero, int pos) {\n\t\tif (collect( hero.belongings.backpack )) {\n\t\t\t\n\t\t\tGameScene.pickUp( this, pos );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.ITEM );\n\t\t\thero.spendAndNext( TIME_TO_PICK_UP );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "uniqueId": "d81141bd8bad459c0b3d867907d0ad38f48ec7c2_115_126_117_128_113_115"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f28c15b84242c7e34a42eb3608a550f177694bfd",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f28c15b84242c7e34a42eb3608a550f177694bfd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\t\t\n\t\tint health = Dungeon.hero.HP;\n\t\tint shield = Dungeon.hero.shielding();\n\t\tint max = Dungeon.hero.HT;\n\n\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\tavatar.tint(0x000000, 0.5f);\n\t\t} else if ((health/(float)max) < 0.3f) {\n\t\t\twarning += Game.elapsed * 5f *(0.4f - (health/(float)max));\n\t\t\twarning %= 1f;\n\t\t\tavatar.tint(ColorMath.interpolate(warning, warningColors), 0.5f );\n\t\t} else if (talentBlink > 0.33f){ //stops early so it doesn't end in the middle of a blink\n\t\t\ttalentBlink -= Game.elapsed;\n\t\t\tavatar.tint(1, 1, 0, (float)Math.abs(Math.cos(talentBlink*FLASH_RATE))/2f);\n\t\t} else {\n\t\t\tavatar.resetColor();\n\t\t}\n\n\t\thp.scale.x = Math.max( 0, (health-shield)/(float)max);\n\t\tshieldedHP.scale.x = health/(float)max;\n\t\trawShielding.scale.x = shield/(float)max;\n\n\t\tif (shield <= 0){\n\t\t\thpText.text(health + \"/\" + max);\n\t\t} else {\n\t\t\thpText.text(health + \"+\" + shield +  \"/\" + max);\n\t\t}\n\n\t\texp.scale.x = (width / exp.width) * Dungeon.hero.exp / Dungeon.hero.maxExp();\n\n\t\tif (Dungeon.hero.lvl != lastLvl) {\n\n\t\t\tif (lastLvl != -1) {\n\t\t\t\tEmitter emitter = (Emitter)recycle( Emitter.class );\n\t\t\t\temitter.revive();\n\t\t\t\temitter.pos( 27, 27 );\n\t\t\t\temitter.burst( Speck.factory( Speck.STAR ), 12 );\n\t\t\t}\n\n\t\t\tlastLvl = Dungeon.hero.lvl;\n\t\t\tlevel.text( Integer.toString( lastLvl ) );\n\t\t\tlevel.measure();\n\t\t\tlevel.x = 27.5f - level.width() / 2f;\n\t\t\tlevel.y = 28.0f - level.baseLine() / 2f;\n\t\t\tPixelScene.align(level);\n\t\t}\n\n\t\tint tier = Dungeon.hero.tier();\n\t\tif (tier != lastTier) {\n\t\t\tlastTier = tier;\n\t\t\tavatar.copy( HeroSprite.avatar( Dungeon.hero.heroClass, tier ) );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void update() {\n\t\tsuper.update();\n\t\t\n\t\tint health = Dungeon.hero.HP;\n\t\tint shield = Dungeon.hero.shielding();\n\t\tint max = Dungeon.hero.HT;\n\n\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\tavatar.tint(0x000000, 0.5f);\n\t\t} else if ((health/(float)max) < 0.3f) {\n\t\t\twarning += Game.elapsed * 5f *(0.4f - (health/(float)max));\n\t\t\twarning %= 1f;\n\t\t\tavatar.tint(ColorMath.interpolate(warning, warningColors), 0.5f );\n\t\t} else if (talentBlink > 0.33f){ //stops early so it doesn't end in the middle of a blink\n\t\t\ttalentBlink -= Game.elapsed;\n\t\t\tavatar.tint(1, 1, 0, (float)Math.abs(Math.cos(talentBlink*FLASH_RATE))/2f);\n\t\t} else {\n\t\t\tavatar.resetColor();\n\t\t}\n\n\t\thp.scale.x = Math.max( 0, (health-shield)/(float)max);\n\t\tshieldedHP.scale.x = health/(float)max;\n\t\trawShielding.scale.x = shield/(float)max;\n\n\t\tif (shield <= 0){\n\t\t\thpText.text(health + \"/\" + max);\n\t\t} else {\n\t\t\thpText.text(health + \"+\" + shield +  \"/\" + max);\n\t\t}\n\n\t\texp.scale.x = (width / exp.width) * Dungeon.hero.exp / Dungeon.hero.maxExp();\n\n\t\tif (Dungeon.hero.lvl != lastLvl) {\n\n\t\t\tif (lastLvl != -1) {\n\t\t\t\tshowStarParticles();\n\t\t\t}\n\n\t\t\tlastLvl = Dungeon.hero.lvl;\n\t\t\tlevel.text( Integer.toString( lastLvl ) );\n\t\t\tlevel.measure();\n\t\t\tlevel.x = 27.5f - level.width() / 2f;\n\t\t\tlevel.y = 28.0f - level.baseLine() / 2f;\n\t\t\tPixelScene.align(level);\n\t\t}\n\n\t\tint tier = Dungeon.hero.tier();\n\t\tif (tier != lastTier) {\n\t\t\tlastTier = tier;\n\t\t\tavatar.copy( HeroSprite.avatar( Dungeon.hero.heroClass, tier ) );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void showStarParticles(){\n\t\tEmitter emitter = (Emitter)recycle( Emitter.class );\n\t\temitter.revive();\n\t\temitter.pos( 27, 27 );\n\t\temitter.burst( Speck.factory( Speck.STAR ), 12 );\n\t}",
          "uniqueId": "f28c15b84242c7e34a42eb3608a550f177694bfd_208_263_262_267_208_260"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8d0630a607c38a1e830ec96fdb910518dbd07d6a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8d0630a607c38a1e830ec96fdb910518dbd07d6a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onItemSelected(Item item) {\n\t\t\n\t\tItem result;\n\t\t\n\t\tif (item instanceof MagesStaff) {\n\t\t\tresult = changeStaff( (MagesStaff)item );\n\t\t} else if (item instanceof MeleeWeapon || item instanceof MissileWeapon) {\n\t\t\tresult = changeWeapon( (Weapon)item );\n\t\t} else if (item instanceof Scroll) {\n\t\t\tresult = changeScroll( (Scroll)item );\n\t\t} else if (item instanceof Potion) {\n\t\t\tresult = changePotion( (Potion)item );\n\t\t} else if (item instanceof Ring) {\n\t\t\tresult = changeRing( (Ring)item );\n\t\t} else if (item instanceof Wand) {\n\t\t\tresult = changeWand( (Wand)item );\n\t\t} else if (item instanceof Plant.Seed) {\n\t\t\tresult = changeSeed((Plant.Seed) item);\n\t\t} else if (item instanceof Runestone) {\n\t\t\tresult = changeStone((Runestone) item);\n\t\t} else if (item instanceof Artifact) {\n\t\t\tresult = changeArtifact( (Artifact)item );\n\t\t} else {\n\t\t\tresult = null;\n\t\t}\n\t\t\n\t\tif (result == null){\n\t\t\t//This shouldn't ever trigger\n\t\t\tGLog.n( Messages.get(this, \"nothing\") );\n\t\t\tcurItem.collect( curUser.belongings.backpack );\n\t\t} else {\n\t\t\tif (item.isEquipped(Dungeon.hero)){\n\t\t\t\titem.cursed = false; //to allow it to be unequipped\n\t\t\t\t((EquipableItem)item).doUnequip(Dungeon.hero, false);\n\t\t\t\t((EquipableItem)result).doEquip(Dungeon.hero);\n\t\t\t} else {\n\t\t\t\titem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\tif (!result.collect()){\n\t\t\t\t\tDungeon.level.drop(result, curUser.pos).sprite.drop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isIdentified()){\n\t\t\t\tCatalog.setSeen(result.getClass());\n\t\t\t}\n\t\t\tTransmuting.show(curUser, item, result);\n\t\t\tcurUser.sprite.emitter().start(Speck.factory(Speck.CHANGE), 0.2f, 10);\n\t\t\tGLog.p( Messages.get(this, \"morph\") );\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onItemSelected(Item item) {\n\t\t\n\t\tItem result = changeItem(item);\n\t\t\n\t\tif (result == null){\n\t\t\t//This shouldn't ever trigger\n\t\t\tGLog.n( Messages.get(this, \"nothing\") );\n\t\t\tcurItem.collect( curUser.belongings.backpack );\n\t\t} else {\n\t\t\tif (item.isEquipped(Dungeon.hero)){\n\t\t\t\titem.cursed = false; //to allow it to be unequipped\n\t\t\t\t((EquipableItem)item).doUnequip(Dungeon.hero, false);\n\t\t\t\t((EquipableItem)result).doEquip(Dungeon.hero);\n\t\t\t} else {\n\t\t\t\titem.detach(Dungeon.hero.belongings.backpack);\n\t\t\t\tif (!result.collect()){\n\t\t\t\t\tDungeon.level.drop(result, curUser.pos).sprite.drop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result.isIdentified()){\n\t\t\t\tCatalog.setSeen(result.getClass());\n\t\t\t}\n\t\t\tTransmuting.show(curUser, item, result);\n\t\t\tcurUser.sprite.emitter().start(Speck.factory(Speck.CHANGE), 0.2f, 10);\n\t\t\tGLog.p( Messages.get(this, \"morph\") );\n\t\t}\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Item changeItem( Item item ){\n\t\tif (item instanceof MagesStaff) {\n\t\t\treturn changeStaff( (MagesStaff)item );\n\t\t} else if (item instanceof MeleeWeapon || item instanceof MissileWeapon) {\n\t\t\treturn changeWeapon( (Weapon)item );\n\t\t} else if (item instanceof Scroll) {\n\t\t\treturn changeScroll( (Scroll)item );\n\t\t} else if (item instanceof Potion) {\n\t\t\treturn changePotion( (Potion)item );\n\t\t} else if (item instanceof Ring) {\n\t\t\treturn changeRing( (Ring)item );\n\t\t} else if (item instanceof Wand) {\n\t\t\treturn changeWand( (Wand)item );\n\t\t} else if (item instanceof Plant.Seed) {\n\t\t\treturn changeSeed((Plant.Seed) item);\n\t\t} else if (item instanceof Runestone) {\n\t\t\treturn changeStone((Runestone) item);\n\t\t} else if (item instanceof Artifact) {\n\t\t\treturn changeArtifact( (Artifact)item );\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "8d0630a607c38a1e830ec96fdb910518dbd07d6a_75_125_105_127_75_103"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected Item affectItem( Item item, int pos ) {\n\t\t\n\t\tif (item instanceof MagesStaff) {\n\t\t\titem = changeStaff( (MagesStaff)item );\n\t\t} else if (item instanceof MeleeWeapon) {\n\t\t\titem = changeWeapon( (MeleeWeapon)item );\n\t\t} else if (item instanceof Scroll) {\n\t\t\titem = changeScroll( (Scroll)item );\n\t\t} else if (item instanceof Potion) {\n\t\t\titem = changePotion( (Potion)item );\n\t\t} else if (item instanceof Ring) {\n\t\t\titem = changeRing( (Ring)item );\n\t\t} else if (item instanceof Wand) {\n\t\t\titem = changeWand( (Wand)item );\n\t\t} else if (item instanceof Plant.Seed) {\n\t\t\titem = changeSeed( (Plant.Seed)item );\n\t\t} else if (item instanceof Artifact) {\n\t\t\titem = changeArtifact( (Artifact)item );\n\t\t} else {\n\t\t\titem = null;\n\t\t}\n\t\t\n\t\t//incase a never-seen item pops out\n\t\tif (item != null&& item.isIdentified()){\n\t\t\tCatalog.setSeen(item.getClass());\n\t\t}\n\n\t\treturn item;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected Item affectItem( Item item, int pos ) {\n\t\t\n\t\titem = ScrollOfTransmutation.changeItem(item);\n\t\t\n\t\t//incase a never-seen item pops out\n\t\tif (item != null&& item.isIdentified()){\n\t\t\tCatalog.setSeen(item.getClass());\n\t\t}\n\n\t\treturn item;\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "8d0630a607c38a1e830ec96fdb910518dbd07d6a_50_80_105_127_51_63"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "313ad4751c5e1aec4769c2e5922606287520196c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/313ad4751c5e1aec4769c2e5922606287520196c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate( Char ch ) {\n\t\tif(wand != null) wand.charge( ch, STAFF_SCALE_FACTOR );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate( Char ch ) {\n\t\tapplyWandChargeBuff(ch);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void applyWandChargeBuff(Char owner){\n\t\tif (wand != null){\n\t\t\twand.charge(owner, STAFF_SCALE_FACTOR);\n\t\t}\n\t}",
          "uniqueId": "313ad4751c5e1aec4769c2e5922606287520196c_114_117_267_271_114_117"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean collect( Bag container ) {\n\t\tif (super.collect(container)) {\n\t\t\tif (container.owner != null && wand != null) {\n\t\t\t\twand.charge(container.owner, STAFF_SCALE_FACTOR);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean collect( Bag container ) {\n\t\tif (super.collect(container)) {\n\t\t\tif (container.owner != null) {\n\t\t\t\tapplyWandChargeBuff(container.owner);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void applyWandChargeBuff(Char owner){\n\t\tif (wand != null){\n\t\t\twand.charge(owner, STAFF_SCALE_FACTOR);\n\t\t}\n\t}",
          "uniqueId": "313ad4751c5e1aec4769c2e5922606287520196c_189_199_267_271_189_199"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d776e83bb5b02e054bd6ab1092d32e910296cc3c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d776e83bb5b02e054bd6ab1092d32e910296cc3c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void zapWand( ArrayList<Wand> wands, Hero hero, int target){\n\t\tWand cur = wands.remove(0);\n\n\t\tBallistica aim = new Ballistica(hero.pos, target, cur.collisionProperties(target));\n\n\t\thero.sprite.zap(target);\n\t\tcur.fx(aim, new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tcur.onZap(aim);\n\t\t\t\tcur.partialCharge -= (float)Math.pow(0.67f, hero.pointsInTalent(Talent.CONSERVED_MAGIC));\n\t\t\t\tif (cur.partialCharge < 0){\n\t\t\t\t\tcur.partialCharge++;\n\t\t\t\t\tcur.curCharges--;\n\t\t\t\t}\n\t\t\t\tif (!wands.isEmpty()){\n\t\t\t\t\tzapWand(wands, hero, target);\n\t\t\t\t} else {\n\t\t\t\t\tif (hero.buff(WildMagicTracker.class) != null){\n\t\t\t\t\t\thero.buff(WildMagicTracker.class).detach();\n\t\t\t\t\t}\n\t\t\t\t\tItem.updateQuickslot();\n\t\t\t\t\tInvisibility.dispel();\n\t\t\t\t\thero.spendAndNext(Actor.TICK);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "private void zapWand( ArrayList<Wand> wands, Hero hero, int target){\n\t\tWand cur = wands.remove(0);\n\n\t\tBallistica aim = new Ballistica(hero.pos, target, cur.collisionProperties(target));\n\n\t\thero.sprite.zap(target);\n\n\t\tif (!cur.cursed) {\n\t\t\tcur.fx(aim, new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tafterZap(cur, wands, hero, target);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tCursedWand.cursedZap(cur,\n\t\t\t\t\thero,\n\t\t\t\t\tnew Ballistica(hero.pos, target, Ballistica.MAGIC_BOLT),\n\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tafterZap(cur, wands, hero, target);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void afterZap( Wand cur, ArrayList<Wand> wands, Hero hero, int target){\n\t\tcur.partialCharge -= (float) Math.pow(0.67f, hero.pointsInTalent(Talent.CONSERVED_MAGIC));\n\t\tif (cur.partialCharge < 0) {\n\t\t\tcur.partialCharge++;\n\t\t\tcur.curCharges--;\n\t\t}\n\t\tif (!wands.isEmpty()) {\n\t\t\tzapWand(wands, hero, target);\n\t\t} else {\n\t\t\tif (hero.buff(WildMagicTracker.class) != null) {\n\t\t\t\thero.buff(WildMagicTracker.class).detach();\n\t\t\t}\n\t\t\tItem.updateQuickslot();\n\t\t\tInvisibility.dispel();\n\t\t\thero.spendAndNext(Actor.TICK);\n\t\t}\n\t}",
          "uniqueId": "d776e83bb5b02e054bd6ab1092d32e910296cc3c_125_152_153_169_126_151"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "20226d29460daf6535f5d04eaa347bf454be77fb",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/20226d29460daf6535f5d04eaa347bf454be77fb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public BuffIcon(Buff buff, boolean large){\n\t\tthis(buff.icon(), large);\n\t\tbuff.tintIcon(this);\n\t}",
          "sourceCodeAfterRefactoring": "public BuffIcon(Buff buff, boolean large){\n\t\tsuper( large ? Assets.Interfaces.BUFFS_LARGE : Assets.Interfaces.BUFFS_SMALL );\n\t\tthis.large = large;\n\t\trefresh(buff);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void refresh(Buff buff){\n\t\trefresh(buff.icon());\n\t\tbuff.tintIcon(this);\n\t}",
          "uniqueId": "20226d29460daf6535f5d04eaa347bf454be77fb_17_20_31_34_19_23"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public BuffIcon(int icon, boolean large){\n\t\tsuper( large ? Assets.Interfaces.BUFFS_LARGE : Assets.Interfaces.BUFFS_SMALL );\n\n\t\tif (large){\n\t\t\tif (largeFilm == null) largeFilm = new TextureFilm(texture, LRG_SIZE, LRG_SIZE);\n\t\t\tframe(largeFilm.get(icon));\n\t\t} else {\n\t\t\tif (smallFilm == null ) smallFilm = new TextureFilm(texture, SML_SIZE, SML_SIZE);\n\t\t\tframe(smallFilm.get(icon));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public BuffIcon(int icon, boolean large){\n\t\tsuper( large ? Assets.Interfaces.BUFFS_LARGE : Assets.Interfaces.BUFFS_SMALL );\n\t\tthis.large = large;\n\t\trefresh(icon);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void refresh(int icon){\n\t\tif (large){\n\t\t\tif (largeFilm == null) largeFilm = new TextureFilm(texture, LRG_SIZE, LRG_SIZE);\n\t\t\tframe(largeFilm.get(icon));\n\t\t} else {\n\t\t\tif (smallFilm == null ) smallFilm = new TextureFilm(texture, SML_SIZE, SML_SIZE);\n\t\t\tframe(smallFilm.get(icon));\n\t\t}\n\t}",
          "uniqueId": "20226d29460daf6535f5d04eaa347bf454be77fb_22_32_36_44_25_29"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c50c012f8fb908683dbfd4f33bf00bdb423e6801",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c50c012f8fb908683dbfd4f33bf00bdb423e6801",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public synchronized void play( String assetName, boolean looping ) {\n\n\t\t//iOS cannot play ogg, so we use an mp3 alternative instead\n\t\tif (assetName != null && DeviceCompat.isiOS()){\n\t\t\tassetName = assetName.replace(\".ogg\", \".mp3\");\n\t\t}\n\t\t\n\t\tif (isPlaying() && lastPlayed != null && lastPlayed.equals( assetName )) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstop();\n\t\t\n\t\tlastPlayed = assetName;\n\t\tthis.looping = looping;\n\n\t\tif (!enabled || assetName == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tplayer = Gdx.audio.newMusic(Gdx.files.internal(assetName));\n\t\t\tplayer.setLooping(looping);\n\t\t\tplayer.setVolume(volume);\n\t\t\tplayer.play();\n\t\t} catch (Exception e){\n\t\t\tGame.reportException(e);\n\t\t\tplayer = null;\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "public synchronized void play( String assetName, boolean looping ) {\n\n\t\t//iOS cannot play ogg, so we use an mp3 alternative instead\n\t\tif (assetName != null && DeviceCompat.isiOS()){\n\t\t\tassetName = assetName.replace(\".ogg\", \".mp3\");\n\t\t}\n\t\t\n\t\tif (isPlaying() && lastPlayed != null && lastPlayed.equals( assetName )) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tstop();\n\t\t\n\t\tlastPlayed = assetName;\n\t\ttrackList = null;\n\n\t\tthis.looping = looping;\n\t\tthis.shuffle = false;\n\n\t\tif (!enabled || assetName == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tplay(assetName, null);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate synchronized void play(String track, com.badlogic.gdx.audio.Music.OnCompletionListener listener){\n\t\ttry {\n\t\t\tplayer = Gdx.audio.newMusic(Gdx.files.internal(track));\n\t\t\tplayer.setLooping(looping);\n\t\t\tplayer.setVolume(volume);\n\t\t\tplayer.play();\n\t\t\tif (listener != null) {\n\t\t\t\tplayer.setOnCompletionListener(listener);\n\t\t\t}\n\t\t} catch (Exception e){\n\t\t\tGame.reportException(e);\n\t\t\tplayer = null;\n\t\t}\n\t}",
          "uniqueId": "c50c012f8fb908683dbfd4f33bf00bdb423e6801_40_70_151_164_49_73"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2706ed0fdffaed1d80899db84555f5f4f5a1f0ee",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2706ed0fdffaed1d80899db84555f5f4f5a1f0ee",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private BadgeBanner( int index ) {\n\t\t\n\t\tsuper( Assets.Interfaces.BADGES );\n\t\t\n\t\tif (atlas == null) {\n\t\t\tatlas = new TextureFilm( texture, 16, 16 );\n\t\t}\n\t\t\n\t\tthis.index = index;\n\t\t\n\t\tframe( atlas.get( index ) );\n\t\torigin.set( width / 2, height / 2 );\n\t\t\n\t\talpha( 0 );\n\t\tscale.set( 2 * DEFAULT_SCALE );\n\t\t\n\t\tstate = State.FADE_IN;\n\t\ttime = FADE_IN_TIME;\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.BADGE );\n\t}",
          "sourceCodeAfterRefactoring": "private BadgeBanner( int index ) {\n\t\t\n\t\tsuper( Assets.Interfaces.BADGES );\n\t\t\n\t\tif (atlas == null) {\n\t\t\tatlas = new TextureFilm( texture, 16, 16 );\n\t\t}\n\t\t\n\t\tsetup(index);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void setup( int index ){\n\t\tthis.index = index;\n\t\t\n\t\tframe( atlas.get( index ) );\n\t\torigin.set( width / 2, height / 2 );\n\t\t\n\t\talpha( 0 );\n\t\tscale.set( 2 * DEFAULT_SCALE );\n\t\t\n\t\tstate = State.FADE_IN;\n\t\ttime = FADE_IN_TIME;\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.BADGE );\n\t}",
          "uniqueId": "2706ed0fdffaed1d80899db84555f5f4f5a1f0ee_56_76_67_80_56_65"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f6ed111b3e5fcc5e37e79c1ce906308c2bb842fe",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f6ed111b3e5fcc5e37e79c1ce906308c2bb842fe",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public RatKingSprite() {\n\t\tsuper();\n\n\t\tfinal Calendar calendar = Calendar.getInstance();\n\t\t//once a year the rat king feels a bit festive!\n\t\tfestive = (calendar.get(Calendar.MONTH) == Calendar.DECEMBER\n\t\t\t\t&& calendar.get(Calendar.WEEK_OF_MONTH) > 2);\n\n\t\tfinal int c = festive ? 8 : 0;\n\t\t\n\t\ttexture( Assets.Sprites.RATKING );\n\t\t\n\t\tTextureFilm frames = new TextureFilm( texture, 16, 17 );\n\t\t\n\t\tidle = new Animation( 2, true );\n\t\tidle.frames( frames, c+0, c+0, c+0, c+1 );\n\t\t\n\t\trun = new Animation( 10, true );\n\t\trun.frames( frames, c+2, c+3, c+4, c+5, c+6 );\n\t\t\n\t\tattack = new Animation( 15, false );\n\t\tattack.frames( frames, c+0 );\n\t\t\n\t\tdie = new Animation( 10, false );\n\t\tdie.frames( frames, c+0 );\n\t\t\n\t\tplay( idle );\n\t}",
          "sourceCodeAfterRefactoring": "public RatKingSprite() {\n\t\tsuper();\n\n\t\tresetAnims();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void resetAnims(){\n\n\t\tfinal Calendar calendar = Calendar.getInstance();\n\t\t//once a year the rat king feels a bit festive!\n\t\tfestive = (calendar.get(Calendar.MONTH) == Calendar.DECEMBER\n\t\t\t\t&& calendar.get(Calendar.WEEK_OF_MONTH) > 2);\n\n\t\tint c = festive ? 8 : 0;\n\n\t\tif (Dungeon.hero != null && Dungeon.hero.armorAbility instanceof Ratmogrify){\n\t\t\tc += 16;\n\t\t\tif (parent != null) aura(0xFFFF00);\n\t\t}\n\n\t\ttexture( Assets.Sprites.RATKING );\n\n\t\tTextureFilm frames = new TextureFilm( texture, 16, 17 );\n\n\t\tidle = new Animation( 2, true );\n\t\tidle.frames( frames, c+0, c+0, c+0, c+1 );\n\n\t\trun = new Animation( 10, true );\n\t\trun.frames( frames, c+2, c+3, c+4, c+5, c+6 );\n\n\t\tattack = new Animation( 15, false );\n\t\tattack.frames( frames, c+0 );\n\n\t\tdie = new Animation( 10, false );\n\t\tdie.frames( frames, c+0 );\n\n\t\tplay( idle );\n\n\t}",
          "uniqueId": "f6ed111b3e5fcc5e37e79c1ce906308c2bb842fe_33_60_42_74_36_40"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d3ebcd0f4b81d31649f1c5690df0828849ab3b58",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d3ebcd0f4b81d31649f1c5690df0828849ab3b58",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\n\t\tint preHP = HP;\n\t\tsuper.damage( dmg, src );\n\n\t\tif (phase == 0 || findFist() != null) return;\n\n\t\tif (phase < 4) {\n\t\t\tHP = Math.max(HP, HT - 300 * phase);\n\t\t} else if (phase == 4) {\n\t\t\tHP = Math.max(HP, 100);\n\t\t}\n\t\tint dmgTaken = preHP - HP;\n\n\t\tif (dmgTaken > 0) {\n\t\t\tabilityCooldown -= dmgTaken / 10f;\n\t\t\tsummonCooldown -= dmgTaken / 10f;\n\t\t}\n\n\t\tif (phase < 4 && HP <= HT - 300*phase){\n\n\t\t\tphase++;\n\n\t\t\tupdateVisibility(Dungeon.level);\n\t\t\tGLog.n(Messages.get(this, \"darkness\"));\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\n\t\t\tYogFist fist = (YogFist) Reflection.newInstance(fistSummons.remove(0));\n\t\t\tfist.pos = Dungeon.level.exit;\n\n\t\t\tCellEmitter.get(Dungeon.level.exit-1).burst(ShadowParticle.UP, 25);\n\t\t\tCellEmitter.get(Dungeon.level.exit).burst(ShadowParticle.UP, 100);\n\t\t\tCellEmitter.get(Dungeon.level.exit+1).burst(ShadowParticle.UP, 25);\n\n\t\t\tif (abilityCooldown < 5) abilityCooldown = 5;\n\t\t\tif (summonCooldown < 5) summonCooldown = 5;\n\n\t\t\tint targetPos = Dungeon.level.exit + Dungeon.level.width();\n\t\t\tif (Actor.findChar(targetPos) == null){\n\t\t\t\tfist.pos = targetPos;\n\t\t\t} else if (Actor.findChar(targetPos-1) == null){\n\t\t\t\tfist.pos = targetPos-1;\n\t\t\t} else if (Actor.findChar(targetPos+1) == null){\n\t\t\t\tfist.pos = targetPos+1;\n\t\t\t}\n\n\t\t\tGameScene.add(fist, 4);\n\t\t\tActor.addDelayed( new Pushing( fist, Dungeon.level.exit, fist.pos ), -1 );\n\t\t}\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null) lock.addTime(dmgTaken);\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\n\t\tint preHP = HP;\n\t\tsuper.damage( dmg, src );\n\n\t\tif (phase == 0 || findFist() != null) return;\n\n\t\tif (phase < 4) {\n\t\t\tHP = Math.max(HP, HT - 300 * phase);\n\t\t} else if (phase == 4) {\n\t\t\tHP = Math.max(HP, 100);\n\t\t}\n\t\tint dmgTaken = preHP - HP;\n\n\t\tif (dmgTaken > 0) {\n\t\t\tabilityCooldown -= dmgTaken / 10f;\n\t\t\tsummonCooldown -= dmgTaken / 10f;\n\t\t}\n\n\t\tif (phase < 4 && HP <= HT - 300*phase){\n\n\t\t\tphase++;\n\n\t\t\tupdateVisibility(Dungeon.level);\n\t\t\tGLog.n(Messages.get(this, \"darkness\"));\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\n\t\t\taddFist((YogFist)Reflection.newInstance(fistSummons.remove(0)));\n\n\t\t\tif (Dungeon.isChallenged(Challenges.STRONGER_BOSSES)){\n\t\t\t\taddFist((YogFist)Reflection.newInstance(challengeSummons.remove(0)));\n\t\t\t}\n\n\t\t\tCellEmitter.get(Dungeon.level.exit-1).burst(ShadowParticle.UP, 25);\n\t\t\tCellEmitter.get(Dungeon.level.exit).burst(ShadowParticle.UP, 100);\n\t\t\tCellEmitter.get(Dungeon.level.exit+1).burst(ShadowParticle.UP, 25);\n\n\t\t\tif (abilityCooldown < 5) abilityCooldown = 5;\n\t\t\tif (summonCooldown < 5) summonCooldown = 5;\n\n\t\t}\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null) lock.addTime(dmgTaken);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void addFist(YogFist fist){\n\t\tfist.pos = Dungeon.level.exit;\n\n\t\tCellEmitter.get(Dungeon.level.exit-1).burst(ShadowParticle.UP, 25);\n\t\tCellEmitter.get(Dungeon.level.exit).burst(ShadowParticle.UP, 100);\n\t\tCellEmitter.get(Dungeon.level.exit+1).burst(ShadowParticle.UP, 25);\n\n\t\tif (abilityCooldown < 5) abilityCooldown = 5;\n\t\tif (summonCooldown < 5) summonCooldown = 5;\n\n\t\tint targetPos = Dungeon.level.exit + Dungeon.level.width();\n\n\t\tif (!Dungeon.isChallenged(Challenges.STRONGER_BOSSES)\n\t\t\t\t&& Actor.findChar(targetPos) == null){\n\t\t\tfist.pos = targetPos;\n\t\t} else if (Actor.findChar(targetPos-1) == null){\n\t\t\tfist.pos = targetPos-1;\n\t\t} else if (Actor.findChar(targetPos+1) == null){\n\t\t\tfist.pos = targetPos+1;\n\t\t} else if (Actor.findChar(targetPos) == null){\n\t\t\tfist.pos = targetPos;\n\t\t}\n\n\t\tGameScene.add(fist, 4);\n\t\tActor.addDelayed( new Pushing( fist, Dungeon.level.exit, fist.pos ), -1 );\n\t}",
          "uniqueId": "d3ebcd0f4b81d31649f1c5690df0828849ab3b58_297_351_383_408_335_381"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8e84b017388c5cfe2fe18f1354e5f7bab541c6c0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8e84b017388c5cfe2fe18f1354e5f7bab541c6c0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void wandHeal( int wandLevel ){\n\t\t\tif (this.wandLevel < wandLevel){\n\t\t\t\tthis.wandLevel = wandLevel;\n\t\t\t}\n\n\t\t\tint heal;\n\t\t\tswitch(tier){\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t\tcase 4:\n\t\t\t\t\theal = 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\theal = 12;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\theal = 16;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tHP = Math.min(HT, HP+heal);\n\t\t\tif (sprite != null) sprite.showStatus(CharSprite.POSITIVE, Integer.toString(heal));\n\n\t\t}",
          "sourceCodeAfterRefactoring": "public void wandHeal( int wandLevel ){\n\t\t\twandHeal( wandLevel, 1f );\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void wandHeal( int wandLevel, float healFactor ){\n\t\t\tif (this.wandLevel < wandLevel){\n\t\t\t\tthis.wandLevel = wandLevel;\n\t\t\t}\n\n\t\t\tint heal;\n\t\t\tswitch(tier){\n\t\t\t\tdefault:\n\t\t\t\t\treturn;\n\t\t\t\tcase 4:\n\t\t\t\t\theal = Math.round(9 * healFactor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 5:\n\t\t\t\t\theal = Math.round(12 * healFactor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\theal = Math.round(16 * healFactor);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tHP = Math.min(HT, HP+heal);\n\t\t\tif (sprite != null) sprite.showStatus(CharSprite.POSITIVE, Integer.toString(heal));\n\n\t\t}",
          "uniqueId": "8e84b017388c5cfe2fe18f1354e5f7bab541c6c0_235_258_239_262_235_237"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9412eb81f4f1c933666288154c3ac5072c89e49f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9412eb81f4f1c933666288154c3ac5072c89e49f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void holdAllies( Level level ){\n\t\theldAllies.clear();\n\t\tfor (Mob mob : level.mobs.toArray( new Mob[0] )) {\n\t\t\t//preserve the ghost no matter where they are\n\t\t\tif (mob instanceof DriedRose.GhostHero) {\n\t\t\t\t((DriedRose.GhostHero) mob).clearDefensingPos();\n\t\t\t\tlevel.mobs.remove( mob );\n\t\t\t\theldAllies.add(mob);\n\t\t\t\t\n\t\t\t//preserve intelligent allies if they are near the hero\n\t\t\t} else if (mob.alignment == Alignment.ALLY\n\t\t\t\t\t&& mob.intelligentAlly\n\t\t\t\t\t&& Dungeon.level.distance(Dungeon.hero.pos, mob.pos) <= 3){\n\t\t\t\tlevel.mobs.remove( mob );\n\t\t\t\theldAllies.add(mob);\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void holdAllies( Level level ){\n\t\tholdAllies(level, Dungeon.hero.pos);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void holdAllies( Level level, int holdFromPos ){\n\t\theldAllies.clear();\n\t\tfor (Mob mob : level.mobs.toArray( new Mob[0] )) {\n\t\t\t//preserve the ghost no matter where they are\n\t\t\tif (mob instanceof DriedRose.GhostHero) {\n\t\t\t\t((DriedRose.GhostHero) mob).clearDefensingPos();\n\t\t\t\tlevel.mobs.remove( mob );\n\t\t\t\theldAllies.add(mob);\n\t\t\t\t\n\t\t\t//preserve intelligent allies if they are near the hero\n\t\t\t} else if (mob.alignment == Alignment.ALLY\n\t\t\t\t\t&& mob.intelligentAlly\n\t\t\t\t\t&& Dungeon.level.distance(holdFromPos, mob.pos) <= 5){\n\t\t\t\tlevel.mobs.remove( mob );\n\t\t\t\theldAllies.add(mob);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "9412eb81f4f1c933666288154c3ac5072c89e49f_1057_1074_1062_1079_1058_1060"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void restoreAllies( Level level, int pos ){\n\t\tif (!heldAllies.isEmpty()){\n\t\t\t\n\t\t\tArrayList<Integer> candidatePositions = new ArrayList<>();\n\t\t\tfor (int i : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (!Dungeon.level.solid[i+pos] && level.findMob(i+pos) == null){\n\t\t\t\t\tcandidatePositions.add(i+pos);\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.shuffle(candidatePositions);\n\t\t\t\n\t\t\tfor (Mob ally : heldAllies) {\n\t\t\t\tlevel.mobs.add(ally);\n\t\t\t\tally.state = ally.WANDERING;\n\t\t\t\t\n\t\t\t\tif (!candidatePositions.isEmpty()){\n\t\t\t\t\tally.pos = candidatePositions.remove(0);\n\t\t\t\t} else {\n\t\t\t\t\tally.pos = pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\theldAllies.clear();\n\t}",
          "sourceCodeAfterRefactoring": "public static void restoreAllies( Level level, int pos ){\n\t\trestoreAllies(level, pos, -1);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void restoreAllies( Level level, int pos, int gravitatePos ){\n\t\tif (!heldAllies.isEmpty()){\n\t\t\t\n\t\t\tArrayList<Integer> candidatePositions = new ArrayList<>();\n\t\t\tfor (int i : PathFinder.NEIGHBOURS8) {\n\t\t\t\tif (!Dungeon.level.solid[i+pos] && level.findMob(i+pos) == null){\n\t\t\t\t\tcandidatePositions.add(i+pos);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//gravitate pos sets a preferred location for allies to be closer to\n\t\t\tif (gravitatePos == -1) {\n\t\t\t\tCollections.shuffle(candidatePositions);\n\t\t\t} else {\n\t\t\t\tCollections.sort(candidatePositions, new Comparator<Integer>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic int compare(Integer t1, Integer t2) {\n\t\t\t\t\t\treturn Dungeon.level.distance(gravitatePos, t1) -\n\t\t\t\t\t\t\t\tDungeon.level.distance(gravitatePos, t2);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tfor (Mob ally : heldAllies) {\n\t\t\t\tlevel.mobs.add(ally);\n\t\t\t\tally.state = ally.WANDERING;\n\t\t\t\t\n\t\t\t\tif (!candidatePositions.isEmpty()){\n\t\t\t\t\tally.pos = candidatePositions.remove(0);\n\t\t\t\t} else {\n\t\t\t\t\tally.pos = pos;\n\t\t\t\t}\n\t\t\t\tif (ally.sprite != null) ally.sprite.place(ally.pos);\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\theldAllies.clear();\n\t}",
          "uniqueId": "9412eb81f4f1c933666288154c3ac5072c89e49f_1076_1100_1085_1122_1081_1083"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "720f6a65906767c5702e9eb4a6ffef695dc9fe37",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/720f6a65906767c5702e9eb4a6ffef695dc9fe37",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean attack( Char enemy ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\n\t\tif (enemy.isInvulnerable(getClass())) {\n\n\t\t\tif (visibleFight) {\n\t\t\t\tenemy.sprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"invulnerable\") );\n\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_PARRY, 1f, Random.Float(0.96f, 1.05f));\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} else if (hit( this, enemy, false )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\n\t\t\tBarkskin bark = enemy.buff(Barkskin.class);\n\t\t\tif (bark != null)   dr += Random.NormalIntRange( 0 , bark.level() );\n\n\t\t\tBlocking.BlockBuff block = enemy.buff(Blocking.BlockBuff.class);\n\t\t\tif (block != null)  dr += block.blockingRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this);\n\t\t\t\tif (this == Dungeon.hero && Dungeon.hero.hasTalent(Talent.BOUNTY_HUNTER)) {\n\t\t\t\t\tBuff.affect(Dungeon.hero, Talent.BountyHunterTracker.class, 0.0f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tif (effectiveDamage > 0 || !enemy.blockSound(Random.Float(0.96f, 1.05f))) {\n\t\t\t\t\thitSound(Random.Float(0.87f, 1.15f));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)  buff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null) buff(FrostImbue.class).proc(enemy);\n\n\t\t\tif (enemy.isAlive() && prep != null && prep.canKO(enemy)){\n\t\t\t\tenemy.HP = 0;\n\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\tenemy.die(this);\n\t\t\t\t} else {\n\t\t\t\t\t//helps with triggering any on-damage effects that need to activate\n\t\t\t\t\tenemy.damage(-1, this);\n\t\t\t\t}\n\t\t\t\tenemy.sprite.showStatus(CharSprite.NEGATIVE, Messages.get(Preparation.class, \"assassinated\"));\n\t\t\t}\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name())) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\n\t\t\t\t//TODO enemy.defenseSound? currently miss plays for monks/crab even when they parry\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "final public boolean attack( Char enemy ){\n\t\treturn attack(enemy, 1f, 0f, 1f);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean attack( Char enemy, float dmgMulti, float dmgBonus, float accMulti ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\n\t\tif (enemy.isInvulnerable(getClass())) {\n\n\t\t\tif (visibleFight) {\n\t\t\t\tenemy.sprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"invulnerable\") );\n\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.HIT_PARRY, 1f, Random.Float(0.96f, 1.05f));\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} else if (hit( this, enemy, accMulti )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\n\t\t\tBarkskin bark = enemy.buff(Barkskin.class);\n\t\t\tif (bark != null)   dr += Random.NormalIntRange( 0 , bark.level() );\n\n\t\t\tBlocking.BlockBuff block = enemy.buff(Blocking.BlockBuff.class);\n\t\t\tif (block != null)  dr += block.blockingRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this);\n\t\t\t\tif (this == Dungeon.hero && Dungeon.hero.hasTalent(Talent.BOUNTY_HUNTER)) {\n\t\t\t\t\tBuff.affect(Dungeon.hero, Talent.BountyHunterTracker.class, 0.0f);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\n\t\t\tdmg = Math.round(dmg*dmgMulti);\n\t\t\tdmg += dmgBonus;\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tif (effectiveDamage > 0 || !enemy.blockSound(Random.Float(0.96f, 1.05f))) {\n\t\t\t\t\thitSound(Random.Float(0.87f, 1.15f));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)  buff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null) buff(FrostImbue.class).proc(enemy);\n\n\t\t\tif (enemy.isAlive() && prep != null && prep.canKO(enemy)){\n\t\t\t\tenemy.HP = 0;\n\t\t\t\tif (!enemy.isAlive()) {\n\t\t\t\t\tenemy.die(this);\n\t\t\t\t} else {\n\t\t\t\t\t//helps with triggering any on-damage effects that need to activate\n\t\t\t\t\tenemy.damage(-1, this);\n\t\t\t\t}\n\t\t\t\tenemy.sprite.showStatus(CharSprite.NEGATIVE, Messages.get(Preparation.class, \"assassinated\"));\n\t\t\t}\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name())) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\n\t\t\t\t//TODO enemy.defenseSound? currently miss plays for monks/crab even when they parry\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "uniqueId": "720f6a65906767c5702e9eb4a6ffef695dc9fe37_274_390_278_397_274_276"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean hit( Char attacker, Char defender, boolean magic ) {\n\t\tfloat acuStat = attacker.attackSkill( defender );\n\t\tfloat defStat = defender.defenseSkill( attacker );\n\n\t\t//if accuracy or evasion are large enough, treat them as infinite.\n\t\t//note that infinite evasion beats infinite accuracy\n\t\tif (defStat >= INFINITE_EVASION){\n\t\t\treturn false;\n\t\t} else if (acuStat >= INFINITE_ACCURACY){\n\t\t\treturn true;\n\t\t}\n\n\t\tfloat acuRoll = Random.Float( acuStat );\n\t\tif (attacker.buff(Bless.class) != null) acuRoll *= 1.25f;\n\t\tif (attacker.buff(  Hex.class) != null) acuRoll *= 0.8f;\n\t\tfor (ChampionEnemy buff : attacker.buffs(ChampionEnemy.class)){\n\t\t\tacuRoll *= buff.evasionAndAccuracyFactor();\n\t\t}\n\t\t\n\t\tfloat defRoll = Random.Float( defStat );\n\t\tif (defender.buff(Bless.class) != null) defRoll *= 1.25f;\n\t\tif (defender.buff(  Hex.class) != null) defRoll *= 0.8f;\n\t\tfor (ChampionEnemy buff : defender.buffs(ChampionEnemy.class)){\n\t\t\tdefRoll *= buff.evasionAndAccuracyFactor();\n\t\t}\n\t\t\n\t\treturn (magic ? acuRoll * 2 : acuRoll) >= defRoll;\n\t}",
          "sourceCodeAfterRefactoring": "final public static boolean hit( Char attacker, Char defender, boolean magic ) {\n\t\treturn hit(attacker, defender, magic ? 2f : 1f);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean hit( Char attacker, Char defender, float accMulti ) {\n\t\tfloat acuStat = attacker.attackSkill( defender );\n\t\tfloat defStat = defender.defenseSkill( attacker );\n\n\t\t//if accuracy or evasion are large enough, treat them as infinite.\n\t\t//note that infinite evasion beats infinite accuracy\n\t\tif (defStat >= INFINITE_EVASION){\n\t\t\treturn false;\n\t\t} else if (acuStat >= INFINITE_ACCURACY){\n\t\t\treturn true;\n\t\t}\n\n\t\tfloat acuRoll = Random.Float( acuStat );\n\t\tif (attacker.buff(Bless.class) != null) acuRoll *= 1.25f;\n\t\tif (attacker.buff(  Hex.class) != null) acuRoll *= 0.8f;\n\t\tfor (ChampionEnemy buff : attacker.buffs(ChampionEnemy.class)){\n\t\t\tacuRoll *= buff.evasionAndAccuracyFactor();\n\t\t}\n\t\t\n\t\tfloat defRoll = Random.Float( defStat );\n\t\tif (defender.buff(Bless.class) != null) defRoll *= 1.25f;\n\t\tif (defender.buff(  Hex.class) != null) defRoll *= 0.8f;\n\t\tfor (ChampionEnemy buff : defender.buffs(ChampionEnemy.class)){\n\t\t\tdefRoll *= buff.evasionAndAccuracyFactor();\n\t\t}\n\t\t\n\t\treturn (acuRoll * accMulti) >= defRoll;\n\t}",
          "uniqueId": "720f6a65906767c5702e9eb4a6ffef695dc9fe37_395_422_406_433_402_404"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4bef7c7d04636ac2a3a3f00bbb68b6c6ccb6b2ba",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4bef7c7d04636ac2a3a3f00bbb68b6c6ccb6b2ba",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndOptions( String title, String message, String... options ) {\n\t\tsuper();\n\n\t\tint width = PixelScene.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tfloat pos = MARGIN;\n\t\tif (title != null) {\n\t\t\tRenderedTextBlock tfTitle = PixelScene.renderTextBlock(title, 9);\n\t\t\ttfTitle.hardlight(TITLE_COLOR);\n\t\t\ttfTitle.setPos(MARGIN, pos);\n\t\t\ttfTitle.maxWidth(width - MARGIN * 2);\n\t\t\tadd(tfTitle);\n\n\t\t\tpos = tfTitle.bottom() + 3*MARGIN;\n\t\t}\n\t\t\n\t\tRenderedTextBlock tfMesage = PixelScene.renderTextBlock( 6 );\n\t\ttfMesage.text(message, width - MARGIN * 2);\n\t\ttfMesage.setPos( MARGIN, pos );\n\t\tadd( tfMesage );\n\t\t\n\t\tpos = tfMesage.bottom() + 2*MARGIN;\n\t\t\n\t\tfor (int i=0; i < options.length; i++) {\n\t\t\tfinal int index = i;\n\t\t\tRedButton btn = new RedButton( options[i] ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\thide();\n\t\t\t\t\tonSelect( index );\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtn.enable(enabled(i));\n\t\t\tbtn.setRect( MARGIN, pos, width - MARGIN * 2, BUTTON_HEIGHT );\n\t\t\tadd( btn );\n\t\t\t\n\t\t\tpos += BUTTON_HEIGHT + MARGIN;\n\t\t}\n\t\t\n\t\tresize( width, (int)pos );\n\t}",
          "sourceCodeAfterRefactoring": "public WndOptions( String title, String message, String... options ) {\n\t\tsuper();\n\n\t\tint width = PixelScene.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tfloat pos = MARGIN;\n\t\tif (title != null) {\n\t\t\tRenderedTextBlock tfTitle = PixelScene.renderTextBlock(title, 9);\n\t\t\ttfTitle.hardlight(TITLE_COLOR);\n\t\t\ttfTitle.setPos(MARGIN, pos);\n\t\t\ttfTitle.maxWidth(width - MARGIN * 2);\n\t\t\tadd(tfTitle);\n\n\t\t\tpos = tfTitle.bottom() + 2*MARGIN;\n\t\t}\n\t\t\n\t\tlayoutBody(pos, message, options);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void layoutBody(float pos, String message, String... options){\n\t\tint width = PixelScene.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tRenderedTextBlock tfMesage = PixelScene.renderTextBlock( 6 );\n\t\ttfMesage.text(message, width);\n\t\ttfMesage.setPos( 0, pos );\n\t\tadd( tfMesage );\n\n\t\tpos = tfMesage.bottom() + 2*MARGIN;\n\n\t\tfor (int i=0; i < options.length; i++) {\n\t\t\tfinal int index = i;\n\t\t\tRedButton btn = new RedButton( options[i] ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\thide();\n\t\t\t\t\tonSelect( index );\n\t\t\t\t}\n\t\t\t};\n\t\t\tbtn.enable(enabled(i));\n\t\t\tbtn.setRect( 0, pos, width, BUTTON_HEIGHT );\n\t\t\tadd( btn );\n\n\t\t\tpos += BUTTON_HEIGHT + MARGIN;\n\t\t}\n\n\t\tresize( width, (int)(pos - MARGIN) );\n\t}",
          "uniqueId": "4bef7c7d04636ac2a3a3f00bbb68b6c6ccb6b2ba_37_77_74_101_55_72"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "636e58e4904460f4f40dc40ef2fcaadaccb2dd2b",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/636e58e4904460f4f40dc40ef2fcaadaccb2dd2b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void updateQuickslot() {\n\t\t\tQuickSlotButton.refresh();\n\t}",
          "sourceCodeAfterRefactoring": "public static void updateQuickslot() {\n\t\tupdateQuickslot(true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void updateQuickslot(boolean full) {\n\t\tQuickSlotButton.refresh(full);\n\t}",
          "uniqueId": "636e58e4904460f4f40dc40ef2fcaadaccb2dd2b_475_477_479_481_475_477"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onSelect( Item item ) {\n\t\tif (item != null) {\n\t\t\tDungeon.quickslot.setSlot( slotNum , item );\n\t\t\tfor (int i = 0; i < instance.length; i++) {\n\t\t\t\tif (instance[i] != null) {\n\t\t\t\t\tinstance[i].item(select(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onSelect( Item item ) {\n\t\tif (item != null) {\n\t\t\tDungeon.quickslot.setSlot( slotNum , item );\n\t\t\trefresh(false);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void refresh( boolean full ) {\n\t\tfor (int i = 0; i < instance.length; i++) {\n\t\t\tif (instance[i] != null) {\n\t\t\t\tif (full) {\n\t\t\t\t\tinstance[i].item(select(i));\n\t\t\t\t} else {\n\t\t\t\t\tinstance[i].slot.updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "636e58e4904460f4f40dc40ef2fcaadaccb2dd2b_182_192_263_273_182_188"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void refresh() {\n\t\tfor (int i = 0; i < instance.length; i++) {\n\t\t\tif (instance[i] != null) {\n\t\t\t\tinstance[i].slot.updateText();\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void refresh() {\n\t\trefresh(true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void refresh( boolean full ) {\n\t\tfor (int i = 0; i < instance.length; i++) {\n\t\t\tif (instance[i] != null) {\n\t\t\t\tif (full) {\n\t\t\t\t\tinstance[i].item(select(i));\n\t\t\t\t} else {\n\t\t\t\t\tinstance[i].slot.updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "636e58e4904460f4f40dc40ef2fcaadaccb2dd2b_263_269_263_273_259_261"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "68f879a4ff9e2662fe1180d782423c59cfb8c3bc",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/68f879a4ff9e2662fe1180d782423c59cfb8c3bc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean chain(int target){\n\t\tif (chainsUsed || enemy.properties().contains(Property.IMMOVABLE))\n\t\t\treturn false;\n\n\t\tBallistica chain = new Ballistica(pos, target, Ballistica.PROJECTILE);\n\n\t\tif (chain.collisionPos != enemy.pos\n\t\t\t\t|| chain.path.size() < 2\n\t\t\t\t|| Dungeon.level.pit[chain.path.get(1)])\n\t\t\treturn false;\n\t\telse {\n\t\t\tint newPos = -1;\n\t\t\tfor (int i : chain.subPath(1, chain.dist)){\n\t\t\t\tif (!Dungeon.level.solid[i] && Actor.findChar(i) == null){\n\t\t\t\t\tnewPos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newPos == -1){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfinal int newPosFinal = newPos;\n\t\t\t\tthis.target = newPos;\n\t\t\t\tyell( Messages.get(this, \"scorpion\") );\n\t\t\t\tnew Item().throwSound();\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.CHAINS );\n\t\t\t\tsprite.parent.add(new Chains(sprite.center(), enemy.sprite.center(), new Callback() {\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tActor.addDelayed(new Pushing(enemy, enemy.pos, newPosFinal, new Callback(){\n\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\tenemy.pos = newPosFinal;\n\t\t\t\t\t\t\t\tDungeon.level.occupyCell(enemy);\n\t\t\t\t\t\t\t\tCripple.prolong(enemy, Cripple.class, 4f);\n\t\t\t\t\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\t\t\t\tDungeon.hero.interrupt();\n\t\t\t\t\t\t\t\t\tDungeon.observe();\n\t\t\t\t\t\t\t\t\tGameScene.updateFog();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}), -1);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t\tchainsUsed = true;\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "private boolean chain(int target){\n\t\tif (chainsUsed || enemy.properties().contains(Property.IMMOVABLE))\n\t\t\treturn false;\n\n\t\tBallistica chain = new Ballistica(pos, target, Ballistica.PROJECTILE);\n\n\t\tif (chain.collisionPos != enemy.pos\n\t\t\t\t|| chain.path.size() < 2\n\t\t\t\t|| Dungeon.level.pit[chain.path.get(1)])\n\t\t\treturn false;\n\t\telse {\n\t\t\tint newPos = -1;\n\t\t\tfor (int i : chain.subPath(1, chain.dist)){\n\t\t\t\tif (!Dungeon.level.solid[i] && Actor.findChar(i) == null){\n\t\t\t\t\tnewPos = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (newPos == -1){\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tfinal int newPosFinal = newPos;\n\t\t\t\tthis.target = newPos;\n\n\t\t\t\tif (sprite.visible || enemy.sprite.visible) {\n\t\t\t\t\tyell(Messages.get(this, \"scorpion\"));\n\t\t\t\t\tnew Item().throwSound();\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.CHAINS);\n\t\t\t\t\tsprite.parent.add(new Chains(sprite.center(), enemy.sprite.center(), new Callback() {\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tActor.addDelayed(new Pushing(enemy, enemy.pos, newPosFinal, new Callback() {\n\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\tpullEnemy(enemy, newPosFinal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}), -1);\n\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\t\t\t\t\tpullEnemy(enemy, newPos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchainsUsed = true;\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void pullEnemy( Char enemy, int pullPos ){\n\t\tenemy.pos = pullPos;\n\t\tDungeon.level.occupyCell(enemy);\n\t\tCripple.prolong(enemy, Cripple.class, 4f);\n\t\tif (enemy == Dungeon.hero) {\n\t\t\tDungeon.hero.interrupt();\n\t\t\tDungeon.observe();\n\t\t\tGameScene.updateFog();\n\t\t}\n\t}",
          "uniqueId": "68f879a4ff9e2662fe1180d782423c59cfb8c3bc_69_117_117_126_69_115"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act(boolean enemyInFOV, boolean justAlerted) {\n\t\t\tenemySeen = enemyInFOV;\n\t\t\t\n\t\t\tif (storedSkeletonID != -1){\n\t\t\t\tActor ch = Actor.findById(storedSkeletonID);\n\t\t\t\tstoredSkeletonID = -1;\n\t\t\t\tif (ch instanceof NecroSkeleton){\n\t\t\t\t\tmySkeleton = (NecroSkeleton) ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (summoning){\n\t\t\t\t\n\t\t\t\t//push anything on summoning spot away, to the furthest valid cell\n\t\t\t\tif (Actor.findChar(summoningPos) != null) {\n\t\t\t\t\tint pushPos = pos;\n\t\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\t\t\tif (pushPos != pos) {\n\t\t\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\t\t\tActor.addDelayed( new Pushing( ch, ch.pos, pushPos ), -1 );\n\t\t\t\t\t\t\n\t\t\t\t\t\tch.pos = pushPos;\n\t\t\t\t\t\tDungeon.level.occupyCell(ch );\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\t\t\tblocker.damage( Random.NormalIntRange(2, 10), this );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tspend(TICK);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsummoning = firstSummon = false;\n\t\t\t\t\n\t\t\t\tmySkeleton = new NecroSkeleton();\n\t\t\t\tmySkeleton.pos = summoningPos;\n\t\t\t\tGameScene.add( mySkeleton );\n\t\t\t\tDungeon.level.occupyCell( mySkeleton );\n\t\t\t\tSample.INSTANCE.play(Assets.Sounds.BONES);\n\t\t\t\tsummoningEmitter.burst(Speck.factory(Speck.RATTLE), 5);\n\t\t\t\tsprite.idle();\n\t\t\t\t\n\t\t\t\tif (buff(Corruption.class) != null){\n\t\t\t\t\tBuff.affect(mySkeleton, Corruption.class);\n\t\t\t\t}\n\t\t\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\t\t\tBuff.affect( mySkeleton, b.getClass());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tspend(TICK);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif (mySkeleton != null &&\n\t\t\t\t\t(!mySkeleton.isAlive()\n\t\t\t\t\t|| !Dungeon.level.mobs.contains(mySkeleton)\n\t\t\t\t\t|| mySkeleton.alignment != alignment)){\n\t\t\t\tmySkeleton = null;\n\t\t\t}\n\t\t\t\n\t\t\t//if enemy is seen, and enemy is within range, and we haven no skeleton, summon a skeleton!\n\t\t\tif (enemySeen && Dungeon.level.distance(pos, enemy.pos) <= 4 && mySkeleton == null){\n\t\t\t\t\n\t\t\t\tsummoningPos = -1;\n\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8){\n\t\t\t\t\tif (Actor.findChar(enemy.pos+c) == null\n\t\t\t\t\t\t\t&& Dungeon.level.passable[enemy.pos+c]\n\t\t\t\t\t\t\t&& fieldOfView[enemy.pos+c]\n\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, enemy.pos+c) < Dungeon.level.trueDistance(pos, summoningPos)){\n\t\t\t\t\t\tsummoningPos = enemy.pos+c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (summoningPos != -1){\n\t\t\t\t\t\n\t\t\t\t\tsummoning = true;\n\t\t\t\t\tsummoningEmitter = CellEmitter.get(summoningPos);\n\t\t\t\t\tsummoningEmitter.pour(Speck.factory(Speck.RATTLE), 0.2f);\n\t\t\t\t\t\n\t\t\t\t\tsprite.zap( summoningPos );\n\t\t\t\t\t\n\t\t\t\t\tspend( firstSummon ? TICK : 2*TICK );\n\t\t\t\t} else {\n\t\t\t\t\t//wait for a turn\n\t\t\t\t\tspend(TICK);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t//otherwise, if enemy is seen, and we have a skeleton...\n\t\t\t} else if (enemySeen && mySkeleton != null){\n\t\t\t\t\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\tspend(TICK);\n\t\t\t\t\n\t\t\t\tif (!fieldOfView[mySkeleton.pos]){\n\t\t\t\t\t\n\t\t\t\t\t//if the skeleton is not next to the enemy\n\t\t\t\t\t//teleport them to the closest spot next to the enemy that can be seen\n\t\t\t\t\tif (!Dungeon.level.adjacent(mySkeleton.pos, enemy.pos)){\n\t\t\t\t\t\tint telePos = -1;\n\t\t\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (Actor.findChar(enemy.pos+c) == null\n\t\t\t\t\t\t\t\t\t&& Dungeon.level.passable[enemy.pos+c]\n\t\t\t\t\t\t\t\t\t&& fieldOfView[enemy.pos+c]\n\t\t\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, enemy.pos+c) < Dungeon.level.trueDistance(pos, telePos)){\n\t\t\t\t\t\t\t\ttelePos = enemy.pos+c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (telePos != -1){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tScrollOfTeleportation.appear(mySkeleton, telePos);\n\t\t\t\t\t\t\tmySkeleton.teleportSpend();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (sprite != null && sprite.visible){\n\t\t\t\t\t\t\t\tsprite.zap(telePos);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonZapComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t//zap skeleton\n\t\t\t\t\tif (mySkeleton.HP < mySkeleton.HT || mySkeleton.buff(Adrenaline.class) == null) {\n\t\t\t\t\t\tif (sprite != null && sprite.visible){\n\t\t\t\t\t\t\tsprite.zap(mySkeleton.pos);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonZapComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t//otherwise, default to regular hunting behaviour\n\t\t\t} else {\n\t\t\t\treturn super.act(enemyInFOV, justAlerted);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act(boolean enemyInFOV, boolean justAlerted) {\n\t\t\tenemySeen = enemyInFOV;\n\t\t\t\n\t\t\tif (storedSkeletonID != -1){\n\t\t\t\tActor ch = Actor.findById(storedSkeletonID);\n\t\t\t\tstoredSkeletonID = -1;\n\t\t\t\tif (ch instanceof NecroSkeleton){\n\t\t\t\t\tmySkeleton = (NecroSkeleton) ch;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (summoning){\n\t\t\t\t\n\t\t\t\t//push anything on summoning spot away, to the furthest valid cell\n\t\t\t\tif (Actor.findChar(summoningPos) != null) {\n\t\t\t\t\tint pushPos = pos;\n\t\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8) {\n\t\t\t\t\t\tif (Actor.findChar(summoningPos + c) == null\n\t\t\t\t\t\t\t\t&& Dungeon.level.passable[summoningPos + c]\n\t\t\t\t\t\t\t\t&& (Dungeon.level.openSpace[summoningPos + c] || !hasProp(Actor.findChar(summoningPos), Property.LARGE))\n\t\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, summoningPos + c) > Dungeon.level.trueDistance(pos, pushPos)) {\n\t\t\t\t\t\t\tpushPos = summoningPos + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//push enemy, or wait a turn if there is no valid pushing position\n\t\t\t\t\tif (pushPos != pos) {\n\t\t\t\t\t\tChar ch = Actor.findChar(summoningPos);\n\t\t\t\t\t\tActor.addDelayed( new Pushing( ch, ch.pos, pushPos ), -1 );\n\t\t\t\t\t\t\n\t\t\t\t\t\tch.pos = pushPos;\n\t\t\t\t\t\tDungeon.level.occupyCell(ch );\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tChar blocker = Actor.findChar(summoningPos);\n\t\t\t\t\t\tif (blocker.alignment != alignment){\n\t\t\t\t\t\t\tblocker.damage( Random.NormalIntRange(2, 10), this );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tspend(TICK);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsummoning = firstSummon = false;\n\t\t\t\t\n\t\t\t\tmySkeleton = new NecroSkeleton();\n\t\t\t\tmySkeleton.pos = summoningPos;\n\t\t\t\tGameScene.add( mySkeleton );\n\t\t\t\tDungeon.level.occupyCell( mySkeleton );\n\t\t\t\t((NecromancerSprite)sprite).finishSummoning();\n\t\t\t\t\n\t\t\t\tif (buff(Corruption.class) != null){\n\t\t\t\t\tBuff.affect(mySkeleton, Corruption.class);\n\t\t\t\t}\n\t\t\t\tfor (Buff b : buffs(ChampionEnemy.class)){\n\t\t\t\t\tBuff.affect( mySkeleton, b.getClass());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tspend(TICK);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tif (mySkeleton != null &&\n\t\t\t\t\t(!mySkeleton.isAlive()\n\t\t\t\t\t|| !Dungeon.level.mobs.contains(mySkeleton)\n\t\t\t\t\t|| mySkeleton.alignment != alignment)){\n\t\t\t\tmySkeleton = null;\n\t\t\t}\n\t\t\t\n\t\t\t//if enemy is seen, and enemy is within range, and we haven no skeleton, summon a skeleton!\n\t\t\tif (enemySeen && Dungeon.level.distance(pos, enemy.pos) <= 4 && mySkeleton == null){\n\t\t\t\t\n\t\t\t\tsummoningPos = -1;\n\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8){\n\t\t\t\t\tif (Actor.findChar(enemy.pos+c) == null\n\t\t\t\t\t\t\t&& Dungeon.level.passable[enemy.pos+c]\n\t\t\t\t\t\t\t&& fieldOfView[enemy.pos+c]\n\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, enemy.pos+c) < Dungeon.level.trueDistance(pos, summoningPos)){\n\t\t\t\t\t\tsummoningPos = enemy.pos+c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (summoningPos != -1){\n\t\t\t\t\t\n\t\t\t\t\tsummoning = true;\n\t\t\t\t\tsprite.zap( summoningPos );\n\t\t\t\t\t\n\t\t\t\t\tspend( firstSummon ? TICK : 2*TICK );\n\t\t\t\t} else {\n\t\t\t\t\t//wait for a turn\n\t\t\t\t\tspend(TICK);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t//otherwise, if enemy is seen, and we have a skeleton...\n\t\t\t} else if (enemySeen && mySkeleton != null){\n\t\t\t\t\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\tspend(TICK);\n\t\t\t\t\n\t\t\t\tif (!fieldOfView[mySkeleton.pos]){\n\t\t\t\t\t\n\t\t\t\t\t//if the skeleton is not next to the enemy\n\t\t\t\t\t//teleport them to the closest spot next to the enemy that can be seen\n\t\t\t\t\tif (!Dungeon.level.adjacent(mySkeleton.pos, enemy.pos)){\n\t\t\t\t\t\tint telePos = -1;\n\t\t\t\t\t\tfor (int c : PathFinder.NEIGHBOURS8){\n\t\t\t\t\t\t\tif (Actor.findChar(enemy.pos+c) == null\n\t\t\t\t\t\t\t\t\t&& Dungeon.level.passable[enemy.pos+c]\n\t\t\t\t\t\t\t\t\t&& fieldOfView[enemy.pos+c]\n\t\t\t\t\t\t\t\t\t&& Dungeon.level.trueDistance(pos, enemy.pos+c) < Dungeon.level.trueDistance(pos, telePos)){\n\t\t\t\t\t\t\t\ttelePos = enemy.pos+c;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (telePos != -1){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tScrollOfTeleportation.appear(mySkeleton, telePos);\n\t\t\t\t\t\t\tmySkeleton.teleportSpend();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (sprite != null && sprite.visible){\n\t\t\t\t\t\t\t\tsprite.zap(telePos);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tonZapComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t//zap skeleton\n\t\t\t\t\tif (mySkeleton.HP < mySkeleton.HT || mySkeleton.buff(Adrenaline.class) == null) {\n\t\t\t\t\t\tif (sprite != null && sprite.visible){\n\t\t\t\t\t\t\tsprite.zap(mySkeleton.pos);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonZapComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\t//otherwise, default to regular hunting behaviour\n\t\t\t} else {\n\t\t\t\treturn super.act(enemyInFOV, justAlerted);\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic void die(Object cause) {\n\t\tif (storedSkeletonID != -1){\n\t\t\tActor ch = Actor.findById(storedSkeletonID);\n\t\t\tstoredSkeletonID = -1;\n\t\t\tif (ch instanceof NecroSkeleton){\n\t\t\t\tmySkeleton = (NecroSkeleton) ch;\n\t\t\t}\n\t\t}",
          "uniqueId": "68f879a4ff9e2662fe1180d782423c59cfb8c3bc_204_363_97_105_180_334"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ea7e58bd2d59121a815e0c9a4a3620693e2c2dcf",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ea7e58bd2d59121a815e0c9a4a3620693e2c2dcf",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\n\t\t\tif (enemyInFOV) {\n\n\t\t\t\tfloat enemyStealth = enemy.stealth();\n\n\t\t\t\tif (enemy instanceof Hero && ((Hero) enemy).hasTalent(Talent.SILENT_STEPS)){\n\t\t\t\t\tif (Dungeon.level.distance(pos, enemy.pos) >= 4 - ((Hero) enemy).pointsInTalent(Talent.SILENT_STEPS)) {\n\t\t\t\t\t\tenemyStealth = Float.POSITIVE_INFINITY;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (Random.Float( distance( enemy ) + enemyStealth ) < 1) {\n\t\t\t\t\tenemySeen = true;\n\n\t\t\t\t\tnotice();\n\t\t\t\t\tstate = HUNTING;\n\t\t\t\t\ttarget = enemy.pos;\n\n\t\t\t\t\tif (alignment == Alignment.ENEMY && Dungeon.isChallenged(Challenges.SWARM_INTELLIGENCE)) {\n\t\t\t\t\t\tfor (Mob mob : Dungeon.level.mobs) {\n\t\t\t\t\t\t\tif (mob.paralysed <= 0\n\t\t\t\t\t\t\t\t\t&& Dungeon.level.distance(pos, mob.pos) <= 8\n\t\t\t\t\t\t\t\t\t&& mob.state != mob.HUNTING) {\n\t\t\t\t\t\t\t\tmob.beckon(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tspend(TIME_TO_WAKE_UP);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\n\t\t\t//debuffs cause mobs to wake as well\n\t\t\tfor (Buff b : buffs()){\n\t\t\t\tif (b.type == Buff.buffType.NEGATIVE){\n\t\t\t\t\tawaken(enemyInFOV);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (enemyInFOV) {\n\n\t\t\t\tfloat enemyStealth = enemy.stealth();\n\n\t\t\t\tif (enemy instanceof Hero && ((Hero) enemy).hasTalent(Talent.SILENT_STEPS)){\n\t\t\t\t\tif (Dungeon.level.distance(pos, enemy.pos) >= 4 - ((Hero) enemy).pointsInTalent(Talent.SILENT_STEPS)) {\n\t\t\t\t\t\tenemyStealth = Float.POSITIVE_INFINITY;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (Random.Float( distance( enemy ) + enemyStealth ) < 1) {\n\t\t\t\t\tawaken(enemyInFOV);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void awaken( boolean enemyInFOV ){\n\t\t\tif (enemyInFOV) {\n\t\t\t\tenemySeen = true;\n\t\t\t\tnotice();\n\t\t\t\tstate = HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t} else {\n\t\t\t\tnotice();\n\t\t\t\tstate = WANDERING;\n\t\t\t\ttarget = Dungeon.level.randomDestination( Mob.this );\n\t\t\t}\n\n\t\t\tif (alignment == Alignment.ENEMY && Dungeon.isChallenged(Challenges.SWARM_INTELLIGENCE)) {\n\t\t\t\tfor (Mob mob : Dungeon.level.mobs) {\n\t\t\t\t\tif (mob.paralysed <= 0\n\t\t\t\t\t\t\t&& Dungeon.level.distance(pos, mob.pos) <= 8\n\t\t\t\t\t\t\t&& mob.state != mob.HUNTING) {\n\t\t\t\t\t\tmob.beckon(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tspend(TIME_TO_WAKE_UP);\n\t\t}",
          "uniqueId": "ea7e58bd2d59121a815e0c9a4a3620693e2c2dcf_828_868_862_884_828_860"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "13588b16992a4ca846bf5b958e9eac8b2789da36",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/13588b16992a4ca846bf5b958e9eac8b2789da36",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void pumpUp( int warnDist ) {\n\t\tif (warnDist == 0){\n\t\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\t\te.on = false;\n\t\t\t}\n\t\t\tpumpUpEmitters.clear();\n\t\t} else {\n\t\t\tplay(pump);\n\t\t\tPathFinder.buildDistanceMap(ch.pos, BArray.not(Dungeon.level.solid, null), 2);\n\t\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\t\tif (PathFinder.distance[i] <= warnDist) {\n\t\t\t\t\tEmitter e = CellEmitter.get(i);\n\t\t\t\t\te.pour(GooParticle.FACTORY, 0.04f);\n\t\t\t\t\tpumpUpEmitters.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void pumpUp( int warnDist ) {\n\t\tif (warnDist == 0){\n\t\t\tclearEmitters();\n\t\t} else {\n\t\t\tplay(pump);\n\t\t\tSample.INSTANCE.play( Assets.Sounds.CHARGEUP, 1f, warnDist == 1 ? 0.8f : 1f );\n\t\t\tPathFinder.buildDistanceMap(ch.pos, BArray.not(Dungeon.level.solid, null), 2);\n\t\t\tfor (int i = 0; i < PathFinder.distance.length; i++) {\n\t\t\t\tif (PathFinder.distance[i] <= warnDist) {\n\t\t\t\t\tEmitter e = CellEmitter.get(i);\n\t\t\t\t\te.pour(GooParticle.FACTORY, 0.04f);\n\t\t\t\t\tpumpUpEmitters.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void clearEmitters(){\n\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\te.on = false;\n\t\t}\n\t\tpumpUpEmitters.clear();\n\t}",
          "uniqueId": "13588b16992a4ca846bf5b958e9eac8b2789da36_88_105_106_111_89_104"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void play(Animation anim) {\n\t\tif (anim != pump && anim != pumpAttack){\n\t\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\t\te.on = false;\n\t\t\t}\n\t\t\tpumpUpEmitters.clear();\n\t\t}\n\t\tsuper.play(anim);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void play(Animation anim) {\n\t\tif (anim != pump && anim != pumpAttack){\n\t\t\tclearEmitters();\n\t\t}\n\t\tsuper.play(anim);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void clearEmitters(){\n\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\te.on = false;\n\t\t}\n\t\tpumpUpEmitters.clear();\n\t}",
          "uniqueId": "13588b16992a4ca846bf5b958e9eac8b2789da36_109_118_106_111_123_129"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onComplete( Animation anim ) {\n\t\tsuper.onComplete(anim);\n\n\t\tif (anim == pumpAttack) {\n\n\t\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\t\te.burst(ElmoParticle.FACTORY, 10);\n\t\t\t}\n\t\t\tpumpUpEmitters.clear();\n\n\t\t\tidle();\n\t\t\tch.onAttackComplete();\n\t\t} else if (anim == die) {\n\t\t\tspray.killAndErase();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onComplete( Animation anim ) {\n\t\tsuper.onComplete(anim);\n\n\t\tif (anim == pumpAttack) {\n\n\t\t\ttriggerEmitters();\n\n\t\t\tidle();\n\t\t\tch.onAttackComplete();\n\t\t} else if (anim == die) {\n\t\t\tspray.killAndErase();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void triggerEmitters(){\n\t\tfor (Emitter e : pumpUpEmitters){\n\t\t\te.burst(ElmoParticle.FACTORY, 10);\n\t\t}\n\t\tSample.INSTANCE.play( Assets.Sounds.BURNING );\n\t\tpumpUpEmitters.clear();\n\t}",
          "uniqueId": "13588b16992a4ca846bf5b958e9eac8b2789da36_174_190_113_119_185_198"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5f6285d3d27fc7db3632b9acf5b6f36e5a9801b7",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5f6285d3d27fc7db3632b9acf5b6f36e5a9801b7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\n\t\tint preHP = HP;\n\t\tsuper.damage( dmg, src );\n\n\t\tif (phase == 0 || findFist() != null) return;\n\n\t\tif (phase < 4) {\n\t\t\tHP = Math.max(HP, HT - 300 * phase);\n\t\t} else if (phase == 4) {\n\t\t\tHP = Math.max(HP, 100);\n\t\t}\n\t\tint dmgTaken = preHP - HP;\n\n\t\tif (dmgTaken > 0) {\n\t\t\tabilityCooldown -= dmgTaken / 10f;\n\t\t\tsummonCooldown -= dmgTaken / 10f;\n\t\t}\n\n\t\tif (phase < 4 && HP <= HT - 300*phase){\n\n\t\t\tDungeon.level.viewDistance = Math.max(1, Dungeon.level.viewDistance-1);\n\t\t\tif (Dungeon.hero.buff(Light.class) == null){\n\t\t\t\tDungeon.hero.viewDistance = Dungeon.level.viewDistance;\n\t\t\t}\n\t\t\tDungeon.observe();\n\t\t\tGLog.n(Messages.get(this, \"darkness\"));\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\n\t\t\tYogFist fist = (YogFist) Reflection.newInstance(fistSummons.remove(0));\n\t\t\tfist.pos = Dungeon.level.exit;\n\n\t\t\tCellEmitter.get(Dungeon.level.exit-1).burst(ShadowParticle.UP, 25);\n\t\t\tCellEmitter.get(Dungeon.level.exit).burst(ShadowParticle.UP, 100);\n\t\t\tCellEmitter.get(Dungeon.level.exit+1).burst(ShadowParticle.UP, 25);\n\n\t\t\tif (abilityCooldown < 5) abilityCooldown = 5;\n\t\t\tif (summonCooldown < 5) summonCooldown = 5;\n\n\t\t\tint targetPos = Dungeon.level.exit + Dungeon.level.width();\n\t\t\tif (Actor.findChar(targetPos) == null){\n\t\t\t\tfist.pos = targetPos;\n\t\t\t} else if (Actor.findChar(targetPos-1) == null){\n\t\t\t\tfist.pos = targetPos-1;\n\t\t\t} else if (Actor.findChar(targetPos+1) == null){\n\t\t\t\tfist.pos = targetPos+1;\n\t\t\t}\n\n\t\t\tGameScene.add(fist, 4);\n\t\t\tActor.addDelayed( new Pushing( fist, Dungeon.level.exit, fist.pos ), -1 );\n\t\t\tphase++;\n\t\t}\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null) lock.addTime(dmgTaken);\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage( int dmg, Object src ) {\n\n\t\tint preHP = HP;\n\t\tsuper.damage( dmg, src );\n\n\t\tif (phase == 0 || findFist() != null) return;\n\n\t\tif (phase < 4) {\n\t\t\tHP = Math.max(HP, HT - 300 * phase);\n\t\t} else if (phase == 4) {\n\t\t\tHP = Math.max(HP, 100);\n\t\t}\n\t\tint dmgTaken = preHP - HP;\n\n\t\tif (dmgTaken > 0) {\n\t\t\tabilityCooldown -= dmgTaken / 10f;\n\t\t\tsummonCooldown -= dmgTaken / 10f;\n\t\t}\n\n\t\tif (phase < 4 && HP <= HT - 300*phase){\n\n\t\t\tphase++;\n\n\t\t\tupdateVisibility(Dungeon.level);\n\t\t\tGLog.n(Messages.get(this, \"darkness\"));\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\n\t\t\tYogFist fist = (YogFist) Reflection.newInstance(fistSummons.remove(0));\n\t\t\tfist.pos = Dungeon.level.exit;\n\n\t\t\tCellEmitter.get(Dungeon.level.exit-1).burst(ShadowParticle.UP, 25);\n\t\t\tCellEmitter.get(Dungeon.level.exit).burst(ShadowParticle.UP, 100);\n\t\t\tCellEmitter.get(Dungeon.level.exit+1).burst(ShadowParticle.UP, 25);\n\n\t\t\tif (abilityCooldown < 5) abilityCooldown = 5;\n\t\t\tif (summonCooldown < 5) summonCooldown = 5;\n\n\t\t\tint targetPos = Dungeon.level.exit + Dungeon.level.width();\n\t\t\tif (Actor.findChar(targetPos) == null){\n\t\t\t\tfist.pos = targetPos;\n\t\t\t} else if (Actor.findChar(targetPos-1) == null){\n\t\t\t\tfist.pos = targetPos-1;\n\t\t\t} else if (Actor.findChar(targetPos+1) == null){\n\t\t\t\tfist.pos = targetPos+1;\n\t\t\t}\n\n\t\t\tGameScene.add(fist, 4);\n\t\t\tActor.addDelayed( new Pushing( fist, Dungeon.level.exit, fist.pos ), -1 );\n\t\t}\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null) lock.addTime(dmgTaken);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateVisibility( Level level ){\n\t\tif (phase > 1 && isAlive()){\n\t\t\tlevel.viewDistance = 4 - (phase-1);\n\t\t} else {\n\t\t\tlevel.viewDistance = 4;\n\t\t}\n\t\tlevel.viewDistance = Math.max(1, level.viewDistance);\n\t\tif (Dungeon.hero != null) {\n\t\t\tif (Dungeon.hero.buff(Light.class) == null) {\n\t\t\t\tDungeon.hero.viewDistance = level.viewDistance;\n\t\t\t}\n\t\t\tDungeon.observe();\n\t\t}\n\t}",
          "uniqueId": "5f6285d3d27fc7db3632b9acf5b6f36e5a9801b7_296_353_353_366_297_351"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void die( Object cause ) {\n\n\t\tfor (Mob mob : (Iterable<Mob>)Dungeon.level.mobs.clone()) {\n\t\t\tif (mob instanceof Larva || mob instanceof RipperDemon) {\n\t\t\t\tmob.die( cause );\n\t\t\t}\n\t\t}\n\n\t\tDungeon.level.viewDistance = 4;\n\t\tif (Dungeon.hero.buff(Light.class) == null){\n\t\t\tDungeon.hero.viewDistance = Dungeon.level.viewDistance;\n\t\t}\n\n\t\tGameScene.bossSlain();\n\t\tDungeon.level.unseal();\n\t\tsuper.die( cause );\n\n\t\tyell( Messages.get(this, \"defeated\") );\n\t}",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void die( Object cause ) {\n\n\t\tfor (Mob mob : (Iterable<Mob>)Dungeon.level.mobs.clone()) {\n\t\t\tif (mob instanceof Larva || mob instanceof RipperDemon) {\n\t\t\t\tmob.die( cause );\n\t\t\t}\n\t\t}\n\n\t\tupdateVisibility(Dungeon.level);\n\n\t\tGameScene.bossSlain();\n\t\tDungeon.level.unseal();\n\t\tsuper.die( cause );\n\n\t\tyell( Messages.get(this, \"defeated\") );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateVisibility( Level level ){\n\t\tif (phase > 1 && isAlive()){\n\t\t\tlevel.viewDistance = 4 - (phase-1);\n\t\t} else {\n\t\t\tlevel.viewDistance = 4;\n\t\t}\n\t\tlevel.viewDistance = Math.max(1, level.viewDistance);\n\t\tif (Dungeon.hero != null) {\n\t\t\tif (Dungeon.hero.buff(Light.class) == null) {\n\t\t\t\tDungeon.hero.viewDistance = level.viewDistance;\n\t\t\t}\n\t\t\tDungeon.observe();\n\t\t}\n\t}",
          "uniqueId": "5f6285d3d27fc7db3632b9acf5b6f36e5a9801b7_378_398_353_366_391_408"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "bad49ee880bd27f605f38517905ba7896ed068d5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/bad49ee880bd27f605f38517905ba7896ed068d5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean doPickUp( Hero hero ) {\n\t\t\n\t\tDewVial vial = hero.belongings.getItem( DewVial.class );\n\t\t\n\t\tif (vial != null && !vial.isFull()){\n\t\t\t\n\t\t\tvial.collectDew( this );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t//20 drops for a full heal\n\t\t\tint heal = Math.round( hero.HT * 0.05f * quantity );\n\t\t\t\n\t\t\tint effect = Math.min( hero.HT - hero.HP, heal );\n\t\t\tif (effect > 0) {\n\t\t\t\thero.HP += effect;\n\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\thero.sprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"value\", effect) );\n\t\t\t} else {\n\t\t\t\tGLog.i( Messages.get(this, \"already_full\") );\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.DEWDROP );\n\t\thero.spendAndNext( TIME_TO_PICK_UP );\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean doPickUp( Hero hero ) {\n\t\t\n\t\tDewVial vial = hero.belongings.getItem( DewVial.class );\n\t\t\n\t\tif (vial != null && !vial.isFull()){\n\t\t\t\n\t\t\tvial.collectDew( this );\n\t\t\t\n\t\t} else {\n\n\t\t\tif (!consumeDew(1, hero)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.Sounds.DEWDROP );\n\t\thero.spendAndNext( TIME_TO_PICK_UP );\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean consumeDew(int quantity, Hero hero){\n\t\t//20 drops for a full heal\n\t\tint heal = Math.round( hero.HT * 0.05f * quantity );\n\n\t\tint effect = Math.min( hero.HT - hero.HP, heal );\n\t\tint shield = 0;\n\t\tif (hero.hasTalent(Talent.SHIELDING_DEW)){\n\t\t\tshield = heal - effect;\n\t\t\tint maxShield = Math.round(hero.HT *0.2f*hero.pointsInTalent(Talent.SHIELDING_DEW));\n\t\t\tint curShield = 0;\n\t\t\tif (hero.buff(Barrier.class) != null) curShield = hero.buff(Barrier.class).shielding();\n\t\t\tshield = Math.min(shield, maxShield-curShield);\n\t\t}\n\t\tif (effect > 0 || shield > 0) {\n\t\t\thero.HP += effect;\n\t\t\tif (shield > 0) Buff.affect(hero, Barrier.class).incShield(shield);\n\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\tif (effect > 0 && shield > 0){\n\t\t\t\thero.sprite.showStatus( CharSprite.POSITIVE, Messages.get(Dewdrop.class, \"both\", effect, shield) );\n\t\t\t} else if (effect > 0){\n\t\t\t\thero.sprite.showStatus( CharSprite.POSITIVE, Messages.get(Dewdrop.class, \"heal\", effect) );\n\t\t\t} else {\n\t\t\t\thero.sprite.showStatus( CharSprite.POSITIVE, Messages.get(Dewdrop.class, \"shield\", shield) );\n\t\t\t}\n\n\t\t} else {\n\t\t\tGLog.i( Messages.get(Dewdrop.class, \"already_full\") );\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}",
          "uniqueId": "bad49ee880bd27f605f38517905ba7896ed068d5_42_72_68_99_45_66"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( final Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_DRINK )) {\n\n\t\t\tif (volume > 0) {\n\t\t\t\t\n\t\t\t\tfloat missingHealthPercent = 1f - (hero.HP / (float)hero.HT);\n\t\t\t\t\n\t\t\t\t//trimming off 0.01 drops helps with floating point errors\n\t\t\t\tint dropsNeeded = (int)Math.ceil((missingHealthPercent / 0.05f) - 0.01f);\n\t\t\t\tdropsNeeded = (int)GameMath.gate(1, dropsNeeded, volume);\n\t\t\t\t\n\t\t\t\t//20 drops for a full heal normally\n\t\t\t\tint heal = Math.round( hero.HT * 0.05f * dropsNeeded );\n\t\t\t\t\n\t\t\t\tint effect = Math.min( hero.HT - hero.HP, heal );\n\t\t\t\tif (effect > 0) {\n\t\t\t\t\thero.HP += effect;\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 + dropsNeeded/5 );\n\t\t\t\t\thero.sprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"value\", effect) );\n\t\t\t\t}\n\n\t\t\t\tvolume -= dropsNeeded;\n\n\t\t\t\thero.spend( TIME_TO_DRINK );\n\t\t\t\thero.busy();\n\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.DRINK );\n\t\t\t\thero.sprite.operate( hero.pos );\n\n\t\t\t\tupdateQuickslot();\n\n\n\t\t\t} else {\n\t\t\t\tGLog.w( Messages.get(this, \"empty\") );\n\t\t\t}\n\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( final Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_DRINK )) {\n\n\t\t\tif (volume > 0) {\n\t\t\t\t\n\t\t\t\tfloat missingHealthPercent = 1f - (hero.HP / (float)hero.HT);\n\n\t\t\t\tint curShield = 0;\n\t\t\t\tif (hero.buff(Barrier.class) != null) curShield = hero.buff(Barrier.class).shielding();\n\t\t\t\tint maxShield = Math.round(hero.HT *0.2f*hero.pointsInTalent(Talent.SHIELDING_DEW));\n\t\t\t\tif (hero.hasTalent(Talent.SHIELDING_DEW)){\n\t\t\t\t\tfloat missingShieldPercent = 1f - (curShield / (float)maxShield);\n\t\t\t\t\tmissingShieldPercent *= 0.2f*hero.pointsInTalent(Talent.SHIELDING_DEW);\n\t\t\t\t\tif (missingShieldPercent > 0){\n\t\t\t\t\t\tmissingHealthPercent += missingShieldPercent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//trimming off 0.01 drops helps with floating point errors\n\t\t\t\tint dropsNeeded = (int)Math.ceil((missingHealthPercent / 0.05f) - 0.01f);\n\t\t\t\tdropsNeeded = (int)GameMath.gate(1, dropsNeeded, volume);\n\n\t\t\t\tif (Dewdrop.consumeDew(dropsNeeded, hero)){\n\t\t\t\t\tvolume -= dropsNeeded;\n\n\t\t\t\t\thero.spend(TIME_TO_DRINK);\n\t\t\t\t\thero.busy();\n\n\t\t\t\t\tSample.INSTANCE.play(Assets.Sounds.DRINK);\n\t\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\t\tupdateQuickslot();\n\t\t\t\t}\n\n\n\t\t\t} else {\n\t\t\t\tGLog.w( Messages.get(this, \"empty\") );\n\t\t\t}\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nvolume\t= bundle.getInt( VOLUME );\n\t}\n\n\t@Override\n\tpublic ArrayList<String> actions( Hero hero ) {\n\t\tArrayList<String> actions = super.actions( hero );\n\t\tif (volume > 0) {\n\t\t\tactions.add( AC_DRINK );\n\t\t}\n\t\treturn actions;\n\t}\n\n\t@Override\n\tpublic void execute( final Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_DRINK )) {\n\n\t\t\tif (volume > 0) {\n\t\t\t\t\n\t\t\t\tfloat missingHealthPercent = 1f - (hero.HP / (float)hero.HT);\n\n\t\t\t\tint curShield = 0;\n\t\t\t\tif (hero.buff(Barrier.class) != null) curShield = hero.buff(Barrier.class).shielding();\n\t\t\t\tint maxShield = Math.round(hero.HT *0.2f*hero.pointsInTalent(Talent.SHIELDING_DEW));\n\t\t\t\tif (hero.hasTalent(Talent.SHIELDING_DEW)){\n\t\t\t\t\tfloat missingShieldPercent = 1f - (curShield / (float)maxShield);\n\t\t\t\t\tmissingShieldPercent *= 0.2f*hero.pointsInTalent(Talent.SHIELDING_DEW);\n\t\t\t\t\tif (missingShieldPercent > 0){\n\t\t\t\t\t\tmissingHealthPercent += missingShieldPercent;\n\t\t\t\t\t}",
          "uniqueId": "bad49ee880bd27f605f38517905ba7896ed068d5_80_121_68_99_80_124"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8077c77498d7d1ff6f3c8acfec67752aafff4cc1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8077c77498d7d1ff6f3c8acfec67752aafff4cc1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v0_9_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v0.9.1\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(\"v0.9.1d\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Fixed error with runic transference caused by v0.9.1d\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Targeting errors with projecting bow and ethereal chains\"));\n\n\t\tchanges = new ChangeInfo(\"v0.9.1c\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Frozen carpaccio can now burn like mystery meat\\n\\n\" +\n\t\t\t\t\"_-_ Challenge completion badges can now appear in rankings\\n\\n\" +\n\t\t\t\t\"_-_ Improved blacksmith logic when upgraded item is also equipped\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Various uncommon freeze bugs caused by v0.9.1b\\n\" +\n\t\t\t\t\"_-_ Various minor errors with runic transference\\n\" +\n\t\t\t\t\"_-_ Doors failing to spawn in rare cases\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Rare cases where dieing to a chasm would be recorded as 'Killed by Something'\\n\" +\n\t\t\t\t\"_-_ Various minor errors with magical charge buff\\n\" +\n\t\t\t\t\"_-_ DM-300 rarely using abilities while stunned\\n\" +\n\t\t\t\t\"_-_ Tengu getting extra turns on game load in rare cases\"));\n\n\t\tchanges = new ChangeInfo(\"v0.9.1b\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Necromancers now damage enemies if their summoning position is totally blocked\\n\\n\" +\n\t\t\t\t\"_-_ Rogue's foresight can now also trigger when returning to a floor, if that floor was detected initially\\n\\n\" +\n\t\t\t\t\"_-_ Small UI improvements to rankings window\\n\\n\" +\n\t\t\t\t\"_-_ The Overgrowth curse can now trigger starflower effects\\n\\n\" +\n\t\t\t\t\"_-_ Added some VFX to scroll of transmutation\\n\\n\" +\n\t\t\t\t\"_-_ Piranha are no longer invulnerable to electricity and frost\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Rare freeze errors caused by Cached Rations talent\\n\" +\n\t\t\t\t\"_-_ Various minor visual and text errors\\n\" +\n\t\t\t\t\"_-_ Incorrect numbers in wand of transfusion description\\n\" +\n\t\t\t\t\"_-_ Horn of Plenty not triggering Iron Stomach\\n\" +\n\t\t\t\t\"_-_ Iron Stomach immunity lasting longer than intended\\n\" +\n\t\t\t\t\"_-_ Various minor timing bugs in the Tengu and DM-300 bossfights\\n\" +\n\t\t\t\t\"_-_ Pathfinding errors in DM-300\\n\" +\n\t\t\t\t\"_-_ Bees being affected by Improvised Projectiles when they spawn\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Rare freeze and crash errors\\n\" +\n\t\t\t\t\"_-_ 'death from viscocity' badge not appearing in rankings\\n\" +\n\t\t\t\t\"_-_ Various rare errors with shops\\n\" +\n\t\t\t\t\"_-_ Scrolls of teleportation spending a turn when they fail\\n\" +\n\t\t\t\t\"_-_ Various rare errors with Gladiator's fury\\n\" +\n\t\t\t\t\"_-_ Various rare errors with multiplicity curse\"));\n\n\t\tchanges = new ChangeInfo(\"v0.9.1a\", false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Slightly adjusted the Huntress' splash art to improve details on her face.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Errors with autotargeting and the wand of disintegration\\n\" +\n\t\t\t\t\"_-_ Fissure rooms in the caves rarely failing to make bridges\\n\" +\n\t\t\t\t\"_-_ Enemies not changing targets when their current target cannot be reached\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v0.9.1):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Incorrect badges rarely showing in rankings\\n\" +\n\t\t\t\t\"_-_ Hourglass spawning sand when unidentified or cursed\\n\" +\n\t\t\t\t\"_-_ Hero having a smaller tap region than other characters\\n\" +\n\t\t\t\t\"_-_ Questgivers rarely not being added to the journal\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released December 11th, 2020\\n\" +\n\t\t\t\t\"_-_ 68 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Tier Two Talents!\",\n\t\t\t\t\"_A second tier of talents has been added, including twenty new talents spanning levels 7-12!_\\n\\n\" +\n\t\t\t\t\"The second talent tier is similar to the first, but talent powers are much less focused on the early game. Expect effects that are useful all game long.\\n\\n\" +\n\t\t\t\t\"Look forward to tier 3 of the talent system coming in v0.9.2, which will span levels 13-20.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.DEPTH), \"Levelgen Improvements!\",\n\t\t\t\t\"_The game's level generation system has received a number of improvements!:_\\n\\n\" +\n\t\t\t\t\"_-_ A new region specific room has been added to each dungeon region, 5 in total.\\n\" +\n\t\t\t\t\"_-_ Three new level feelings have been added: large, secrets, and traps.\\n\" +\n\t\t\t\t\"_-_ The level layout system now creates much more varied layouts based on more shapes.\\n\" +\n\t\t\t\t\"_-_ Adjacent rooms can now be merged in many more cases.\\n\" +\n\t\t\t\t\"_-_ Several existing room types have received small tweaks and improvements.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.HUNTRESS, 0, 15, 12, 15), \"Huntress and Rogue Adjustments\",\n\t\t\t\t\"The _Huntress and Rogue_ have both received some adjustments to their innate powers:\\n\\n\" +\n\t\t\t\t\"_-_ Bonus thrown weapon durability is no longer an innate huntress power, it is now a talent.\\n\" +\n\t\t\t\t\"_-_ Short-range mind vision is no longer an innate huntress power, it is now a talent.\\n\\n\" +\n\t\t\t\t\"_-_ The Rogue no longer causes the game to spawn slightly more secret rooms. Instead secret room generation has been slightly increased for all heroes, and the Rogue has talents that help him find these secrets.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Tier One Talent Changes\",\n\t\t\t\t\"Several _tier one talents_ have been changed based on feedback and gameplay data:\\n\\n\" +\n\t\t\t\t\"_- Test Subject_ now triggers on identifying any item, but the healing it grants has been halved.\\n\\n\" +\n\t\t\t\t\"_- Energizing Meal_ is now a T2 talent. In T1 it has been replaced by _Empowering Meal_, which grants bonus damage on wand zaps.\\n\" +\n\t\t\t\t\"_- Tested Hypothesis_ now triggers on identifying any item. It now also grants a small amount of recharging, instead of shielding.\\n\" +\n\t\t\t\t\"_- Energizing Upgrade_ is now a T2 talent. In T1 it has been replaced by _Backup Barrier_, which gives a small shield when the Mage's staff runs out of charge.\\n\\n\" +\n\t\t\t\t\"_- Rationed Meal_ has been removed. It is replaced by _Cached Rations_, which allows the Rogue to find bonus food.\\n\" +\n\t\t\t\t\"_- Mending Shadow_ has been reworked. It is now _Protective Shadows_, which grants the Rogue shielding.\\n\\n\" +\n\t\t\t\t\"_- Invigorating Meal_ is now a T2 talent. In T1 it has been replaced by _Nature's Bounty_, which allows the Huntress to find berries in grass.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Statue grid rooms now appear in the Dwarven City, rather than the Prison.\\n\" +\n\t\t\t\t\"_-_ Pillar rooms now appear in the Prison, rather than the Dwarven City.\\n\\n\" +\n\t\t\t\t\"_-_ The Sad Ghost's reward UI has been improved.\\n\\n\" +\n\t\t\t\t\"_-_ Added a debuff indicating when enemies have thrown weapons attached to them.\\n\\n\" +\n\t\t\t\t\"_-_ Sniper's mark, charm, and terror all now cancel if their subject is dead.\\n\\n\" +\n\t\t\t\t\"_-_ Stones of intuition can now be used on rings.\\n\\n\" +\n\t\t\t\t\"_-_ Barriers now decay more slowly when under 20 shielding.\\n\\n\" +\n\t\t\t\t\"_-_ Elixir of honeyed healing now triggers on-eat talents and satiates 150 turns of hunger, up from 90.\\n\\n\" +\n\t\t\t\t\"_-_ The Mage's staff is no longer automatically set to max charges when imbuing a new wand.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor audiovisual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Curse infusion not awarding item level badge\\n\" +\n\t\t\t\t\"_-_ Various errors with DM-300\\n\" +\n\t\t\t\t\"_-_ Various minor errors relating to time freeze\\n\" +\n\t\t\t\t\"_-_ Dwarf King and some Yog fists rarely taking negative damage\\n\" +\n\t\t\t\t\"_-_ Talisman gaining charge while cursed\\n\" +\n\t\t\t\t\"_-_ Large characters entering tunnels when vertigoed\\n\" +\n\t\t\t\t\"_-_ Assassin blink ignoring hero being rooted\\n\" +\n\t\t\t\t\"_-_ Hero being able to be both well-fed and hungry\\n\" +\n\t\t\t\t\"_-_ Rare AI issues when paths are blocked\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with corruption\\n\" +\n\t\t\t\t\"_-_ Antimagic not applying to wards or magical sleep debuff\\n\" +\n\t\t\t\t\"_-_ Artifacts rarely losing levels when transmuted\\n\" +\n\t\t\t\t\"_-_ High grass appearing on top of plants in rare cases\\n\" +\n\t\t\t\t\"_-_ Characters rarely appearing inside doors or the hero\\n\" +\n\t\t\t\t\"_-_ Talent points being spendable when the hero is dead\\n\" +\n\t\t\t\t\"_-_ Warlocks not having capped health potions drops\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.MAGE, 0, 90, 12, 15), HeroSubClass.BATTLEMAGE.title(),\n\t\t\t\t\"I'm making a variety of adjustments to the _Battlemage_ to make him a more compelling choice vs. the Warlock, and to improve some wands that don't work as well for him as the Warlock:\\n\\n\" +\n\t\t\t\t\"_-_ Staff charge granted on-hit increased to 0.5 from 0.33\\n\\n\" +\n\t\t\t\t\"_- Staff of Magic Missile_ on-hit now gives all wands 0.5 charge, up from 0.33\\n\\n\" +\n\t\t\t\t\"_- Staff of Transfusion_ on-hit now triggers when enemy is charmed\\n\" +\n\t\t\t\t\"_- Staff of Transfusion_ on-hit now grants a shield in addition to a free shot on allies\\n\\n\" +\n\t\t\t\t\"_- Staff of Frost_ on-hit now has a chance to trigger at lower amounts of chill, still guaranteed at 10+ turns.\\n\\n\" +\n\t\t\t\t\"_- Staff of Living Earth_ on-hit now grants 33% of damage as armor, up from 25%.\\n\\n\" +\n\t\t\t\t\"_- Staff of Regrowth_ on-hit now triggers if the hero or enemy are standing in grass.\\n\" +\n\t\t\t\t\"_- Staff of Regrowth_ on-hit now grants herbal healing, instead of spawning grass.\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfTransfusion(),\n\t\t\t\t\"The _Wand of Transfusion_ is currently in an odd place, where it is not very useful as a general wand, but is GREAT when heavily upgraded by the warlock. I'm making a few adjustments so that its power is less polarized, and to make it hopefully more useful when combined with allies:\\n\\n\" +\n\t\t\t\t\"_-_ Starting charges increased to 2, from 1\\n\" +\n\t\t\t\t\"_-_ Shield per-hit adjusted to 5+lvl from 5+2*lvl\\n\" +\n\t\t\t\t\"_-_ Self-damage reduced to 5% of max HP, from 10% max HP\\n\" +\n\t\t\t\t\"_-_ Damage from allies no longer cancels charm effect\"));\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.RING_TOPAZ, null), Messages.get(RingOfEnergy.class, \"name\"),\n\t\t\t\t\"The _Ring of Energy_ is doing better after being buffed to apply to artifacts, but there is still room to make its effect stronger without making it overpowered:\\n\\n\" +\n\t\t\t\t\"_-_ Bonus artifact charging increased from 10% to 15%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Interfaces.TALENT_ICONS, 0, 0, 16, 16), Talent.HEARTY_MEAL.title(),\n\t\t\t\t\"_Hearty Meal_ is currently the strongest tier one talent in the game, so I'm deepening the missing health requirement slightly to make its power a bit harder to access:\\n\\n\" +\n\t\t\t\t\"_-_ Now grants 2/3 healing when hero is below 50% health, down from 3/5\\n\" +\n\t\t\t\t\"_-_ The full 3/5 heal is still available if the hero is below 25% health\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(new SpinnerSprite()), Messages.get(Spinner.class, \"name\"),\n\t\t\t\t\"I'm pulling down the damage of _Cave Spinners_ slightly to address player frustration:\\n\\n\" +\n\t\t\t\t\"_-_ Melee damage down to 10-20 from 10-25\"));\n\n\t\tchanges = new ChangeInfo(\"v0.9.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released October 5th, 2020\\n\" +\n\t\t\t\t\"_-_ 61 days after Shattered v0.8.2\\n\" +\n\t\t\t\t\"_-_ 173 days after Shattered v0.8.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Hero Talents!\",\n\t\t\t\t\"_A new gameplay system has been added!_\\n\\n\" +\n\t\t\t\t\"As you play the game and level up, you now unlock points to spend on hero talents. These talents have a range of effects, from stat adjustments to triggered effects to full on abilities!\\n\\n\" +\n\t\t\t\t\"Talents are split into tiers, and to start only the first tier is available, which covers levels 1 to 6. More talents will be added soon!\\n\\n\" +\n\t\t\t\t\"Previously I would have spent many more months on v0.9.0 and released the entire system in one update, but I'm changing up my strategy and splitting these big updates into smaller parts.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.CHALLENGE_ON), \"Hostile Champions!\",\n\t\t\t\t\"A new challenge has been added: _Hostile Champions!_\\n\\n\" +\n\t\t\t\t\"Unlike most other challenges, this one focuses on amping up the difficulty of the dungeon, rather than removing tools from the player. Give it a try if you've unlocked challenges, and you might find some particularly nasty enemies in the dungeon!\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BADGES), \"Badge Visuals\",\n\t\t\t\t\"The badges screen now shows which badges are locked, rather than just using a generic 'locked badge' visual.\\n\\n\" +\n\t\t\t\t\"Badges now have different border colors based on their difficulty (bronze, silver, gold, platinum, diamond), and are ordered based on these colors.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.WARRIOR, 0, 15, 12, 15), \"Hero balance adjustments\",\n\t\t\t\t\"The _Warrior, Mage, and Huntress_ are getting some balance tweaks to offset their new talents:\\n\\n\" +\n\t\t\t\t\"The _Warrior and Mage_ no longer have innate on-eat effects, these are replaced by their food-based talents.\\n\\n\" +\n\t\t\t\t\"The _Warrior's_ base max shielding has been reduced from 2 to 1, to compensate for his shielding talent.\\n\\n\" +\n\t\t\t\t\"The _Mage_ no longer has an innate wand identification effect, this is replaced by his wand identification talent.\\n\\n\" +\n\t\t\t\t\"The _Huntress'_ studded gloves have had their base damage reduced to 1-5 from 1-6, to compensate for her damage-dealing talent.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.CHALLENGE_OFF), \"Existing Challenges\",\n\t\t\t\t\"Some existing challenges have been tweaked to reduce the number of items that they remove from the game:\\n\\n\" +\n\t\t\t\t\"_On Diet_ no longer restricts food, but instead causes all food to be 1/3 as effective at satiating hunger.\\n\\n\" +\n\t\t\t\t\"_Faith Is My Armor_ no longer restricts the hero to cloth armor, but instead heavily reduces the blocking power of all armor above cloth.\\n\\n\" +\n\t\t\t\t\"_Pharmacophobia_ no longer removes health potions, but instead makes them poisonous to the player.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Unidentified scrolls can now be used to make runestones! You won't know what stones you'll get until you brew the scroll, but the scroll will be retroactively identified.\\n\\n\" +\n\t\t\t\t\"_-_ Reduced hero unlock requirements.\\n\\n\" +\n\t\t\t\t\"_-_ Added HP numbers to the player's health bar.\\n\" +\n\t\t\t\t\"_-_ Tweaked some interface visuals to be more rounded.\\n\\n\" +\n\t\t\t\t\"_-_ Spider webs are now flammable, and can be shot through by fireblast.\\n\" +\n\t\t\t\t\"_-_ The reclaim trap spell can no longer be dropped when a trap is stored in it. This prevents an exploit.\\n\" +\n\t\t\t\t\"_-_ Items gained from secret mazes are now known to be uncursed.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"I'm making some adjustments to sewers loot to give players a bit more control of what gear they get, and to reduce the chance of spawning high tier gear that the player may never get to use:\\n\" +\n\t\t\t\t\"_-_ Chance for regular gear drops in the sewers to be T4/T5 reduced by 50%.\\n\" +\n\t\t\t\t\"_-_ Players can now see what type of weapon/armor the sad ghost has before selecting it.\\n\\n\" +\n\t\t\t\t\"_-_ Statues are now killed if a disarming trap triggers under them.\\n\" +\n\t\t\t\t\"_-_ Weak shields no longer override stronger ones.\\n\" +\n\t\t\t\t\"_-_ Long pressing item slots in the alchemy screen now shows the item's description.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various visual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various rare game freeze bugs\\n\" +\n\t\t\t\t\"_-_ Back button closing the game in hero select\\n\" +\n\t\t\t\t\"_-_ Issues with touch input on Android 11 when gestures are enabled\\n\" +\n\t\t\t\t\"_-_ Crystal mimics escaping when they are still visible\\n\" +\n\t\t\t\t\"_-_ Shadows buff being cancelled by enemies seen via mind vision\\n\" +\n\t\t\t\t\"_-_ Aqua blast occasionally not stunning\\n\" +\n\t\t\t\t\"_-_ Errors with turn spending when talisman is used\\n\" +\n\t\t\t\t\"_-_ Newborn elemental not dropping its quest item for overlevelled heroes\\n\" +\n\t\t\t\t\"_-_ Spinners shooting webs though walls\\n\" +\n\t\t\t\t\"_-_ Elastic enchantment closing doors when used with spirit bow\\n\" +\n\t\t\t\t\"_-_ Shopkeepers buying items worth 0 gold\\n\" +\n\t\t\t\t\"_-_ Duplicate artifacts in rare cases\\n\" +\n\t\t\t\t\"_-_ Custom names not applying to Mage's staff\\n\" +\n\t\t\t\t\"_-_ Ring of might not reducing max HP when degraded\\n\" +\n\t\t\t\t\"_-_ Rare bugs involving ripper demon leaping\\n\" +\n\t\t\t\t\"_-_ Hero unable to cleanse fire with chill when immune to it, and vice-versa\\n\" +\n\t\t\t\t\"_-_ DM-201's attacking while stunned\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (existed prior to v0.9.0):\\n\" +\n\t\t\t\t\"_-_ Tengu's abilities being reset by saving/loading\\n\" +\n\t\t\t\t\"_-_ Various cases where game win badges would not appear\\n\" +\n\t\t\t\t\"_-_ Force cubes trigger traps before being placed to the floor\\n\" +\n\t\t\t\t\"_-_ Beacon of returning rarely teleporting the player into walls\\n\" +\n\t\t\t\t\"_-_ Player being forced to swap equipped misc items when they shouldn't in some cases\\n\" +\n\t\t\t\t\"_-_ Enemies rarely not appearing paralyzed when they are\\n\" +\n\t\t\t\t\"_-_ Great crab sometimes dropping 3 meat instead of 2\\n\" +\n\t\t\t\t\"_-_ Cleave being reset when a kill corrupts the enemy\\n\" +\n\t\t\t\t\"_-_ Sleeping VFX persisting in cases where it shouldn't\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfFrost(),\n\t\t\t\t\"This is actually a bugfix, but I'm listing it separately for clarity. In v0.8.2 the _wand of frost_ is listed as losing 6.67% damage per turn of chill, to a max of -50%. This is not what was implemented however, and the wand instead lost 3.33% per turn to a max of -30%. This has now been corrected and the wand performs as listed in the 0.8.2 changelog.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v0_9_0_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v0.9.0\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released October 5th, 2020\\n\" +\n\t\t\t\t\"_-_ 61 days after Shattered v0.8.2\\n\" +\n\t\t\t\t\"_-_ 173 days after Shattered v0.8.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Hero Talents!\",\n\t\t\t\t\"_A new gameplay system has been added!_\\n\\n\" +\n\t\t\t\t\"As you play the game and level up, you now unlock points to spend on hero talents. These talents have a range of effects, from stat adjustments to triggered effects to full on abilities!\\n\\n\" +\n\t\t\t\t\"Talents are split into tiers, and to start only the first tier is available, which covers levels 1 to 6. More talents will be added soon!\\n\\n\" +\n\t\t\t\t\"Previously I would have spent many more months on v0.9.0 and released the entire system in one update, but I'm changing up my strategy and splitting these big updates into smaller parts.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.CHALLENGE_ON), \"Hostile Champions!\",\n\t\t\t\t\"A new challenge has been added: _Hostile Champions!_\\n\\n\" +\n\t\t\t\t\"Unlike most other challenges, this one focuses on amping up the difficulty of the dungeon, rather than removing tools from the player. Give it a try if you've unlocked challenges, and you might find some particularly nasty enemies in the dungeon!\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.BADGES), \"Badge Visuals\",\n\t\t\t\t\"The badges screen now shows which badges are locked, rather than just using a generic 'locked badge' visual.\\n\\n\" +\n\t\t\t\t\"Badges now have different border colors based on their difficulty (bronze, silver, gold, platinum, diamond), and are ordered based on these colors.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.WARRIOR, 0, 15, 12, 15), \"Hero balance adjustments\",\n\t\t\t\t\"The _Warrior, Mage, and Huntress_ are getting some balance tweaks to offset their new talents:\\n\\n\" +\n\t\t\t\t\"The _Warrior and Mage_ no longer have innate on-eat effects, these are replaced by their food-based talents.\\n\\n\" +\n\t\t\t\t\"The _Warrior's_ base max shielding has been reduced from 2 to 1, to compensate for his shielding talent.\\n\\n\" +\n\t\t\t\t\"The _Mage_ no longer has an innate wand identification effect, this is replaced by his wand identification talent.\\n\\n\" +\n\t\t\t\t\"The _Huntress'_ studded gloves have had their base damage reduced to 1-5 from 1-6, to compensate for her damage-dealing talent.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.CHALLENGE_OFF), \"Existing Challenges\",\n\t\t\t\t\"Some existing challenges have been tweaked to reduce the number of items that they remove from the game:\\n\\n\" +\n\t\t\t\t\"_On Diet_ no longer restricts food, but instead causes all food to be 1/3 as effective at satiating hunger.\\n\\n\" +\n\t\t\t\t\"_Faith Is My Armor_ no longer restricts the hero to cloth armor, but instead heavily reduces the blocking power of all armor above cloth.\\n\\n\" +\n\t\t\t\t\"_Pharmacophobia_ no longer removes health potions, but instead makes them poisonous to the player.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Unidentified scrolls can now be used to make runestones! You won't know what stones you'll get until you brew the scroll, but the scroll will be retroactively identified.\\n\\n\" +\n\t\t\t\t\"_-_ Reduced hero unlock requirements.\\n\\n\" +\n\t\t\t\t\"_-_ Added HP numbers to the player's health bar.\\n\" +\n\t\t\t\t\"_-_ Tweaked some interface visuals to be more rounded.\\n\\n\" +\n\t\t\t\t\"_-_ Spider webs are now flammable, and can be shot through by fireblast.\\n\" +\n\t\t\t\t\"_-_ The reclaim trap spell can no longer be dropped when a trap is stored in it. This prevents an exploit.\\n\" +\n\t\t\t\t\"_-_ Items gained from secret mazes are now known to be uncursed.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"I'm making some adjustments to sewers loot to give players a bit more control of what gear they get, and to reduce the chance of spawning high tier gear that the player may never get to use:\\n\" +\n\t\t\t\t\"_-_ Chance for regular gear drops in the sewers to be T4/T5 reduced by 50%.\\n\" +\n\t\t\t\t\"_-_ Players can now see what type of weapon/armor the sad ghost has before selecting it.\\n\\n\" +\n\t\t\t\t\"_-_ Statues are now killed if a disarming trap triggers under them.\\n\" +\n\t\t\t\t\"_-_ Weak shields no longer override stronger ones.\\n\" +\n\t\t\t\t\"_-_ Long pressing item slots in the alchemy screen now shows the item's description.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits.\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various visual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various rare game freeze bugs\\n\" +\n\t\t\t\t\"_-_ Back button closing the game in hero select\\n\" +\n\t\t\t\t\"_-_ Issues with touch input on Android 11 when gestures are enabled\\n\" +\n\t\t\t\t\"_-_ Crystal mimics escaping when they are still visible\\n\" +\n\t\t\t\t\"_-_ Shadows buff being cancelled by enemies seen via mind vision\\n\" +\n\t\t\t\t\"_-_ Aqua blast occasionally not stunning\\n\" +\n\t\t\t\t\"_-_ Errors with turn spending when talisman is used\\n\" +\n\t\t\t\t\"_-_ Newborn elemental not dropping its quest item for overlevelled heroes\\n\" +\n\t\t\t\t\"_-_ Spinners shooting webs though walls\\n\" +\n\t\t\t\t\"_-_ Elastic enchantment closing doors when used with spirit bow\\n\" +\n\t\t\t\t\"_-_ Shopkeepers buying items worth 0 gold\\n\" +\n\t\t\t\t\"_-_ Duplicate artifacts in rare cases\\n\" +\n\t\t\t\t\"_-_ Custom names not applying to Mage's staff\\n\" +\n\t\t\t\t\"_-_ Ring of might not reducing max HP when degraded\\n\" +\n\t\t\t\t\"_-_ Rare bugs involving ripper demon leaping\\n\" +\n\t\t\t\t\"_-_ Hero unable to cleanse fire with chill when immune to it, and vice-versa\\n\" +\n\t\t\t\t\"_-_ DM-201's attacking while stunned\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (existed prior to v0.9.0):\\n\" +\n\t\t\t\t\"_-_ Tengu's abilities being reset by saving/loading\\n\" +\n\t\t\t\t\"_-_ Various cases where game win badges would not appear\\n\" +\n\t\t\t\t\"_-_ Force cubes trigger traps before being placed to the floor\\n\" +\n\t\t\t\t\"_-_ Beacon of returning rarely teleporting the player into walls\\n\" +\n\t\t\t\t\"_-_ Player being forced to swap equipped misc items when they shouldn't in some cases\\n\" +\n\t\t\t\t\"_-_ Enemies rarely not appearing paralyzed when they are\\n\" +\n\t\t\t\t\"_-_ Great crab sometimes dropping 3 meat instead of 2\\n\" +\n\t\t\t\t\"_-_ Cleave being reset when a kill corrupts the enemy\\n\" +\n\t\t\t\t\"_-_ Sleeping VFX persisting in cases where it shouldn't\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfFrost(),\n\t\t\t\t\"This is actually a bugfix, but I'm listing it separately for clarity. In v0.8.2 the _wand of frost_ is listed as losing 6.67% damage per turn of chill, to a max of -50%. This is not what was implemented however, and the wand instead lost 3.33% per turn to a max of -30%. This has now been corrected and the wand performs as listed in the 0.8.2 changelog.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v0_9_1_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\n\t\tChangeInfo changes = new ChangeInfo(\"v0.9.1\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released December 11th, 2020\\n\" +\n\t\t\t\t\"_-_ 68 days after Shattered v0.9.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Tier Two Talents!\",\n\t\t\t\t\"_A second tier of talents has been added, including twenty new talents spanning levels 7-12!_\\n\\n\" +\n\t\t\t\t\"The second talent tier is similar to the first, but talent powers are much less focused on the early game. Expect effects that are useful all game long.\\n\\n\" +\n\t\t\t\t\"Look forward to tier 3 of the talent system coming in v0.9.2, which will span levels 13-20.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.DEPTH), \"Levelgen Improvements!\",\n\t\t\t\t\"_The game's level generation system has received a number of improvements!:_\\n\\n\" +\n\t\t\t\t\"_-_ A new region specific room has been added to each dungeon region, 5 in total.\\n\" +\n\t\t\t\t\"_-_ Three new level feelings have been added: large, secrets, and traps.\\n\" +\n\t\t\t\t\"_-_ The level layout system now creates much more varied layouts based on more shapes.\\n\" +\n\t\t\t\t\"_-_ Adjacent rooms can now be merged in many more cases.\\n\" +\n\t\t\t\t\"_-_ Several existing room types have received small tweaks and improvements.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.HUNTRESS, 0, 15, 12, 15), \"Huntress and Rogue Adjustments\",\n\t\t\t\t\"The _Huntress and Rogue_ have both received some adjustments to their innate powers:\\n\\n\" +\n\t\t\t\t\"_-_ Bonus thrown weapon durability is no longer an innate huntress power, it is now a talent.\\n\" +\n\t\t\t\t\"_-_ Short-range mind vision is no longer an innate huntress power, it is now a talent.\\n\\n\" +\n\t\t\t\t\"_-_ The Rogue no longer causes the game to spawn slightly more secret rooms. Instead secret room generation has been slightly increased for all heroes, and the Rogue has talents that help him find these secrets.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.TALENT), \"Tier One Talent Changes\",\n\t\t\t\t\"Several _tier one talents_ have been changed based on feedback and gameplay data:\\n\\n\" +\n\t\t\t\t\"_- Test Subject_ now triggers on identifying any item, but the healing it grants has been halved.\\n\\n\" +\n\t\t\t\t\"_- Energizing Meal_ is now a T2 talent. In T1 it has been replaced by _Empowering Meal_, which grants bonus damage on wand zaps.\\n\" +\n\t\t\t\t\"_- Tested Hypothesis_ now triggers on identifying any item. It now also grants a small amount of recharging, instead of shielding.\\n\" +\n\t\t\t\t\"_- Energizing Upgrade_ is now a T2 talent. In T1 it has been replaced by _Backup Barrier_, which gives a small shield when the Mage's staff runs out of charge.\\n\\n\" +\n\t\t\t\t\"_- Rationed Meal_ has been removed. It is replaced by _Cached Rations_, which allows the Rogue to find bonus food.\\n\" +\n\t\t\t\t\"_- Mending Shadow_ has been reworked. It is now _Protective Shadows_, which grants the Rogue shielding.\\n\\n\" +\n\t\t\t\t\"_- Invigorating Meal_ is now a T2 talent. In T1 it has been replaced by _Nature's Bounty_, which allows the Huntress to find berries in grass.\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Statue grid rooms now appear in the Dwarven City, rather than the Prison.\\n\" +\n\t\t\t\t\"_-_ Pillar rooms now appear in the Prison, rather than the Dwarven City.\\n\\n\" +\n\t\t\t\t\"_-_ Improved blacksmith logic when upgraded item is also equipped\\n\" +\n\t\t\t\t\"_-_ Stones of intuition can now be used on rings.\\n\" +\n\t\t\t\t\"_-_ Elixir of honeyed healing now triggers on-eat talents and satiates 150 turns of hunger, up from 90.\\n\" +\n\t\t\t\t\"_-_ The Mage's staff is no longer automatically set to max charges when imbuing a new wand.\\n\" +\n\t\t\t\t\"_-_ Frozen carpaccio can now burn like mystery meat\\n\\n\" +\n\t\t\t\t\"_-_ Necromancers now damage enemies if their summoning position is totally blocked\\n\" +\n\t\t\t\t\"_-_ Piranha are no longer invulnerable to electricity and frost\\n\\n\" +\n\t\t\t\t\"_-_ Barriers now decay more slowly when under 20 shielding.\\n\" +\n\t\t\t\t\"_-_ Sniper's mark, charm, and terror all now cancel if their subject is dead.\\n\" +\n\t\t\t\t\"_-_ Rogue's foresight can now also trigger when returning to a floor, if that floor was detected initially\\n\" +\n\t\t\t\t\"_-_ The Overgrowth curse can now trigger starflower effects\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Slightly adjusted the Huntress' splash art to improve details on her face.\\n\" +\n\t\t\t\t\"_-_ The Sad Ghost's reward UI has been improved.\\n\" +\n\t\t\t\t\"_-_ Small UI improvements to rankings window\\n\" +\n\t\t\t\t\"_-_ Challenge completion badges can now appear in rankings\\n\" +\n\t\t\t\t\"_-_ Added a debuff indicating when enemies have thrown weapons attached to them.\\n\" +\n\t\t\t\t\"_-_ Added some VFX to scroll of transmutation\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor audiovisual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash and freeze bugs\\n\" +\n\t\t\t\t\"_-_ Targeting errors with projecting bow and ethereal chains\\n\" +\n\t\t\t\t\"_-_ Curse infusion not awarding item level badge\\n\" +\n\t\t\t\t\"_-_ Talisman gaining charge while cursed\\n\" +\n\t\t\t\t\"_-_ Artifacts rarely losing levels when transmuted\\n\" +\n\t\t\t\t\"_-_ Hourglass spawning sand when unidentified or cursed\\n\" +\n\t\t\t\t\"_-_ Various rare errors with shops\\n\" +\n\t\t\t\t\"_-_ Scrolls of teleportation spending a turn when they fail\\n\" +\n\t\t\t\t\"_-_ Tengu getting extra turns on game load in rare cases\\n\" +\n\t\t\t\t\"_-_ Various errors with DM-300\\n\" +\n\t\t\t\t\"_-_ Dwarf King and some Yog fists rarely taking negative damage\\n\" +\n\t\t\t\t\"_-_ Warlocks not having capped health potions drops\\n\" +\n\t\t\t\t\"_-_ Large characters entering tunnels when vertigoed\\n\" +\n\t\t\t\t\"_-_ Rare AI issues when paths are blocked\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various minor errors relating to time freeze\\n\" +\n\t\t\t\t\"_-_ Assassin blink ignoring hero being rooted\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with corruption\\n\" +\n\t\t\t\t\"_-_ Hero being able to be both well-fed and hungry\\n\" +\n\t\t\t\t\"_-_ Antimagic not applying to wards or magical sleep debuff\\n\" +\n\t\t\t\t\"_-_ Various rare errors with Gladiator's fury\\n\" +\n\t\t\t\t\"_-_ Various rare errors with multiplicity curse\\n\" +\n\t\t\t\t\"_-_ Various minor errors with magical charge buff\\n\" +\n\t\t\t\t\"_-_ Rare cases where dieing to a chasm would be recorded as 'Killed by Something'\\n\" +\n\t\t\t\t\"_-_ Hero having a smaller tap region than other characters\\n\" +\n\t\t\t\t\"_-_ Questgivers rarely not being added to the journal\\n\" +\n\t\t\t\t\"_-_ 'death from viscocity' badge not appearing in rankings\\n\" +\n\t\t\t\t\"_-_ Incorrect badges rarely showing in rankings\\n\" +\n\t\t\t\t\"_-_ High grass appearing on top of plants in rare cases\\n\" +\n\t\t\t\t\"_-_ Characters rarely appearing inside doors or the hero\\n\" +\n\t\t\t\t\"_-_ Talent points being spendable when the hero is dead\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.MAGE, 0, 90, 12, 15), HeroSubClass.BATTLEMAGE.title(),\n\t\t\t\t\"I'm making a variety of adjustments to the _Battlemage_ to make him a more compelling choice vs. the Warlock, and to improve some wands that don't work as well for him as the Warlock:\\n\\n\" +\n\t\t\t\t\"_-_ Staff charge granted on-hit increased to 0.5 from 0.33\\n\\n\" +\n\t\t\t\t\"_- Staff of Magic Missile_ on-hit now gives all wands 0.5 charge, up from 0.33\\n\\n\" +\n\t\t\t\t\"_- Staff of Transfusion_ on-hit now triggers when enemy is charmed\\n\" +\n\t\t\t\t\"_- Staff of Transfusion_ on-hit now grants a shield in addition to a free shot on allies\\n\\n\" +\n\t\t\t\t\"_- Staff of Frost_ on-hit now has a chance to trigger at lower amounts of chill, still guaranteed at 10+ turns.\\n\\n\" +\n\t\t\t\t\"_- Staff of Living Earth_ on-hit now grants 33% of damage as armor, up from 25%.\\n\\n\" +\n\t\t\t\t\"_- Staff of Regrowth_ on-hit now triggers if the hero or enemy are standing in grass.\\n\" +\n\t\t\t\t\"_- Staff of Regrowth_ on-hit now grants herbal healing, instead of spawning grass.\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfTransfusion(),\n\t\t\t\t\"The _Wand of Transfusion_ is currently in an odd place, where it is not very useful as a general wand, but is GREAT when heavily upgraded by the warlock. I'm making a few adjustments so that its power is less polarized, and to make it hopefully more useful when combined with allies:\\n\\n\" +\n\t\t\t\t\"_-_ Starting charges increased to 2, from 1\\n\" +\n\t\t\t\t\"_-_ Shield per-hit adjusted to 5+lvl from 5+2*lvl\\n\" +\n\t\t\t\t\"_-_ Self-damage reduced to 5% of max HP, from 10% max HP\\n\" +\n\t\t\t\t\"_-_ Damage from allies no longer cancels charm effect\"));\n\n\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.RING_TOPAZ, null), Messages.get(RingOfEnergy.class, \"name\"),\n\t\t\t\t\"The _Ring of Energy_ is doing better after being buffed to apply to artifacts, but there is still room to make its effect stronger without making it overpowered:\\n\\n\" +\n\t\t\t\t\"_-_ Bonus artifact charging increased from 10% to 15%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Interfaces.TALENT_ICONS, 0, 0, 16, 16), Talent.HEARTY_MEAL.title(),\n\t\t\t\t\"_Hearty Meal_ is currently the strongest tier one talent in the game, so I'm deepening the missing health requirement slightly to make its power a bit harder to access:\\n\\n\" +\n\t\t\t\t\"_-_ Now grants 2/3 healing when hero is below 50% health, down from 3/5\\n\" +\n\t\t\t\t\"_-_ The full 3/5 heal is still available if the hero is below 25% health\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(new SpinnerSprite()), Messages.get(Spinner.class, \"name\"),\n\t\t\t\t\"I'm pulling down the damage of _Cave Spinners_ slightly to address player frustration:\\n\\n\" +\n\t\t\t\t\"_-_ Melee damage down to 10-20 from 10-25\"));\n\n\t}",
          "uniqueId": "8077c77498d7d1ff6f3c8acfec67752aafff4cc1_49_353_50_199_201_304"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "778fafbcdd1c4e303db24a0c49060e4d4c8c1adc",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/778fafbcdd1c4e303db24a0c49060e4d4c8c1adc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void destroy() {\n\t\t\n\t\t//tell the actor thread to finish, then wait for it to complete any actions it may be doing.\n\t\tif (actorThread != null && actorThread.isAlive()){\n\t\t\tsynchronized (GameScene.class){\n\t\t\t\tsynchronized (actorThread) {\n\t\t\t\t\tactorThread.interrupt();\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tGameScene.class.wait(5000);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t}\n\t\t\t\tsynchronized (actorThread) {\n\t\t\t\t\tif (Actor.processing()) {\n\t\t\t\t\t\tThrowable t = new Throwable();\n\t\t\t\t\t\tt.setStackTrace(actorThread.getStackTrace());\n\t\t\t\t\t\tthrow new RuntimeException(\"timeout waiting for actor thread! \", t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tEmitter.freezeEmitters = false;\n\t\t\n\t\tscene = null;\n\t\tBadges.saveGlobal();\n\t\tJournal.saveGlobal();\n\t\t\n\t\tsuper.destroy();\n\t}",
          "sourceCodeAfterRefactoring": "public void destroy() {\n\t\t\n\t\t//tell the actor thread to finish, then wait for it to complete any actions it may be doing.\n\t\tif (!waitForActorThread( 4500 )){\n\t\t\tThrowable t = new Throwable();\n\t\t\tt.setStackTrace(actorThread.getStackTrace());\n\t\t\tthrow new RuntimeException(\"timeout waiting for actor thread! \", t);\n\t\t}\n\n\t\tEmitter.freezeEmitters = false;\n\t\t\n\t\tscene = null;\n\t\tBadges.saveGlobal();\n\t\tJournal.saveGlobal();\n\t\t\n\t\tsuper.destroy();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic synchronized boolean waitForActorThread(int msToWait ){\n\t\tif (actorThread != null && actorThread.isAlive()){\n\t\t\treturn true;\n\t\t}\n\t\tsynchronized (actorThread) {\n\t\t\tactorThread.interrupt();\n\t\t}\n\t\ttry {\n\t\t\tGameScene.class.wait(msToWait);\n\t\t} catch (InterruptedException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\t\tsynchronized (actorThread) {\n\t\t\treturn Actor.processing();\n\t\t}\n\t}",
          "uniqueId": "778fafbcdd1c4e303db24a0c49060e4d4c8c1adc_532_562_557_572_532_548"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0d00952eb52ebd3f15ad507a6ac73dc1560268bb",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0d00952eb52ebd3f15ad507a6ac73dc1560268bb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public int STRReq(int lvl){\n\t\tlvl = Math.max(0, lvl);\n\n\t\t//strength req decreases at +1,+3,+6,+10,etc.\n\t\treturn (8 + Math.round(tier * 2)) - (int)(Math.sqrt(8 * lvl + 1) - 1)/2;\n\t}",
          "sourceCodeAfterRefactoring": "public int STRReq(int lvl){\n\t\treturn STRReq(tier, lvl);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static int STRReq(int tier, int lvl){\n\t\tlvl = Math.max(0, lvl);\n\n\t\t//strength req decreases at +1,+3,+6,+10,etc.\n\t\tint req = (8 + Math.round(tier * 2)) - (int)(Math.sqrt(8 * lvl + 1) - 1)/2;\n\n\t\tif (Dungeon.hero.hasTalent(Talent.STRONGMAN)){\n\t\t\treq -= (Dungeon.hero.pointsInTalent(Talent.STRONGMAN)+1)/2;\n\t\t}\n\n\t\treturn req;\n\t}",
          "uniqueId": "0d00952eb52ebd3f15ad507a6ac73dc1560268bb_530_535_534_545_530_532"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int STRReq(int lvl) {\n\t\tlvl = Math.max(0, lvl);\n\n\t\t//strength req decreases at +1,+3,+6,+10,etc.\n\t\treturn (8 + Math.round(armorTier * 2)) - (int)(Math.sqrt(8 * lvl + 1) - 1)/2;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int STRReq(int lvl) {\n\t\treturn STRReq(armorTier, lvl);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "0d00952eb52ebd3f15ad507a6ac73dc1560268bb_154_160_534_545_154_157"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "7b2fab973009bf01c77e2993f17044a1b3368661",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/7b2fab973009bf01c77e2993f17044a1b3368661",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "Talent(int icon ){\n\t\tthis.icon = icon;\n\t}",
          "sourceCodeAfterRefactoring": "Talent( int icon ){\n\t\tthis(icon, 2);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nTalent( int icon, int maxPoints ){\n\t\tthis.icon = icon;\n\t\tthis.maxPoints = maxPoints;\n\t}",
          "uniqueId": "7b2fab973009bf01c77e2993f17044a1b3368661_123_125_128_131_124_126"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "65a6c54b98bee4da3f6c73924e99c12965113f4c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/65a6c54b98bee4da3f6c73924e99c12965113f4c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void gainCharge( float amt ){\n\t\tpartialCharge += amt;\n\t\twhile (partialCharge >= 1) {\n\t\t\tcurCharges = Math.min(maxCharges, curCharges+1);\n\t\t\tpartialCharge--;\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void gainCharge( float amt ){\n\t\tgainCharge( amt, false );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void gainCharge( float amt, boolean overcharge ){\n\t\tpartialCharge += amt;\n\t\twhile (partialCharge >= 1) {\n\t\t\tif (overcharge) curCharges = Math.min(maxCharges+(int)amt, curCharges+1);\n\t\t\telse curCharges = Math.min(maxCharges, curCharges+1);\n\t\t\tpartialCharge--;\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "uniqueId": "65a6c54b98bee4da3f6c73924e99c12965113f4c_150_157_154_162_150_152"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void gainCharge( float amt ){\n\t\tif (wand != null){\n\t\t\twand.gainCharge(amt);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void gainCharge( float amt ){\n\t\tgainCharge(amt, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void gainCharge( float amt, boolean overcharge ){\n\t\tif (wand != null){\n\t\t\twand.gainCharge(amt, overcharge);\n\t\t}\n\t}",
          "uniqueId": "65a6c54b98bee4da3f6c73924e99c12965113f4c_221_225_223_227_219_221"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3b0aaa7d29d178c6682e7479dbf0965d6420a719",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3b0aaa7d29d178c6682e7479dbf0965d6420a719",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected int randomDropCell() {\n\t\twhile (true) {\n\t\t\tRoom room = randomRoom( StandardRoom.class );\n\t\t\tif (room != null && room != roomEntrance) {\n\t\t\t\tint pos = pointToCell(room.random());\n\t\t\t\tif (passable[pos]\n\t\t\t\t\t\t&& pos != exit\n\t\t\t\t\t\t&& heaps.get(pos) == null\n\t\t\t\t\t\t&& findMob(pos) == null) {\n\t\t\t\t\t\n\t\t\t\t\tTrap t = traps.get(pos);\n\t\t\t\t\t\n\t\t\t\t\t//items cannot spawn on traps which destroy items\n\t\t\t\t\tif (t == null ||\n\t\t\t\t\t\t\t! (t instanceof BurningTrap || t instanceof BlazingTrap\n\t\t\t\t\t\t\t|| t instanceof ChillingTrap || t instanceof FrostTrap\n\t\t\t\t\t\t\t|| t instanceof ExplosiveTrap || t instanceof DisintegrationTrap)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected int randomDropCell(){\n\t\treturn randomDropCell(StandardRoom.class);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int randomDropCell( Class<?extends Room> roomType ) {\n\t\twhile (true) {\n\t\t\tRoom room = randomRoom( roomType );\n\t\t\tif (room != null && room != roomEntrance) {\n\t\t\t\tint pos = pointToCell(room.random());\n\t\t\t\tif (passable[pos]\n\t\t\t\t\t\t&& pos != exit\n\t\t\t\t\t\t&& heaps.get(pos) == null\n\t\t\t\t\t\t&& findMob(pos) == null) {\n\t\t\t\t\t\n\t\t\t\t\tTrap t = traps.get(pos);\n\t\t\t\t\t\n\t\t\t\t\t//items cannot spawn on traps which destroy items\n\t\t\t\t\tif (t == null ||\n\t\t\t\t\t\t\t! (t instanceof BurningTrap || t instanceof BlazingTrap\n\t\t\t\t\t\t\t|| t instanceof ChillingTrap || t instanceof FrostTrap\n\t\t\t\t\t\t\t|| t instanceof ExplosiveTrap || t instanceof DisintegrationTrap)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn pos;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "3b0aaa7d29d178c6682e7479dbf0965d6420a719_478_501_503_526_499_501"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9263fa90f0b128b992998b51ca56b11b4761655c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9263fa90f0b128b992998b51ca56b11b4761655c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( message );\n\n\t\t\tTalent.onFoodEaten(hero, energy);\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.EAT );\n\t\t\t\n\t\t\thero.spend( TIME_TO_EAT );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( message );\n\n\t\t\tTalent.onFoodEaten(hero, energy);\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.Sounds.EAT );\n\t\t\t\n\t\t\thero.spend( eatingTime() );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected float eatingTime(){\n\t\tif (Dungeon.hero.hasTalent(Talent.INVIGORATING_MEAL)){\n\t\t\treturn TIME_TO_EAT - 2;\n\t\t} else {\n\t\t\treturn TIME_TO_EAT;\n\t\t}\n\t}",
          "uniqueId": "9263fa90f0b128b992998b51ca56b11b4761655c_65_90_92_98_65_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6fabcbe3e93e702b9684bedda043c0465013dcbe",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6fabcbe3e93e702b9684bedda043c0465013dcbe",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void setShield( int shield ) {\n\t\tthis.shielding = shield;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t}",
          "sourceCodeAfterRefactoring": "public void setShield( int shield ) {\n\t\tsetShield(shield, 0);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void setShield( int shield, float delay ) {\n\t\tif (this.shielding <= shield) this.shielding = shield;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t\tspend(delay);\n\t}",
          "uniqueId": "6fabcbe3e93e702b9684bedda043c0465013dcbe_51_54_55_59_51_53"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void incShield( int amt ){\n\t\tshielding += amt;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t}",
          "sourceCodeAfterRefactoring": "public void incShield( int amt ){\n\t\tincShield(amt, 0);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void incShield( int amt, float delay ){\n\t\tshielding += amt;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t\tspend(delay);\n\t}",
          "uniqueId": "6fabcbe3e93e702b9684bedda043c0465013dcbe_60_63_69_73_65_67"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void decShield( int amt ){\n\t\tshielding -= amt;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t}",
          "sourceCodeAfterRefactoring": "public void decShield( int amt ){\n\t\tdecShield(amt, 0);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void decShield( int amt, float delay ){\n\t\tshielding -= amt;\n\t\tif (target != null) target.needsShieldUpdate = true;\n\t\tspend(delay);\n\t}",
          "uniqueId": "6fabcbe3e93e702b9684bedda043c0465013dcbe_69_72_83_87_79_81"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "afb53fe171e94a5636a3fb830668ba52d4bd7cbd",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/afb53fe171e94a5636a3fb830668ba52d4bd7cbd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void initClassTalents( Hero hero ){\n\t\twhile (hero.talents.size() < TALENT_TIERS){\n\t\t\thero.talents.add(new LinkedHashMap<>());\n\t\t}\n\n\t\tArrayList<Talent> tierTalents = new ArrayList<>();\n\n\t\t//tier 1\n\t\tswitch (hero.heroClass){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HEARTY_MEAL, ARMSMASTERS_INTUITION, TEST_SUBJECT, IRON_WILL);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, ENERGIZING_MEAL, SCHOLARS_INTUITION, TESTED_HYPOTHESIS, ENERGIZING_UPGRADE);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, RATIONED_MEAL, THIEFS_INTUITION, SUCKER_PUNCH, MENDING_SHADOWS);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, INVIGORATING_MEAL, SURVIVALISTS_INTUITION, FOLLOWUP_STRIKE, NATURES_AID);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\thero.talents.get(0).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 2+\n\t\t//TBD\n\t}",
          "sourceCodeAfterRefactoring": "public static void initClassTalents( Hero hero ){\n\t\tinitClassTalents( hero.heroClass, hero.talents );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void initClassTalents( HeroClass cls, ArrayList<LinkedHashMap<Talent, Integer>> talents ){\n\t\twhile (talents.size() < TALENT_TIERS){\n\t\t\ttalents.add(new LinkedHashMap<>());\n\t\t}\n\n\t\tArrayList<Talent> tierTalents = new ArrayList<>();\n\n\t\t//tier 1\n\t\tswitch (cls){\n\t\t\tcase WARRIOR: default:\n\t\t\t\tCollections.addAll(tierTalents, HEARTY_MEAL, ARMSMASTERS_INTUITION, TEST_SUBJECT, IRON_WILL);\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\tCollections.addAll(tierTalents, ENERGIZING_MEAL, SCHOLARS_INTUITION, TESTED_HYPOTHESIS, ENERGIZING_UPGRADE);\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\t\tCollections.addAll(tierTalents, RATIONED_MEAL, THIEFS_INTUITION, SUCKER_PUNCH, MENDING_SHADOWS);\n\t\t\t\tbreak;\n\t\t\tcase HUNTRESS:\n\t\t\t\tCollections.addAll(tierTalents, INVIGORATING_MEAL, SURVIVALISTS_INTUITION, FOLLOWUP_STRIKE, NATURES_AID);\n\t\t\t\tbreak;\n\t\t}\n\t\tfor (Talent talent : tierTalents){\n\t\t\ttalents.get(0).put(talent, 0);\n\t\t}\n\t\ttierTalents.clear();\n\n\t\t//tier 2+\n\t\t//TBD\n\t}",
          "uniqueId": "afb53fe171e94a5636a3fb830668ba52d4bd7cbd_199_228_203_232_199_201"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public TalentsPane( boolean canUpgrade ) {\n\t\tsuper(new Component());\n\n\t\ttitle = PixelScene.renderTextBlock(Messages.titleCase(Messages.get(this, \"tier\", 1)), 9);\n\t\ttitle.hardlight(Window.TITLE_COLOR);\n\t\tcontent.add(title);\n\n\t\tsetupStars();\n\n\t\tbuttons = new ArrayList<>();\n\t\tfor (Talent talent : Dungeon.hero.talents.get(0).keySet()){\n\t\t\tTalentButton btn = new TalentButton(talent, canUpgrade){\n\t\t\t\t@Override\n\t\t\t\tpublic void upgradeTalent() {\n\t\t\t\t\tsuper.upgradeTalent();\n\t\t\t\t\tsetupStars();\n\t\t\t\t\tTalentsPane.this.layout();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbuttons.add(btn);\n\t\t\tcontent.add(btn);\n\t\t}\n\n\t\tsep = new ColorBlock(0, 1, 0xFF000000);\n\t\tcontent.add(sep);\n\n\t\tblocker = new ColorBlock(0, 0, 0xFF222222);\n\t\tcontent.add(blocker);\n\n\t\tblockText = PixelScene.renderTextBlock(Messages.get(this, \"coming_soon\"), 6);\n\t\tcontent.add(blockText);\n\t}",
          "sourceCodeAfterRefactoring": "public TalentsPane( boolean canUpgrade ) {\n\t\tthis( canUpgrade, Dungeon.hero.talents );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic TalentsPane( boolean canUpgrade, ArrayList<LinkedHashMap<Talent, Integer>> talents ) {\n\t\tsuper(new Component());\n\n\t\ttitle = PixelScene.renderTextBlock(Messages.titleCase(Messages.get(this, \"tier\", 1)), 9);\n\t\ttitle.hardlight(Window.TITLE_COLOR);\n\t\tcontent.add(title);\n\n\t\tif (canUpgrade) setupStars();\n\n\t\tbuttons = new ArrayList<>();\n\t\tfor (Talent talent : talents.get(0).keySet()){\n\t\t\tTalentButton btn = new TalentButton(talent, talents.get(0).get(talent), canUpgrade){\n\t\t\t\t@Override\n\t\t\t\tpublic void upgradeTalent() {\n\t\t\t\t\tsuper.upgradeTalent();\n\t\t\t\t\tsetupStars();\n\t\t\t\t\tTalentsPane.this.layout();\n\t\t\t\t}\n\t\t\t};\n\t\t\tbuttons.add(btn);\n\t\t\tcontent.add(btn);\n\t\t}\n\n\t\tsep = new ColorBlock(0, 1, 0xFF000000);\n\t\tcontent.add(sep);\n\n\t\tblocker = new ColorBlock(0, 0, 0xFF222222);\n\t\tcontent.add(blocker);\n\n\t\tblockText = PixelScene.renderTextBlock(Messages.get(this, \"coming_soon\"), 6);\n\t\tcontent.add(blockText);\n\t}",
          "uniqueId": "afb53fe171e94a5636a3fb830668ba52d4bd7cbd_47_78_52_83_48_50"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0c764c6505d77d239211d343c3405f2ef3f9423f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0c764c6505d77d239211d343c3405f2ef3f9423f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static List<Badge> filtered( boolean global ) {\n\t\t\n\t\tHashSet<Badge> filtered = new HashSet<>(global ? Badges.global : Badges.local);\n\n\t\tIterator<Badge> iterator = filtered.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tBadge badge = iterator.next();\n\t\t\tif ((!global && badge.meta) || badge.image == -1) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\tleaveBest( filtered, Badge.MONSTERS_SLAIN_1, Badge.MONSTERS_SLAIN_2, Badge.MONSTERS_SLAIN_3, Badge.MONSTERS_SLAIN_4 );\n\t\tleaveBest( filtered, Badge.GOLD_COLLECTED_1, Badge.GOLD_COLLECTED_2, Badge.GOLD_COLLECTED_3, Badge.GOLD_COLLECTED_4 );\n\t\tleaveBest( filtered, Badge.BOSS_SLAIN_1, Badge.BOSS_SLAIN_2, Badge.BOSS_SLAIN_3, Badge.BOSS_SLAIN_4 );\n\t\tleaveBest( filtered, Badge.LEVEL_REACHED_1, Badge.LEVEL_REACHED_2, Badge.LEVEL_REACHED_3, Badge.LEVEL_REACHED_4 );\n\t\tleaveBest( filtered, Badge.STRENGTH_ATTAINED_1, Badge.STRENGTH_ATTAINED_2, Badge.STRENGTH_ATTAINED_3, Badge.STRENGTH_ATTAINED_4 );\n\t\tleaveBest( filtered, Badge.FOOD_EATEN_1, Badge.FOOD_EATEN_2, Badge.FOOD_EATEN_3, Badge.FOOD_EATEN_4 );\n\t\tleaveBest( filtered, Badge.ITEM_LEVEL_1, Badge.ITEM_LEVEL_2, Badge.ITEM_LEVEL_3, Badge.ITEM_LEVEL_4 );\n\t\tleaveBest( filtered, Badge.POTIONS_COOKED_1, Badge.POTIONS_COOKED_2, Badge.POTIONS_COOKED_3, Badge.POTIONS_COOKED_4 );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_FIRE, Badge.YASD );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_GAS, Badge.YASD );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_HUNGER, Badge.YASD );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_POISON, Badge.YASD );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_GLYPH, Badge.YASD );\n\t\tleaveBest( filtered, Badge.DEATH_FROM_FALLING, Badge.YASD );\n\t\tleaveBest( filtered, Badge.ALL_WEAPONS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_ARMOR_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_WANDS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_RINGS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_ARTIFACTS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_POTIONS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.ALL_SCROLLS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( filtered, Badge.GAMES_PLAYED_1, Badge.GAMES_PLAYED_2, Badge.GAMES_PLAYED_3, Badge.GAMES_PLAYED_4 );\n\t\tleaveBest( filtered, Badge.CHAMPION_1, Badge.CHAMPION_2, Badge.CHAMPION_3 );\n\t\t\n\t\tArrayList<Badge> list = new ArrayList<>(filtered);\n\t\tCollections.sort( list );\n\t\t\n\t\treturn list;\n\t}",
          "sourceCodeAfterRefactoring": "public static List<Badge> filterReplacedBadges( boolean global ) {\n\n\t\tArrayList<Badge> badges = new ArrayList<>(global ? Badges.global : Badges.local);\n\n\t\tIterator<Badge> iterator = badges.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tBadge badge = iterator.next();\n\t\t\tif ((!global && badge.meta) || badge.image == -1) {\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(badges);\n\n\t\treturn filterReplacedBadges(badges);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static List<Badge> filterReplacedBadges( List<Badge> badges ) {\n\n\t\tleaveBest( badges, Badge.MONSTERS_SLAIN_1, Badge.MONSTERS_SLAIN_2, Badge.MONSTERS_SLAIN_3, Badge.MONSTERS_SLAIN_4 );\n\t\tleaveBest( badges, Badge.GOLD_COLLECTED_1, Badge.GOLD_COLLECTED_2, Badge.GOLD_COLLECTED_3, Badge.GOLD_COLLECTED_4 );\n\t\tleaveBest( badges, Badge.BOSS_SLAIN_1, Badge.BOSS_SLAIN_2, Badge.BOSS_SLAIN_3, Badge.BOSS_SLAIN_4 );\n\t\tleaveBest( badges, Badge.LEVEL_REACHED_1, Badge.LEVEL_REACHED_2, Badge.LEVEL_REACHED_3, Badge.LEVEL_REACHED_4 );\n\t\tleaveBest( badges, Badge.STRENGTH_ATTAINED_1, Badge.STRENGTH_ATTAINED_2, Badge.STRENGTH_ATTAINED_3, Badge.STRENGTH_ATTAINED_4 );\n\t\tleaveBest( badges, Badge.FOOD_EATEN_1, Badge.FOOD_EATEN_2, Badge.FOOD_EATEN_3, Badge.FOOD_EATEN_4 );\n\t\tleaveBest( badges, Badge.ITEM_LEVEL_1, Badge.ITEM_LEVEL_2, Badge.ITEM_LEVEL_3, Badge.ITEM_LEVEL_4 );\n\t\tleaveBest( badges, Badge.POTIONS_COOKED_1, Badge.POTIONS_COOKED_2, Badge.POTIONS_COOKED_3, Badge.POTIONS_COOKED_4 );\n\t\tleaveBest( badges, Badge.DEATH_FROM_FIRE, Badge.YASD );\n\t\tleaveBest( badges, Badge.DEATH_FROM_GAS, Badge.YASD );\n\t\tleaveBest( badges, Badge.DEATH_FROM_HUNGER, Badge.YASD );\n\t\tleaveBest( badges, Badge.DEATH_FROM_POISON, Badge.YASD );\n\t\tleaveBest( badges, Badge.DEATH_FROM_GLYPH, Badge.YASD );\n\t\tleaveBest( badges, Badge.DEATH_FROM_FALLING, Badge.YASD );\n\t\tleaveBest( badges, Badge.ALL_WEAPONS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_ARMOR_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_WANDS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_RINGS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_ARTIFACTS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_POTIONS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.ALL_SCROLLS_IDENTIFIED, Badge.ALL_ITEMS_IDENTIFIED );\n\t\tleaveBest( badges, Badge.GAMES_PLAYED_1, Badge.GAMES_PLAYED_2, Badge.GAMES_PLAYED_3, Badge.GAMES_PLAYED_4 );\n\t\tleaveBest( badges, Badge.CHAMPION_1, Badge.CHAMPION_2, Badge.CHAMPION_3 );\n\t\t\n\t\treturn badges;\n\t}",
          "uniqueId": "0c764c6505d77d239211d343c3405f2ef3f9423f_852_892_871_898_853_869"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5b7ef9dacfba4094c848aa22976026efef80446f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5b7ef9dacfba4094c848aa22976026efef80446f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\t//throw any items that are on top of an immovable char\n\t\tif (properties.contains(Property.IMMOVABLE)){\n\t\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\t\tif (heap != null && heap.type == Heap.Type.HEAP) {\n\t\t\t\tint n;\n\t\t\t\tdo {\n\t\t\t\t\tn = pos + PathFinder.NEIGHBOURS8[Random.Int( 8 )];\n\t\t\t\t} while (!Dungeon.level.passable[n] && !Dungeon.level.avoid[n]);\n\t\t\t\tDungeon.level.drop( heap.pickUp(), n ).sprite.drop( pos );\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\tif (fieldOfView == null || fieldOfView.length != Dungeon.level.length()){\n\t\t\tfieldOfView = new boolean[Dungeon.level.length()];\n\t\t}\n\t\tDungeon.level.updateFieldOfView( this, fieldOfView );\n\n\t\t//throw any items that are on top of an immovable char\n\t\tif (properties.contains(Property.IMMOVABLE)){\n\t\t\tthrowItems();\n\t\t}\n\t\treturn false;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void throwItems(){\n\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\tif (heap != null && heap.type == Heap.Type.HEAP) {\n\t\t\tint n;\n\t\t\tdo {\n\t\t\t\tn = pos + PathFinder.NEIGHBOURS8[Random.Int( 8 )];\n\t\t\t} while (!Dungeon.level.passable[n] && !Dungeon.level.avoid[n]);\n\t\t\tDungeon.level.drop( heap.pickUp(), n ).sprite.drop( pos );\n\t\t}\n\t}",
          "uniqueId": "5b7ef9dacfba4094c848aa22976026efef80446f_127_146_141_150_127_139"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "076b26302cb714c6f343d59574e7db7fbba640c1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/076b26302cb714c6f343d59574e7db7fbba640c1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void commonEffect(final Item origin, final Char user, final Ballistica bolt, final Callback afterZap){\n\t\tswitch(Random.Int(4)){\n\n\t\t\t//anti-entropy\n\t\t\tcase 0:\n\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tChar target = Actor.findChar(bolt.collisionPos);\n\t\t\t\t\t\t\tswitch (Random.Int(2)){\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tif (target != null)\n\t\t\t\t\t\t\t\t\t\tBuff.affect(target, Burning.class).reignite(target);\n\t\t\t\t\t\t\t\t\tBuff.affect(user, Frost.class, Frost.DURATION);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tBuff.affect(user, Burning.class).reignite(user);\n\t\t\t\t\t\t\t\t\tif (target != null)\n\t\t\t\t\t\t\t\t\t\tBuff.affect(target, Frost.class, Frost.DURATION);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tafterZap.call();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t//spawns some regrowth\n\t\t\tcase 1:\n\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.add( Blob.seed(bolt.collisionPos, 30, Regrowth.class));\n\t\t\t\t\t\tafterZap.call();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t//random teleportation\n\t\t\tcase 2:\n\t\t\t\tswitch(Random.Int(2)){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tScrollOfTeleportation.teleportChar(user);\n\t\t\t\t\t\tafterZap.call();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\tChar ch = Actor.findChar( bolt.collisionPos );\n\t\t\t\t\t\t\t\tif (ch != null && !ch.properties().contains(Char.Property.IMMOVABLE)) {\n\t\t\t\t\t\t\t\t\tScrollOfTeleportation.teleportChar(user);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tafterZap.call();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t//random gas at location\n\t\t\tcase 3:\n\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tswitch (Random.Int(3)) {\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tGameScene.add( Blob.seed( bolt.collisionPos, 800, ConfusionGas.class ) );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tGameScene.add( Blob.seed( bolt.collisionPos, 500, ToxicGas.class ) );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tGameScene.add( Blob.seed( bolt.collisionPos, 200, ParalyticGas.class ) );\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSample.INSTANCE.play( Assets.Sounds.GAS );\n\t\t\t\t\t\tafterZap.call();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean cursedEffect(final Item origin, final Char user, final int targetPos){\n\t\tswitch (Random.chances(new float[]{COMMON_CHANCE, UNCOMMON_CHANCE, RARE_CHANCE, VERY_RARE_CHANCE})){\n\t\t\tcase 0: default:\n\t\t\t\treturn commonEffect(origin, user, targetPos);\n\t\t\tcase 1:\n\t\t\t\treturn uncommonEffect(origin, user, targetPos);\n\t\t\tcase 2:\n\t\t\t\treturn rareEffect(origin, user, targetPos);\n\t\t\tcase 3:\n\t\t\t\treturn veryRareEffect(origin, user, targetPos);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static boolean commonEffect(final Item origin, final Char user, final int targetPos){\n\t\tswitch(Random.Int(4)){\n\n\t\t\t//anti-entropy\n\t\t\tcase 0: default:\n\t\t\t\tChar target = Actor.findChar(targetPos);\n\t\t\t\tif (Random.Int(2) == 0) {\n\t\t\t\t\tif (target != null) Buff.affect(target, Burning.class).reignite(target);\n\t\t\t\t\tBuff.affect(user, Frost.class, Frost.DURATION);\n\t\t\t\t} else {\n\t\t\t\t\tBuff.affect(user, Burning.class).reignite(user);\n\t\t\t\t\tif (target != null) Buff.affect(target, Frost.class, Frost.DURATION);\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t//spawns some regrowth\n\t\t\tcase 1:\n\t\t\t\tGameScene.add( Blob.seed(targetPos, 30, Regrowth.class));\n\t\t\t\treturn true;\n\n\t\t\t//random teleportation\n\t\t\tcase 2:\n\t\t\t\tif(Random.Int(2) == 0) {\n\t\t\t\t\tif (user != null && !user.properties().contains(Char.Property.IMMOVABLE)) {\n\t\t\t\t\t\tScrollOfTeleportation.teleportChar(user);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tChar ch = Actor.findChar( targetPos );\n\t\t\t\t\tif (ch != null && !ch.properties().contains(Char.Property.IMMOVABLE)) {\n\t\t\t\t\t\tScrollOfTeleportation.teleportChar(ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn cursedEffect(origin, user, targetPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\n\t\t\t//random gas at location\n\t\t\tcase 3:\n\t\t\t\tSample.INSTANCE.play( Assets.Sounds.GAS );\n\t\t\t\tswitch (Random.Int(3)) {\n\t\t\t\t\tcase 0: default:\n\t\t\t\t\t\tGameScene.add( Blob.seed( targetPos, 800, ConfusionGas.class ) );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tGameScene.add( Blob.seed( targetPos, 500, ToxicGas.class ) );\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tGameScene.add( Blob.seed( targetPos, 200, ParalyticGas.class ) );\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t}\n\n\t}",
          "uniqueId": "076b26302cb714c6f343d59574e7db7fbba640c1_103_181_116_170_103_114"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "39c5da606125cc51df89feb7db311e00bdb4f867",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/39c5da606125cc51df89feb7db311e00bdb4f867",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean collect( Bag container ) {\n\n\t\tfor (Item item : container.items.toArray( new Item[0] )) {\n\t\t\tif (canHold( item )) {\n\t\t\t\tint slot = Dungeon.quickslot.getSlot(item);\n\t\t\t\titem.detachAll(container);\n\t\t\t\tif (!item.collect(this)) {\n\t\t\t\t\titem.collect(container);\n\t\t\t\t}\n\t\t\t\tif (slot != -1) {\n\t\t\t\t\tDungeon.quickslot.setSlot(slot, item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (super.collect( container )) {\n\t\t\t\n\t\t\towner = container.owner;\n\t\t\t\n\t\t\tBadges.validateAllBagsBought( this );\n\t\t\t\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean collect( Bag container ) {\n\n\t\tgrabItems(container);\n\n\t\tif (super.collect( container )) {\n\t\t\t\n\t\t\towner = container.owner;\n\t\t\t\n\t\t\tBadges.validateAllBagsBought( this );\n\t\t\t\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void grabItems( Bag container ){\n\t\tfor (Item item : container.items.toArray( new Item[0] )) {\n\t\t\tif (canHold( item )) {\n\t\t\t\tint slot = Dungeon.quickslot.getSlot(item);\n\t\t\t\titem.detachAll(container);\n\t\t\t\tif (!item.collect(this)) {\n\t\t\t\t\titem.collect(container);\n\t\t\t\t}\n\t\t\t\tif (slot != -1) {\n\t\t\t\t\tDungeon.quickslot.setSlot(slot, item);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "39c5da606125cc51df89feb7db311e00bdb4f867_69_95_100_113_69_84"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6c53c8aa2228a1483272d6b7b615e13ed2b43330",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6c53c8aa2228a1483272d6b7b615e13ed2b43330",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v0_8_1_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.1\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( \"\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( \"v0.8.1a\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"Sound Effect Adjustments\",\n\t\t\t\t\"_-_ The volume of debuffing, item collection, and dewdrop collection sounds has been adjusted.\\n\\n\" +\n\t\t\t\t\"_-_ The grass trampling sound no longer layers ontop of the regular grass stepping sound.\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted the hitsounds for arrows and darts.\\n\" +\n\t\t\t\t\"_-_ Added pitch variance to the attack sounds for the bow and crossbow.\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted the warning sounds that play when the hero is injured.\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted the surprise attack sound to play better on phone speakers.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_- The Wand of Frost_ can now stack chill debuff, instead of just refreshing it. This should make the battlemage's freeze affect more accessible after the nerf, but multiple charges may be needed.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by v0.8.1):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Warlocks not playing their debuff sound if the hero is already debuffed\\n\" +\n\t\t\t\t\"_-_ Various small logic errors with ring of wealth\\n\" +\n\t\t\t\t\"_-_ Wand of warding incorrectly refusing to place a new ward with 1 energy left\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to v0.8.1):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Various minor visual errors\\n\" +\n\t\t\t\t\"_-_ Corpse dust wraiths rarely spawning inside doors\"));\n\n\t\tchanges = new ChangeInfo( Messages.get( ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released June 27th, 2020\\n\" +\n\t\t\t\t\"_-_ 72 days after Shattered v0.8.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"New Hero Select!\",\n\t\t\t\t\"The game's hero select screen has been completely overhauled, and how shows off the heroes in more detail than ever before.\\n\\n\" +\n\t\t\t\t\"The new hero select features a minimal UI that retains all the old functionality while trying to keep out of the way as much as possible. The centerpiece of hero select is now the heroes themselves, who are depicted with _new detailed splash arts_ by Aleksandar Komitov! _Make sure check out their credits listing in the new about page!_\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"Sound Effects\",\n\t\t\t\t\"_15+ new sound effects_ have been added to the game, courtesy of Charlie! _Make sure check out their credits listing in the new about page!_\\n\\n\" +\n\t\t\t\t\"These sounds cover movement, combat, and a bunch of miscellanious situations:\\n\" +\n\t\t\t\t\"_-_ Grass now crunches underfoot (extra loud if it's tall grass), and solid floors now have a more solid sound.\\n\" +\n\t\t\t\t\"_-_ The default hitsound has been remastered, and weapons can now produce slashing, stabbing, or crushing sounds.\\n\" +\n\t\t\t\t\"_-_ Bows, crossbows, and projectile wands have new shooting/hitting sounds.\\n\" +\n\t\t\t\t\"_-_ A new heavy impact sound plays when you land a surprise attack, and a new blocking sound when damage is negated by parrying or shields.\\n\" +\n\t\t\t\t\"_-_ Some misc sounds have also been added for: gas spewing, chains being thrown, magical effects charging up, and the player being hit to low health.\\n\\n\" +\n\t\t\t\t\"I've also remastered the title and ending music tracks to improve their quality and volume.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Interfaces.BUFFS_LARGE, 0, 0, 16, 16), \"Item and Buff Icons\",\n\t\t\t\t\"_Buff icons now have a new fading behaviour_ that much more accurately communicates how much of their duration is left. Several duplicated buff icons have also been recolored so they are distinct.\\n\\n\" +\n\t\t\t\t\"_Item icons have been added to rings!_ To accommodate this, item icons now appear in the top-right of an item's inventory slot. Several existing item icons have also been improved.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalismanOfForesight(),\n\t\t\t\t\"The _Talisman of Foresight_ has received a rework to make its active ability more useful and interactive!\\n\\n\" +\n\t\t\t\t\"A few changes have been made to passive trap detection:\\n\" +\n\t\t\t\t\"_-_ Talisman no longer gains EXP from the hero finding secrets\\n\" +\n\t\t\t\t\"_-_ 'uneasy' status no longer lingers when traps aren't in range\\n\" +\n\t\t\t\t\"_-_ Passive charge speed at max level reduced by 33%\\n\\n\" +\n\t\t\t\t\"The talisman's scry active ability has been redesigned:\\n\" +\n\t\t\t\t\"_-_ Scry now projects outward in a cone, in a direction and distance of the player's choice.\\n\" +\n\t\t\t\t\"_-_ Everything within scry's range is revealed, including the map, secrets, and enemies/items.\\n\" +\n\t\t\t\t\"_-_ The player gets temporary mind vision on revealed enemies/items.\\n\" +\n\t\t\t\t\"_-_ The talisman gains exp based on what it reveals. Secrets are worth the most EXP.\\n\" +\n\t\t\t\t\"_-_ As the talisman levels, max scry distance and mind vision duration increase.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfRegrowth(),\n\t\t\t\t\"The _Wand of Regrowth_ has been reworked, with the goal of making it useful for more than just farming:\\n\\n\" +\n\t\t\t\t\"_-_ Initial charges increased to 2 from 1.\\n\" +\n\t\t\t\t\"_-_ Regrowth now attacks in the same pattern as fireblast, no longer consumes all charges at once.\\n\" +\n\t\t\t\t\"_-_ Rebalanced rooting time, AOE size, farming cap, grass and plant spawning frequency, and upgrade scaling.\\n\" +\n\t\t\t\t\"_-_ Added a new unique plant that is only summoned when spending 3 charges of regrowth.\\n\\n\" +\n\t\t\t\t\"_Starflower_ is no longer a special regrowth plant, so it's getting a few changes:\\n\" +\n\t\t\t\t\"_-_ Starflower no longer has a 1/5 chance to drop its own seed.\\n\" +\n\t\t\t\t\"_-_ Starflower is now 2.5x as rare as other seeds, down from 10x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfMagicMissile(),\n\t\t\t\t\"The _Wand of Magic Missile_ has received a new ability that lets it better synergize with other wands!\\n\\n\" +\n\t\t\t\t\"After zapping with an upgraded magic missile wand, the hero becomes 'magically charged' for a few turns. When the hero zaps with another lower-level wand, the charge is consumed and that wand will act as if it is the same level as the wand of magic missile!\\n\\n\" +\n\t\t\t\t\"My hope with this change is to make magic missile more worthy of upgrades if the player is going for a sort of 'wandslinger' build, while still maintaining the wands weakness when used solo.\\n\\n\" +\n\t\t\t\t\"I intend to closely watch how this change plays out, and make adjustments if it ends up messing with the Mage too much. As a start to this, the _Battlemage_ on-hit effect for magic missile has been toned down, to prevent a magic missile staff plus a single low-level wand being stronger than just imbuing that wand.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.POUCH), \"Item Droprate and Inventory Managment\",\n\t\t\t\t\"I'm making several changes primarily targeted at reducing inventory clutter. These shouldn't have a significant impact on game balance, but should reduce the likelihood of the player's inventory being clogged with low-value items.\\n\\n\" +\n\t\t\t\t\"_-_ Bags now appear inside of themselves, rather than taking up main inventory space.\\n\" +\n\t\t\t\t\"_-_ Consumable drops are now slightly rarer, but the game is now much more likely to give a variety of consumables over the course of a run.\\n\" +\n\t\t\t\t\"_-_ Equipment drops are now slightly rarer, but are also higher in quality on average. In particular enemy equipment drops can now be above +0.\\n\" +\n\t\t\t\t\"_-_ Item drops have been added to DM-200s, Ghouls, and Golems.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Sprites.TENGU, 0, 0, 14, 16), \"Boss Changes\",\n\t\t\t\t\"I'm making some design and balance changes to bosses based on analytics data and feedback:\\n\\n\" +\n\t\t\t\t\"_Tengu_'s second phase has been removed due to its overall negative reception. In exchange, the traps in Tengu's first phase are now more maze-like. Tengu now also receives an accuracy penalty when attacking at melee range.\\n\\n\" +\n\t\t\t\t\"_DM-300_'s boss fight now starts after the player explores its arena, the supercharge sparks now move more quickly, and several dialogue lines have been tweaked. This will hopefully make it easier for the player to understand what to do when DM-300 becomes supercharged.\\n\\n\" +\n\t\t\t\t\"_Yog-Dzewa_ is receiving some smaller balance tweaks:\\n\" +\n\t\t\t\t\"_-_ Yog laser damage down to 20-30 from 20-35\\n\" +\n\t\t\t\t\"_-_ Bright/Dark fist ranged damage down to 10-20 from 12-24\\n\" +\n\t\t\t\t\"_-_ Burning fist now evaporates slightly more water tiles\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"Interface Adjustments\",\n\t\t\t\t\"Aside from the new hero select, several other interfaces have been adjusted as well:\\n\" +\n\t\t\t\t\"_-_ The about scene has been expanded with more credits listings and links.\\n\" +\n\t\t\t\t\"_-_ Small improvements to icon style and button layout on the title screen.\\n\" +\n\t\t\t\t\"_-_ The layout of the language selection window has been improved.\\n\" +\n\t\t\t\t\"_-_ The settings window now uses icons for its tabs, instead of text.\\n\" +\n\t\t\t\t\"_-_ Adjusted the layout of buying and selling windows slightly.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game's startup time has been substantially improved on devices with slower storage.\\n\" +\n\t\t\t\t\"_-_ Volume sliders are now more sensetive at the lower range.\\n\" +\n\t\t\t\t\"_-_ A keybinding has been added for resting.\\n\\n\" +\n\t\t\t\t\"_-_ Passive enemies are no longer automatically surprise attacked.\\n\" +\n\t\t\t\t\"_-_ Several buff durations have been slightly tweaked to be more consistent.\\n\" +\n\t\t\t\t\"_-_ The footwear of nature now only lets you select seeds that you haven't fed to it already.\\n\\n\" +\n\t\t\t\t\"_-_ Cell checking visual effects have been improved.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various visual/textual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Levitation applying ground pressing effects before actually ending\\n\" +\n\t\t\t\t\"_-_ Ascend/descend working while rooted\\n\" +\n\t\t\t\t\"_-_ Scroll of remove curse not being usable while degraded\\n\" +\n\t\t\t\t\"_-_ Stone glyph not clamping negative accuracy or evasion\\n\" +\n\t\t\t\t\"_-_ Incorrect interactions between corrupting and on-kill effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revives waking up mimics\\n\" +\n\t\t\t\t\"_-_ Rogue armor's blink not going over terrain in some cases\\n\" +\n\t\t\t\t\"_-_ DM-300 being able to drill out of its arena in rare cases\\n\" +\n\t\t\t\t\"_-_ Dark & bright fists rarely teleporting to unreachable places\\n\" +\n\t\t\t\t\"_-_ Summoning traps failing to summon anything in some cases\\n\" +\n\t\t\t\t\"_-_ Debuffs being incorrectly persisted in rankings\\n\" +\n\t\t\t\t\"_-_ Tengu cleansing doomed debuff between first and second phase\\n\" +\n\t\t\t\t\"_-_ Gasses being examinable when not visible\\n\" +\n\t\t\t\t\"_-_ Fireblast applying debuffs to dead enemies\\n\" +\n\t\t\t\t\"_-_ Update checker using data on metered networks\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST), \"Ring of Wealth and Lucky Enchant\",\n\t\t\t\t\"The _Ring of Wealth_ has been substantially buffed to make it more worth investing upgrades in:\\n\" +\n\t\t\t\t\"_-_ Regular drop chance boost up to 25% from 20%.\\n\" +\n\t\t\t\t\"_-_ Special ring of wealth drops now increase in value, not frequency, as the ring levels.\\n\" +\n\t\t\t\t\"_-_ Removed guaranteed +0 weapons/armor from special ring of wealth drops.\\n\" +\n\t\t\t\t\"_-_ Added new vfx to special ring of wealth drops to better indicate how rare a drop was.\\n\\n\" +\n\t\t\t\t\"The _Lucky_ Enchantment is also being buffed:\\n\" +\n\t\t\t\t\"_-_ Lucky now gives low and medium value drops from ring of wealth's special reward pool.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), \"Assassin and Sniper\",\n\t\t\t\t\"The _Assassin_ is having a little trouble now that more enemies have tools to counter raw damage, so he's getting a boost:\\n\" +\n\t\t\t\t\"_-_ Preparation now gives a +15% damage bonus at 1/3/6/11 turns, up from a +10% damage bonus at 1/3/6/11/16 turns.\\n\" +\n\t\t\t\t\"_-_ Preparation now executes low health enemies, rather than dealing more damage.\\n\" +\n\t\t\t\t\"_-_ Preparation can now execute bosses if they are very weak.\\n\\n\" +\n\t\t\t\t\"The _Sniper_ is also having trouble after 0.8.0, so she's getting a boost as well:\\n\" +\n\t\t\t\t\"_-_ Sniper's mark now lasts 4 turns, up from 2.\\n\" +\n\t\t\t\t\"_-_ Sniper shot damage scaling with distance increased, now caps at 3x damage, up from 2.5x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"The _Wand of Warding_ has received a variety of changes focused around making it more powerful and easier to use:\\n\" +\n\t\t\t\t\"_-_ Wards/sentries are now inorganic\\n\" +\n\t\t\t\t\"_-_ Ward/sentry energy cost and warding energy capacity reduced by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry vision range increased by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry attack speed standardized to 0.5x/1x\\n\" +\n\t\t\t\t\"_-_ Greater wards now get 5 zaps, up from 4\\n\" +\n\t\t\t\t\"_-_ Lesser sentries now start with 4 less HP for each zap they used as a ward\\n\" +\n\t\t\t\t\"_-_ Upgrading a sentry now always grants it the largest possible health boost\\n\" +\n\t\t\t\t\"_-_ Sentry healing up to 8/10/15 from 6/8/12\\n\\n\" +\n\t\t\t\t\"_-_ Ward sprites now visually darken as they use up charges\\n\" +\n\t\t\t\t\"_-_ Sentries now show how much they are being healed\\n\" +\n\t\t\t\t\"_-_ Wards can now be adjacent to eachother\\n\" +\n\t\t\t\t\"_-_ Wards can now be summoned out of FOV if nothing is in the way\\n\" +\n\t\t\t\t\"_-_ Wards now spawn adjacent to an enemy/wall if shot at one\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_DISINTEGRATION), \"Various Item Buffs\",\n\t\t\t\t\"I'm buffing items that are performing poorly after v0.8.0:\\n\\n\" +\n\t\t\t\t\"Several wands need a boost as raw damage is now less effective:\\n\" +\n\t\t\t\t\"_- Disintegration_ base range up to 6 from 4.\\n\" +\n\t\t\t\t\"_- Lightning_ no longer harms allies, self-damage down to 67% from 100%.\\n\" +\n\t\t\t\t\"_- Frost_ chill damage reduction down to 5% per turn from 10%.\\n\" +\n\t\t\t\t\"_- Fireblast_ now spreads fire in a wider cone shape.\\n\" +\n\t\t\t\t\"_- Potion of Dragon's Breath_ uses this wider cone too.\\n\\n\" +\n\t\t\t\t\"With more ranged enemies, knockback needs more utility:\\n\" +\n\t\t\t\t\"_- Knockback effects_ now close doors if the knockback target was inside one.\\n\\n\" +\n\t\t\t\t\"Various other items/enchants are also being buffed:\\n\" +\n\t\t\t\t\"_- Horn of Plenty_ charge rate increased by 25%\\n\" +\n\t\t\t\t\"_- Shocking_ no longer harms allies\\n\" +\n\t\t\t\t\"_- Camouflage_ now applies regular invisibility\\n\" +\n\t\t\t\t\"_- Flow_ speed multiplier increased to 2 + 0.25xlvl from 2.\\n\" +\n\t\t\t\t\"_- Corrupting_ proc rate scaling increased by ~20%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_CORRUPTION), \"Various Item Nerfs\",\n\t\t\t\t\"I'm nerfing items that are overperforming due to v0.8.0:\\n\\n\" +\n\t\t\t\t\"The _Wand of Corruption_ is once again overpowered, so I'm trying out making it more dependant on enemy health:\\n\" +\n\t\t\t\t\"_-_ Enemies now have 5x resistance at full HP, up from 3x.\\n\\n\" +\n\t\t\t\t\"As _Wand of Frost_ was buffed, I'm scaling back the battlemage's frost ability a bit:\\n\" +\n\t\t\t\t\"_-_ Battlemage frost on-hit now only freezes at 10+ turns of chill, rather than at 2-10 turns.\\n\\n\" +\n\t\t\t\t\"Magic defense items are being scaled back due to the increased number of magical enemies:\\n\" +\n\t\t\t\t\"_- Ring of Elements_ resist per level down to 17.5% from 20%\\n\" +\n\t\t\t\t\"_- Antimagic_ defense reduced by ~20%\\n\\n\" +\n\t\t\t\t\"A few other items/enchants are being adjusted as well:\\n\" +\n\t\t\t\t\"_- Ethereal chains_ levelling speed reduced\\n\" +\n\t\t\t\t\"_- Timekeeper's Hourglass_ sand cost doubled\\n\" +\n\t\t\t\t\"_- Chilling_ and _Shocking_ proc rate reduced\\n\" +\n\t\t\t\t\"_- Swiftness_ now requires 2 tiles of space, up from 1\\n\" +\n\t\t\t\t\"_- Thorns_ proc rate scaling reduced by ~50%\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.GREATAXE), \"Various Weapon Nerfs\",\n\t\t\t\t\"A few weapons are also being toned down:\\n\\n\" +\n\t\t\t\t\"As warlocks no longer reduce hero strength, the greataxe is now much easier to use and is too strong as a result:\\n\" +\n\t\t\t\t\"_- Greataxe_ base dmg reduced to 5-45 from 5-50\\n\\n\" +\n\t\t\t\t\"Defense is now much more useful overall, so several defense-granting weapons are performing better than intended:\\n\" +\n\t\t\t\t\"_- Greatshield_ base block down to 0-6 from 0-10\\n\" +\n\t\t\t\t\"_- Gauntlet_ blocking reduced to 0 from 0-4\\n\" +\n\t\t\t\t\"_- Roundshield_ base dmg down to 3-10 from 3-12\\n\" +\n\t\t\t\t\"_- Roundshield_ base block down to 0-4 from 0-5\\n\" +\n\t\t\t\t\"_- Sai_ blocking reduced to 0 from 0-2\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v0_8_1_Changes( ArrayList<ChangeInfo> changeInfos ){\n\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.1\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( Messages.get( ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released June 27th, 2020\\n\" +\n\t\t\t\t\"_-_ 72 days after Shattered v0.8.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"New Hero Select!\",\n\t\t\t\t\"The game's hero select screen has been completely overhauled, and how shows off the heroes in more detail than ever before.\\n\\n\" +\n\t\t\t\t\"The new hero select features a minimal UI that retains all the old functionality while trying to keep out of the way as much as possible. The centerpiece of hero select is now the heroes themselves, who are depicted with _new detailed splash arts_ by Aleksandar Komitov! _Make sure check out their credits listing in the new about page!_\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"Sound Effects\",\n\t\t\t\t\"_15+ new sound effects_ have been added to the game, courtesy of Charlie! _Make sure check out their credits listing in the new about page!_\\n\\n\" +\n\t\t\t\t\"These sounds cover movement, combat, and a bunch of miscellanious situations:\\n\" +\n\t\t\t\t\"_-_ Grass now crunches underfoot (extra loud if it's tall grass), and solid floors now have a more solid sound.\\n\" +\n\t\t\t\t\"_-_ The default hitsound has been remastered, and weapons can now produce slashing, stabbing, or crushing sounds.\\n\" +\n\t\t\t\t\"_-_ Bows, crossbows, and projectile wands have new shooting/hitting sounds.\\n\" +\n\t\t\t\t\"_-_ A new heavy impact sound plays when you land a surprise attack, and a new blocking sound when damage is negated by parrying or shields.\\n\" +\n\t\t\t\t\"_-_ Some misc sounds have also been added for: gas spewing, chains being thrown, magical effects charging up, and the player being hit to low health.\\n\\n\" +\n\t\t\t\t\"I've also remastered the title and ending music tracks to improve their quality and volume.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Interfaces.BUFFS_LARGE, 0, 0, 16, 16), \"Item and Buff Icons\",\n\t\t\t\t\"_Buff icons now have a new fading behaviour_ that much more accurately communicates how much of their duration is left. Several duplicated buff icons have also been recolored so they are distinct.\\n\\n\" +\n\t\t\t\t\"_Item icons have been added to rings!_ To accommodate this, item icons now appear in the top-right of an item's inventory slot. Several existing item icons have also been improved.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalismanOfForesight(),\n\t\t\t\t\"The _Talisman of Foresight_ has received a rework to make its active ability more useful and interactive!\\n\\n\" +\n\t\t\t\t\"A few changes have been made to passive trap detection:\\n\" +\n\t\t\t\t\"_-_ Talisman no longer gains EXP from the hero finding secrets\\n\" +\n\t\t\t\t\"_-_ 'uneasy' status no longer lingers when traps aren't in range\\n\" +\n\t\t\t\t\"_-_ Passive charge speed at max level reduced by 33%\\n\\n\" +\n\t\t\t\t\"The talisman's scry active ability has been redesigned:\\n\" +\n\t\t\t\t\"_-_ Scry now projects outward in a cone, in a direction and distance of the player's choice.\\n\" +\n\t\t\t\t\"_-_ Everything within scry's range is revealed, including the map, secrets, and enemies/items.\\n\" +\n\t\t\t\t\"_-_ The player gets temporary mind vision on revealed enemies/items.\\n\" +\n\t\t\t\t\"_-_ The talisman gains exp based on what it reveals. Secrets are worth the most EXP.\\n\" +\n\t\t\t\t\"_-_ As the talisman levels, max scry distance and mind vision duration increase.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfRegrowth(),\n\t\t\t\t\"The _Wand of Regrowth_ has been reworked, with the goal of making it useful for more than just farming:\\n\\n\" +\n\t\t\t\t\"_-_ Initial charges increased to 2 from 1.\\n\" +\n\t\t\t\t\"_-_ Regrowth now attacks in the same pattern as fireblast, no longer consumes all charges at once.\\n\" +\n\t\t\t\t\"_-_ Rebalanced rooting time, AOE size, farming cap, grass and plant spawning frequency, and upgrade scaling.\\n\" +\n\t\t\t\t\"_-_ Added a new unique plant that is only summoned when spending 3 charges of regrowth.\\n\\n\" +\n\t\t\t\t\"_Starflower_ is no longer a special regrowth plant, so it's getting a few changes:\\n\" +\n\t\t\t\t\"_-_ Starflower no longer has a 1/5 chance to drop its own seed.\\n\" +\n\t\t\t\t\"_-_ Starflower is now 2.5x as rare as other seeds, down from 10x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfMagicMissile(),\n\t\t\t\t\"The _Wand of Magic Missile_ has received a new ability that lets it better synergize with other wands!\\n\\n\" +\n\t\t\t\t\"After zapping with an upgraded magic missile wand, the hero becomes 'magically charged' for a few turns. When the hero zaps with another lower-level wand, the charge is consumed and that wand will act as if it is the same level as the wand of magic missile!\\n\\n\" +\n\t\t\t\t\"My hope with this change is to make magic missile more worthy of upgrades if the player is going for a sort of 'wandslinger' build, while still maintaining the wands weakness when used solo.\\n\\n\" +\n\t\t\t\t\"I intend to closely watch how this change plays out, and make adjustments if it ends up messing with the Mage too much. As a start to this, the _Battlemage_ on-hit effect for magic missile has been toned down, to prevent a magic missile staff plus a single low-level wand being stronger than just imbuing that wand.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.POUCH), \"Item Droprate and Inventory Managment\",\n\t\t\t\t\"I'm making several changes primarily targeted at reducing inventory clutter. These shouldn't have a significant impact on game balance, but should reduce the likelihood of the player's inventory being clogged with low-value items.\\n\\n\" +\n\t\t\t\t\"_-_ Bags now appear inside of themselves, rather than taking up main inventory space.\\n\" +\n\t\t\t\t\"_-_ Consumable drops are now slightly rarer, but the game is now much more likely to give a variety of consumables over the course of a run.\\n\" +\n\t\t\t\t\"_-_ Equipment drops are now slightly rarer, but are also higher in quality on average. In particular enemy equipment drops can now be above +0.\\n\" +\n\t\t\t\t\"_-_ Item drops have been added to DM-200s, Ghouls, and Golems.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Sprites.TENGU, 0, 0, 14, 16), \"Boss Changes\",\n\t\t\t\t\"I'm making some design and balance changes to bosses based on analytics data and feedback:\\n\\n\" +\n\t\t\t\t\"_Tengu_'s second phase has been removed due to its overall negative reception. In exchange, the traps in Tengu's first phase are now more maze-like. Tengu now also receives an accuracy penalty when attacking at melee range.\\n\\n\" +\n\t\t\t\t\"_DM-300_'s boss fight now starts after the player explores its arena, the supercharge sparks now move more quickly, and several dialogue lines have been tweaked. This will hopefully make it easier for the player to understand what to do when DM-300 becomes supercharged.\\n\\n\" +\n\t\t\t\t\"_Yog-Dzewa_ is receiving some smaller balance tweaks:\\n\" +\n\t\t\t\t\"_-_ Yog laser damage down to 20-30 from 20-35\\n\" +\n\t\t\t\t\"_-_ Bright/Dark fist ranged damage down to 10-20 from 12-24\\n\" +\n\t\t\t\t\"_-_ Burning fist now evaporates slightly more water tiles\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"Interface Adjustments\",\n\t\t\t\t\"Aside from the new hero select, several other interfaces have been adjusted as well:\\n\" +\n\t\t\t\t\"_-_ The about scene has been expanded with more credits listings and links.\\n\" +\n\t\t\t\t\"_-_ Small improvements to icon style and button layout on the title screen.\\n\" +\n\t\t\t\t\"_-_ The layout of the language selection window has been improved.\\n\" +\n\t\t\t\t\"_-_ The settings window now uses icons for its tabs, instead of text.\\n\" +\n\t\t\t\t\"_-_ Adjusted the layout of buying and selling windows slightly.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game's startup time has been substantially improved on devices with slower storage.\\n\" +\n\t\t\t\t\"_-_ Volume sliders are now more sensetive at the lower range.\\n\" +\n\t\t\t\t\"_-_ A keybinding has been added for resting.\\n\\n\" +\n\t\t\t\t\"_-_ Passive enemies are no longer automatically surprise attacked.\\n\" +\n\t\t\t\t\"_-_ Several buff durations have been slightly tweaked to be more consistent.\\n\" +\n\t\t\t\t\"_-_ The footwear of nature now only lets you select seeds that you haven't fed to it already.\\n\\n\" +\n\t\t\t\t\"_-_ Cell checking visual effects have been improved.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various visual/textual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Levitation applying ground pressing effects before actually ending\\n\" +\n\t\t\t\t\"_-_ Ascend/descend working while rooted\\n\" +\n\t\t\t\t\"_-_ Scroll of remove curse not being usable while degraded\\n\" +\n\t\t\t\t\"_-_ Stone glyph not clamping negative accuracy or evasion\\n\" +\n\t\t\t\t\"_-_ Incorrect interactions between corrupting and on-kill effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revives waking up mimics\\n\" +\n\t\t\t\t\"_-_ Rogue armor's blink not going over terrain in some cases\\n\" +\n\t\t\t\t\"_-_ DM-300 being able to drill out of its arena in rare cases\\n\" +\n\t\t\t\t\"_-_ Dark & bright fists rarely teleporting to unreachable places\\n\" +\n\t\t\t\t\"_-_ Summoning traps failing to summon anything in some cases\\n\" +\n\t\t\t\t\"_-_ Debuffs being incorrectly persisted in rankings\\n\" +\n\t\t\t\t\"_-_ Tengu cleansing doomed debuff between first and second phase\\n\" +\n\t\t\t\t\"_-_ Gasses being examinable when not visible\\n\" +\n\t\t\t\t\"_-_ Fireblast applying debuffs to dead enemies\\n\" +\n\t\t\t\t\"_-_ Update checker using data on metered networks\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST), \"Ring of Wealth and Lucky Enchant\",\n\t\t\t\t\"The _Ring of Wealth_ has been substantially buffed to make it more worth investing upgrades in:\\n\" +\n\t\t\t\t\"_-_ Regular drop chance boost up to 25% from 20%.\\n\" +\n\t\t\t\t\"_-_ Special ring of wealth drops now increase in value, not frequency, as the ring levels.\\n\" +\n\t\t\t\t\"_-_ Removed guaranteed +0 weapons/armor from special ring of wealth drops.\\n\" +\n\t\t\t\t\"_-_ Added new vfx to special ring of wealth drops to better indicate how rare a drop was.\\n\\n\" +\n\t\t\t\t\"The _Lucky_ Enchantment is also being buffed:\\n\" +\n\t\t\t\t\"_-_ Lucky now gives low and medium value drops from ring of wealth's special reward pool.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), \"Assassin and Sniper\",\n\t\t\t\t\"The _Assassin_ is having a little trouble now that more enemies have tools to counter raw damage, so he's getting a boost:\\n\" +\n\t\t\t\t\"_-_ Preparation now gives a +15% damage bonus at 1/3/6/11 turns, up from a +10% damage bonus at 1/3/6/11/16 turns.\\n\" +\n\t\t\t\t\"_-_ Preparation now executes low health enemies, rather than dealing more damage.\\n\" +\n\t\t\t\t\"_-_ Preparation can now execute bosses if they are very weak.\\n\\n\" +\n\t\t\t\t\"The _Sniper_ is also having trouble after 0.8.0, so she's getting a boost as well:\\n\" +\n\t\t\t\t\"_-_ Sniper's mark now lasts 4 turns, up from 2.\\n\" +\n\t\t\t\t\"_-_ Sniper shot damage scaling with distance increased, now caps at 3x damage, up from 2.5x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"The _Wand of Warding_ has received a variety of changes focused around making it more powerful and easier to use:\\n\" +\n\t\t\t\t\"_-_ Wards/sentries are now inorganic\\n\" +\n\t\t\t\t\"_-_ Ward/sentry energy cost and warding energy capacity reduced by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry vision range increased by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry attack speed standardized to 0.5x/1x\\n\" +\n\t\t\t\t\"_-_ Greater wards now get 5 zaps, up from 4\\n\" +\n\t\t\t\t\"_-_ Lesser sentries now start with 4 less HP for each zap they used as a ward\\n\" +\n\t\t\t\t\"_-_ Upgrading a sentry now always grants it the largest possible health boost\\n\" +\n\t\t\t\t\"_-_ Sentry healing up to 8/10/15 from 6/8/12\\n\\n\" +\n\t\t\t\t\"_-_ Ward sprites now visually darken as they use up charges\\n\" +\n\t\t\t\t\"_-_ Sentries now show how much they are being healed\\n\" +\n\t\t\t\t\"_-_ Wards can now be adjacent to eachother\\n\" +\n\t\t\t\t\"_-_ Wards can now be summoned out of FOV if nothing is in the way\\n\" +\n\t\t\t\t\"_-_ Wards now spawn adjacent to an enemy/wall if shot at one\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_DISINTEGRATION), \"Various Item Buffs\",\n\t\t\t\t\"I'm buffing items that are performing poorly after v0.8.0:\\n\\n\" +\n\t\t\t\t\"Several wands need a boost as raw damage is now less effective:\\n\" +\n\t\t\t\t\"_- Disintegration_ base range up to 6 from 4.\\n\" +\n\t\t\t\t\"_- Lightning_ no longer harms allies, self-damage down to 67% from 100%.\\n\" +\n\t\t\t\t\"_- Frost_ can now stack chill, and chill damage reduction down to 5% per turn from 10%.\\n\" +\n\t\t\t\t\"_- Fireblast_ now spreads fire in a wider cone shape.\\n\" +\n\t\t\t\t\"_- Potion of Dragon's Breath_ uses this wider cone too.\\n\\n\" +\n\t\t\t\t\"With more ranged enemies, knockback needs more utility:\\n\" +\n\t\t\t\t\"_- Knockback effects_ now close doors if the knockback target was inside one.\\n\\n\" +\n\t\t\t\t\"Various other items/enchants are also being buffed:\\n\" +\n\t\t\t\t\"_- Horn of Plenty_ charge rate increased by 25%\\n\" +\n\t\t\t\t\"_- Shocking_ no longer harms allies\\n\" +\n\t\t\t\t\"_- Camouflage_ now applies regular invisibility\\n\" +\n\t\t\t\t\"_- Flow_ speed multiplier increased to 2 + 0.25xlvl from 2.\\n\" +\n\t\t\t\t\"_- Corrupting_ proc rate scaling increased by ~20%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_CORRUPTION), \"Various Item Nerfs\",\n\t\t\t\t\"I'm nerfing items that are overperforming due to v0.8.0:\\n\\n\" +\n\t\t\t\t\"The _Wand of Corruption_ is once again overpowered, so I'm trying out making it more dependant on enemy health:\\n\" +\n\t\t\t\t\"_-_ Enemies now have 5x resistance at full HP, up from 3x.\\n\\n\" +\n\t\t\t\t\"As _Wand of Frost_ was buffed, I'm scaling back the battlemage's frost ability a bit:\\n\" +\n\t\t\t\t\"_-_ Battlemage frost on-hit now only freezes at 10+ turns of chill, rather than at 2-10 turns.\\n\\n\" +\n\t\t\t\t\"Magic defense items are being scaled back due to the increased number of magical enemies:\\n\" +\n\t\t\t\t\"_- Ring of Elements_ resist per level down to 17.5% from 20%\\n\" +\n\t\t\t\t\"_- Antimagic_ defense reduced by ~20%\\n\\n\" +\n\t\t\t\t\"A few other items/enchants are being adjusted as well:\\n\" +\n\t\t\t\t\"_- Ethereal chains_ levelling speed reduced\\n\" +\n\t\t\t\t\"_- Timekeeper's Hourglass_ sand cost doubled\\n\" +\n\t\t\t\t\"_- Chilling_ and _Shocking_ proc rate reduced\\n\" +\n\t\t\t\t\"_- Swiftness_ now requires 2 tiles of space, up from 1\\n\" +\n\t\t\t\t\"_- Thorns_ proc rate scaling reduced by ~50%\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.GREATAXE), \"Various Weapon Nerfs\",\n\t\t\t\t\"A few weapons are also being toned down:\\n\\n\" +\n\t\t\t\t\"As warlocks no longer reduce hero strength, the greataxe is now much easier to use and is too strong as a result:\\n\" +\n\t\t\t\t\"_- Greataxe_ base dmg reduced to 5-45 from 5-50\\n\\n\" +\n\t\t\t\t\"Defense is now much more useful overall, so several defense-granting weapons are performing better than intended:\\n\" +\n\t\t\t\t\"_- Greatshield_ base block down to 0-6 from 0-10\\n\" +\n\t\t\t\t\"_- Gauntlet_ blocking reduced to 0 from 0-4\\n\" +\n\t\t\t\t\"_- Roundshield_ base dmg down to 3-10 from 3-12\\n\" +\n\t\t\t\t\"_- Roundshield_ base block down to 0-4 from 0-5\\n\" +\n\t\t\t\t\"_- Sai_ blocking reduced to 0 from 0-2\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v0_8_2_Changes( ArrayList<ChangeInfo> changeInfos ) {\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.2\", true, \"\");\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight(Window.TITLE_COLOR);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released August 6th, 2020\\n\" +\n\t\t\t\t\"_-_ 40 days after Shattered v0.8.1\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.ARTIFACT_HORN1), \"Fifth Equipment Slot!\",\n\t\t\t\t\"_An extra slot has been added for rings/artifacts_, bringing the total number of equip slots up to 5!\\n\\n\" +\n\t\t\t\t\"The player can now equip _one ring, one artifact, and one ring or artifact._ The third slot doesn't allow equipping three of the same type of item.\\n\\n\" +\n\t\t\t\t\"I'm hoping this change will reduce the amount that these two item types compete with each other, and also opens up some interesting new build possibilities!\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.NEWS), \"Ingame News Feed\",\n\t\t\t\t\"_A news feed has been added to the game's main menu!_\\n\\n\" +\n\t\t\t\t\"This feed pulls in blog posts from ShatteredPixel.com, and displays then within the game. It will also notify players when new posts are available.\\n\\n\" +\n\t\t\t\t\"I've wanted to improve my communication with the game's playerbase for quite a while, and this is a huge step in that direction.\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_TOPAZ), Messages.get(RingOfEnergy.class, \"name\"),\n\t\t\t\t\"With the changes to equipment slots, I've taken the opportunity to buff and expand the _Ring of Energy_ a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Ring of Energy wand recharge boost down to 20% from 30%\\n\" +\n\t\t\t\t\"_-_ Ring of Energy now increases artifact recharge speed by 10%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight(CharSprite.WARNING);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.DISPLAY), \"Interface Improvements\",\n\t\t\t\t\"Several of the game's interfaces have been substantially improved:\\n\\n\" +\n\t\t\t\t\"_-_ The title screen has received major layout changes. It now has links to the new news screen, and no longer has buttons cluttering the corners\\n\\n\" +\n\t\t\t\t\"_-_ The supporter interface now has its own dedicated scene and improved visuals\\n\\n\" +\n\t\t\t\t\"_-_ The settings window has been expanded with additional options for new and existing functionality\\n\\n\" +\n\t\t\t\t\"_-_ Icons have been added to pages of the adventurer's guidebook\\n\\n\" +\n\t\t\t\t\"_-_ Various minor tweaks/improvements to other interfaces\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.DATA), \"Google Play Functionality\",\n\t\t\t\t\"Several Improvements have been made to Google Play-specific functionality:\\n\\n\" +\n\t\t\t\t\"_-_ Shattered now supports Android instant app and instant game functionality, which lets new users try the game without installing it\\n\\n\" +\n\t\t\t\t\"_-_ Google Play Games is now much smarter about when it prompts the player to sign in if they have already enabled it\\n\\n\" +\n\t\t\t\t\"_-_ Google Play Games now prompts new users to sign in if they already have Google Play Games installed\\n\\n\" +\n\t\t\t\t\"_-_ Journal sync is now supported by Google Play Games functionality\"));\n\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ New sound effects have been added for sheep and the talisman of foresight\\n\" +\n\t\t\t\t\"_-_ The SFX for discovering secrets has been remastered\\n\\n\" +\n\t\t\t\t\"_-_ Thrown potions no longer cleanse ooze/fire from enemies\\n\" +\n\t\t\t\t\"_-_ Strength Potions, Upgrade Scrolls, and items which use them are now considered unique and are immune to burn/freeze\\n\\n\" +\n\t\t\t\t\"_-_ Questgivers now appear in landmarks when they are seen\\n\" +\n\t\t\t\t\"_-_ Shops now appear in landmarks\\n\" +\n\t\t\t\t\"_-_ Items for sale now show their price when being examined\\n\" +\n\t\t\t\t\"_-_ Stackable unique items can now be sold to shops\\n\" +\n\t\t\t\t\"_-_ Entrance doors on floor 2 are now only hidden the first time, not every time before Goo is beaten\\n\" +\n\t\t\t\t\"_-_ Ranged traps will now prefer to shoot visible targets over invisible ones\\n\\n\" +\n\t\t\t\t\"_-_ Added a new language: Ukranian!\\n\" +\n\t\t\t\t\"_-_ Updated translations\"));\n\n\t\tchanges.addButton(new ChangeButton(new Image(Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various rare crash/freeze errors\\n\" +\n\t\t\t\t\"_-_ Various audiovisual errors\\n\" +\n\t\t\t\t\"_-_ Multiple of the same artifact spawning in the same run\\n\" +\n\t\t\t\t\"_-_ Talisman of Foresight taking no time to scry\\n\" +\n\t\t\t\t\"_-_ Talisman of Foresight not gaining exp in some cases\\n\" +\n\t\t\t\t\"_-_ Bees refusing to retarget when target is invulnerable\\n\" +\n\t\t\t\t\"_-_ Blast wave throwing enemies that move after being damaged\\n\" +\n\t\t\t\t\"_-_ Wand of Warding healing sentries for more than intended\\n\" +\n\t\t\t\t\"_-_ Wand of regrowth overriding existing plants/grass\\n\" +\n\t\t\t\t\"_-_ Corrupting enchant attempting to corrupt dead enemies\\n\" +\n\t\t\t\t\"_-_ Magic missile charge buff working incorrectly in specific cases\\n\" +\n\t\t\t\t\"_-_ Large enemies rarely appearing in enclosed spaces\\n\" +\n\t\t\t\t\"_-_ Player being able to drop corpse dust\\n\" +\n\t\t\t\t\"_-_ Remains in pit rooms rarely not being haunted when they contain cursed items\\n\" +\n\t\t\t\t\"_-_ Wandmaker rarely spawning ontop of traps\\n\" +\n\t\t\t\t\"_-_ Tengu placing traps over plants\\n\" +\n\t\t\t\t\"_-_ Items not being IDed in rankings in rare cases\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight(CharSprite.POSITIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST), Messages.get(RingOfWealth.class, \"name\"),\n\t\t\t\t\"The _Ring of Wealth_ is doing better after its buff/rework in v0.8.1, but it's still the weakest ring when upgraded. I'm making some more tweaks to improve its upgrade scaling, and put more emphasis on its new rare drops:\\n\\n\" +\n\t\t\t\t\"_-_ Regular drop chance boost down to 20% from 25%\\n\" +\n\t\t\t\t\"_-_ Now gives a rare drop every 0-25 kills, down from 0-30\\n\" +\n\t\t\t\t\"_-_ Rare drops are now an equip every 4-8 times, down from 5-10\\n\" +\n\t\t\t\t\"_-_ Equip drop minimum upgrade now increments at +1/3/6/10/15, from +1/4/9/16/25\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfBlastWave(),\n\t\t\t\t\"Based on feedback and balance data, I'm making some further adjustments to knockback effects and the _Wand of Blast Wave_:\\n\\n\" +\n\t\t\t\t\"_-_ Knockback effects now only close doors if they originate from a melee attack\\n\" +\n\t\t\t\t\"_-_ Wand of blast wave base damage down to 1-3 from 1-5\\n\" +\n\t\t\t\t\"_-_ Damage from knockback collision doubled\\n\" +\n\t\t\t\t\"_-_ Stun from knockback collision adjusted to 1+dist/2, from dist/2-dist\\n\\n\" +\n\t\t\t\t\"This should fix the usability disparity of knockback between melee and ranged, make stunning more consistent, give another slight buff to elastic/repulsion, and boost blast wave at higher levels without also making it much stronger at +0/+1.\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfFireblast(),\n\t\t\t\t\"While I'm happy with how consistent its new cone logic is, the _Wand of Fireblast_ lost a bit of its chaotic firepower in v0.8.1. So I'm giving it some of that back:\\n\\n\" +\n\t\t\t\t\"_-_ Fireblast can now trickshot just like other wands along the center of its cone\\n\" +\n\t\t\t\t\"_-_ Fireblast now bursts open doors and goes through them\\n\" +\n\t\t\t\t\"_-_ Increased Fireblast's range to 5/7/9 from 4/6/8\"));\n\n\t\tchanges.addButton(new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_WARDING), \"Various Wand Buffs\",\n\t\t\t\t\"I'm buffing a few wands as a followup to the changes made in v0.8.1:\\n\\n\" +\n\t\t\t\t\"The _Wand of Warding_ is in a much better spot, but could still use a slight boost, so I'm increasing the efficiency of its sentries:\\n\" +\n\t\t\t\t\"_-_ Sentry HP up to 35/54/84, from 30/48/70\\n\" +\n\t\t\t\t\"_-_ Upgrade heal up to 19/30, from 18/22\\n\" +\n\t\t\t\t\"_-_ Regular heal up to 9/12/16, from 8/10/15\\n\\n\" +\n\t\t\t\t\"_- Wand of Lightning_ self damage down to 0.5x from 0.67x\\n\\n\" +\n\t\t\t\t\"_- Wand of Magic Missile_ can now empower other wands of magic missile (but this does not create an empower loop)\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight(CharSprite.NEGATIVE);\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton(new ChangeButton(new Quarterstaff(),\n\t\t\t\t\"Along with the nerfs other defense-granting weapons got in v0.8.1, I'm also toning down the _Quarterstaff_ a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Quarterstaff blocking down to 0-2 from 0-3\"));\n\n\t\tchanges.addButton(new ChangeButton(new Flail(),\n\t\t\t\t\"The _Flail_ is currently performing a bit too well, so I'm deepening its accuracy downside a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Flail accuracy penalty up to 20% from 10%\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfRegrowth(),\n\t\t\t\t\"The _Wand of Regrowth_ is currently doing well when heavily upgraded, and EXTREMELY well when lightly upgraded. To address this, I'm pulling some power out of its basic plant and grass generation, and putting a bit more into the golden lotus:\\n\\n\" +\n\t\t\t\t\"_-_ Grass per zap down to 3.67+lvl/3 from 3.5+lvl/2\\n\" +\n\t\t\t\t\"_-_ Plant spawn chance down to 100%/67%/33% from 200%/100%/50%\\n\" +\n\t\t\t\t\"_-_ Seedpod/dewcatcher chance down to 50%/33%/16% from 100%/50%/0%\\n\" +\n\t\t\t\t\"_-_ Lotus lifespan adjusted to 25+3*lvl, from 4*lvl \\n25 -> 40 at +5, 75 -> 70 at +15)\\n\" +\n\t\t\t\t\"_-_ Lotus plant longevity buff adjusted to 40% + 4%/lvl from 25% + 5%/lvl\\n(50% -> 60% at +5, still 100% at +15)\"));\n\n\t\tchanges.addButton(new ChangeButton(new WandOfFrost(),\n\t\t\t\t\"The _Wand of Frost_ is doing a bit too well after its recent buff, so I'm stepping it back just a bit:\\n\\n\" +\n\t\t\t\t\"_-_ Damage reduction per turn of frost up to 6.67% from 5%\\n\" +\n\t\t\t\t\"_-_ Damage reduction now caps at 10 turns of frost (~50% dmg reduction)\"));\n\n\t}",
          "uniqueId": "6c53c8aa2228a1483272d6b7b615e13ed2b43330_64_301_72_214_216_423"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2c4a880d67241227935dea3dffcb8253aa950909",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2c4a880d67241227935dea3dffcb8253aa950909",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tSample.INSTANCE.play( Assets.Sounds.BLAST );\n\t\tBlastWave.blast(bolt.collisionPos);\n\n\t\t//presses all tiles in the AOE first, with the exception of tengu dart traps\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (!(Dungeon.level.traps.get(bolt.collisionPos+i) instanceof TenguDartTrap)) {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos + i);\n\t\t\t}\n\t\t}\n\n\t\t//throws other chars around the center.\n\t\tfor (int i  : PathFinder.NEIGHBOURS8){\n\t\t\tChar ch = Actor.findChar(bolt.collisionPos + i);\n\n\t\t\tif (ch != null){\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tif (ch.alignment != Char.Alignment.ALLY) ch.damage(damageRoll(), this);\n\n\t\t\t\tif (ch.isAlive() && ch.pos == bolt.collisionPos + i) {\n\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, ch.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\tint strength = 1 + Math.round(buffedLvl() / 2f);\n\t\t\t\t\tthrowChar(ch, trajectory, strength);\n\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.get( this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//throws the char at the center of the blast\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (ch != null){\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage(damageRoll(), this);\n\n\t\t\tif (ch.isAlive() && bolt.path.size() > bolt.dist+1 && ch.pos == bolt.collisionPos) {\n\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, bolt.path.get(bolt.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\tint strength = buffedLvl() + 3;\n\t\t\t\tthrowChar(ch, trajectory, strength);\n\t\t\t}\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tSample.INSTANCE.play( Assets.Sounds.BLAST );\n\t\tBlastWave.blast(bolt.collisionPos);\n\n\t\t//presses all tiles in the AOE first, with the exception of tengu dart traps\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (!(Dungeon.level.traps.get(bolt.collisionPos+i) instanceof TenguDartTrap)) {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos + i);\n\t\t\t}\n\t\t}\n\n\t\t//throws other chars around the center.\n\t\tfor (int i  : PathFinder.NEIGHBOURS8){\n\t\t\tChar ch = Actor.findChar(bolt.collisionPos + i);\n\n\t\t\tif (ch != null){\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tif (ch.alignment != Char.Alignment.ALLY) ch.damage(damageRoll(), this);\n\n\t\t\t\tif (ch.isAlive() && ch.pos == bolt.collisionPos + i) {\n\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, ch.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\tint strength = 1 + Math.round(buffedLvl() / 2f);\n\t\t\t\t\tthrowChar(ch, trajectory, strength, false);\n\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.get( this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//throws the char at the center of the blast\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (ch != null){\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage(damageRoll(), this);\n\n\t\t\tif (ch.isAlive() && bolt.path.size() > bolt.dist+1 && ch.pos == bolt.collisionPos) {\n\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, bolt.path.get(bolt.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\tint strength = buffedLvl() + 3;\n\t\t\t\tthrowChar(ch, trajectory, strength, false);\n\t\t\t}\n\t\t}\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void throwChar(final Char ch, final Ballistica trajectory, int power,\n\t                             boolean closeDoors) {\n\t\tthrowChar(ch, trajectory, power, closeDoors, true);\n\t}",
          "uniqueId": "2c4a880d67241227935dea3dffcb8253aa950909_67_111_117_120_67_111"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tSample.INSTANCE.play( Assets.Sounds.BLAST );\n\t\tBlastWave.blast(bolt.collisionPos);\n\n\t\t//presses all tiles in the AOE first, with the exception of tengu dart traps\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (!(Dungeon.level.traps.get(bolt.collisionPos+i) instanceof TenguDartTrap)) {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos + i);\n\t\t\t}\n\t\t}\n\n\t\t//throws other chars around the center.\n\t\tfor (int i  : PathFinder.NEIGHBOURS8){\n\t\t\tChar ch = Actor.findChar(bolt.collisionPos + i);\n\n\t\t\tif (ch != null){\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tif (ch.alignment != Char.Alignment.ALLY) ch.damage(damageRoll(), this);\n\n\t\t\t\tif (ch.isAlive() && ch.pos == bolt.collisionPos + i) {\n\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, ch.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\tint strength = 1 + Math.round(buffedLvl() / 2f);\n\t\t\t\t\tthrowChar(ch, trajectory, strength);\n\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.get( this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//throws the char at the center of the blast\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (ch != null){\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage(damageRoll(), this);\n\n\t\t\tif (ch.isAlive() && bolt.path.size() > bolt.dist+1 && ch.pos == bolt.collisionPos) {\n\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, bolt.path.get(bolt.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\tint strength = buffedLvl() + 3;\n\t\t\t\tthrowChar(ch, trajectory, strength);\n\t\t\t}\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tSample.INSTANCE.play( Assets.Sounds.BLAST );\n\t\tBlastWave.blast(bolt.collisionPos);\n\n\t\t//presses all tiles in the AOE first, with the exception of tengu dart traps\n\t\tfor (int i : PathFinder.NEIGHBOURS9){\n\t\t\tif (!(Dungeon.level.traps.get(bolt.collisionPos+i) instanceof TenguDartTrap)) {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos + i);\n\t\t\t}\n\t\t}\n\n\t\t//throws other chars around the center.\n\t\tfor (int i  : PathFinder.NEIGHBOURS8){\n\t\t\tChar ch = Actor.findChar(bolt.collisionPos + i);\n\n\t\t\tif (ch != null){\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tif (ch.alignment != Char.Alignment.ALLY) ch.damage(damageRoll(), this);\n\n\t\t\t\tif (ch.isAlive() && ch.pos == bolt.collisionPos + i) {\n\t\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, ch.pos + i, Ballistica.MAGIC_BOLT);\n\t\t\t\t\tint strength = 1 + Math.round(buffedLvl() / 2f);\n\t\t\t\t\tthrowChar(ch, trajectory, strength, false);\n\t\t\t\t} else if (ch == Dungeon.hero){\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.get( this, \"ondeath\") );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//throws the char at the center of the blast\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (ch != null){\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage(damageRoll(), this);\n\n\t\t\tif (ch.isAlive() && bolt.path.size() > bolt.dist+1 && ch.pos == bolt.collisionPos) {\n\t\t\t\tBallistica trajectory = new Ballistica(ch.pos, bolt.path.get(bolt.dist + 1), Ballistica.MAGIC_BOLT);\n\t\t\t\tint strength = buffedLvl() + 3;\n\t\t\t\tthrowChar(ch, trajectory, strength, false);\n\t\t\t}\n\t\t}\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void throwChar(final Char ch, final Ballistica trajectory, int power,\n\t                             boolean closeDoors) {\n\t\tthrowChar(ch, trajectory, power, closeDoors, true);\n\t}",
          "uniqueId": "2c4a880d67241227935dea3dffcb8253aa950909_67_111_117_120_67_111"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "40da8d23958d64ebee6541301e1f114396561cb5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/40da8d23958d64ebee6541301e1f114396561cb5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndStory( String text ) {\n\t\tsuper( 0, 0, Chrome.get( Chrome.Type.SCROLL ) );\n\t\t\n\t\ttf = PixelScene.renderTextBlock( text, 6 );\n\t\ttf.maxWidth(PixelScene.landscape() ?\n\t\t\t\t\tWIDTH_L - MARGIN * 2:\n\t\t\t\t\tWIDTH_P - MARGIN *2);\n\t\ttf.invert();\n\t\ttf.setPos(MARGIN, 2);\n\t\tadd( tf );\n\t\t\n\t\tadd( new PointerArea( chrome ) {\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\thide();\n\t\t\t}\n\t\t} );\n\t\t\n\t\tresize( (int)(tf.width() + MARGIN * 2), (int)Math.min( tf.height()+2, 180 ) );\n\t}",
          "sourceCodeAfterRefactoring": "public WndStory( String text ) {\n\t\tthis( null, null, text );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic WndStory(Image icon, String title, String text ) {\n\t\tsuper( 0, 0, Chrome.get( Chrome.Type.SCROLL ) );\n\n\t\tint width = PixelScene.landscape() ? WIDTH_L - MARGIN * 2: WIDTH_P - MARGIN *2;\n\n\t\tfloat y = MARGIN;\n\t\tif (icon != null && title != null){\n\t\t\tttl = new IconTitle(icon, title);\n\t\t\tttl.setRect(MARGIN, y, width-2*MARGIN, 0);\n\t\t\ty = ttl.bottom()+MARGIN;\n\t\t\tadd(ttl);\n\t\t\tttl.tfLabel.invert();\n\t\t}\n\t\t\n\t\ttf = PixelScene.renderTextBlock( text, 6 );\n\t\ttf.maxWidth(width);\n\t\ttf.invert();\n\t\ttf.setPos(MARGIN, y);\n\t\tadd( tf );\n\t\t\n\t\tadd( new PointerArea( chrome ) {\n\t\t\t@Override\n\t\t\tprotected void onClick( PointerEvent event ) {\n\t\t\t\thide();\n\t\t\t}\n\t\t} );\n\t\t\n\t\tresize( (int)(tf.width() + MARGIN * 2), (int)Math.min( tf.bottom()+MARGIN, 180 ) );\n\t}",
          "uniqueId": "40da8d23958d64ebee6541301e1f114396561cb5_65_84_71_99_67_69"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6cca2154d6ca006ba8dedc02daa626a70eb8f4a3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6cca2154d6ca006ba8dedc02daa626a70eb8f4a3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void checkForUpdate(){\n\t\tif (!supportsUpdates()) return;\n\t\tif (lastCheck != null && (new Date().getTime() - lastCheck.getTime()) < CHECK_DELAY) return;\n\n\t\tservice.checkForUpdate(!SPDSettings.WiFi(), new UpdateService.UpdateResultCallback() {\n\t\t\t@Override\n\t\t\tpublic void onUpdateAvailable(AvailableUpdateData update) {\n\t\t\t\tlastCheck = new Date();\n\t\t\t\tupdateData = update;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNoUpdateFound() {\n\t\t\t\tlastCheck = new Date();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onConnectionFailed() {\n\t\t\t\tlastCheck = null;\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "public static void checkForUpdate(){\n\t\tif (!isUpdateable()) return;\n\t\tif (lastCheck != null && (new Date().getTime() - lastCheck.getTime()) < CHECK_DELAY) return;\n\n\t\tservice.checkForUpdate(!SPDSettings.WiFi(), new UpdateService.UpdateResultCallback() {\n\t\t\t@Override\n\t\t\tpublic void onUpdateAvailable(AvailableUpdateData update) {\n\t\t\t\tlastCheck = new Date();\n\t\t\t\tupdateData = update;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onNoUpdateFound() {\n\t\t\t\tlastCheck = new Date();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onConnectionFailed() {\n\t\t\t\tlastCheck = null;\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean isUpdateable(){\n\t\treturn supportsUpdates() && service.isUpdateable();\n\t}",
          "uniqueId": "6cca2154d6ca006ba8dedc02daa626a70eb8f4a3_39_60_39_41_43_64"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0b568f5a58994567125d2337c149ecb0fd613c10",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0b568f5a58994567125d2337c149ecb0fd613c10",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void reset() {\n\t\tfor (Category cat : Category.values()) {\n\t\t\tcategoryProbs.put( cat, cat.prob );\n\t\t\tif (cat.defaultProbs != null) cat.probs = cat.defaultProbs.clone();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void fullReset() {\n\t\tgeneralReset();\n\t\tfor (Category cat : Category.values()) {\n\t\t\treset(cat);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void generalReset(){\n\t\tfor (Category cat : Category.values()) {\n\t\t\tcategoryProbs.put( cat, cat.prob );\n\t\t}\n\t}",
          "uniqueId": "0b568f5a58994567125d2337c149ecb0fd613c10_474_479_481_485_474_479"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ea4d45da7f82d3e92a0b57f765bfd0903ee59dff",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ea4d45da7f82d3e92a0b57f765bfd0903ee59dff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void die() {\n\t\tsleeping = false;\n\t\tplay( die );\n\t\t\n\t\tif (emo != null) {\n\t\t\temo.killAndErase();\n\t\t}\n\t\t\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void die() {\n\t\tsleeping = false;\n\t\tplay( die );\n\n\t\thideEmo();\n\t\t\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void hideEmo(){\n\t\tsynchronized (EmoIcon.class) {\n\t\t\tif (emo != null) {\n\t\t\t\temo.killAndErase();\n\t\t\t\temo = null;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "ea4d45da7f82d3e92a0b57f765bfd0903ee59dff_291_302_577_584_291_300"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void kill() {\n\t\tsuper.kill();\n\t\t\n\t\tif (emo != null) {\n\t\t\temo.killAndErase();\n\t\t}\n\t\t\n\t\tfor( State s : State.values()){\n\t\t\tremove(s);\n\t\t}\n\t\t\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void kill() {\n\t\tsuper.kill();\n\t\t\n\t\thideEmo();\n\t\t\n\t\tfor( State s : State.values()){\n\t\t\tremove(s);\n\t\t}\n\t\t\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void hideEmo(){\n\t\tsynchronized (EmoIcon.class) {\n\t\t\tif (emo != null) {\n\t\t\t\temo.killAndErase();\n\t\t\t\temo = null;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "ea4d45da7f82d3e92a0b57f765bfd0903ee59dff_572_587_577_584_586_599"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void crumple(){\n\t\tif (emo != null){\n\t\t\temo.killAndErase();\n\t\t\temo = null;\n\t\t}\n\t\tplay(crumple);\n\t}",
          "sourceCodeAfterRefactoring": "public void crumple(){\n\t\thideEmo();\n\t\tplay(crumple);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "ea4d45da7f82d3e92a0b57f765bfd0903ee59dff_56_62_577_584_56_59"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void fall() {\n\t\t\n\t\torigin.set( width / 2, height - DungeonTilemap.SIZE / 2 );\n\t\tangularSpeed = Random.Int( 2 ) == 0 ? -720 : 720;\n\t\tam = 1;\n\n\t\tif (emo != null){\n\t\t\temo.killAndErase();\n\t\t}\n\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t\t\n\t\tparent.add( new ScaleTweener( this, new PointF( 0, 0 ), FALL_TIME ) {\n\t\t\t@Override\n\t\t\tprotected void onComplete() {\n\t\t\t\tMobSprite.this.killAndErase();\n\t\t\t\tparent.erase( this );\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void updateValues( float progress ) {\n\t\t\t\tsuper.updateValues( progress );\n\t\t\t\ty += 12 * Game.elapsed;\n\t\t\t\tam = 1 - progress;\n\t\t\t}\n\t\t} );\n\t}",
          "sourceCodeAfterRefactoring": "public void fall() {\n\t\t\n\t\torigin.set( width / 2, height - DungeonTilemap.SIZE / 2 );\n\t\tangularSpeed = Random.Int( 2 ) == 0 ? -720 : 720;\n\t\tam = 1;\n\n\t\thideEmo();\n\n\t\tif (health != null){\n\t\t\thealth.killAndErase();\n\t\t}\n\t\t\n\t\tparent.add( new ScaleTweener( this, new PointF( 0, 0 ), FALL_TIME ) {\n\t\t\t@Override\n\t\t\tprotected void onComplete() {\n\t\t\t\tMobSprite.this.killAndErase();\n\t\t\t\tparent.erase( this );\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void updateValues( float progress ) {\n\t\t\t\tsuper.updateValues( progress );\n\t\t\t\ty += 12 * Game.elapsed;\n\t\t\t\tam = 1 - progress;\n\t\t\t}\n\t\t} );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "ea4d45da7f82d3e92a0b57f765bfd0903ee59dff_59_86_577_584_59_84"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b3783295bf46e3dc429ae47af4306277f9f73d6a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b3783295bf46e3dc429ae47af4306277f9f73d6a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v0_8_0_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.0\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( \"0.8.0b\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Yog-Dzewa's fists are now considered bosses, not minibosses.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.8.0):\\n\" +\n\t\t\t\t\"_-_ Various rare freezes when descending\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Yog-Dzewa fight glitching in rare cases where the eye and last fist are killed at the same time\\n\" +\n\t\t\t\t\"_-_ Bright/Dark fist very rarely teleporting into enclosed spaces\"));\n\n\t\tchanges = new ChangeInfo( \"0.8.0a\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tImage i = new Image(new YogSprite());\n\t\ti.scale.set(0.8f);\n\t\tchanges.addButton( new ChangeButton(i, \"Enemy and Boss adjustments\",\n\t\t\t\t\"Based on player feedback and gameplay data, I'm making the following tweaks to enemy/boss balance. These changes mainly make particular enemies/bosses a bit easier:\\n\\n\" +\n\t\t\t\t\"_-_ Turns taken for DM-300 to dig through rock increased to 3 from 2.5\\n\" +\n\t\t\t\t\"_-_ DM-300 pylons now resist damage above 15, up from 10\\n\\n\" +\n\t\t\t\t\"_-_ Ripper Demon leap ability now has a short cooldown\\n\" +\n\t\t\t\t\"_-_ Ripper Demon damage reduced by ~8%\\n\" +\n\t\t\t\t\"_-_ Ripper Demon leap now deals large bleed damage less often\\n\\n\" +\n\t\t\t\t\"_-_ Yog's laser damage reduced by ~8%\\n\" +\n\t\t\t\t\"_-_ Bright fist blind duration reduced by 40%\\n\" +\n\t\t\t\t\"_-_ Dark fist ranged damage reduced by 20%\\n\" +\n\t\t\t\t\"_-_ Soiled fist now spreads slightly more furrowed grass\\n\" +\n\t\t\t\t\"_-_ Soiled fist now resists burning\\n\" +\n\t\t\t\t\"_-_ Rusted fist melee damage increased by 10%\"));\n\n\t\tchanges.addButton( new ChangeButton(new SpiritBow(),\n\t\t\t\t\"Sniper shot is currently performing quite poorly versus the sniper's other abilities, so I'm giving it a significant buff:\\n\\n\" +\n\t\t\t\t\"_-_ Base sniper shot damage increased by 20%\\n\" +\n\t\t\t\t\"_-_ Sniper shot damage scaling with distance increased. At high distance sniper shot will deal up to 40% more total damage.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"Following feedback I've tweaked the sensitivity of the new 'red flash' effect. It should now trigger in far fewer cases where the hero isn't taking serious damage, but should still trigger when the hero is at risk of death.\\n\\n\" +\n\t\t\t\t\"I've tweaked the behaviour of ranged enemies slightly, which should eliminate cases where they don't follow the hero through a door despite seeing them go through it.\\n\\n\" +\n\t\t\t\t\"_-_ Increased the size of the descending region at the end of Dwarf King's level.\\n\\n\" +\n\t\t\t\t\"_-_ Decreased the minimum window size for desktop users.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.8.0):\\n\" +\n\t\t\t\t\"_-_ Various errors/crashed caused by new imp shop\\n\" +\n\t\t\t\t\"_-_ Several cases where water could spread to tiles that it shouldn't spread to.\\n\" +\n\t\t\t\t\"_-_ Water of health being used up on items that cannot be cursed\\n\" +\n\t\t\t\t\"_-_ Golems being able to teleport immovable characters\\n\" +\n\t\t\t\t\"_-_ Armored statues appearing in faith is my armor challenge\\n\" +\n\t\t\t\t\"_-_ Yog-dzewa being able to totally blind the player if into darkness is enabled\\n\" +\n\t\t\t\t\"_-_ Large enemies being able to move into enclosed spaces when vertigoed\\n\" +\n\t\t\t\t\"_-_ Infinite loop bug when attempting to teleport DM-300\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\"));\n\n\t\tchanges = new ChangeInfo( Messages.get( ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released April 16th, 2020\\n\" +\n\t\t\t\t\"_-_ 546 days after Shattered v0.7.0\\n\" +\n\t\t\t\t\"_-_ 197 days after Shattered v0.7.5\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new DM100Sprite()), \"Misc Enemies\",\n\t\t\t\t\"_DM-100s_ have been added to the prison to replace gnoll shamans. They behave very similarly to prison shamans, but have a few stat tweaks:\\n\" +\n\t\t\t\t\"_-_ Health increased to 20 from 18.\\n\" +\n\t\t\t\t\"_-_ Removed bonus damage vs enemies in water.\\n\" +\n\t\t\t\t\"_-_ The Max level for hero to earn exp from them is reduced to 13 from 14.\\n\\n\" +\n\t\t\t\t\"_Mimics_ have been reworked! I don't want to fully spoil the surprise, but they are now deadlier but offer more counterplay. Keep an eye on chests before you open them...\\n\\n\" +\n\t\t\t\t\"_Golden and Crystal Mimics_ have also been added! Golden mimics have higher stats but a better reward, and crystal mimics will try to run away with their loot! Neither require a key to open.\\n\\n\"+\n\t\t\t\t\"_Armored Statues_ have been added as a rare variant to regular statues. These statues have much higher defense and HP, but will give you both a weapon and armor if you kill them.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ShamanSprite.Purple()), \"Caves\",\n\t\t\t\t\"Vision range in the caves is now the same as other regions.\\n\\n\" +\n\t\t\t\t\"_Bats_ have had their damage reduced by 13%, and heal for less when they attack. This should make them less oppressive in the early caves.\\n\\n\" +\n\t\t\t\t\"_Gnoll Brutes_ now deal ~8% less damage, and rage at 0 hp instead of 1/4 HP. This rage grants them shielding that slowly fades over time. When the shield runs out, they die.\\n\\n\" +\n\t\t\t\t\"_Gnoll shamans_ have been completely reworked for the caves. They are more powerful and inflict different debuffs depending on the color of their mask.\\n\\n\" +\n\t\t\t\t\"_Spinners_ are now 20% more evasive, 10% more accurate, and now spit their webs toward the hero from a distance. Their webs block projectiles, but can be cleared.\\n\\n\" +\n\t\t\t\t\"_DM-200s_ are a new enemy in the later parts of the caves. They are too big to move into tunnels and doors, but make up for it with high stats and a toxic gas attack.\"));\n\n\t\ti = new Image(new DM300Sprite());\n\t\ti.scale.set(PixelScene.align(0.74f));\n\t\tchanges.addButton( new ChangeButton(i, Messages.get(NewDM300.class, \"name\"),\n\t\t\t\t\"The DM-300 fight has been reworked! DM-300 now has redesigned abilities, a new boss arena, and multiple phases!\\n\\n\" +\n\t\t\t\t\"As a part of this rework, DM-300's direct stats have been adjusted:\\n\" +\n\t\t\t\t\"_-_ Health increased to 300 from 200\\n\" +\n\t\t\t\t\"_-_ Evasion reduced by ~17%\\n\" +\n\t\t\t\t\"_-_ Damage reduced by ~11%\\n\" +\n\t\t\t\t\"_-_ Accuracy reduced by ~28%\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ElementalSprite.Frost()), \"Dwarven City\",\n\t\t\t\t\"_Dwarven Ghouls_ are a new enemy which replace elementals as the most simple opponent in the city. They are fairly weak on their own, but always travel in groups.\\n\\n\" +\n\t\t\t\t\"_Elementals_ now have ~10% less HP, multiple different types, and will occasionally fire debuffing ranged attacks. The debuffs they inflict, and their resistances, vary by the elemental type.\\n\\n\" +\n\t\t\t\t\"_Monks_ no longer disarm, but instead build focus which allows them to always dodge one physical attack. Monks start combat with full focus and build it faster when on the move.\\n\\n\" +\n\t\t\t\t\"_Warlocks_ now deal ~21% less damage in melee, but have a nasty new debuff. They inflict 'degraded', which temporarily weakens heavily upgraded gear.\\n\\n\" +\n\t\t\t\t\"_Golems_ have been entirely reworked and are now large enemies like DM-200s. Unlike DM-200s they have no ranged attacks, but instead use dwarven teleportation magic to compensate for their low mobility.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new KingSprite()), Messages.get(DwarfKing.class, \"name\"),\n\t\t\t\t\"The Dwarf King fight has received a full rework! His fight still heavily features minion summoning, but now also features new abilities, a new arena, and multiple phases!\\n\\n\" +\n\t\t\t\t\"As a part of this fight rework DK's stats have been adjusted:\\n\" +\n\t\t\t\t\"_-_ Damage reduced by ~40%\\n\" +\n\t\t\t\t\"_-_ Accuracy reduced by ~18%\\n\" +\n\t\t\t\t\"_-_ Armor reduced by ~30%\\n\" +\n\t\t\t\t\"_-_ Evasion reduced by ~12%\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new SpawnerSprite()), \"Demon Halls\",\n\t\t\t\t\"Floor 21 is now a regular demon halls floor\\n\\n\" +\n\t\t\t\t\"_Ripper Demons_ are a new basic enemy. They have high damage attacks and a leap ability, but have weaker defensive stats. Instead of spawning normally, they are created by the next enemy...\\n\\n\" +\n\t\t\t\t\"_Demon Spawners_ exist in special rooms within the demon halls, and create a steady stream of ripper demons as long as they are alive. Spawners do not return once killed, and award a bunch of EXP and a guaranteed potion of healing.\\n\\n\" +\n\t\t\t\t\"Minor adjustments have been made to existing demon halls enemies:\\n\" +\n\t\t\t\t\"_-_ Spawn rates reduced slightly, to account for ripper demons.\\n\" +\n\t\t\t\t\"_-_ Succubi now drop scrolls which are more likely to be rare.\\n\" +\n\t\t\t\t\"_-_ Evil Eyes now always drop dew, a seed, or a runestone.\\n\" +\n\t\t\t\t\"_-_ Scorpios now drop potions which are more likely to be rare. They cannot drop healing.\\n\" +\n\t\t\t\t\"_-_ Acidic scorpios now inflict ooze and don't reflect damage.\"));\n\n\t\ti = new Image(new YogSprite());\n\t\ti.scale.set(0.8f);\n\t\tchanges.addButton( new ChangeButton(i, \"Yog-Dzewa\",\n\t\t\t\t\"The Yog-Dzewa fight has been reworked! The key ingredients (eye, fists, and larva) are still present, but the specific stats, mechanics, and pacing of the fight have been almost totally redone.\\n\\n\" +\n\t\t\t\t\"Most notably, the fight is now much more evenly paced. Rather than summoning the same two fists every time at the start of the fight, Yog now summons fists steadily as the fight progresses. The fists also won't be the same each time, which gives the fight some variance.\\n\\n\" +\n\t\t\t\t\"To discourage skipping the demon halls, the fight is also affected by how many demon spawners were left alive on the previous floors. Expect the fight to be much harder if demon spawners are left alive!\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 96, 16, 16), \"Trap Adjustments\",\n\t\t\t\t\"I've re-evaluated several lategame traps, and trap spawning frequency. My hope with these changes is to make traps less oppressive in the lategame, while still keeping their general effect wherever possible.\\n\\n\" +\n\t\t\t\t\"Traps now show up ~10% more in the sewers, scaling down to ~25% less in the demon halls.\\n\\n\" +\n\t\t\t\t\"_-_ Worn dart traps now deal more damage\\n\" +\n\t\t\t\t\"_-_ Ooze traps now affect a 3x3 area\\n\" +\n\t\t\t\t\"_-_ Explosive traps no longer appear as regular random traps, but still show up in special rooms\\n\" +\n\t\t\t\t\"_-_ Cursing traps now only curse a single worn weapon or armor\\n\" +\n\t\t\t\t\"_-_ Disintegration traps no longer affect items in the player's inventory\\n\" +\n\t\t\t\t\"_-_ Disarming traps are now more common, but cannot teleport your weapon too far away\\n\" +\n\t\t\t\t\"_-_ Pitfall traps are now more common, affect a 3x3 area, and give you one turn to react\\n\" +\n\t\t\t\t\"_-_ Distortion traps are now more common, can appear in the city, and have a reworked effect. They now act as more chaotic summoning traps, instead of resetting the current floor.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_WARRIOR), \"Weapon and Armor Changes\",\n\t\t\t\t\"While I intend to make larger changes in a future update, I've decided to do some targeted improvements to class armors now to make the abilities more usable:\\n\" +\n\t\t\t\t\"_-_ Class armor now has a charge percentage which builds at a rate of 50% per level, each ability uses 35% charge.\\n\" +\n\t\t\t\t\"_-_ Stun from heroic leap increased to 5 turns from 3.\\n\" +\n\t\t\t\t\"_-_ Molten earth now roots for 5 turns, up from 3, and deals a burst of immediate damage.\\n\" +\n\t\t\t\t\"_-_ Smoke bomb now stealths the rogue for 10 turns and blinds for 5 turns, up from 2, but only blinds enemies adjacent to the rogue's old location.\\n\\n\" +\n\t\t\t\t\"Weapon/armor spawns have been adjusted, primarily to remove rare low tier item drops in the lategame:\\n\" +\n\t\t\t\t\"_-_ Tier 2 items no longer spawn in caves+\\n\" +\n\t\t\t\t\"_-_ Tier 3 items no longer spawn in demon halls\\n\" +\n\t\t\t\t\"_-_ Tier 4 items are slightly more common in caves, slightly less common in city\\n\" +\n\t\t\t\t\"_-_ Tier 5 items are notably more common in city, slightly more common in demon halls\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new StatueSprite()), \"AI Tweaks\",\n\t\t\t\t\"Improvements have been made to hero, ally, and enemy AI:\\n\\n\" +\n\t\t\t\t\"_-_ Wandering characters are now less likely to repeatedly block eachother in hallways.\\n\\n\" +\n\t\t\t\t\"_-_ Characters can now approach their enemy even if the path to them is blocked.\\n\\n\" +\n\t\t\t\t\"_-_ Characters are now more willing to switch targets if the path to their current target is blocked.\\n\\n\" +\n\t\t\t\t\"_-_ Fleeing enemies are now more willing to run around the hero to retreat.\\n\\n\" +\n\t\t\t\t\"_-_ The hero is now interrupted if their path becomes obstructed by an ally.\"));\n\n\t\tif (DeviceCompat.isDesktop()) {\n\t\t\tchanges.addButton( new ChangeButton( Icons.get( Icons.LIBGDX ), \"LibGDX Desktop Functionality\",\n\t\t\t\t\t\"The desktop version of the game is now running through the same codebase as the Android version!\\n\\n\" +\n\t\t\t\t\t\"Moving forward the desktop version of the game will be at feature parity with the Android version, which includes translations, access to betas, and release timings!\\n\\n\" +\n\t\t\t\t\t\"Currently all features from the old desktop codebase have been re-implemented in this version:\\n\" +\n\t\t\t\t\t\"_-_ Keyboard support, including movement and keybindings\\n\" +\n\t\t\t\t\t\"_-_ Mouse support, including scroll to zoom\\n\" +\n\t\t\t\t\t\"_-_ Full window management support, including fullscreen\\n\" +\n\t\t\t\t\t\"_-_ Update notifier (also now appears for android users)\\n\\n\" +\n\t\t\t\t\t\"The following additional features have also been added:\\n\" +\n\t\t\t\t\t\"_-_ Support for all languages, including asian scripts\\n\" +\n\t\t\t\t\t\"_-_ Support for smooth font (droid sans) on all languages\\n\" +\n\t\t\t\t\t\"_-_ A crash popup, which includes debug info\" ) );\n\t\t} else {\n\t\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.SCROLL_TIWAZ, null), \"Update Notification\",\n\t\t\t\t\t\"A little blinking button will now appear in the bottom-left of the title screen if an update is available for the game. \\n\\n\" +\n\t\t\t\t\t\"The Google Play version of the game uses Google's in-app updates library, and will seamlessly update the game through Google Play if the user accepts the prompt.\\n\\n\" +\n\t\t\t\t\t\"Other versions of the game will grab update info from Github, and will direct the player to the latest releases page to download the update.\\n\\n\" +\n\t\t\t\t\t\"Note that on Android, both updaters require Android 5.0+ to work correctly. If your device isn't compatible the notification simply won't appear.\"));\n\t\t}\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game now flashes red when the hero is badly hurt.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Imp now assigns monks or golems based on depth.\\n\" +\n\t\t\t\t\"_-_ Number of monks/golems required reduced to 5/4 from 8/6.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Torch light duration reduced to 250 turns from 300.\\n\" +\n\t\t\t\t\"_-_ Each demon halls floor now contains 2 torches, up from 1.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ The velvet pouch now stores goo blobs and metal shards.\\n\" +\n\t\t\t\t\"_-_ Items will now go into the main inventory if a bag is full.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Shops can now stock more exotic weapons.\\n\" +\n\t\t\t\t\"_-_ Improved logic for which bag a shop stocks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Upgrading a stack of missile weapons now resets the durability of the stack\\n\" +\n\t\t\t\t\"_-_ Brewing a potion with 3 of the same seed now identifies it.\\n\" +\n\t\t\t\t\"_-_ Skeletal remains now always spawn a wraith if a cursed item spawned within them.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Dried rose desc now includes ghost's weapon and armor.\\n\" +\n\t\t\t\t\"_-_ Wand of Transfusion desc now includes damage/healing numbers.\\n\" +\n\t\t\t\t\"_-_ Beneficial darts now mention that they don't harm allies.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Thrown potions of purity now cleanse Tengu's smoke bomb and fire wave effects.\\n\" +\n\t\t\t\t\"_-_ Wand of blast wave and force cube AOEs no longer trigger Tengu's traps.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Ankhs are now blessed when thrown into a well of healing.\\n\" +\n\t\t\t\t\"_-_ Items are now uncursed when thrown into a well of healing.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Improved the story text for the caves, city, and halls.\\n\" +\n\t\t\t\t\"_-_ Added some hint text to snakes for new players.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Improved vfx for falling enemies and items.\\n\" +\n\t\t\t\t\"_-_ The settings menu and game options have been streamlined slightly.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Rare freeze bugs when enemies make ranged attacks\\n\" +\n\t\t\t\t\"_-_ Loading screens very rarely freezing\\n\" +\n\t\t\t\t\"_-_ Various bugs in the new Tengu fight\\n\" +\n\t\t\t\t\"_-_ Unstable spellbook not casting spells if the game was closed while using it\\n\" +\n\t\t\t\t\"_-_ Shurikens sometimes not attacking instantly even after the hero moved\\n\" +\n\t\t\t\t\"_-_ Items spawning on the same tile as an enemy spawn\\n\" +\n\t\t\t\t\"_-_ Unidentified alchemists toolkit being usable in alchemy\\n\" +\n\t\t\t\t\"_-_ Storm clouds spreading faster than intended\\n\" +\n\t\t\t\t\"_-_ Chests opening when they are teleported\\n\" +\n\t\t\t\t\"_-_ Teleportation rarely placing the hero onto hidden traps\\n\" +\n\t\t\t\t\"_-_ Viscocity glyph not considering all armor sources when applying deferred damage\\n\" +\n\t\t\t\t\"_-_ Wand of warding bolts not pushing on terrain\\n\" +\n\t\t\t\t\"_-_ Wand of prismatic light rarely revealing areas it shouldn't\\n\" +\n\t\t\t\t\"_-_ Upgraded wands not spawning fully charged\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Invisibility not applying if the hero is also shadowmelded\\n\" +\n\t\t\t\t\"_-_ Landscape/portrait modes working incorrectly in rare cases\\n\" +\n\t\t\t\t\"_-_ Inventory incorrectly being seen as full when upgrading with the blacksmith\\n\" +\n\t\t\t\t\"_-_ Odd interactions between the blacksmith and curse infusion\\n\" +\n\t\t\t\t\"_-_ Force cubes not pressing on every tile in their AOE\\n\" +\n\t\t\t\t\"_-_ Force cubes affecting an AOE when thrown onto chasms\\n\" +\n\t\t\t\t\"_-_ Rankings rarely not being recorded if hero is killed by a statue\\n\" +\n\t\t\t\t\"_-_ Caustic slimes attacking slower than intended\\n\" +\n\t\t\t\t\"_-_ Newborn elementals disappearing when unblessed ankhs are used\\n\" +\n\t\t\t\t\"_-_ Hero being able to swap places with allies when movement is restricted\\n\" +\n\t\t\t\t\"_-_ Some allies being corruptable when they shouldn't be\\n\" +\n\t\t\t\t\"_-_ Piranhas playing no death animation if they die on land\\n\" +\n\t\t\t\t\"_-_ Many rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Many minor audio and visual bugs\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new WandOfCorruption(),\n\t\t\t\t\"This is actually a bugfix, but is so significant that I'm listing it as a buff for clarity:\\n\\n\" +\n\t\t\t\t\"_-_ Fixed Wand of corruption acting as if it were one level weaker than it was in some cases.\\n\\n\" +\n\t\t\t\t\"_-_ Doubled corruption resistance reduction from debuffs, as it was 50% weaker than intended. It is now as strong as listed in 0.7.5 changelog (50% for major debuffs, 25% for minor)\\n\\n\" +\n\t\t\t\t\"Additionally, corruption is getting access to two of the new debuffs added in 0.8.0: _Hex,_ and _Weakness._\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Interfaces.BUFFS_LARGE, 80, 32, 16, 16), \"Bless changes\",\n\t\t\t\t\"Accuracy and evasion bonuses from blessed buff increased to 25% from 20%.\" ));\n\n\t\tchanges.addButton( new ChangeButton(new StoneOfAugmentation(),\n\t\t\t\t\"The Evasion armor augment has been underperforming verses the defence augment, so I'm adjusting the stat tradeoff they provide:\\n\" +\n\t\t\t\t\"_-_ Evasion now grants 33% more evasion\\n\" +\n\t\t\t\t\"_-_ Defense now costs 33% more evasion\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new NecromancerSprite()), \"Necromancers\",\n\t\t\t\t\"To better balance overall prison difficulty, I've strengthened necromancers slightly:\\n\" +\n\t\t\t\t\"_-_ Necromancer evasion increased by ~18%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new StoneOfAugmentation(),\n\t\t\t\t\"The Defense armor augment has been overperforming verses the evasion augment, so I'm adjusting the stat tradeoff they provide:\\n\" +\n\t\t\t\t\"_-_ Defense now costs 33% more evasion\\n\" +\n\t\t\t\t\"_-_ Evasion now grants 33% more evasion\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new GuardSprite()), \"Enemy Nerfs\",\n\t\t\t\t\"To better balance overall prison difficulty, I've weakened prison guards slightly:\\n\" +\n\t\t\t\t\"_-_ Prison guard accuracy reduced by ~15%\\n\" +\n\t\t\t\t\"_-_ Prison guard armor reduced by ~12%\\n\\n\" +\n\t\t\t\t\"Some unnecessary enemy debuff resistances have been removed:\\n\" +\n\t\t\t\t\"_-_ Several enemies are no longer immune to terror or amok\\n\" +\n\t\t\t\t\"_-_ Evil eyes and wraiths no longer resist grim\\n\" +\n\t\t\t\t\"_-_ Golems and succubi are no longer immune to sleep\\n\" +\n\t\t\t\t\"_-_ Bees are no longer immune to poison\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v0_8_0_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.0\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( Messages.get( ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released April 16th, 2020\\n\" +\n\t\t\t\t\"_-_ 546 days after Shattered v0.7.0\\n\" +\n\t\t\t\t\"_-_ 197 days after Shattered v0.7.5\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new DM100Sprite()), \"Misc Enemies\",\n\t\t\t\t\"_DM-100s_ have been added to the prison to replace gnoll shamans. They behave very similarly to prison shamans, but have a few stat tweaks:\\n\" +\n\t\t\t\t\"_-_ Health increased to 20 from 18.\\n\" +\n\t\t\t\t\"_-_ Removed bonus damage vs enemies in water.\\n\" +\n\t\t\t\t\"_-_ The Max level for hero to earn exp from them is reduced to 13 from 14.\\n\\n\" +\n\t\t\t\t\"_Mimics_ have been reworked! I don't want to fully spoil the surprise, but they are now deadlier but offer more counterplay. Keep an eye on chests before you open them...\\n\\n\" +\n\t\t\t\t\"_Golden and Crystal Mimics_ have also been added! Golden mimics have higher stats but a better reward, and crystal mimics will try to run away with their loot! Neither require a key to open.\\n\\n\"+\n\t\t\t\t\"_Armored Statues_ have been added as a rare variant to regular statues. These statues have much higher defense and HP, but will give you both a weapon and armor if you kill them.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ShamanSprite.Purple()), \"Caves\",\n\t\t\t\t\"Vision range in the caves is now the same as other regions.\\n\\n\" +\n\t\t\t\t\"_Bats_ have had their damage reduced by 13%, and heal for less when they attack. This should make them less oppressive in the early caves.\\n\\n\" +\n\t\t\t\t\"_Gnoll Brutes_ now deal ~8% less damage, and rage at 0 hp instead of 1/4 HP. This rage grants them shielding that slowly fades over time. When the shield runs out, they die.\\n\\n\" +\n\t\t\t\t\"_Gnoll shamans_ have been completely reworked for the caves. They are more powerful and inflict different debuffs depending on the color of their mask.\\n\\n\" +\n\t\t\t\t\"_Spinners_ are now 20% more evasive, 10% more accurate, and now spit their webs toward the hero from a distance. Their webs block projectiles, but can be cleared.\\n\\n\" +\n\t\t\t\t\"_DM-200s_ are a new enemy in the later parts of the caves. They are too big to move into tunnels and doors, but make up for it with high stats and a toxic gas attack.\"));\n\n\t\tImage i = new Image(new DM300Sprite());\n\t\ti.scale.set(PixelScene.align(0.74f));\n\t\tchanges.addButton( new ChangeButton(i, Messages.get(NewDM300.class, \"name\"),\n\t\t\t\t\"The DM-300 fight has been reworked! DM-300 now has redesigned abilities, a new boss arena, and multiple phases!\\n\\n\" +\n\t\t\t\t\"As a part of this rework, DM-300's direct stats have been adjusted:\\n\" +\n\t\t\t\t\"_-_ Health increased to 300 from 200\\n\" +\n\t\t\t\t\"_-_ Evasion reduced by ~17%\\n\" +\n\t\t\t\t\"_-_ Damage reduced by ~11%\\n\" +\n\t\t\t\t\"_-_ Accuracy reduced by ~28%\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new ElementalSprite.Frost()), \"Dwarven City\",\n\t\t\t\t\"_Dwarven Ghouls_ are a new enemy which replace elementals as the most simple opponent in the city. They are fairly weak on their own, but always travel in groups.\\n\\n\" +\n\t\t\t\t\"_Elementals_ now have ~10% less HP, multiple different types, and will occasionally fire debuffing ranged attacks. The debuffs they inflict, and their resistances, vary by the elemental type.\\n\\n\" +\n\t\t\t\t\"_Monks_ no longer disarm, but instead build focus which allows them to always dodge one physical attack. Monks start combat with full focus and build it faster when on the move.\\n\\n\" +\n\t\t\t\t\"_Warlocks_ now deal ~21% less damage in melee, but have a nasty new debuff. They inflict 'degraded', which temporarily weakens heavily upgraded gear.\\n\\n\" +\n\t\t\t\t\"_Golems_ have been entirely reworked and are now large enemies like DM-200s. Unlike DM-200s they have no ranged attacks, but instead use dwarven teleportation magic to compensate for their low mobility.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new KingSprite()), Messages.get(DwarfKing.class, \"name\"),\n\t\t\t\t\"The Dwarf King fight has received a full rework! His fight still heavily features minion summoning, but now also features new abilities, a new arena, and multiple phases!\\n\\n\" +\n\t\t\t\t\"As a part of this fight rework DK's stats have been adjusted:\\n\" +\n\t\t\t\t\"_-_ Damage reduced by ~40%\\n\" +\n\t\t\t\t\"_-_ Accuracy reduced by ~18%\\n\" +\n\t\t\t\t\"_-_ Armor reduced by ~30%\\n\" +\n\t\t\t\t\"_-_ Evasion reduced by ~12%\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new SpawnerSprite()), \"Demon Halls\",\n\t\t\t\t\"Floor 21 is now a regular demon halls floor\\n\\n\" +\n\t\t\t\t\"_Ripper Demons_ are a new basic enemy. They have high damage attacks and a leap ability, but have weaker defensive stats. Instead of spawning normally, they are created by the next enemy...\\n\\n\" +\n\t\t\t\t\"_Demon Spawners_ exist in special rooms within the demon halls, and create a steady stream of ripper demons as long as they are alive. Spawners do not return once killed, and award a bunch of EXP and a guaranteed potion of healing.\\n\\n\" +\n\t\t\t\t\"Minor adjustments have been made to existing demon halls enemies:\\n\" +\n\t\t\t\t\"_-_ Spawn rates reduced slightly, to account for ripper demons.\\n\" +\n\t\t\t\t\"_-_ Succubi now drop scrolls which are more likely to be rare.\\n\" +\n\t\t\t\t\"_-_ Evil Eyes now always drop dew, a seed, or a runestone.\\n\" +\n\t\t\t\t\"_-_ Scorpios now drop potions which are more likely to be rare. They cannot drop healing.\\n\" +\n\t\t\t\t\"_-_ Acidic scorpios now inflict ooze and don't reflect damage.\"));\n\n\t\ti = new Image(new YogSprite());\n\t\ti.scale.set(0.8f);\n\t\tchanges.addButton( new ChangeButton(i, \"Yog-Dzewa\",\n\t\t\t\t\"The Yog-Dzewa fight has been reworked! The key ingredients (eye, fists, and larva) are still present, but the specific stats, mechanics, and pacing of the fight have been almost totally redone.\\n\\n\" +\n\t\t\t\t\"Most notably, the fight is now much more evenly paced. Rather than summoning the same two fists every time at the start of the fight, Yog now summons fists steadily as the fight progresses. The fists also won't be the same each time, which gives the fight some variance.\\n\\n\" +\n\t\t\t\t\"To discourage skipping the demon halls, the fight is also affected by how many demon spawners were left alive on the previous floors. Expect the fight to be much harder if demon spawners are left alive!\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Environment.TERRAIN_FEATURES, 64, 96, 16, 16), \"Trap Adjustments\",\n\t\t\t\t\"I've re-evaluated several lategame traps, and trap spawning frequency. My hope with these changes is to make traps less oppressive in the lategame, while still keeping their general effect wherever possible.\\n\\n\" +\n\t\t\t\t\"Traps now show up ~10% more in the sewers, scaling down to ~25% less in the demon halls.\\n\\n\" +\n\t\t\t\t\"_-_ Worn dart traps now deal more damage\\n\" +\n\t\t\t\t\"_-_ Ooze traps now affect a 3x3 area\\n\" +\n\t\t\t\t\"_-_ Explosive traps no longer appear as regular random traps, but still show up in special rooms\\n\" +\n\t\t\t\t\"_-_ Cursing traps now only curse a single worn weapon or armor\\n\" +\n\t\t\t\t\"_-_ Disintegration traps no longer affect items in the player's inventory\\n\" +\n\t\t\t\t\"_-_ Disarming traps are now more common, but cannot teleport your weapon too far away\\n\" +\n\t\t\t\t\"_-_ Pitfall traps are now more common, affect a 3x3 area, and give you one turn to react\\n\" +\n\t\t\t\t\"_-_ Distortion traps are now more common, can appear in the city, and have a reworked effect. They now act as more chaotic summoning traps, instead of resetting the current floor.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_WARRIOR), \"Weapon and Armor Changes\",\n\t\t\t\t\"While I intend to make larger changes in a future update, I've decided to do some targeted improvements to class armors now to make the abilities more usable:\\n\" +\n\t\t\t\t\"_-_ Class armor now has a charge percentage which builds at a rate of 50% per level, each ability uses 35% charge.\\n\" +\n\t\t\t\t\"_-_ Stun from heroic leap increased to 5 turns from 3.\\n\" +\n\t\t\t\t\"_-_ Molten earth now roots for 5 turns, up from 3, and deals a burst of immediate damage.\\n\" +\n\t\t\t\t\"_-_ Smoke bomb now stealths the rogue for 10 turns and blinds for 5 turns, up from 2, but only blinds enemies adjacent to the rogue's old location.\\n\\n\" +\n\t\t\t\t\"Weapon/armor spawns have been adjusted, primarily to remove rare low tier item drops in the lategame:\\n\" +\n\t\t\t\t\"_-_ Tier 2 items no longer spawn in caves+\\n\" +\n\t\t\t\t\"_-_ Tier 3 items no longer spawn in demon halls\\n\" +\n\t\t\t\t\"_-_ Tier 4 items are slightly more common in caves, slightly less common in city\\n\" +\n\t\t\t\t\"_-_ Tier 5 items are notably more common in city, slightly more common in demon halls\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new StatueSprite()), \"AI Tweaks\",\n\t\t\t\t\"Improvements have been made to hero, ally, and enemy AI:\\n\\n\" +\n\t\t\t\t\"_-_ Wandering characters are now less likely to repeatedly block eachother in hallways.\\n\\n\" +\n\t\t\t\t\"_-_ Characters can now approach their enemy even if the path to them is blocked.\\n\\n\" +\n\t\t\t\t\"_-_ Characters are now more willing to switch targets if the path to their current target is blocked.\\n\\n\" +\n\t\t\t\t\"_-_ Fleeing enemies are now more willing to run around the hero to retreat.\\n\\n\" +\n\t\t\t\t\"_-_ The hero is now interrupted if their path becomes obstructed by an ally.\"));\n\n\t\tif (DeviceCompat.isDesktop()) {\n\t\t\tchanges.addButton( new ChangeButton( Icons.get( Icons.LIBGDX ), \"LibGDX Desktop Functionality\",\n\t\t\t\t\t\"The desktop version of the game is now running through the same codebase as the Android version!\\n\\n\" +\n\t\t\t\t\t\"Moving forward the desktop version of the game will be at feature parity with the Android version, which includes translations, access to betas, and release timings!\\n\\n\" +\n\t\t\t\t\t\"Currently all features from the old desktop codebase have been re-implemented in this version:\\n\" +\n\t\t\t\t\t\"_-_ Keyboard support, including movement and keybindings\\n\" +\n\t\t\t\t\t\"_-_ Mouse support, including scroll to zoom\\n\" +\n\t\t\t\t\t\"_-_ Full window management support, including fullscreen\\n\" +\n\t\t\t\t\t\"_-_ Update notifier (also now appears for android users)\\n\\n\" +\n\t\t\t\t\t\"The following additional features have also been added:\\n\" +\n\t\t\t\t\t\"_-_ Support for all languages, including asian scripts\\n\" +\n\t\t\t\t\t\"_-_ Support for smooth font (droid sans) on all languages\\n\" +\n\t\t\t\t\t\"_-_ A crash popup, which includes debug info\" ) );\n\t\t} else {\n\t\t\tchanges.addButton( new ChangeButton( new ItemSprite(ItemSpriteSheet.SCROLL_TIWAZ, null), \"Update Notification\",\n\t\t\t\t\t\"A little blinking button will now appear in the bottom-left of the title screen if an update is available for the game. \\n\\n\" +\n\t\t\t\t\t\"The Google Play version of the game uses Google's in-app updates library, and will seamlessly update the game through Google Play if the user accepts the prompt.\\n\\n\" +\n\t\t\t\t\t\"Other versions of the game will grab update info from Github, and will direct the player to the latest releases page to download the update.\\n\\n\" +\n\t\t\t\t\t\"Note that on Android, both updaters require Android 5.0+ to work correctly. If your device isn't compatible the notification simply won't appear.\"));\n\t\t}\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game now flashes red when the hero is badly hurt.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Imp now assigns monks or golems based on depth.\\n\" +\n\t\t\t\t\"_-_ Number of monks/golems required reduced to 5/4 from 8/6.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Torch light duration reduced to 250 turns from 300.\\n\" +\n\t\t\t\t\"_-_ Each demon halls floor now contains 2 torches, up from 1.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ The velvet pouch now stores goo blobs and metal shards.\\n\" +\n\t\t\t\t\"_-_ Items will now go into the main inventory if a bag is full.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Shops can now stock more exotic weapons.\\n\" +\n\t\t\t\t\"_-_ Improved logic for which bag a shop stocks.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Upgrading a stack of missile weapons now resets the durability of the stack\\n\" +\n\t\t\t\t\"_-_ Brewing a potion with 3 of the same seed now identifies it.\\n\" +\n\t\t\t\t\"_-_ Skeletal remains now always spawn a wraith if a cursed item spawned within them.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Dried rose desc now includes ghost's weapon and armor.\\n\" +\n\t\t\t\t\"_-_ Wand of Transfusion desc now includes damage/healing numbers.\\n\" +\n\t\t\t\t\"_-_ Beneficial darts now mention that they don't harm allies.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Thrown potions of purity now cleanse Tengu's smoke bomb and fire wave effects.\\n\" +\n\t\t\t\t\"_-_ Wand of blast wave and force cube AOEs no longer trigger Tengu's traps.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Ankhs are now blessed when thrown into a well of healing.\\n\" +\n\t\t\t\t\"_-_ Items are now uncursed when thrown into a well of healing.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Improved the story text for the caves, city, and halls.\\n\" +\n\t\t\t\t\"_-_ Added some hint text to snakes for new players.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Improved vfx for falling enemies and items.\\n\" +\n\t\t\t\t\"_-_ The settings menu and game options have been streamlined slightly.\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"_-_ Updated translations and translator credits\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Rare freeze bugs when enemies make ranged attacks\\n\" +\n\t\t\t\t\"_-_ Loading screens very rarely freezing\\n\" +\n\t\t\t\t\"_-_ Various bugs in the new Tengu fight\\n\" +\n\t\t\t\t\"_-_ Unstable spellbook not casting spells if the game was closed while using it\\n\" +\n\t\t\t\t\"_-_ Shurikens sometimes not attacking instantly even after the hero moved\\n\" +\n\t\t\t\t\"_-_ Items spawning on the same tile as an enemy spawn\\n\" +\n\t\t\t\t\"_-_ Unidentified alchemists toolkit being usable in alchemy\\n\" +\n\t\t\t\t\"_-_ Storm clouds spreading faster than intended\\n\" +\n\t\t\t\t\"_-_ Chests opening when they are teleported\\n\" +\n\t\t\t\t\"_-_ Teleportation rarely placing the hero onto hidden traps\\n\" +\n\t\t\t\t\"_-_ Viscocity glyph not considering all armor sources when applying deferred damage\\n\" +\n\t\t\t\t\"_-_ Wand of warding bolts not pushing on terrain\\n\" +\n\t\t\t\t\"_-_ Wand of prismatic light rarely revealing areas it shouldn't\\n\" +\n\t\t\t\t\"_-_ Upgraded wands not spawning fully charged\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Invisibility not applying if the hero is also shadowmelded\\n\" +\n\t\t\t\t\"_-_ Landscape/portrait modes working incorrectly in rare cases\\n\" +\n\t\t\t\t\"_-_ Inventory incorrectly being seen as full when upgrading with the blacksmith\\n\" +\n\t\t\t\t\"_-_ Odd interactions between the blacksmith and curse infusion\\n\" +\n\t\t\t\t\"_-_ Force cubes not pressing on every tile in their AOE\\n\" +\n\t\t\t\t\"_-_ Force cubes affecting an AOE when thrown onto chasms\\n\" +\n\t\t\t\t\"_-_ Rankings rarely not being recorded if hero is killed by a statue\\n\" +\n\t\t\t\t\"_-_ Caustic slimes attacking slower than intended\\n\" +\n\t\t\t\t\"_-_ Newborn elementals disappearing when unblessed ankhs are used\\n\" +\n\t\t\t\t\"_-_ Hero being able to swap places with allies when movement is restricted\\n\" +\n\t\t\t\t\"_-_ Some allies being corruptable when they shouldn't be\\n\" +\n\t\t\t\t\"_-_ Piranhas playing no death animation if they die on land\\n\" +\n\t\t\t\t\"_-_ Many rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Many minor audio and visual bugs\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new SpiritBow(),\n\t\t\t\t\"Sniper shot is currently performing quite poorly versus the sniper's other abilities, so I'm giving it a significant buff:\\n\\n\" +\n\t\t\t\t\"_-_ Base sniper shot damage increased by 20%\\n\" +\n\t\t\t\t\"_-_ Sniper shot damage scaling with distance increased. At high distance sniper shot will deal up to 40% more total damage.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfCorruption(),\n\t\t\t\t\"This is actually a bugfix, but is so significant that I'm listing it as a buff for clarity:\\n\\n\" +\n\t\t\t\t\"_-_ Fixed Wand of corruption acting as if it were one level weaker than it was in some cases.\\n\\n\" +\n\t\t\t\t\"_-_ Doubled corruption resistance reduction from debuffs, as it was 50% weaker than intended. It is now as strong as listed in 0.7.5 changelog (50% for major debuffs, 25% for minor)\\n\\n\" +\n\t\t\t\t\"Additionally, corruption is getting access to two of the new debuffs added in 0.8.0: _Hex,_ and _Weakness._\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Interfaces.BUFFS_LARGE, 80, 32, 16, 16), \"Bless changes\",\n\t\t\t\t\"Accuracy and evasion bonuses from blessed buff increased to 25% from 20%.\" ));\n\n\t\tchanges.addButton( new ChangeButton(new StoneOfAugmentation(),\n\t\t\t\t\"The Evasion armor augment has been underperforming verses the defence augment, so I'm adjusting the stat tradeoff they provide:\\n\" +\n\t\t\t\t\"_-_ Evasion now grants 33% more evasion\\n\" +\n\t\t\t\t\"_-_ Defense now costs 33% more evasion\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new NecromancerSprite()), \"Necromancers\",\n\t\t\t\t\"To better balance overall prison difficulty, I've strengthened necromancers slightly:\\n\" +\n\t\t\t\t\"_-_ Necromancer evasion increased by ~18%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new StoneOfAugmentation(),\n\t\t\t\t\"The Defense armor augment has been overperforming verses the evasion augment, so I'm adjusting the stat tradeoff they provide:\\n\" +\n\t\t\t\t\"_-_ Defense now costs 33% more evasion\\n\" +\n\t\t\t\t\"_-_ Evasion now grants 33% more evasion\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(new GuardSprite()), \"Enemy Nerfs\",\n\t\t\t\t\"To better balance overall prison difficulty, I've weakened prison guards slightly:\\n\" +\n\t\t\t\t\"_-_ Prison guard accuracy reduced by ~15%\\n\" +\n\t\t\t\t\"_-_ Prison guard armor reduced by ~12%\\n\\n\" +\n\t\t\t\t\"Some unnecessary enemy debuff resistances have been removed:\\n\" +\n\t\t\t\t\"_-_ Several enemies are no longer immune to terror or amok\\n\" +\n\t\t\t\t\"_-_ Evil eyes and wraiths no longer resist grim\\n\" +\n\t\t\t\t\"_-_ Golems and succubi are no longer immune to sleep\\n\" +\n\t\t\t\t\"_-_ Bees are no longer immune to poison\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v0_8_1_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.8.1\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo( Messages.get( ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released June 27th, 2020\\n\" +\n\t\t\t\t\"_-_ 72 days after Shattered v0.8.0\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"New Hero Select!\",\n\t\t\t\t\"The game's hero select screen has been completely overhauled, and how shows off the heroes in more detail than ever before.\\n\\n\" +\n\t\t\t\t\"The new hero select features a minimal UI that retains all the old functionality while trying to keep out of the way as much as possible. The centerpiece of hero select is now the heroes themselves, who are depicted with _new detailed splash arts_ by Aleksandar Komitov! _Make sure check out their credits listing in the new about page!_\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.AUDIO), \"Sound Effects\",\n\t\t\t\t\"_15+ new sound effects_ have been added to the game, courtesy of Charlie! _Make sure check out their credits listing in the new about page!_\\n\\n\" +\n\t\t\t\t\"These sounds cover movement, combat, and a bunch of miscellanious situations:\\n\" +\n\t\t\t\t\"_-_ Grass now crunches underfoot (extra loud if it's tall grass), and solid floors now have a more solid sound.\\n\" +\n\t\t\t\t\"_-_ The default hitsound has been remastered, and weapons can now produce slashing, stabbing, or crushing sounds.\\n\" +\n\t\t\t\t\"_-_ Bows, crossbows, and projectile wands have new shooting/hitting sounds.\\n\" +\n\t\t\t\t\"_-_ A new heavy impact sound plays when you land a surprise attack, and a new blocking sound when damage is negated by parrying or shields.\\n\" +\n\t\t\t\t\"_-_ Some misc sounds have also been added for: gas spewing, chains being thrown, magical effects charging up, and the player being hit to low health.\\n\\n\" +\n\t\t\t\t\"I've also remastered the title and ending music tracks to improve their quality and volume.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Interfaces.BUFFS_LARGE, 0, 0, 16, 16), \"Item and Buff Icons\",\n\t\t\t\t\"_Buff icons now have a new fading behaviour_ that much more accurately communicates how much of their duration is left. Several duplicated buff icons have also been recolored so they are distinct.\\n\\n\" +\n\t\t\t\t\"_Item icons have been added to rings!_ To accommodate this, item icons now appear in the top-right of an item's inventory slot. Several existing item icons have also been improved.\"));\n\n\t\tchanges.addButton( new ChangeButton(new TalismanOfForesight(),\n\t\t\t\t\"The _Talisman of Foresight_ has received a rework to make its active ability more useful and interactive!\\n\\n\" +\n\t\t\t\t\"A few changes have been made to passive trap detection:\\n\" +\n\t\t\t\t\"_-_ Talisman no longer gains EXP from the hero finding secrets\\n\" +\n\t\t\t\t\"_-_ 'uneasy' status no longer lingers when traps aren't in range\\n\" +\n\t\t\t\t\"_-_ Passive charge speed at max level reduced by 33%\\n\\n\" +\n\t\t\t\t\"The talisman's scry active ability has been redesigned:\\n\" +\n\t\t\t\t\"_-_ Scry now projects outward in a cone, in a direction and distance of the player's choice.\\n\" +\n\t\t\t\t\"_-_ Everything within scry's range is revealed, including the map, secrets, and enemies/items.\\n\" +\n\t\t\t\t\"_-_ The player gets temporary mind vision on revealed enemies/items.\\n\" +\n\t\t\t\t\"_-_ The talisman gains exp based on what it reveals. Secrets are worth the most EXP.\\n\" +\n\t\t\t\t\"_-_ As the talisman levels, max scry distance and mind vision duration increase.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfRegrowth(),\n\t\t\t\t\"The _Wand of Regrowth_ has been reworked, with the goal of making it useful for more than just farming:\\n\\n\" +\n\t\t\t\t\"_-_ Initial charges increased to 2 from 1.\\n\" +\n\t\t\t\t\"_-_ Regrowth now attacks in the same pattern as fireblast, no longer consumes all charges at once.\\n\" +\n\t\t\t\t\"_-_ Rebalanced rooting time, AOE size, farming cap, grass and plant spawning frequency, and upgrade scaling.\\n\" +\n\t\t\t\t\"_-_ Added a new unique plant that is only summoned when spending 3 charges of regrowth.\\n\\n\" +\n\t\t\t\t\"_Starflower_ is no longer a special regrowth plant, so it's getting a few changes:\\n\" +\n\t\t\t\t\"_-_ Starflower no longer has a 1/5 chance to drop its own seed.\\n\" +\n\t\t\t\t\"_-_ Starflower is now 2.5x as rare as other seeds, down from 10x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfMagicMissile(),\n\t\t\t\t\"The _Wand of Magic Missile_ has received a new ability that lets it better synergize with other wands!\\n\\n\" +\n\t\t\t\t\"After zapping with an upgraded magic missile wand, the hero becomes 'magically charged' for a few turns. When the hero zaps with another lower-level wand, the charge is consumed and that wand will act as if it is the same level as the wand of magic missile!\\n\\n\" +\n\t\t\t\t\"My hope with this change is to make magic missile more worthy of upgrades if the player is going for a sort of 'wandslinger' build, while still maintaining the wands weakness when used solo.\\n\\n\" +\n\t\t\t\t\"I intend to closely watch how this change plays out, and make adjustments if it ends up messing with the Mage too much. As a start to this, the _Battlemage_ on-hit effect for magic missile has been toned down, to prevent a magic missile staff plus a single low-level wand being stronger than just imbuing that wand.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.POUCH), \"Item Droprate and Inventory Managment\",\n\t\t\t\t\"I'm making several changes primarily targeted at reducing inventory clutter. These shouldn't have a significant impact on game balance, but should reduce the likelihood of the player's inventory being clogged with low-value items.\\n\\n\" +\n\t\t\t\t\"_-_ Bags now appear inside of themselves, rather than taking up main inventory space.\\n\" +\n\t\t\t\t\"_-_ Consumable drops are now slightly rarer, but the game is now much more likely to give a variety of consumables over the course of a run.\\n\" +\n\t\t\t\t\"_-_ Equipment drops are now slightly rarer, but are also higher in quality on average. In particular enemy equipment drops can now be above +0.\\n\" +\n\t\t\t\t\"_-_ Item drops have been added to DM-200s, Ghouls, and Golems.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.Sprites.TENGU, 0, 0, 14, 16), \"Boss Changes\",\n\t\t\t\t\"I'm making some design and balance changes to bosses based on analytics data and feedback:\\n\\n\" +\n\t\t\t\t\"_Tengu_'s second phase has been removed due to its overall negative reception. In exchange, the traps in Tengu's first phase are now more maze-like. Tengu now also receives an accuracy penalty when attacking at melee range.\\n\\n\" +\n\t\t\t\t\"_DM-300_'s boss fight now starts after the player explores its arena, the supercharge sparks now move more quickly, and several dialogue lines have been tweaked. This will hopefully make it easier for the player to understand what to do when DM-300 becomes supercharged.\\n\\n\" +\n\t\t\t\t\"_Yog-Dzewa_ is receiving some smaller balance tweaks:\\n\" +\n\t\t\t\t\"_-_ Yog laser damage down to 20-30 from 20-35\\n\" +\n\t\t\t\t\"_-_ Bright/Dark fist ranged damage down to 10-20 from 12-24\\n\" +\n\t\t\t\t\"_-_ Burning fist now evaporates slightly more water tiles\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.DISPLAY), \"Interface Adjustments\",\n\t\t\t\t\"Aside from the new hero select, several other interfaces have been adjusted as well:\\n\" +\n\t\t\t\t\"_-_ The about scene has been expanded with more credits listings and links.\\n\" +\n\t\t\t\t\"_-_ Small improvements to icon style and button layout on the title screen.\\n\" +\n\t\t\t\t\"_-_ The layout of the language selection window has been improved.\\n\" +\n\t\t\t\t\"_-_ The settings window now uses icons for its tabs, instead of text.\\n\" +\n\t\t\t\t\"_-_ Adjusted the layout of buying and selling windows slightly.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game's startup time has been substantially improved on devices with slower storage.\\n\" +\n\t\t\t\t\"_-_ Volume sliders are now more sensetive at the lower range.\\n\" +\n\t\t\t\t\"_-_ A keybinding has been added for resting.\\n\\n\" +\n\t\t\t\t\"_-_ Passive enemies are no longer automatically surprise attacked.\\n\" +\n\t\t\t\t\"_-_ Several buff durations have been slightly tweaked to be more consistent.\\n\" +\n\t\t\t\t\"_-_ The footwear of nature now only lets you select seeds that you haven't fed to it already.\\n\\n\" +\n\t\t\t\t\"_-_ Cell checking visual effects have been improved.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image( Assets.Sprites.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various visual/textual errors\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Levitation applying ground pressing effects before actually ending\\n\" +\n\t\t\t\t\"_-_ Ascend/descend working while rooted\\n\" +\n\t\t\t\t\"_-_ Scroll of remove curse not being usable while degraded\\n\" +\n\t\t\t\t\"_-_ Stone glyph not clamping negative accuracy or evasion\\n\" +\n\t\t\t\t\"_-_ Incorrect interactions between corrupting and on-kill effects\\n\" +\n\t\t\t\t\"_-_ Unblessed ankh revives waking up mimics\\n\" +\n\t\t\t\t\"_-_ Rogue armor's blink not going over terrain in some cases\\n\" +\n\t\t\t\t\"_-_ DM-300 being able to drill out of its arena in rare cases\\n\" +\n\t\t\t\t\"_-_ Dark & bright fists rarely teleporting to unreachable places\\n\" +\n\t\t\t\t\"_-_ Summoning traps failing to summon anything in some cases\\n\" +\n\t\t\t\t\"_-_ Debuffs being incorrectly persisted in rankings\\n\" +\n\t\t\t\t\"_-_ Tengu cleansing doomed debuff between first and second phase\\n\" +\n\t\t\t\t\"_-_ Gasses being examinable when not visible\\n\" +\n\t\t\t\t\"_-_ Fireblast applying debuffs to dead enemies\\n\" +\n\t\t\t\t\"_-_ Update checker using data on metered networks\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST), \"Ring of Wealth and Lucky Enchant\",\n\t\t\t\t\"The _Ring of Wealth_ has been substantially buffed to make it more worth investing upgrades in:\\n\" +\n\t\t\t\t\"_-_ Regular drop chance boost up to 25% from 20%.\\n\" +\n\t\t\t\t\"_-_ Special ring of wealth drops now increase in value, not frequency, as the ring levels.\\n\" +\n\t\t\t\t\"_-_ Removed guaranteed +0 weapons/armor from special ring of wealth drops.\\n\" +\n\t\t\t\t\"_-_ Added new vfx to special ring of wealth drops to better indicate how rare a drop was.\\n\\n\" +\n\t\t\t\t\"The _Lucky_ Enchantment is also being buffed:\\n\" +\n\t\t\t\t\"_-_ Lucky now gives low and medium value drops from ring of wealth's special reward pool.\"));\n\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.Sprites.ROGUE, 0, 90, 12, 15), \"Assassin and Sniper\",\n\t\t\t\t\"The _Assassin_ is having a little trouble now that more enemies have tools to counter raw damage, so he's getting a boost:\\n\" +\n\t\t\t\t\"_-_ Preparation now gives a +15% damage bonus at 1/3/6/11 turns, up from a +10% damage bonus at 1/3/6/11/16 turns.\\n\" +\n\t\t\t\t\"_-_ Preparation now executes low health enemies, rather than dealing more damage.\\n\" +\n\t\t\t\t\"_-_ Preparation can now execute bosses if they are very weak.\\n\\n\" +\n\t\t\t\t\"The _Sniper_ is also having trouble after 0.8.0, so she's getting a boost as well:\\n\" +\n\t\t\t\t\"_-_ Sniper's mark now lasts 4 turns, up from 2.\\n\" +\n\t\t\t\t\"_-_ Sniper shot damage scaling with distance increased, now caps at 3x damage, up from 2.5x.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"The _Wand of Warding_ has received a variety of changes focused around making it more powerful and easier to use:\\n\" +\n\t\t\t\t\"_-_ Wards/sentries are now inorganic\\n\" +\n\t\t\t\t\"_-_ Ward/sentry energy cost and warding energy capacity reduced by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry vision range increased by 1\\n\" +\n\t\t\t\t\"_-_ Ward/sentry attack speed standardized to 0.5x/1x\\n\" +\n\t\t\t\t\"_-_ Greater wards now get 5 zaps, up from 4\\n\" +\n\t\t\t\t\"_-_ Lesser sentries now start with 4 less HP for each zap they used as a ward\\n\" +\n\t\t\t\t\"_-_ Upgrading a sentry now always grants it the largest possible health boost\\n\" +\n\t\t\t\t\"_-_ Sentry healing up to 8/10/15 from 6/8/12\\n\\n\" +\n\t\t\t\t\"_-_ Ward sprites now visually darken as they use up charges\\n\" +\n\t\t\t\t\"_-_ Sentries now show how much they are being healed\\n\" +\n\t\t\t\t\"_-_ Wards can now be adjacent to eachother\\n\" +\n\t\t\t\t\"_-_ Wards can now be summoned out of FOV if nothing is in the way\\n\" +\n\t\t\t\t\"_-_ Wards now spawn adjacent to an enemy/wall if shot at one\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_DISINTEGRATION), \"Various Item Buffs\",\n\t\t\t\t\"I'm buffing items that are performing poorly after v0.8.0:\\n\\n\" +\n\t\t\t\t\"Several wands need a boost as raw damage is now less effective:\\n\" +\n\t\t\t\t\"_- Disintegration_ base range up to 6 from 4.\\n\" +\n\t\t\t\t\"_- Lightning_ no longer harms allies, self-damage down to 67% from 100%.\\n\" +\n\t\t\t\t\"_- Frost_ chill damage reduction down to 5% per turn from 10%.\\n\" +\n\t\t\t\t\"_- Fireblast_ now spreads fire in a wider cone shape.\\n\" +\n\t\t\t\t\"_- Potion of Dragon's Breath_ uses this wider cone too.\\n\\n\" +\n\t\t\t\t\"With more ranged enemies, knockback needs more utility:\\n\" +\n\t\t\t\t\"_- Knockback effects_ now close doors if the knockback target was inside one.\\n\\n\" +\n\t\t\t\t\"Various other items/enchants are also being buffed:\\n\" +\n\t\t\t\t\"_- Horn of Plenty_ charge rate increased by 25%\\n\" +\n\t\t\t\t\"_- Shocking_ no longer harms allies\\n\" +\n\t\t\t\t\"_- Camouflage_ now applies regular invisibility\\n\" +\n\t\t\t\t\"_- Flow_ speed multiplier increased to 2 + 0.25xlvl from 2.\\n\" +\n\t\t\t\t\"_- Corrupting_ proc rate scaling increased by ~20%\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_CORRUPTION), \"Various Item Nerfs\",\n\t\t\t\t\"I'm nerfing items that are overperforming due to v0.8.0:\\n\\n\" +\n\t\t\t\t\"The _Wand of Corruption_ is once again overpowered, so I'm trying out making it more dependant on enemy health:\\n\" +\n\t\t\t\t\"_-_ Enemies now have 5x resistance at full HP, up from 3x.\\n\\n\" +\n\t\t\t\t\"As _Wand of Frost_ was buffed, I'm scaling back the battlemage's frost ability a bit:\\n\" +\n\t\t\t\t\"_-_ Battlemage frost on-hit now only freezes at 10+ turns of chill, rather than at 2-10 turns.\\n\\n\" +\n\t\t\t\t\"Magic defense items are being scaled back due to the increased number of magical enemies:\\n\" +\n\t\t\t\t\"_- Ring of Elements_ resist per level down to 17.5% from 20%\\n\" +\n\t\t\t\t\"_- Antimagic_ defense reduced by ~20%\\n\\n\" +\n\t\t\t\t\"A few other items/enchants are being adjusted as well:\\n\" +\n\t\t\t\t\"_- Ethereal chains_ levelling speed reduced\\n\" +\n\t\t\t\t\"_- Timekeeper's Hourglass_ sand cost doubled\\n\" +\n\t\t\t\t\"_- Chilling_ and _Shocking_ proc rate reduced\\n\" +\n\t\t\t\t\"_- Swiftness_ now requires 2 tiles of space, up from 1\\n\" +\n\t\t\t\t\"_- Thorns_ proc rate scaling reduced by ~50%\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.GREATAXE), \"Various Weapon Nerfs\",\n\t\t\t\t\"A few weapons are also being toned down:\\n\\n\" +\n\t\t\t\t\"As warlocks no longer reduce hero strength, the greataxe is now much easier to use and is too strong as a result:\\n\" +\n\t\t\t\t\"_- Greataxe_ base dmg reduced to 5-45 from 5-50\\n\\n\" +\n\t\t\t\t\"Defense is now much more useful overall, so several defense-granting weapons are performing better than intended:\\n\" +\n\t\t\t\t\"_- Greatshield_ base block down to 0-6 from 0-10\\n\" +\n\t\t\t\t\"_- Gauntlet_ blocking reduced to 0 from 0-4\\n\" +\n\t\t\t\t\"_- Roundshield_ base dmg down to 3-10 from 3-12\\n\" +\n\t\t\t\t\"_- Roundshield_ base block down to 0-4 from 0-5\\n\" +\n\t\t\t\t\"_- Sai_ blocking reduced to 0 from 0-2\"));\n\n\t}",
          "uniqueId": "b3783295bf46e3dc429ae47af4306277f9f73d6a_59_364_64_270_272_523"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5db6795d54a081db19c482c13583ed03e55a0cc4",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5db6795d54a081db19c482c13583ed03e55a0cc4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void fillFields( Heap heap ) {\n\t\t\n\t\tint width = PixelScene.landscape() ? WIDTH_L : WIDTH_P;\n\t\t\n\t\tIconTitle titlebar = new IconTitle( heap );\n\t\ttitlebar.color( TITLE_COLOR );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextBlock txtInfo = PixelScene.renderTextBlock( heap.info(), 6 );\n\t\ttxtInfo.maxWidth(width);\n\t\ttxtInfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( txtInfo );\n\t\t\n\t\tresize( width, (int)(txtInfo.bottom() + 2) );\n\t}",
          "sourceCodeAfterRefactoring": "private void fillFields( Heap heap ) {\n\t\t\n\t\tIconTitle titlebar = new IconTitle( heap );\n\t\ttitlebar.color( TITLE_COLOR );\n\t\t\n\t\tRenderedTextBlock txtInfo = PixelScene.renderTextBlock( heap.info(), 6 );\n\n\t\tlayoutFields(titlebar, txtInfo);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void layoutFields(IconTitle title, RenderedTextBlock info){\n\t\tint width = WIDTH_MIN;\n\n\t\tinfo.maxWidth(width);\n\n\t\t//window can go out of the screen on landscape, so widen it as appropriate\n\t\twhile (PixelScene.landscape()\n\t\t\t\t&& info.height() > 100\n\t\t\t\t&& width < WIDTH_MAX){\n\t\t\twidth += 20;\n\t\t\tinfo.maxWidth(width);\n\t\t}\n\n\t\ttitle.setRect( 0, 0, width, 0 );\n\t\tadd( title );\n\n\t\tinfo.setPos(title.left(), title.bottom() + GAP);\n\t\tadd( info );\n\n\t\tresize( width, (int)(info.bottom() + 2) );\n\t}",
          "uniqueId": "5db6795d54a081db19c482c13583ed03e55a0cc4_57_72_84_104_57_65"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void fillFields( Item item ) {\n\t\t\n\t\tint color = TITLE_COLOR;\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t}\n\t\t\n\t\tint width = PixelScene.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.color( color );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextBlock txtInfo = PixelScene.renderTextBlock( item.info(), 6 );\n\t\ttxtInfo.maxWidth(width);\n\t\ttxtInfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( txtInfo );\n\t\t\n\t\tresize( width, (int)(txtInfo.bottom() + 2) );\n\t}",
          "sourceCodeAfterRefactoring": "private void fillFields( Item item ) {\n\t\t\n\t\tint color = TITLE_COLOR;\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t}\n\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.color( color );\n\t\t\n\t\tRenderedTextBlock txtInfo = PixelScene.renderTextBlock( item.info(), 6 );\n\t\t\n\t\tlayoutFields(titlebar, txtInfo);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void layoutFields(IconTitle title, RenderedTextBlock info){\n\t\tint width = WIDTH_MIN;\n\n\t\tinfo.maxWidth(width);\n\n\t\t//window can go out of the screen on landscape, so widen it as appropriate\n\t\twhile (PixelScene.landscape()\n\t\t\t\t&& info.height() > 100\n\t\t\t\t&& width < WIDTH_MAX){\n\t\t\twidth += 20;\n\t\t\tinfo.maxWidth(width);\n\t\t}\n\n\t\ttitle.setRect( 0, 0, width, 0 );\n\t\tadd( title );\n\n\t\tinfo.setPos(title.left(), title.bottom() + GAP);\n\t\tadd( info );\n\n\t\tresize( width, (int)(info.bottom() + 2) );\n\t}",
          "uniqueId": "5db6795d54a081db19c482c13583ed03e55a0cc4_74_96_84_104_67_82"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3dc913fadc5a455bf38fb578b4bbc1db93143f03",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3dc913fadc5a455bf38fb578b4bbc1db93143f03",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void cast( final Hero user, final int dst ) {\n\t\t\n\t\tfinal int cell = throwPos( user, dst );\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tSample.INSTANCE.play( Assets.Sounds.MISS, 0.6f, 0.6f, 1.5f );\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\t\t\n\t\tfinal float delay = castDelay(user, dst);\n\n\t\tif (enemy != null) {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tenemy.sprite,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tcurUser = user;\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} else {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tcurUser = user;\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void cast( final Hero user, final int dst ) {\n\t\t\n\t\tfinal int cell = throwPos( user, dst );\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tthrowSound();\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\t\t\n\t\tfinal float delay = castDelay(user, dst);\n\n\t\tif (enemy != null) {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tenemy.sprite,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tcurUser = user;\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} else {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tcurUser = user;\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void throwSound(){\n\t\tSample.INSTANCE.play(Assets.Sounds.MISS, 0.6f, 0.6f, 1.5f);\n\t}",
          "uniqueId": "3dc913fadc5a455bf38fb578b4bbc1db93143f03_511_551_511_513_515_555"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0390b3dbad28e3b2ea6cd8e81ef9ee2aa73350fa",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0390b3dbad28e3b2ea6cd8e81ef9ee2aa73350fa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void unseal() {\n\t\tsuper.unseal();\n\n\t\tset( bottomDoor, Terrain.DOOR );\n\t\tGameScene.updateMap( bottomDoor );\n\n\t\tset( topDoor, Terrain.DOOR );\n\t\tGameScene.updateMap( topDoor );\n\n\t\tif (Imp.Quest.isCompleted()) {\n\t\t\timpShop.spawnShop(this);\n\t\t}\n\t\tDungeon.observe();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void unseal() {\n\t\tsuper.unseal();\n\n\t\tset( bottomDoor, Terrain.DOOR );\n\t\tGameScene.updateMap( bottomDoor );\n\n\t\tset( topDoor, Terrain.DOOR );\n\t\tGameScene.updateMap( topDoor );\n\n\t\tif (Imp.Quest.isCompleted()) {\n\t\t\tspawnShop();\n\t\t}\n\t\tDungeon.observe();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void spawnShop(){\n\t\twhile (impShop.itemCount() >= 7*(impShop.height()-2)){\n\t\t\timpShop.bottom++;\n\t\t}\n\t\timpShop.spawnShop(this);\n\t}",
          "uniqueId": "0390b3dbad28e3b2ea6cd8e81ef9ee2aa73350fa_299_313_314_319_298_312"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e40a5b5ab18f0bed1613065dc0c1864e3b82c18a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e40a5b5ab18f0bed1613065dc0c1864e3b82c18a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public DM300Sprite() {\n\t\tsuper();\n\t\t\n\t\ttexture( Assets.DM300 );\n\t\t\n\t\tTextureFilm frames = new TextureFilm( texture, 22, 20 );\n\t\t\n\t\tidle = new Animation( 10, true );\n\t\tidle.frames( frames, 0, 1 );\n\t\t\n\t\trun = new Animation( 10, true );\n\t\trun.frames( frames, 2, 3 );\n\t\t\n\t\tattack = new Animation( 15, false );\n\t\tattack.frames( frames, 4, 5, 6 );\n\n\t\tslam = attack.clone();\n\n\t\tzap = attack.clone();\n\n\t\tdie = new Animation( 20, false );\n\t\tdie.frames( frames, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 0, 7, 8 );\n\t\t\n\t\tplay( idle );\n\t}",
          "sourceCodeAfterRefactoring": "public DM300Sprite() {\n\t\tsuper();\n\t\t\n\t\ttexture( Assets.DM300 );\n\t\t\n\t\tsetAnimations(false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void setAnimations( boolean enraged ){\n\t\tint c = enraged ? 10 : 0;\n\n\t\tTextureFilm frames = new TextureFilm( texture, 25, 22 );\n\n\t\tidle = new Animation( enraged ? 15 : 10, true );\n\t\tidle.frames( frames, c+0, c+1 );\n\n\t\trun = new Animation( enraged ? 15 : 10, true );\n\t\trun.frames( frames, c+0, c+2 );\n\n\t\tattack = new Animation( 15, false );\n\t\tattack.frames( frames, c+3, c+4, c+5 );\n\n\t\t//unaffected by enrage state\n\n\t\tif (charge == null) {\n\t\t\tcharge = new Animation(4, true);\n\t\t\tcharge.frames(frames, 0, 10);\n\n\t\t\tslam = attack.clone();\n\n\t\t\tzap = new Animation(15, false);\n\t\t\tzap.frames(frames, 6, 7, 7, 6);\n\n\t\t\tdie = new Animation(20, false);\n\t\t\tdie.frames(frames, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10, 0, 10);\n\t\t}\n\n\t\tif (curAnim != charge) play(idle);\n\t}",
          "uniqueId": "e40a5b5ab18f0bed1613065dc0c1864e3b82c18a_42_66_51_81_43_49"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b5989ee4f66cc0ee2fd0baad186b12faaae90d83",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tif (phase == 2 && !(src instanceof KingDamager)){\n\t\t\tsprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"immune\") );\n\t\t\treturn;\n\t\t} else if (phase == 3 && !(src instanceof Viscosity.DeferedDamage)){\n\t\t\tViscosity.DeferedDamage deferred = Buff.affect( this, Viscosity.DeferedDamage.class );\n\t\t\tdeferred.prolong( dmg );\n\n\t\t\tsprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", dmg) );\n\t\t\treturn;\n\t\t}\n\t\tint preHP = HP;\n\t\tsuper.damage(dmg, src);\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null && !isImmune(src.getClass())) lock.addTime(dmg/3);\n\n\t\tif (phase == 1) {\n\t\t\tint dmgTaken = preHP - HP;\n\t\t\tabilityCooldown -= dmgTaken/8f;\n\t\t\tsummonCooldown -= dmgTaken/8f;\n\t\t\tif (HP <= 50) {\n\t\t\t\tHP = 50;\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"immune\"));\n\t\t\t\tScrollOfTeleportation.appear(this, NewCityBossLevel.throne);\n\t\t\t\tproperties.add(Property.IMMOVABLE);\n\t\t\t\tphase = 2;\n\t\t\t\tsummonsMade = 0;\n\t\t\t\tsprite.idle();\n\t\t\t\tBuff.affect(this, DKBarrior.class).setShield(HT);\n\t\t\t\tfor (Summoning s : buffs(Summoning.class)) {\n\t\t\t\t\ts.detach();\n\t\t\t\t}\n\t\t\t\tfor (Mob m : Dungeon.level.mobs.toArray(new Mob[0])) {\n\t\t\t\t\tif (m instanceof Ghoul || m instanceof Monk || m instanceof Warlock) {\n\t\t\t\t\t\tm.die(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (phase == 2 && shielding() == 0) {\n\t\t\tproperties.remove(Property.IMMOVABLE);\n\t\t\tphase = 3;\n\t\t\tsummonsMade = 3; //opens with a monk/warlock\n\t\t\tsprite.centerEmitter().start( Speck.factory( Speck.SCREAM ), 0.4f, 2 );\n\t\t\tSample.INSTANCE.play( Assets.SND_CHALLENGE );\n\t\t\tyell(  Messages.get(this, \"enraged\", Dungeon.hero.name()) );\n\t\t} else if (phase == 3 && preHP > 20 && HP < 20){\n\t\t\tyell( Messages.get(this, \"losing\") );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tif (isInvulnerable(src.getClass())){\n\t\t\tsuper.damage(dmg, src);\n\t\t\treturn;\n\t\t} else if (phase == 3 && !(src instanceof Viscosity.DeferedDamage)){\n\t\t\tViscosity.DeferedDamage deferred = Buff.affect( this, Viscosity.DeferedDamage.class );\n\t\t\tdeferred.prolong( dmg );\n\n\t\t\tsprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", dmg) );\n\t\t\treturn;\n\t\t}\n\t\tint preHP = HP;\n\t\tsuper.damage(dmg, src);\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null && !isImmune(src.getClass())) lock.addTime(dmg/3);\n\n\t\tif (phase == 1) {\n\t\t\tint dmgTaken = preHP - HP;\n\t\t\tabilityCooldown -= dmgTaken/8f;\n\t\t\tsummonCooldown -= dmgTaken/8f;\n\t\t\tif (HP <= 50) {\n\t\t\t\tHP = 50;\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"invulnerable\"));\n\t\t\t\tScrollOfTeleportation.appear(this, NewCityBossLevel.throne);\n\t\t\t\tproperties.add(Property.IMMOVABLE);\n\t\t\t\tphase = 2;\n\t\t\t\tsummonsMade = 0;\n\t\t\t\tsprite.idle();\n\t\t\t\tBuff.affect(this, DKBarrior.class).setShield(HT);\n\t\t\t\tfor (Summoning s : buffs(Summoning.class)) {\n\t\t\t\t\ts.detach();\n\t\t\t\t}\n\t\t\t\tfor (Mob m : Dungeon.level.mobs.toArray(new Mob[0])) {\n\t\t\t\t\tif (m instanceof Ghoul || m instanceof Monk || m instanceof Warlock) {\n\t\t\t\t\t\tm.die(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (phase == 2 && shielding() == 0) {\n\t\t\tproperties.remove(Property.IMMOVABLE);\n\t\t\tphase = 3;\n\t\t\tsummonsMade = 3; //opens with a monk/warlock\n\t\t\tsprite.centerEmitter().start( Speck.factory( Speck.SCREAM ), 0.4f, 2 );\n\t\t\tSample.INSTANCE.play( Assets.SND_CHALLENGE );\n\t\t\tyell(  Messages.get(this, \"enraged\", Dungeon.hero.name()) );\n\t\t} else if (phase == 3 && preHP > 20 && HP < 20){\n\t\t\tyell( Messages.get(this, \"losing\") );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic boolean isInvulnerable(Class effect) {\n\t\treturn phase == 2 && effect != KingDamager.class;\n\t}",
          "uniqueId": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83_357_407_357_360_362_412"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tif (supercharged){\n\t\t\tsprite.showStatus( CharSprite.POSITIVE, Messages.get(this, \"immune\") );\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.damage(dmg, src);\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null && !isImmune(src.getClass())) lock.addTime(dmg);\n\n\t\tint threshold = HT/3 * (2- pylonsActivated);\n\n\t\tif (HP < threshold){\n\t\t\tHP = threshold;\n\t\t\tsupercharge();\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tsuper.damage(dmg, src);\n\t\tif (isInvulnerable(src.getClass())){\n\t\t\treturn;\n\t\t}\n\n\t\tLockedFloor lock = Dungeon.hero.buff(LockedFloor.class);\n\t\tif (lock != null && !isImmune(src.getClass())) lock.addTime(dmg);\n\n\t\tint threshold = HT/3 * (2- pylonsActivated);\n\n\t\tif (HP < threshold){\n\t\t\tHP = threshold;\n\t\t\tsupercharge();\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic boolean isInvulnerable(Class effect) {\n\t\treturn supercharged;\n\t}",
          "uniqueId": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83_408_427_427_430_408_425"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tif (isNearYog()){\n\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"immune\"));\n\t\t\tif (!immuneWarned){\n\t\t\t\timmuneWarned = true;\n\t\t\t\tGLog.w(Messages.get(this, \"immune_hint\"));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tsuper.damage(dmg, src);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void damage(int dmg, Object src) {\n\t\tif (isInvulnerable(src.getClass())){\n\t\t\tif (!invulnWarned){\n\t\t\t\tinvulnWarned = true;\n\t\t\t\tGLog.w(Messages.get(this, \"invuln_warn\"));\n\t\t\t}\n\t\t}\n\t\tsuper.damage(dmg, src);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic boolean isInvulnerable(Class effect) {\n\t\treturn isNearYog();\n\t}",
          "uniqueId": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83_101_112_101_104_106_115"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void damage(int dmg, Object src) {\n\t\t\tif (isNearYog()){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"immune\"));\n\t\t\t\tif (!immuneWarned){\n\t\t\t\t\timmuneWarned = true;\n\t\t\t\t\tGLog.w(Messages.get(this, \"immune_hint\"));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(src instanceof Bleeding)){\n\t\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\t\tif (b == null){\n\t\t\t\t\tb = new Bleeding();\n\t\t\t\t}\n\t\t\t\tb.announced = false;\n\t\t\t\tb.set(dmg*.67f);\n\t\t\t\tb.attachTo(this);\n\t\t\t\tsprite.showStatus(CharSprite.WARNING, b.toString() + \" \" + (int)b.level());\n\t\t\t} else{\n\t\t\t\tsuper.damage(dmg, src);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void damage(int dmg, Object src) {\n\t\t\tif (!isInvulnerable(src.getClass()) && !(src instanceof Bleeding)){\n\t\t\t\tBleeding b = buff(Bleeding.class);\n\t\t\t\tif (b == null){\n\t\t\t\t\tb = new Bleeding();\n\t\t\t\t}\n\t\t\t\tb.announced = false;\n\t\t\t\tb.set(dmg*.67f);\n\t\t\t\tb.attachTo(this);\n\t\t\t\tsprite.showStatus(CharSprite.WARNING, b.toString() + \" \" + (int)b.level());\n\t\t\t} else{\n\t\t\t\tsuper.damage(dmg, src);\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic boolean isInvulnerable(Class effect) {\n\t\treturn isNearYog();\n\t}",
          "uniqueId": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83_345_367_101_104_348_362"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void damage(int dmg, Object src) {\n\t\t\tif (isNearYog()){\n\t\t\t\tsprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"immune\"));\n\t\t\t\tif (!immuneWarned){\n\t\t\t\t\timmuneWarned = true;\n\t\t\t\t\tGLog.w(Messages.get(this, \"immune_hint\"));\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(src instanceof Viscosity.DeferedDamage)){\n\t\t\t\tBuff.affect(this, Viscosity.DeferedDamage.class).prolong(dmg);\n\t\t\t\tsprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", dmg) );\n\t\t\t} else{\n\t\t\t\tsuper.damage(dmg, src);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void damage(int dmg, Object src) {\n\t\t\tif (!isInvulnerable(src.getClass()) && !(src instanceof Viscosity.DeferedDamage)){\n\t\t\t\tBuff.affect(this, Viscosity.DeferedDamage.class).prolong(dmg);\n\t\t\t\tsprite.showStatus( CharSprite.WARNING, Messages.get(Viscosity.class, \"deferred\", dmg) );\n\t\t\t} else{\n\t\t\t\tsuper.damage(dmg, src);\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic boolean isInvulnerable(Class effect) {\n\t\treturn isNearYog();\n\t}",
          "uniqueId": "b5989ee4f66cc0ee2fd0baad186b12faaae90d83_407_423_101_104_402_410"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3c4e8a5f74e2245fddf0a8300e5e21e0724759e0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3c4e8a5f74e2245fddf0a8300e5e21e0724759e0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void flash( int color ) {\n\t\tscene.fadeIn( 0xFF000000 | color, true );\n\t}",
          "sourceCodeAfterRefactoring": "public static void flash( int color ) {\n\t\tflash( color, true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void flash( int color, boolean lightmode ) {\n\t\tscene.fadeIn( 0xFF000000 | color, lightmode );\n\t}",
          "uniqueId": "3c4e8a5f74e2245fddf0a8300e5e21e0724759e0_934_936_938_940_934_936"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "88a187778468edd660f58137ea203698ffff1fea",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/88a187778468edd660f58137ea203698ffff1fea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean attack( Char enemy ) {\n\t\t\t\n\t\t\tif (!Dungeon.level.adjacent( pos, enemy.pos )) {\n\t\t\t\tspend( attackDelay() );\n\t\t\t\t\n\t\t\t\tif (hit( this, enemy, true )) {\n\t\t\t\t\t\n\t\t\t\t\tint dmg =  damageRoll();\n\t\t\t\t\tenemy.damage( dmg, new DarkBolt() );\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.bloodBurstA( sprite.center(), dmg );\n\t\t\t\t\tenemy.sprite.flash();\n\t\t\t\t\t\n\t\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn super.attack( enemy );\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "protected boolean doAttack( Char enemy ) {\n\n\t\t\tif (Dungeon.level.adjacent( pos, enemy.pos )) {\n\n\t\t\t\treturn super.doAttack( enemy );\n\n\t\t\t} else {\n\n\t\t\t\tif (sprite != null && (sprite.visible || enemy.sprite.visible)) {\n\t\t\t\t\tsprite.zap( enemy.pos );\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tzap();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void zap() {\n\t\t\tspend( 1f );\n\n\t\t\tif (hit( this, enemy, true )) {\n\n\t\t\t\tint dmg = damageRoll();\n\t\t\t\tenemy.damage( dmg, new DarkBolt() );\n\n\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t}\n\t\t}",
          "uniqueId": "88a187778468edd660f58137ea203698ffff1fea_326_354_343_360_325_341"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void jump( int from, int to, Callback callback ) {\n\t\tjumpCallback = callback;\n\n\t\tfloat distance = Dungeon.level.trueDistance( from, to );\n\t\tjumpTweener = new JumpTweener( this, worldToCamera( to ), distance * 2, distance * 0.1f );\n\t\tjumpTweener.listener = this;\n\t\tparent.add( jumpTweener );\n\n\t\tturnTo( from, to );\n\t}",
          "sourceCodeAfterRefactoring": "public void jump( int from, int to, Callback callback ) {\n\t\tfloat distance = Dungeon.level.trueDistance( from, to );\n\t\tjump( from, to, callback, distance * 2, distance * 0.1f );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void jump( int from, int to, Callback callback, float height, float duration ) {\n\t\tjumpCallback = callback;\n\n\t\tjumpTweener = new JumpTweener( this, worldToCamera( to ), height, duration );\n\t\tjumpTweener.listener = this;\n\t\tparent.add( jumpTweener );\n\n\t\tturnTo( from, to );\n\t}",
          "uniqueId": "88a187778468edd660f58137ea203698ffff1fea_275_284_280_288_275_278"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "48471bbfefbd0b1890889c83748771931e338a5e",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/48471bbfefbd0b1890889c83748771931e338a5e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int minWidth() {\n\t\tif (itemsToSpawn == null) itemsToSpawn = generateItems();\n\t\treturn Math.max(7, (int)(Math.sqrt(itemsToSpawn.size())+3));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int minWidth() {\n\t\treturn Math.max(7, (int)(Math.sqrt(itemCount())+3));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int itemCount(){\n\t\tif (itemsToSpawn == null) itemsToSpawn = generateItems();\n\t\treturn itemsToSpawn.size();\n\t}",
          "uniqueId": "48471bbfefbd0b1890889c83748771931e338a5e_69_73_79_82_69_72"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int minHeight() {\n\t\tif (itemsToSpawn == null) itemsToSpawn = generateItems();\n\t\treturn Math.max(7, (int)(Math.sqrt(itemsToSpawn.size())+3));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int minHeight() {\n\t\treturn Math.max(7, (int)(Math.sqrt(itemCount())+3));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int itemCount(){\n\t\tif (itemsToSpawn == null) itemsToSpawn = generateItems();\n\t\treturn itemsToSpawn.size();\n\t}",
          "uniqueId": "48471bbfefbd0b1890889c83748771931e338a5e_75_79_79_82_74_77"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "32a755cfeedd71b2dcb24626991c1e1b15569fe7",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/32a755cfeedd71b2dcb24626991c1e1b15569fe7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void throwChar(final Char ch, final Ballistica trajectory, int power){\n\t\tif (ch.properties().contains(Char.Property.BOSS)) {\n\t\t\tpower /= 2;\n\t\t}\n\n\t\tint dist = Math.min(trajectory.dist, power);\n\n\t\tboolean collided = dist == trajectory.dist;\n\n\t\tif (dist == 0 || ch.properties().contains(Char.Property.IMMOVABLE)) return;\n\n\t\t//large characters cannot be moved into non-open space\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)) {\n\t\t\tfor (int i = 1; i <= dist; i++) {\n\t\t\t\tif (!Dungeon.level.openSpace[trajectory.path.get(i)]){\n\t\t\t\t\tdist = i-1;\n\t\t\t\t\tcollided = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Actor.findChar(trajectory.path.get(dist)) != null){\n\t\t\tdist--;\n\t\t\tcollided = true;\n\t\t}\n\n\t\tif (dist < 0) return;\n\n\t\tfinal int newPos = trajectory.path.get(dist);\n\n\t\tif (newPos == ch.pos) return;\n\n\t\tfinal int finalDist = dist;\n\t\tfinal boolean finalCollided = collided;\n\t\tfinal int initialpos = ch.pos;\n\n\t\tActor.addDelayed(new Pushing(ch, ch.pos, newPos, new Callback() {\n\t\t\tpublic void call() {\n\t\t\t\tif (initialpos != ch.pos) {\n\t\t\t\t\t//something caused movement before pushing resolved, cancel to be safe.\n\t\t\t\t\tch.sprite.place(ch.pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tch.pos = newPos;\n\t\t\t\tif (finalCollided && ch.isAlive()) {\n\t\t\t\t\tch.damage(Random.NormalIntRange((finalDist + 1) / 2, finalDist), this);\n\t\t\t\t\tParalysis.prolong(ch, Paralysis.class, Random.NormalIntRange((finalDist + 1) / 2, finalDist));\n\t\t\t\t}\n\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t//FIXME currently no logic here if the throw effect kills the hero\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t}\n\t\t\t}\n\t\t}), -1);\n\t}",
          "sourceCodeAfterRefactoring": "public static void throwChar(final Char ch, final Ballistica trajectory, int power){\n\t\tthrowChar(ch, trajectory, power, true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void throwChar(final Char ch, final Ballistica trajectory, int power, boolean collideDmg){\n\t\tif (ch.properties().contains(Char.Property.BOSS)) {\n\t\t\tpower /= 2;\n\t\t}\n\n\t\tint dist = Math.min(trajectory.dist, power);\n\n\t\tboolean collided = dist == trajectory.dist;\n\n\t\tif (dist == 0 || ch.properties().contains(Char.Property.IMMOVABLE)) return;\n\n\t\t//large characters cannot be moved into non-open space\n\t\tif (Char.hasProp(ch, Char.Property.LARGE)) {\n\t\t\tfor (int i = 1; i <= dist; i++) {\n\t\t\t\tif (!Dungeon.level.openSpace[trajectory.path.get(i)]){\n\t\t\t\t\tdist = i-1;\n\t\t\t\t\tcollided = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (Actor.findChar(trajectory.path.get(dist)) != null){\n\t\t\tdist--;\n\t\t\tcollided = true;\n\t\t}\n\n\t\tif (dist < 0) return;\n\n\t\tfinal int newPos = trajectory.path.get(dist);\n\n\t\tif (newPos == ch.pos) return;\n\n\t\tfinal int finalDist = dist;\n\t\tfinal boolean finalCollided = collided && collideDmg;\n\t\tfinal int initialpos = ch.pos;\n\n\t\tActor.addDelayed(new Pushing(ch, ch.pos, newPos, new Callback() {\n\t\t\tpublic void call() {\n\t\t\t\tif (initialpos != ch.pos) {\n\t\t\t\t\t//something caused movement before pushing resolved, cancel to be safe.\n\t\t\t\t\tch.sprite.place(ch.pos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tch.pos = newPos;\n\t\t\t\tif (finalCollided && ch.isAlive()) {\n\t\t\t\t\tch.damage(Random.NormalIntRange((finalDist + 1) / 2, finalDist), this);\n\t\t\t\t\tParalysis.prolong(ch, Paralysis.class, Random.NormalIntRange((finalDist + 1) / 2, finalDist));\n\t\t\t\t}\n\t\t\t\tDungeon.level.occupyCell(ch);\n\t\t\t\tif (ch == Dungeon.hero){\n\t\t\t\t\t//FIXME currently no logic here if the throw effect kills the hero\n\t\t\t\t\tDungeon.observe();\n\t\t\t\t}\n\t\t\t}\n\t\t}), -1);\n\t}",
          "uniqueId": "32a755cfeedd71b2dcb24626991c1e1b15569fe7_111_167_115_171_111_113"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4e7aca628ec107fbe9538f8e74b3f882c9563cec",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4e7aca628ec107fbe9538f8e74b3f882c9563cec",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Mimic spawnAt( int pos, List<Item> items, Class mimicType ) {\n\n\t\tMimic m;\n\t\tif (mimicType == GoldenMimic.class){\n\t\t\tm = new GoldenMimic();\n\t\t} else if (mimicType == CrystalMimic.class) {\n\t\t\tm = new CrystalMimic();\n\t\t} else {\n\t\t\tm = new Mimic();\n\t\t}\n\n\t\tm.items = new ArrayList<>( items );\n\t\tm.adjustStats( Dungeon.depth );\n\t\tm.pos = pos;\n\n\t\t//generate an extra reward for killing the mimic\n\t\tItem reward = null;\n\t\tdo {\n\t\t\tswitch (Random.Int(5)) {\n\t\t\t\tcase 0:\n\t\t\t\t\treward = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treward = Generator.randomMissile();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\treward = Generator.randomArmor();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\treward = Generator.randomWeapon();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\treward = Generator.random(Generator.Category.RING);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (reward == null || Challenges.isItemBlocked(reward));\n\t\tm.items.add(reward);\n\t\t\n\t\treturn m;\n\t}",
          "sourceCodeAfterRefactoring": "public static Mimic spawnAt( int pos, List<Item> items, Class mimicType ) {\n\n\t\tMimic m;\n\t\tif (mimicType == GoldenMimic.class){\n\t\t\tm = new GoldenMimic();\n\t\t} else if (mimicType == CrystalMimic.class) {\n\t\t\tm = new CrystalMimic();\n\t\t} else {\n\t\t\tm = new Mimic();\n\t\t}\n\n\t\tm.items = new ArrayList<>( items );\n\t\tm.adjustStats( Dungeon.depth );\n\t\tm.pos = pos;\n\n\t\t//generate an extra reward for killing the mimic\n\t\tm.generatePrize();\n\t\t\n\t\treturn m;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void generatePrize(){\n\t\tItem reward = null;\n\t\tdo {\n\t\t\tswitch (Random.Int(5)) {\n\t\t\t\tcase 0:\n\t\t\t\t\treward = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treward = Generator.randomMissile();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\treward = Generator.randomArmor();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\treward = Generator.randomWeapon();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\treward = Generator.random(Generator.Category.RING);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (reward == null || Challenges.isItemBlocked(reward));\n\t\titems.add(reward);\n\t}",
          "uniqueId": "4e7aca628ec107fbe9538f8e74b3f882c9563cec_233_272_254_276_233_252"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d96351c682cdce22d94302ca6e5b9a22212b96c2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d96351c682cdce22d94302ca6e5b9a22212b96c2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Mimic spawnAt( int pos, Item item ){\n\t\treturn spawnAt( pos, Arrays.asList(item));\n\t}",
          "sourceCodeAfterRefactoring": "public static Mimic spawnAt( int pos, Item item ){\n\t\treturn spawnAt( pos, Arrays.asList(item), Mimic.class);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Mimic spawnAt( int pos, Item item, Class mimicType ){\n\t\treturn spawnAt( pos, Arrays.asList(item), mimicType);\n\t}",
          "uniqueId": "d96351c682cdce22d94302ca6e5b9a22212b96c2_221_223_225_227_221_223"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Mimic spawnAt( int pos, List<Item> items ) {\n\t\t\n\t\tMimic m = new Mimic();\n\t\tm.items = new ArrayList<>( items );\n\t\tm.adjustStats( Dungeon.depth );\n\t\tm.pos = pos;\n\n\t\t//generate an extra reward for killing the mimic\n\t\tItem reward = null;\n\t\tdo {\n\t\t\tswitch (Random.Int(5)) {\n\t\t\t\tcase 0:\n\t\t\t\t\treward = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treward = Generator.randomMissile();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\treward = Generator.randomArmor();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\treward = Generator.randomWeapon();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\treward = Generator.random(Generator.Category.RING);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (reward == null || Challenges.isItemBlocked(reward));\n\t\tm.items.add(reward);\n\t\t\n\t\treturn m;\n\t}",
          "sourceCodeAfterRefactoring": "public static Mimic spawnAt( int pos, List<Item> items ) {\n\t\treturn spawnAt( pos, items, Mimic.class);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Mimic spawnAt( int pos, List<Item> items, Class mimicType ) {\n\n\t\tMimic m;\n\t\tif (mimicType == GoldenMimic.class){\n\t\t\tm = new GoldenMimic();\n\t\t} else if (mimicType == CrystalMimic.class) {\n\t\t\tm = new CrystalMimic();\n\t\t} else {\n\t\t\tm = new Mimic();\n\t\t}\n\n\t\tm.items = new ArrayList<>( items );\n\t\tm.adjustStats( Dungeon.depth );\n\t\tm.pos = pos;\n\n\t\t//generate an extra reward for killing the mimic\n\t\tItem reward = null;\n\t\tdo {\n\t\t\tswitch (Random.Int(5)) {\n\t\t\t\tcase 0:\n\t\t\t\t\treward = new Gold().random();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\treward = Generator.randomMissile();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\treward = Generator.randomArmor();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\treward = Generator.randomWeapon();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\treward = Generator.random(Generator.Category.RING);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (reward == null || Challenges.isItemBlocked(reward));\n\t\tm.items.add(reward);\n\t\t\n\t\treturn m;\n\t}",
          "uniqueId": "d96351c682cdce22d94302ca6e5b9a22212b96c2_225_256_233_272_229_231"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8bcb1e46306e3ba9769414390a26d9ba528fb0b5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean attack( Char enemy ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\t\t\n\t\tif (hit( this, enemy, false )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this, enemy);\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tSample.INSTANCE.play( Assets.SND_HIT, 1, 1, Random.Float( 0.8f, 1.25f ) );\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//TODO: consider revisiting this and shaking in more cases.\n\t\t\tfloat shake = 0f;\n\t\t\tif (enemy == Dungeon.hero)\n\t\t\t\tshake = effectiveDamage / (enemy.HT / 4);\n\n\t\t\tif (shake > 1f)\n\t\t\t\tCamera.main.shake( GameMath.gate( 1, shake, 5), 0.3f );\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)\n\t\t\t\tbuff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(EarthImbue.class) != null)\n\t\t\t\tbuff(EarthImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null)\n\t\t\t\tbuff(FrostImbue.class).proc(enemy);\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name)) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name)) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public boolean attack( Char enemy ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\t\t\n\t\tif (hit( this, enemy, false )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this, enemy);\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tSample.INSTANCE.play( Assets.SND_HIT, 1, 1, Random.Float( 0.8f, 1.25f ) );\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//TODO: consider revisiting this and shaking in more cases.\n\t\t\tfloat shake = 0f;\n\t\t\tif (enemy == Dungeon.hero)\n\t\t\t\tshake = effectiveDamage / (enemy.HT / 4);\n\n\t\t\tif (shake > 1f)\n\t\t\t\tCamera.main.shake( GameMath.gate( 1, shake, 5), 0.3f );\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)\n\t\t\t\tbuff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(EarthImbue.class) != null)\n\t\t\t\tbuff(EarthImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null)\n\t\t\t\tbuff(FrostImbue.class).proc(enemy);\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name())) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String name(){\n\t\treturn Messages.get(this, \"name\");\n\t}",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_222_317_138_140_224_319"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean attack( Char enemy ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\t\t\n\t\tif (hit( this, enemy, false )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this, enemy);\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tSample.INSTANCE.play( Assets.SND_HIT, 1, 1, Random.Float( 0.8f, 1.25f ) );\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//TODO: consider revisiting this and shaking in more cases.\n\t\t\tfloat shake = 0f;\n\t\t\tif (enemy == Dungeon.hero)\n\t\t\t\tshake = effectiveDamage / (enemy.HT / 4);\n\n\t\t\tif (shake > 1f)\n\t\t\t\tCamera.main.shake( GameMath.gate( 1, shake, 5), 0.3f );\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)\n\t\t\t\tbuff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(EarthImbue.class) != null)\n\t\t\t\tbuff(EarthImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null)\n\t\t\t\tbuff(FrostImbue.class).proc(enemy);\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name)) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name)) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public boolean attack( Char enemy ) {\n\n\t\tif (enemy == null) return false;\n\t\t\n\t\tboolean visibleFight = Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[enemy.pos];\n\t\t\n\t\tif (hit( this, enemy, false )) {\n\t\t\t\n\t\t\tint dr = enemy.drRoll();\n\t\t\t\n\t\t\tif (this instanceof Hero){\n\t\t\t\tHero h = (Hero)this;\n\t\t\t\tif (h.belongings.weapon instanceof MissileWeapon\n\t\t\t\t\t\t&& h.subClass == HeroSubClass.SNIPER\n\t\t\t\t\t\t&& !Dungeon.level.adjacent(h.pos, enemy.pos)){\n\t\t\t\t\tdr = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint dmg;\n\t\t\tPreparation prep = buff(Preparation.class);\n\t\t\tif (prep != null){\n\t\t\t\tdmg = prep.damageRoll(this, enemy);\n\t\t\t} else {\n\t\t\t\tdmg = damageRoll();\n\t\t\t}\n\t\t\t\n\t\t\tint effectiveDamage = enemy.defenseProc( this, dmg );\n\t\t\teffectiveDamage = Math.max( effectiveDamage - dr, 0 );\n\t\t\t\n\t\t\tif ( enemy.buff( Vulnerable.class ) != null){\n\t\t\t\teffectiveDamage *= 1.33f;\n\t\t\t}\n\t\t\t\n\t\t\teffectiveDamage = attackProc( enemy, effectiveDamage );\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tSample.INSTANCE.play( Assets.SND_HIT, 1, 1, Random.Float( 0.8f, 1.25f ) );\n\t\t\t}\n\n\t\t\t// If the enemy is already dead, interrupt the attack.\n\t\t\t// This matters as defence procs can sometimes inflict self-damage, such as armor glyphs.\n\t\t\tif (!enemy.isAlive()){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t//TODO: consider revisiting this and shaking in more cases.\n\t\t\tfloat shake = 0f;\n\t\t\tif (enemy == Dungeon.hero)\n\t\t\t\tshake = effectiveDamage / (enemy.HT / 4);\n\n\t\t\tif (shake > 1f)\n\t\t\t\tCamera.main.shake( GameMath.gate( 1, shake, 5), 0.3f );\n\n\t\t\tenemy.damage( effectiveDamage, this );\n\n\t\t\tif (buff(FireImbue.class) != null)\n\t\t\t\tbuff(FireImbue.class).proc(enemy);\n\t\t\tif (buff(EarthImbue.class) != null)\n\t\t\t\tbuff(EarthImbue.class).proc(enemy);\n\t\t\tif (buff(FrostImbue.class) != null)\n\t\t\t\tbuff(FrostImbue.class).proc(enemy);\n\n\t\t\tenemy.sprite.bloodBurstA( sprite.center(), effectiveDamage );\n\t\t\tenemy.sprite.flash();\n\n\t\t\tif (!enemy.isAlive() && visibleFight) {\n\t\t\t\tif (enemy == Dungeon.hero) {\n\t\t\t\t\t\n\t\t\t\t\tif (this == Dungeon.hero) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\tGLog.n( Messages.capitalize(Messages.get(Char.class, \"kill\", name())) );\n\t\t\t\t\t\n\t\t\t\t} else if (this == Dungeon.hero) {\n\t\t\t\t\tGLog.i( Messages.capitalize(Messages.get(Char.class, \"defeat\", enemy.name())) );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tif (visibleFight) {\n\t\t\t\tString defense = enemy.defenseVerb();\n\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL, defense );\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_MISS);\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String name(){\n\t\treturn Messages.get(this, \"name\");\n\t}",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_222_317_138_140_224_319"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\n\t\tGameScene.bossSlain();\n\t\tDungeon.level.drop( new ArmorKit(), pos ).sprite.drop();\n\t\tDungeon.level.drop( new SkeletonKey( Dungeon.depth ), pos ).sprite.drop();\n\t\t\n\t\tsuper.die( cause );\n\t\t\n\t\tBadges.validateBossSlain();\n\n\t\tLloydsBeacon beacon = Dungeon.hero.belongings.getItem(LloydsBeacon.class);\n\t\tif (beacon != null) {\n\t\t\tbeacon.upgrade();\n\t\t}\n\t\t\n\t\tyell( Messages.get(this, \"defeated\", Dungeon.hero.givenName()) );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\n\t\tGameScene.bossSlain();\n\t\tDungeon.level.drop( new ArmorKit(), pos ).sprite.drop();\n\t\tDungeon.level.drop( new SkeletonKey( Dungeon.depth ), pos ).sprite.drop();\n\t\t\n\t\tsuper.die( cause );\n\t\t\n\t\tBadges.validateBossSlain();\n\n\t\tLloydsBeacon beacon = Dungeon.hero.belongings.getItem(LloydsBeacon.class);\n\t\tif (beacon != null) {\n\t\t\tbeacon.upgrade();\n\t\t}\n\t\t\n\t\tyell( Messages.get(this, \"defeated\", Dungeon.hero.name()) );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t\t\treturn super.act();\n\t\t}",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_150_167_138_140_150_167"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void notice() {\n\t\tsuper.notice();\n\t\tif (!BossHealthBar.isAssigned()) {\n\t\t\tBossHealthBar.assignBoss(this);\n\t\t\tif (HP <= HT/2) BossHealthBar.bleed(true);\n\t\t\tif (HP == HT) {\n\t\t\t\tyell(Messages.get(this, \"notice_gotcha\", Dungeon.hero.givenName()));\n\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\tif (ch instanceof DriedRose.GhostHero){\n\t\t\t\t\t\tGLog.n(\"\\n\");\n\t\t\t\t\t\t((DriedRose.GhostHero) ch).sayBoss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyell(Messages.get(this, \"notice_have\", Dungeon.hero.givenName()));\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void notice() {\n\t\tsuper.notice();\n\t\tif (!BossHealthBar.isAssigned()) {\n\t\t\tBossHealthBar.assignBoss(this);\n\t\t\tif (HP <= HT/2) BossHealthBar.bleed(true);\n\t\t\tif (HP == HT) {\n\t\t\t\tyell(Messages.get(this, \"notice_gotcha\", Dungeon.hero.name()));\n\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\tif (ch instanceof DriedRose.GhostHero){\n\t\t\t\t\t\tGLog.n(\"\\n\");\n\t\t\t\t\t\t((DriedRose.GhostHero) ch).sayBoss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyell(Messages.get(this, \"notice_have\", Dungeon.hero.name()));\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n//phase 2 of the fight is over\n\t\tif (HP == 0 && state == NewPrisonBossLevel.State.FIGHT_ARENA) {\n\t\t\t//let full attack action complete first",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_286_304_138_140_286_304"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void notice() {\n\t\tsuper.notice();\n\t\tif (!BossHealthBar.isAssigned()) {\n\t\t\tBossHealthBar.assignBoss(this);\n\t\t\tif (HP <= HT/2) BossHealthBar.bleed(true);\n\t\t\tif (HP == HT) {\n\t\t\t\tyell(Messages.get(this, \"notice_mine\", Dungeon.hero.givenName()));\n\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\tif (ch instanceof DriedRose.GhostHero){\n\t\t\t\t\t\tGLog.n(\"\\n\");\n\t\t\t\t\t\t((DriedRose.GhostHero) ch).sayBoss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyell(Messages.get(this, \"notice_face\", Dungeon.hero.givenName()));\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void notice() {\n\t\tsuper.notice();\n\t\tif (!BossHealthBar.isAssigned()) {\n\t\t\tBossHealthBar.assignBoss(this);\n\t\t\tif (HP <= HT/2) BossHealthBar.bleed(true);\n\t\t\tif (HP == HT) {\n\t\t\t\tyell(Messages.get(this, \"notice_mine\", Dungeon.hero.name()));\n\t\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\t\tif (ch instanceof DriedRose.GhostHero){\n\t\t\t\t\t\tGLog.n(\"\\n\");\n\t\t\t\t\t\t((DriedRose.GhostHero) ch).sayBoss();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tyell(Messages.get(this, \"notice_face\", Dungeon.hero.name()));\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n//if tengu has lost a certain amount of hp, jump\n\t\t} else if (beforeHitHP / hpBracket != HP / hpBracket) {\n\t\t\tjump();",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_244_262_138_140_244_262"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean attack( Char enemy ) {\n\t\t\t\n\t\t\tif (!Dungeon.level.adjacent( pos, enemy.pos )) {\n\t\t\t\tspend( attackDelay() );\n\t\t\t\t\n\t\t\t\tif (hit( this, enemy, true )) {\n\t\t\t\t\t\n\t\t\t\t\tint dmg =  damageRoll();\n\t\t\t\t\tenemy.damage( dmg, new DarkBolt() );\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.bloodBurstA( sprite.center(), dmg );\n\t\t\t\t\tenemy.sprite.flash();\n\t\t\t\t\t\n\t\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name) );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn super.attack( enemy );\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean attack( Char enemy ) {\n\t\t\t\n\t\t\tif (!Dungeon.level.adjacent( pos, enemy.pos )) {\n\t\t\t\tspend( attackDelay() );\n\t\t\t\t\n\t\t\t\tif (hit( this, enemy, true )) {\n\t\t\t\t\t\n\t\t\t\t\tint dmg =  damageRoll();\n\t\t\t\t\tenemy.damage( dmg, new DarkBolt() );\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.bloodBurstA( sprite.center(), dmg );\n\t\t\t\t\tenemy.sprite.flash();\n\t\t\t\t\t\n\t\t\t\t\tif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\t\t\tDungeon.fail( getClass() );\n\t\t\t\t\t\tGLog.n( Messages.get(Char.class, \"kill\", name()) );\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tenemy.sprite.showStatus( CharSprite.NEUTRAL,  enemy.defenseVerb() );\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn super.attack( enemy );\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (spawnPoints.size() > 0) {\n\t\t\tLarva larva = new Larva();",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_326_354_138_140_326_354"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean interact() {\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\n\t\tif (Quest.given) {\n\t\t\tif (Quest.weapon != null) {\n\t\t\t\tif (Quest.processed) {\n\t\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tGameScene.show(new WndSadGhost(Ghost.this, Quest.type));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tswitch (Quest.type) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"rat_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"gnoll_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"crab_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tint newPos = -1;\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tnewPos = Dungeon.level.randomRespawnCell();\n\t\t\t\t\t\tif (newPos != -1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (newPos != -1) {\n\n\t\t\t\t\t\tCellEmitter.get(pos).start(Speck.factory(Speck.LIGHT), 0.2f, 3);\n\t\t\t\t\t\tpos = newPos;\n\t\t\t\t\t\tsprite.place(pos);\n\t\t\t\t\t\tsprite.visible = Dungeon.level.heroFOV[pos];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tMob questBoss;\n\t\t\tString txt_quest;\n\n\t\t\tswitch (Quest.type){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tquestBoss = new FetidRat();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"rat_1\", Dungeon.hero.givenName()); break;\n\t\t\t\tcase 2:\n\t\t\t\t\tquestBoss = new GnollTrickster();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"gnoll_1\", Dungeon.hero.givenName()); break;\n\t\t\t\tcase 3:\n\t\t\t\t\tquestBoss = new GreatCrab();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"crab_1\", Dungeon.hero.givenName()); break;\n\t\t\t}\n\n\t\t\tquestBoss.pos = Dungeon.level.randomRespawnCell();\n\n\t\t\tif (questBoss.pos != -1) {\n\t\t\t\tGameScene.add(questBoss);\n\t\t\t\tQuest.given = true;\n\t\t\t\tNotes.add( Notes.Landmark.GHOST );\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndQuest( Ghost.this, txt_quest ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean interact() {\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\n\t\tif (Quest.given) {\n\t\t\tif (Quest.weapon != null) {\n\t\t\t\tif (Quest.processed) {\n\t\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tGameScene.show(new WndSadGhost(Ghost.this, Quest.type));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tswitch (Quest.type) {\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"rat_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"gnoll_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"crab_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tint newPos = -1;\n\t\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\t\tnewPos = Dungeon.level.randomRespawnCell();\n\t\t\t\t\t\tif (newPos != -1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (newPos != -1) {\n\n\t\t\t\t\t\tCellEmitter.get(pos).start(Speck.factory(Speck.LIGHT), 0.2f, 3);\n\t\t\t\t\t\tpos = newPos;\n\t\t\t\t\t\tsprite.place(pos);\n\t\t\t\t\t\tsprite.visible = Dungeon.level.heroFOV[pos];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tMob questBoss;\n\t\t\tString txt_quest;\n\n\t\t\tswitch (Quest.type){\n\t\t\t\tcase 1: default:\n\t\t\t\t\tquestBoss = new FetidRat();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"rat_1\", Dungeon.hero.name()); break;\n\t\t\t\tcase 2:\n\t\t\t\t\tquestBoss = new GnollTrickster();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"gnoll_1\", Dungeon.hero.name()); break;\n\t\t\t\tcase 3:\n\t\t\t\t\tquestBoss = new GreatCrab();\n\t\t\t\t\ttxt_quest = Messages.get(this, \"crab_1\", Dungeon.hero.name()); break;\n\t\t\t}\n\n\t\t\tquestBoss.pos = Dungeon.level.randomRespawnCell();\n\n\t\t\tif (questBoss.pos != -1) {\n\t\t\t\tGameScene.add(questBoss);\n\t\t\t\tQuest.given = true;\n\t\t\t\tNotes.add( Notes.Landmark.GHOST );\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndQuest( Ghost.this, txt_quest ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nGameScene.show(new WndQuest(Ghost.this, Messages.get(Ghost.this, \"crab_2\")));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_110_193_138_140_110_193"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tif (!Quest.given && Dungeon.level.heroFOV[pos]) {\n\t\t\tif (!seenBefore) {\n\t\t\t\tyell( Messages.get(this, \"hey\", Dungeon.hero.givenName() ) );\n\t\t\t}\n\t\t\tseenBefore = true;\n\t\t} else {\n\t\t\tseenBefore = false;\n\t\t}\n\t\t\n\t\tthrowItem();\n\t\t\n\t\treturn super.act();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tif (!Quest.given && Dungeon.level.heroFOV[pos]) {\n\t\t\tif (!seenBefore) {\n\t\t\t\tyell( Messages.get(this, \"hey\", Dungeon.hero.name() ) );\n\t\t\t}\n\t\t\tseenBefore = true;\n\t\t} else {\n\t\t\tseenBefore = false;\n\t\t}\n\t\t\n\t\tthrowItem();\n\t\t\n\t\treturn super.act();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static class Quest {",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_56_71_138_140_56_71"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean interact() {\n\t\t\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\tif (Quest.given) {\n\t\t\t\n\t\t\tDwarfToken tokens = Dungeon.hero.belongings.getItem( DwarfToken.class );\n\t\t\tif (tokens != null && (tokens.quantity() >= 8 || (!Quest.alternative && tokens.quantity() >= 6))) {\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndImp( Imp.this, tokens ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttell( Quest.alternative ?\n\t\t\t\t\t\tMessages.get(this, \"monks_2\", Dungeon.hero.givenName())\n\t\t\t\t\t\t: Messages.get(this, \"golems_2\", Dungeon.hero.givenName()) );\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\ttell( Quest.alternative ? Messages.get(this, \"monks_1\") : Messages.get(this, \"golems_1\") );\n\t\t\tQuest.given = true;\n\t\t\tQuest.completed = false;\n\t\t\t\n\t\t\tNotes.add( Notes.Landmark.IMP );\n\t\t}\n\n\t\treturn false;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean interact() {\n\t\t\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\tif (Quest.given) {\n\t\t\t\n\t\t\tDwarfToken tokens = Dungeon.hero.belongings.getItem( DwarfToken.class );\n\t\t\tif (tokens != null && (tokens.quantity() >= 8 || (!Quest.alternative && tokens.quantity() >= 6))) {\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndImp( Imp.this, tokens ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttell( Quest.alternative ?\n\t\t\t\t\t\tMessages.get(this, \"monks_2\", Dungeon.hero.name())\n\t\t\t\t\t\t: Messages.get(this, \"golems_2\", Dungeon.hero.name()) );\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\ttell( Quest.alternative ? Messages.get(this, \"monks_1\") : Messages.get(this, \"golems_1\") );\n\t\t\tQuest.given = true;\n\t\t\tQuest.completed = false;\n\t\t\t\n\t\t\tNotes.add( Notes.Landmark.IMP );\n\t\t}\n\n\t\treturn false;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static class Quest {",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_91_120_138_140_91_120"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void flee() {\n\t\t\n\t\tyell( Messages.get(this, \"cya\", Dungeon.hero.givenName()) );\n\t\t\n\t\tdestroy();\n\t\tsprite.die();\n\t}",
          "sourceCodeAfterRefactoring": "public void flee() {\n\t\t\n\t\tyell( Messages.get(this, \"cya\", Dungeon.hero.name()) );\n\t\t\n\t\tdestroy();\n\t\tsprite.die();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static class Quest {",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_131_137_138_140_131_137"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\n\t\tif (!seenBefore && Dungeon.level.heroFOV[pos]) {\n\t\t\tyell( Messages.get(this, \"greetings\", Dungeon.hero.givenName() ) );\n\t\t\tseenBefore = true;\n\t\t}\n\t\t\n\t\treturn super.act();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\n\t\tif (!seenBefore && Dungeon.level.heroFOV[pos]) {\n\t\t\tyell( Messages.get(this, \"greetings\", Dungeon.hero.name() ) );\n\t\t\tseenBefore = true;\n\t\t}\n\t\t\n\t\treturn super.act();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_40_49_138_140_40_49"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean interact() {\n\t\t\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\tif (Quest.given) {\n\t\t\t\n\t\t\tItem item;\n\t\t\tswitch (Quest.type) {\n\t\t\t\tcase 1:\n\t\t\t\tdefault:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(CorpseDust.class);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(Embers.class);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(Rotberry.Seed.class);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (item != null) {\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndWandmaker( Wandmaker.this, item ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tString msg;\n\t\t\t\tswitch(Quest.type){\n\t\t\t\t\tcase 1: default:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_dust\", Dungeon.hero.givenName());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_ember\", Dungeon.hero.givenName());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_berry\", Dungeon.hero.givenName());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t} else {\n\n\t\t\tString msg1 = \"\";\n\t\t\tString msg2 = \"\";\n\t\t\tswitch(Dungeon.hero.heroClass){\n\t\t\t\tcase WARRIOR:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_warrior\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase ROGUE:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_rogue\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase MAGE:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_mage\", Dungeon.hero.givenName());\n\t\t\t\t\tbreak;\n\t\t\t\tcase HUNTRESS:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_huntress\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsg1 += Messages.get(this, \"intro_1\");\n\n\t\t\tswitch (Quest.type){\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_dust\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_ember\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_berry\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsg2 += Messages.get(this, \"intro_2\");\n\t\t\tfinal String msg1Final = msg1;\n\t\t\tfinal String msg2Final = msg2;\n\t\t\t\n\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg1Final){\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void hide() {\n\t\t\t\t\t\t\tsuper.hide();\n\t\t\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg2Final));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tNotes.add( Notes.Landmark.WANDMAKER );\n\t\t\tQuest.given = true;\n\t\t}\n\n\t\treturn false;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean interact() {\n\t\t\n\t\tsprite.turnTo( pos, Dungeon.hero.pos );\n\t\tif (Quest.given) {\n\t\t\t\n\t\t\tItem item;\n\t\t\tswitch (Quest.type) {\n\t\t\t\tcase 1:\n\t\t\t\tdefault:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(CorpseDust.class);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(Embers.class);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\titem = Dungeon.hero.belongings.getItem(Rotberry.Seed.class);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (item != null) {\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show( new WndWandmaker( Wandmaker.this, item ) );\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tString msg;\n\t\t\t\tswitch(Quest.type){\n\t\t\t\t\tcase 1: default:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_dust\", Dungeon.hero.name());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_ember\", Dungeon.hero.name());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tmsg = Messages.get(this, \"reminder_berry\", Dungeon.hero.name());\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t} else {\n\n\t\t\tString msg1 = \"\";\n\t\t\tString msg2 = \"\";\n\t\t\tswitch(Dungeon.hero.heroClass){\n\t\t\t\tcase WARRIOR:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_warrior\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase ROGUE:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_rogue\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase MAGE:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_mage\", Dungeon.hero.name());\n\t\t\t\t\tbreak;\n\t\t\t\tcase HUNTRESS:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_huntress\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsg1 += Messages.get(this, \"intro_1\");\n\n\t\t\tswitch (Quest.type){\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_dust\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_ember\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tmsg2 += Messages.get(this, \"intro_berry\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmsg2 += Messages.get(this, \"intro_2\");\n\t\t\tfinal String msg1Final = msg1;\n\t\t\tfinal String msg2Final = msg2;\n\t\t\t\n\t\t\tGame.runOnRenderThread(new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg1Final){\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void hide() {\n\t\t\t\t\t\t\tsuper.hide();\n\t\t\t\t\t\t\tGameScene.show(new WndQuest(Wandmaker.this, msg2Final));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tNotes.add( Notes.Landmark.WANDMAKER );\n\t\t\tQuest.given = true;\n\t\t}\n\n\t\treturn false;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\ncase WARRIOR:\n\t\t\t\t\tmsg1 += Messages.get(this, \"intro_warrior\");\n\t\t\t\t\tbreak;",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_85_188_138_140_85_188"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (action.equals(AC_SUMMON)) {\n\n\t\t\tif (!Ghost.Quest.completed())   GameScene.show(new WndItem(null, this, true));\n\t\t\telse if (ghost != null)         GLog.i( Messages.get(this, \"spawned\") );\n\t\t\telse if (!isEquipped( hero ))   GLog.i( Messages.get(Artifact.class, \"need_to_equip\") );\n\t\t\telse if (charge != chargeCap)   GLog.i( Messages.get(this, \"no_charge\") );\n\t\t\telse if (cursed)                GLog.i( Messages.get(this, \"cursed\") );\n\t\t\telse {\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<>();\n\t\t\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tghost = new GhostHero( this );\n\t\t\t\t\tghostID = ghost.id();\n\t\t\t\t\tghost.pos = Random.element(spawnPoints);\n\n\t\t\t\t\tGameScene.add(ghost, 1f);\n\t\t\t\t\tDungeon.level.occupyCell(ghost);\n\t\t\t\t\t\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( ShaftParticle.FACTORY, 0.3f, 4 );\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( Speck.factory(Speck.LIGHT), 0.2f, 3 );\n\n\t\t\t\t\thero.spend(1f);\n\t\t\t\t\thero.busy();\n\t\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\t\tif (!firstSummon) {\n\t\t\t\t\t\tghost.yell( Messages.get(GhostHero.class, \"hello\", Dungeon.hero.givenName()) );\n\t\t\t\t\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\t\t\t\tfirstSummon = true;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (BossHealthBar.isAssigned()) {\n\t\t\t\t\t\t\tghost.sayBoss();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tghost.sayAppeared();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tupdateQuickslot();\n\n\t\t\t\t} else\n\t\t\t\t\tGLog.i( Messages.get(this, \"no_space\") );\n\t\t\t}\n\n\t\t} else if (action.equals(AC_DIRECT)){\n\t\t\tif (ghost == null && ghostID != 0){\n\t\t\t\tActor a = Actor.findById(ghostID);\n\t\t\t\tif (a != null){\n\t\t\t\t\tghost = (GhostHero)a;\n\t\t\t\t} else {\n\t\t\t\t\tghostID = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ghost != null) GameScene.selectCell(ghostDirector);\n\t\t\t\n\t\t} else if (action.equals(AC_OUTFIT)){\n\t\t\tGameScene.show( new WndGhostHero(this) );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (action.equals(AC_SUMMON)) {\n\n\t\t\tif (!Ghost.Quest.completed())   GameScene.show(new WndItem(null, this, true));\n\t\t\telse if (ghost != null)         GLog.i( Messages.get(this, \"spawned\") );\n\t\t\telse if (!isEquipped( hero ))   GLog.i( Messages.get(Artifact.class, \"need_to_equip\") );\n\t\t\telse if (charge != chargeCap)   GLog.i( Messages.get(this, \"no_charge\") );\n\t\t\telse if (cursed)                GLog.i( Messages.get(this, \"cursed\") );\n\t\t\telse {\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<>();\n\t\t\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tghost = new GhostHero( this );\n\t\t\t\t\tghostID = ghost.id();\n\t\t\t\t\tghost.pos = Random.element(spawnPoints);\n\n\t\t\t\t\tGameScene.add(ghost, 1f);\n\t\t\t\t\tDungeon.level.occupyCell(ghost);\n\t\t\t\t\t\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( ShaftParticle.FACTORY, 0.3f, 4 );\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( Speck.factory(Speck.LIGHT), 0.2f, 3 );\n\n\t\t\t\t\thero.spend(1f);\n\t\t\t\t\thero.busy();\n\t\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\t\tif (!firstSummon) {\n\t\t\t\t\t\tghost.yell( Messages.get(GhostHero.class, \"hello\", Dungeon.hero.name()) );\n\t\t\t\t\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\t\t\t\tfirstSummon = true;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (BossHealthBar.isAssigned()) {\n\t\t\t\t\t\t\tghost.sayBoss();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tghost.sayAppeared();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tpartialCharge = 0;\n\t\t\t\t\tupdateQuickslot();\n\n\t\t\t\t} else\n\t\t\t\t\tGLog.i( Messages.get(this, \"no_space\") );\n\t\t\t}\n\n\t\t} else if (action.equals(AC_DIRECT)){\n\t\t\tif (ghost == null && ghostID != 0){\n\t\t\t\tActor a = Actor.findById(ghostID);\n\t\t\t\tif (a != null){\n\t\t\t\t\tghost = (GhostHero)a;\n\t\t\t\t} else {\n\t\t\t\t\tghostID = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ghost != null) GameScene.selectCell(ghostDirector);\n\t\t\t\n\t\t} else if (action.equals(AC_OUTFIT)){\n\t\t\tGameScene.show( new WndGhostHero(this) );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Dungeon.level.passable[p] || Dungeon.level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);",
          "uniqueId": "8bcb1e46306e3ba9769414390a26d9ba528fb0b5_123_194_138_140_123_194"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "59824f1556407592e457ba8fdc3aa4d1acfd5c66",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/59824f1556407592e457ba8fdc3aa4d1acfd5c66",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public final int DRMax(){\n\t\treturn DRMax(level());\n\t}",
          "sourceCodeAfterRefactoring": "public final int DRMax(){\n\t\treturn DRMax(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic int buffedLvl() {\n\t\tif (isEquipped( Dungeon.hero ) || Dungeon.hero.belongings.contains( this )){\n\t\t\treturn super.buffedLvl();\n\t\t} else {\n\t\t\treturn level();\n\t\t}\n\t}",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_267_269_357_364_267_269"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public final int DRMin(){\n\t\treturn DRMin(level());\n\t}",
          "sourceCodeAfterRefactoring": "public final int DRMin(){\n\t\treturn DRMin(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic int buffedLvl() {\n\t\tif (isEquipped( Dungeon.hero ) || Dungeon.hero.belongings.contains( this )){\n\t\t\treturn super.buffedLvl();\n\t\t} else {\n\t\t\treturn level();\n\t\t}\n\t}",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_280_282_357_364_280_282"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public float evasionFactor( Char owner, float evasion ){\n\t\t\n\t\tif (hasGlyph(Stone.class, owner) && !((Stone)glyph).testingEvasion()){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (owner instanceof Hero){\n\t\t\tint aEnc = STRReq() - ((Hero) owner).STR();\n\t\t\tif (aEnc > 0) evasion /= Math.pow(1.5, aEnc);\n\t\t\t\n\t\t\tMomentum momentum = owner.buff(Momentum.class);\n\t\t\tif (momentum != null){\n\t\t\t\tevasion += momentum.evasionBonus(Math.max(0, -aEnc));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn evasion + augment.evasionFactor(level());\n\t}",
          "sourceCodeAfterRefactoring": "public float evasionFactor( Char owner, float evasion ){\n\t\t\n\t\tif (hasGlyph(Stone.class, owner) && !((Stone)glyph).testingEvasion()){\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (owner instanceof Hero){\n\t\t\tint aEnc = STRReq() - ((Hero) owner).STR();\n\t\t\tif (aEnc > 0) evasion /= Math.pow(1.5, aEnc);\n\t\t\t\n\t\t\tMomentum momentum = owner.buff(Momentum.class);\n\t\t\tif (momentum != null){\n\t\t\t\tevasion += momentum.evasionBonus(Math.max(0, -aEnc));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn evasion + augment.evasionFactor(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic int buffedLvl() {\n\t\tif (isEquipped( Dungeon.hero ) || Dungeon.hero.belongings.contains( this )){\n\t\t\treturn super.buffedLvl();\n\t\t} else {\n\t\t\treturn level();\n\t\t}\n\t}",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_293_310_357_364_293_310"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap( Ballistica beam ) {\n\t\t\n\t\tboolean terrainAffected = false;\n\t\t\n\t\tint level = level();\n\t\t\n\t\tint maxDistance = Math.min(distance(), beam.dist);\n\t\t\n\t\tArrayList<Char> chars = new ArrayList<>();\n\n\t\tint terrainPassed = 2, terrainBonus = 0;\n\t\tfor (int c : beam.subPath(1, maxDistance)) {\n\t\t\t\n\t\t\tChar ch;\n\t\t\tif ((ch = Actor.findChar( c )) != null) {\n\n\t\t\t\t//we don't want to count passed terrain after the last enemy hit. That would be a lot of bonus levels.\n\t\t\t\t//terrainPassed starts at 2, equivalent of rounding up when /3 for integer arithmetic.\n\t\t\t\tterrainBonus += terrainPassed/3;\n\t\t\t\tterrainPassed = terrainPassed%3;\n\n\t\t\t\tchars.add( ch );\n\t\t\t}\n\n\t\t\tif (Dungeon.level.flamable[c]) {\n\n\t\t\t\tDungeon.level.destroy( c );\n\t\t\t\tGameScene.updateMap( c );\n\t\t\t\tterrainAffected = true;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (Dungeon.level.solid[c])\n\t\t\t\tterrainPassed++;\n\t\t\t\n\t\t\tCellEmitter.center( c ).burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t}\n\t\t\n\t\tif (terrainAffected) {\n\t\t\tDungeon.observe();\n\t\t}\n\t\t\n\t\tint lvl = level + (chars.size()-1) + terrainBonus;\n\t\tfor (Char ch : chars) {\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage( damageRoll(lvl), this );\n\t\t\tch.sprite.centerEmitter().burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t\tch.sprite.flash();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap( Ballistica beam ) {\n\t\t\n\t\tboolean terrainAffected = false;\n\t\t\n\t\tint level = buffedLvl();\n\t\t\n\t\tint maxDistance = Math.min(distance(), beam.dist);\n\t\t\n\t\tArrayList<Char> chars = new ArrayList<>();\n\n\t\tint terrainPassed = 2, terrainBonus = 0;\n\t\tfor (int c : beam.subPath(1, maxDistance)) {\n\t\t\t\n\t\t\tChar ch;\n\t\t\tif ((ch = Actor.findChar( c )) != null) {\n\n\t\t\t\t//we don't want to count passed terrain after the last enemy hit. That would be a lot of bonus levels.\n\t\t\t\t//terrainPassed starts at 2, equivalent of rounding up when /3 for integer arithmetic.\n\t\t\t\tterrainBonus += terrainPassed/3;\n\t\t\t\tterrainPassed = terrainPassed%3;\n\n\t\t\t\tchars.add( ch );\n\t\t\t}\n\n\t\t\tif (Dungeon.level.flamable[c]) {\n\n\t\t\t\tDungeon.level.destroy( c );\n\t\t\t\tGameScene.updateMap( c );\n\t\t\t\tterrainAffected = true;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tif (Dungeon.level.solid[c])\n\t\t\t\tterrainPassed++;\n\t\t\t\n\t\t\tCellEmitter.center( c ).burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t}\n\t\t\n\t\tif (terrainAffected) {\n\t\t\tDungeon.observe();\n\t\t}\n\t\t\n\t\tint lvl = level + (chars.size()-1) + terrainBonus;\n\t\tfor (Char ch : chars) {\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\tch.damage( damageRoll(lvl), this );\n\t\t\tch.sprite.centerEmitter().burst( PurpleParticle.BURST, Random.IntRange( 1, 2 ) );\n\t\t\tch.sprite.flash();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_57_107_300_306_57_107"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tint damage = damageRoll();\n\t\tint armorToAdd = damage;\n\n\t\tEarthGuardian guardian = null;\n\t\tfor (Mob m : Dungeon.level.mobs){\n\t\t\tif (m instanceof EarthGuardian){\n\t\t\t\tguardian = (EarthGuardian) m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRockArmor buff = curUser.buff(RockArmor.class);\n\t\tif (ch == null){\n\t\t\tarmorToAdd = 0;\n\t\t} else {\n\t\t\tif (buff == null && guardian == null) {\n\t\t\t\tbuff = Buff.affect(curUser, RockArmor.class);\n\t\t\t}\n\t\t\tif (buff != null) {\n\t\t\t\tbuff.addArmor(level(), armorToAdd);\n\t\t\t}\n\t\t}\n\n\t\t//shooting at the guardian\n\t\tif (guardian != null && guardian == ch){\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level() / 2);\n\t\t\tguardian.setInfo(curUser, level(), armorToAdd);\n\t\t\tprocessSoulMark(guardian, chargesPerCast());\n\n\t\t//shooting the guardian at a location\n\t\t} else if ( guardian == null && buff != null && buff.armor >= buff.armorToGuardian()){\n\n\t\t\t//create a new guardian\n\t\t\tguardian = new EarthGuardian();\n\t\t\tguardian.setInfo(curUser, level(), buff.armor);\n\n\t\t\t//if the collision pos is occupied (likely will be), then spawn the guardian in the\n\t\t\t//adjacent cell which is closes to the user of the wand.\n\t\t\tif (ch != null){\n\n\t\t\t\tch.sprite.centerEmitter().burst(MagicMissile.EarthParticle.BURST, 5 + level()/2);\n\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tch.damage(damage, this);\n\n\t\t\t\tint closest = -1;\n\t\t\t\tboolean[] passable = Dungeon.level.passable;\n\n\t\t\t\tfor (int n : PathFinder.NEIGHBOURS9) {\n\t\t\t\t\tint c = bolt.collisionPos + n;\n\t\t\t\t\tif (passable[c] && Actor.findChar( c ) == null\n\t\t\t\t\t\t&& (closest == -1 || (Dungeon.level.trueDistance(c, curUser.pos) < (Dungeon.level.trueDistance(closest, curUser.pos))))) {\n\t\t\t\t\t\tclosest = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (closest == -1){\n\t\t\t\t\tcurUser.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level()/2);\n\t\t\t\t\treturn; //do not spawn guardian or detach buff\n\t\t\t\t} else {\n\t\t\t\t\tguardian.pos = closest;\n\t\t\t\t\tGameScene.add(guardian, 1);\n\t\t\t\t\tDungeon.level.occupyCell(guardian);\n\t\t\t\t}\n\n\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY || ch.buff(Amok.class) != null) {\n\t\t\t\t\tguardian.aggro(ch);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tguardian.pos = bolt.collisionPos;\n\t\t\t\tGameScene.add(guardian, 1);\n\t\t\t\tDungeon.level.occupyCell(guardian);\n\t\t\t}\n\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level()/2);\n\t\t\tbuff.detach();\n\n\t\t//shooting at a location/enemy with no guardian being shot\n\t\t} else {\n\n\t\t\tif (ch != null) {\n\n\t\t\t\tch.sprite.centerEmitter().burst(MagicMissile.EarthParticle.BURST, 5 + level() / 2);\n\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tch.damage(damage, this);\n\t\t\t\t\n\t\t\t\tif (guardian == null) {\n\t\t\t\t\tcurUser.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level() / 2);\n\t\t\t\t} else {\n\t\t\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level() / 2);\n\t\t\t\t\tguardian.setInfo(curUser, level(), armorToAdd);\n\t\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY || ch.buff(Amok.class) != null) {\n\t\t\t\t\t\tguardian.aggro(ch);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t}\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tint damage = damageRoll();\n\t\tint armorToAdd = damage;\n\n\t\tEarthGuardian guardian = null;\n\t\tfor (Mob m : Dungeon.level.mobs){\n\t\t\tif (m instanceof EarthGuardian){\n\t\t\t\tguardian = (EarthGuardian) m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tRockArmor buff = curUser.buff(RockArmor.class);\n\t\tif (ch == null){\n\t\t\tarmorToAdd = 0;\n\t\t} else {\n\t\t\tif (buff == null && guardian == null) {\n\t\t\t\tbuff = Buff.affect(curUser, RockArmor.class);\n\t\t\t}\n\t\t\tif (buff != null) {\n\t\t\t\tbuff.addArmor( buffedLvl(), armorToAdd);\n\t\t\t}\n\t\t}\n\n\t\t//shooting at the guardian\n\t\tif (guardian != null && guardian == ch){\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl() / 2);\n\t\t\tguardian.setInfo(curUser, buffedLvl(), armorToAdd);\n\t\t\tprocessSoulMark(guardian, chargesPerCast());\n\n\t\t//shooting the guardian at a location\n\t\t} else if ( guardian == null && buff != null && buff.armor >= buff.armorToGuardian()){\n\n\t\t\t//create a new guardian\n\t\t\tguardian = new EarthGuardian();\n\t\t\tguardian.setInfo(curUser, buffedLvl(), buff.armor);\n\n\t\t\t//if the collision pos is occupied (likely will be), then spawn the guardian in the\n\t\t\t//adjacent cell which is closes to the user of the wand.\n\t\t\tif (ch != null){\n\n\t\t\t\tch.sprite.centerEmitter().burst(MagicMissile.EarthParticle.BURST, 5 + buffedLvl()/2);\n\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tch.damage(damage, this);\n\n\t\t\t\tint closest = -1;\n\t\t\t\tboolean[] passable = Dungeon.level.passable;\n\n\t\t\t\tfor (int n : PathFinder.NEIGHBOURS9) {\n\t\t\t\t\tint c = bolt.collisionPos + n;\n\t\t\t\t\tif (passable[c] && Actor.findChar( c ) == null\n\t\t\t\t\t\t&& (closest == -1 || (Dungeon.level.trueDistance(c, curUser.pos) < (Dungeon.level.trueDistance(closest, curUser.pos))))) {\n\t\t\t\t\t\tclosest = c;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (closest == -1){\n\t\t\t\t\tcurUser.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl()/2);\n\t\t\t\t\treturn; //do not spawn guardian or detach buff\n\t\t\t\t} else {\n\t\t\t\t\tguardian.pos = closest;\n\t\t\t\t\tGameScene.add(guardian, 1);\n\t\t\t\t\tDungeon.level.occupyCell(guardian);\n\t\t\t\t}\n\n\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY || ch.buff(Amok.class) != null) {\n\t\t\t\t\tguardian.aggro(ch);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tguardian.pos = bolt.collisionPos;\n\t\t\t\tGameScene.add(guardian, 1);\n\t\t\t\tDungeon.level.occupyCell(guardian);\n\t\t\t}\n\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl()/2);\n\t\t\tbuff.detach();\n\n\t\t//shooting at a location/enemy with no guardian being shot\n\t\t} else {\n\n\t\t\tif (ch != null) {\n\n\t\t\t\tch.sprite.centerEmitter().burst(MagicMissile.EarthParticle.BURST, 5 + buffedLvl() / 2);\n\n\t\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t\t\tch.damage(damage, this);\n\t\t\t\t\n\t\t\t\tif (guardian == null) {\n\t\t\t\t\tcurUser.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl() / 2);\n\t\t\t\t} else {\n\t\t\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl() / 2);\n\t\t\t\t\tguardian.setInfo(curUser, buffedLvl(), armorToAdd);\n\t\t\t\t\tif (ch.alignment == Char.Alignment.ENEMY || ch.buff(Amok.class) != null) {\n\t\t\t\t\t\tguardian.aggro(ch);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t}\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (wandLevel > this.wandLevel) {\n\t\t\t\tthis.wandLevel = wandLevel;\n\t\t\t\tHT = 16 + 8 * wandLevel;\n\t\t\t}\n\t\t\tHP = Math.min(HT, HP + healthToAdd);\n\t\t\t//half of hero's evasion\n\t\t\tdefenseSkill = (hero.lvl + 4)/2;",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_66_172_300_306_66_172"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onHit(MagesStaff staff, Char attacker, Char defender, int damage) {\n\t\tEarthGuardian guardian = null;\n\t\tfor (Mob m : Dungeon.level.mobs){\n\t\t\tif (m instanceof EarthGuardian){\n\t\t\t\tguardian = (EarthGuardian) m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint armor = Math.round(damage*0.25f);\n\n\t\tif (guardian != null){\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level() / 2);\n\t\t\tguardian.setInfo(Dungeon.hero, level(), armor);\n\t\t} else {\n\t\t\tattacker.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + level() / 2);\n\t\t\tBuff.affect(attacker, RockArmor.class).addArmor(level(), armor);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onHit(MagesStaff staff, Char attacker, Char defender, int damage) {\n\t\tEarthGuardian guardian = null;\n\t\tfor (Mob m : Dungeon.level.mobs){\n\t\t\tif (m instanceof EarthGuardian){\n\t\t\t\tguardian = (EarthGuardian) m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint armor = Math.round(damage*0.25f);\n\n\t\tif (guardian != null){\n\t\t\tguardian.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl() / 2);\n\t\t\tguardian.setInfo(Dungeon.hero, buffedLvl(), armor);\n\t\t} else {\n\t\t\tattacker.sprite.centerEmitter().burst(MagicMissile.EarthParticle.ATTRACT, 8 + buffedLvl() / 2);\n\t\t\tBuff.affect(attacker, RockArmor.class).addArmor( buffedLvl(), armor);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (wandLevel > this.wandLevel) {\n\t\t\t\tthis.wandLevel = wandLevel;\n\t\t\t\tHT = 16 + 8 * wandLevel;\n\t\t\t}\n\t\t\tHP = Math.min(HT, HP + healthToAdd);\n\t\t\t//half of hero's evasion\n\t\t\tdefenseSkill = (hero.lvl + 4)/2;",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_184_203_300_306_184_203"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\t\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (!curUser.fieldOfView[bolt.collisionPos] || !Dungeon.level.passable[bolt.collisionPos]){\n\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t\n\t\t} else if (ch != null){\n\t\t\tif (ch instanceof Ward){\n\t\t\t\tif (wardAvailable) {\n\t\t\t\t\t((Ward) ch).upgrade(level());\n\t\t\t\t} else {\n\t\t\t\t\t((Ward) ch).wandHeal( level() );\n\t\t\t\t}\n\t\t\t\tch.sprite.emitter().burst(MagicMissile.WardParticle.UP, ((Ward) ch).tier);\n\t\t\t} else {\n\t\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t}\n\t\t\t\n\t\t} else if (canPlaceWard(bolt.collisionPos)){\n\t\t\tWard ward = new Ward();\n\t\t\tward.pos = bolt.collisionPos;\n\t\t\tward.wandLevel = level();\n\t\t\tGameScene.add(ward, 1f);\n\t\t\tDungeon.level.occupyCell(ward);\n\t\t\tward.sprite.emitter().burst(MagicMissile.WardParticle.UP, ward.tier);\n\t\t\t\n\t\t} else {\n\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\t\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\t\tif (!curUser.fieldOfView[bolt.collisionPos] || !Dungeon.level.passable[bolt.collisionPos]){\n\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t\n\t\t} else if (ch != null){\n\t\t\tif (ch instanceof Ward){\n\t\t\t\tif (wardAvailable) {\n\t\t\t\t\t((Ward) ch).upgrade( buffedLvl() );\n\t\t\t\t} else {\n\t\t\t\t\t((Ward) ch).wandHeal( buffedLvl() );\n\t\t\t\t}\n\t\t\t\tch.sprite.emitter().burst(MagicMissile.WardParticle.UP, ((Ward) ch).tier);\n\t\t\t} else {\n\t\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t\t}\n\t\t\t\n\t\t} else if (canPlaceWard(bolt.collisionPos)){\n\t\t\tWard ward = new Ward();\n\t\t\tward.pos = bolt.collisionPos;\n\t\t\tward.wandLevel = buffedLvl();\n\t\t\tGameScene.add(ward, 1f);\n\t\t\tDungeon.level.occupyCell(ward);\n\t\t\tward.sprite.emitter().burst(MagicMissile.WardParticle.UP, ward.tier);\n\t\t\t\n\t\t} else {\n\t\t\tGLog.w( Messages.get(this, \"bad_location\"));\n\t\t\tDungeon.level.pressCell(bolt.collisionPos);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (!enemy.isAlive() && enemy == Dungeon.hero) {\n\t\t\t\tDungeon.fail( getClass() );\n\t\t\t}\n\n\t\t\ttotalZaps++;\n\t\t\tswitch(tier){",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_76_109_300_306_76_109"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int min(){\n\t\treturn min(level());\n\t}",
          "sourceCodeAfterRefactoring": "public int min(){\n\t\treturn min(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 0;\n\t}",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_85_87_125_129_85_87"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int max(){\n\t\treturn max(level());\n\t}",
          "sourceCodeAfterRefactoring": "public int max(){\n\t\treturn max(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\n\tpublic int defenseFactor( Char owner ) {\n\t\treturn 0;\n\t}",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_89_91_125_129_89_91"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int min(){\n\t\treturn min(level());\n\t}",
          "sourceCodeAfterRefactoring": "public int min(){\n\t\treturn min(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_85_87_201_205_85_87"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int max(){\n\t\treturn max(level());\n\t}",
          "sourceCodeAfterRefactoring": "public int max(){\n\t\treturn max(buffedLvl());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_89_91_201_205_89_91"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public String statsInfo(){\n\t\tif (isIdentified()){\n\t\t\treturn Messages.get(this, \"stats_desc\", 10+3*level());\n\t\t} else {\n\t\t\treturn Messages.get(this, \"typical_stats_desc\", 10);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public String statsInfo(){\n\t\tif (isIdentified()){\n\t\t\treturn Messages.get(this, \"stats_desc\", 10+3*buffedLvl());\n\t\t} else {\n\t\t\treturn Messages.get(this, \"typical_stats_desc\", 10);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_47_53_201_205_47_53"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public String statsInfo(){\n\t\tif (isIdentified()){\n\t\t\treturn Messages.get(this, \"stats_desc\", 5+2*level());\n\t\t} else {\n\t\t\treturn Messages.get(this, \"typical_stats_desc\", 5);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public String statsInfo(){\n\t\tif (isIdentified()){\n\t\t\treturn Messages.get(this, \"stats_desc\", 5+2*buffedLvl());\n\t\t} else {\n\t\t\treturn Messages.get(this, \"typical_stats_desc\", 5);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_47_53_201_205_47_53"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int min() {\n\t\treturn Math.max(0, min( level() + RingOfSharpshooting.levelDamageBonus(Dungeon.hero) ));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int min() {\n\t\treturn Math.max(0, min( buffedLvl() + RingOfSharpshooting.levelDamageBonus(Dungeon.hero) ));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\ndecrementDurability();\n\t\tif (durability > 0){\n\t\t\t//attempt to stick the missile weapon to the enemy, just drop it if we can't.\n\t\t\tif (sticky && enemy != null && enemy.isAlive() && enemy.buff(Corruption.class) == null){\n\t\t\t\tPinCushion p = Buff.affect(enemy, PinCushion.class);",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_70_73_201_205_70_73"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic int max() {\n\t\treturn Math.max(0, max( level() + RingOfSharpshooting.levelDamageBonus(Dungeon.hero) ));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int max() {\n\t\treturn Math.max(0, max( buffedLvl() + RingOfSharpshooting.levelDamageBonus(Dungeon.hero) ));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\ndecrementDurability();\n\t\tif (durability > 0){\n\t\t\t//attempt to stick the missile weapon to the enemy, just drop it if we can't.\n\t\t\tif (sticky && enemy != null && enemy.isAlive() && enemy.buff(Corruption.class) == null){\n\t\t\t\tPinCushion p = Buff.affect(enemy, PinCushion.class);",
          "uniqueId": "59824f1556407592e457ba8fdc3aa4d1acfd5c66_81_84_201_205_81_84"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b26919e38195b0a98bcc8d4644e1ee1de279e569",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b26919e38195b0a98bcc8d4644e1ee1de279e569",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\t\t\tif (enemyInFOV && (justAlerted || Random.Float( distance( enemy ) / 2f + enemy.stealth() ) < 1)) {\n\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\talerted = true;\n\t\t\t\tstate = HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\n\t\t\t\tif (Dungeon.isChallenged( Challenges.SWARM_INTELLIGENCE )) {\n\t\t\t\t\tfor (Mob mob : Dungeon.level.mobs) {\n\t\t\t\t\t\tif (Dungeon.level.distance(pos, mob.pos) <= 8 && mob.state != mob.HUNTING) {\n\t\t\t\t\t\t\tmob.beckon( target );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemySeen = false;\n\n\t\t\t\tint oldPos = pos;\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\t\t\tif (enemyInFOV && (justAlerted || Random.Float( distance( enemy ) / 2f + enemy.stealth() ) < 1)) {\n\n\t\t\t\treturn noticeEnemy();\n\n\t\t\t} else {\n\n\t\t\t\treturn continueWandering();\n\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected boolean noticeEnemy(){\n\t\t\tenemySeen = true;\n\t\t\t\n\t\t\tnotice();\n\t\t\talerted = true;\n\t\t\tstate = HUNTING;\n\t\t\ttarget = enemy.pos;\n\t\t\t\n\t\t\tif (Dungeon.isChallenged( Challenges.SWARM_INTELLIGENCE )) {\n\t\t\t\tfor (Mob mob : Dungeon.level.mobs) {\n\t\t\t\t\tif (Dungeon.level.distance(pos, mob.pos) <= 8 && mob.state != mob.HUNTING) {\n\t\t\t\t\t\tmob.beckon( target );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}",
          "uniqueId": "b26919e38195b0a98bcc8d4644e1ee1de279e569_749_783_762_779_749_760"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\t\t\tif (enemyInFOV && (justAlerted || Random.Float( distance( enemy ) / 2f + enemy.stealth() ) < 1)) {\n\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\talerted = true;\n\t\t\t\tstate = HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\n\t\t\t\tif (Dungeon.isChallenged( Challenges.SWARM_INTELLIGENCE )) {\n\t\t\t\t\tfor (Mob mob : Dungeon.level.mobs) {\n\t\t\t\t\t\tif (Dungeon.level.distance(pos, mob.pos) <= 8 && mob.state != mob.HUNTING) {\n\t\t\t\t\t\t\tmob.beckon( target );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tenemySeen = false;\n\n\t\t\t\tint oldPos = pos;\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\n\t\t\t}\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act( boolean enemyInFOV, boolean justAlerted ) {\n\t\t\tif (enemyInFOV && (justAlerted || Random.Float( distance( enemy ) / 2f + enemy.stealth() ) < 1)) {\n\n\t\t\t\treturn noticeEnemy();\n\n\t\t\t} else {\n\n\t\t\t\treturn continueWandering();\n\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected boolean continueWandering(){\n\t\t\tenemySeen = false;\n\t\t\t\n\t\t\tint oldPos = pos;\n\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t} else {\n\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\tspend( TICK );\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}",
          "uniqueId": "b26919e38195b0a98bcc8d4644e1ee1de279e569_749_783_781_794_749_760"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f038bde5cc5020a5e34040dd466eaec11d2691ba",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f038bde5cc5020a5e34040dd466eaec11d2691ba",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void dispose() {\n\t\tif (scene != null) {\n\t\t\tscene.destroy();\n\t\t\tscene = null;\n\t\t}\n\t\t\n\t\tsceneClass = null;\n\t\tMusic.INSTANCE.stop();\n\t\tSample.INSTANCE.reset();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void dispose() {\n\t\tdestroy();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void destroy(){\n\t\tif (scene != null) {\n\t\t\tscene.destroy();\n\t\t\tscene = null;\n\t\t}\n\t\t\n\t\tsceneClass = null;\n\t\tMusic.INSTANCE.stop();\n\t\tSample.INSTANCE.reset();\n\t}",
          "uniqueId": "f038bde5cc5020a5e34040dd466eaec11d2691ba_163_173_164_173_175_178"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "addb99163148df3da3e508194bb89ecd72515128",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/addb99163148df3da3e508194bb89ecd72515128",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean fileExists( String name ){\n\t\tFileHandle file = Gdx.files.local(name);\n\t\treturn file.exists() && !file.isDirectory();\n\t}",
          "sourceCodeAfterRefactoring": "public static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_37_40_54_69_54_69"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean fileExists( String name ){\n\t\tFileHandle file = Gdx.files.local(name);\n\t\treturn file.exists() && !file.isDirectory();\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean fileExists( String name ){\n\t\tFileHandle file = getFileHandle( name );\n\t\treturn file.exists() && !file.isDirectory();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( String name ){\n\t\treturn getFileHandle( defaultFileType, defaultPath, name );\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_37_40_46_48_73_76"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean dirExists( String name ){\n\t\tFileHandle dir = Gdx.files.local( name );\n\t\treturn dir.exists() && dir.isDirectory();\n\t}",
          "sourceCodeAfterRefactoring": "public static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_48_51_54_69_54_69"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean dirExists( String name ){\n\t\tFileHandle dir = Gdx.files.local( name );\n\t\treturn dir.exists() && dir.isDirectory();\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean dirExists( String name ){\n\t\tFileHandle dir = getFileHandle( name );\n\t\treturn dir.exists() && dir.isDirectory();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( String name ){\n\t\treturn getFileHandle( defaultFileType, defaultPath, name );\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_48_51_46_48_84_87"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean deleteDir( String name ){\n\t\tFileHandle dir = Gdx.files.local( name );\n\t\t\n\t\tif (dir == null || !dir.isDirectory()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn dir.deleteDirectory();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( Files.FileType type, String basePath, String name ){\n\t\tswitch (type){\n\t\t\tcase Classpath:\n\t\t\t\treturn Gdx.files.classpath( basePath + name );\n\t\t\tcase Internal:\n\t\t\t\treturn Gdx.files.internal( basePath + name );\n\t\t\tcase External:\n\t\t\t\treturn Gdx.files.external( basePath + name );\n\t\t\tcase Absolute:\n\t\t\t\treturn Gdx.files.absolute( basePath + name );\n\t\t\tcase Local:\n\t\t\t\treturn Gdx.files.local( basePath + name );\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_53_61_54_69_54_69"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean deleteDir( String name ){\n\t\tFileHandle dir = Gdx.files.local( name );\n\t\t\n\t\tif (dir == null || !dir.isDirectory()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn dir.deleteDirectory();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean deleteDir( String name ){\n\t\tFileHandle dir = getFileHandle( name );\n\t\t\n\t\tif (dir == null || !dir.isDirectory()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn dir.deleteDirectory();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static FileHandle getFileHandle( String name ){\n\t\treturn getFileHandle( defaultFileType, defaultPath, name );\n\t}",
          "uniqueId": "addb99163148df3da3e508194bb89ecd72515128_53_61_46_48_89_97"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9f8791978a46583d944237abe67d94af0dcb49ef",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9f8791978a46583d944237abe67d94af0dcb49ef",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic BitmapFont getFont(int size, String text) {\n\t\tFreeTypeFontGenerator generator = basicFontGenerator;\n\t\t\n\t\tif (!basicFonts.containsKey(size)) {\n\t\t\tFreeTypeFontGenerator.FreeTypeFontParameter parameters = new FreeTypeFontGenerator.FreeTypeFontParameter();\n\t\t\tparameters.size = size;\n\t\t\tparameters.flip = true;\n\t\t\tparameters.borderWidth = parameters.size / 10f;\n\t\t\tparameters.renderCount = 3;\n\t\t\tparameters.hinting = FreeTypeFontGenerator.Hinting.None;\n\t\t\tparameters.spaceX = -(int) parameters.borderWidth;\n\t\t\tparameters.incremental = true;\n\t\t\tparameters.characters = \"\";\n\t\t\tparameters.packer = packer;\n\t\t\t\n\t\t\tBitmapFont font = generator.generateFont(parameters);\n\t\t\tfont.getData().missingGlyph = font.getData().getGlyph('�');\n\t\t\tbasicFonts.put(size, font);\n\t\t}\n\t\t\n\t\treturn basicFonts.get(size);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic BitmapFont getFont(int size, String text) {\n\t\tFreeTypeFontGenerator generator = getGeneratorForString(text);\n\t\t\n\t\tif (generator == null){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif (!fonts.get(generator).containsKey(size)) {\n\t\t\tFreeTypeFontGenerator.FreeTypeFontParameter parameters = new FreeTypeFontGenerator.FreeTypeFontParameter();\n\t\t\tparameters.size = size;\n\t\t\tparameters.flip = true;\n\t\t\tparameters.borderWidth = parameters.size / 10f;\n\t\t\tparameters.renderCount = 3;\n\t\t\tparameters.hinting = FreeTypeFontGenerator.Hinting.None;\n\t\t\tparameters.spaceX = -(int) parameters.borderWidth;\n\t\t\tparameters.incremental = true;\n\t\t\tif (generator == basicFontGenerator){\n\t\t\t\t//if we're using latin/cyrillic, we can safely pre-generate some common letters\n\t\t\t\t//(we define common as >4% frequency in english)\n\t\t\t\tparameters.characters = \"�etaoinshrdl\";\n\t\t\t} else {\n\t\t\t\tparameters.characters = \"�\";\n\t\t\t}\n\t\t\tparameters.packer = packer;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tBitmapFont font = generator.generateFont(parameters);\n\t\t\t\tfont.getData().missingGlyph = font.getData().getGlyph('�');\n\t\t\t\tfonts.get(generator).put(size, font);\n\t\t\t} catch ( Exception e ){\n\t\t\t\tGame.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn fonts.get(generator).get(size);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static FreeTypeFontGenerator getGeneratorForString( String input ){\n\t\tif (asianMatcher.matcher(input).find()){\n\t\t\treturn asianFontGenerator;\n\t\t} else {\n\t\t\treturn basicFontGenerator;\n\t\t}\n\t}",
          "uniqueId": "9f8791978a46583d944237abe67d94af0dcb49ef_106_128_126_132_135_172"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "53907d8b7a43d658f651619cf7f67b4f1e8c6c39",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/53907d8b7a43d658f651619cf7f67b4f1e8c6c39",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected void onDrag( PointerEvent event ) {\n\t\t\tif (dragging) {\n\n\t\t\t\tCamera c = content.camera;\n\n\t\t\t\tc.shift( PointF.diff( lastPos, event.current ).invScale( c.zoom ) );\n\t\t\t\tif (c.scroll.x + width > content.width()) {\n\t\t\t\t\tc.scroll.x = content.width() - width;\n\t\t\t\t}\n\t\t\t\tif (c.scroll.x < 0) {\n\t\t\t\t\tc.scroll.x = 0;\n\t\t\t\t}\n\t\t\t\tif (c.scroll.y + height > content.height()) {\n\t\t\t\t\tc.scroll.y = content.height() - height;\n\t\t\t\t}\n\t\t\t\tif (c.scroll.y < 0) {\n\t\t\t\t\tc.scroll.y = 0;\n\t\t\t\t}\n\n\t\t\t\tthumb.y = y + height * c.scroll.y / content.height();\n\n\t\t\t\tlastPos.set( event.current );\n\n\t\t\t} else if (PointF.distance( event.current, event.start ) > dragThreshold) {\n\n\t\t\t\tdragging = true;\n\t\t\t\tlastPos.set( event.current );\n\t\t\t\tthumb.am = 1;\n\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected void onDrag( PointerEvent event ) {\n\t\t\tif (dragging) {\n\n\t\t\t\tscroll(event.current);\n\n\t\t\t} else if (PointF.distance( event.current, event.start ) > dragThreshold) {\n\n\t\t\t\tdragging = true;\n\t\t\t\tlastPos.set( event.current );\n\t\t\t\tthumb.am = 1;\n\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void scroll( PointF current ){\n\t\t\t\n\t\t\tCamera c = content.camera;\n\t\t\t\n\t\t\tc.shift( PointF.diff( lastPos, current ).invScale( c.zoom ) );\n\t\t\tif (c.scroll.x + width > content.width()) {\n\t\t\t\tc.scroll.x = content.width() - width;\n\t\t\t}\n\t\t\tif (c.scroll.x < 0) {\n\t\t\t\tc.scroll.x = 0;\n\t\t\t}\n\t\t\tif (c.scroll.y + height > content.height()) {\n\t\t\t\tc.scroll.y = content.height() - height;\n\t\t\t}\n\t\t\tif (c.scroll.y < 0) {\n\t\t\t\tc.scroll.y = 0;\n\t\t\t}\n\t\t\t\n\t\t\tthumb.y = y + height * c.scroll.y / content.height();\n\t\t\t\n\t\t\tlastPos.set( current );\n\t\t\t\n\t\t}",
          "uniqueId": "53907d8b7a43d658f651619cf7f67b4f1e8c6c39_137_168_156_178_141_154"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "47fb795682081142add2762403750e4d1c055677",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/47fb795682081142add2762403750e4d1c055677",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v0_7_4_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.4\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.4d\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed a crash on start error some F-droid users were experiencing.\"));\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.4c\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Shots from the wand of warding now travel more quickly if they are going a great distance.\\n\\n\" +\n\t\t\t\t\"_-_ Class armor abilities no longer affect allies\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.7.4):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\" +\n\t\t\t\t\"_-_ Software keyboard not automatically hiding correctly\\n\" +\n\t\t\t\t\"_-_ Various fog of war errors when distant wards die\"));\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.4b\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LIBGDX), \"LibGDX\",\n\t\t\t\t\"Large sections of Shattered's codebase is now using the multiplatform game library _LibGDX._ Making the game's codebase less heavily tied to Android is a big step towards making the game available on other platforms!\\n\\n\" +\n\t\t\t\t\"Keyboard input handling and text rendering are still coupled to Android however. I will convert these game systems to use LibGDX in a later update.\\n\\n\" +\n\t\t\t\t\"Note that Shattered will not immediately release on other platforms once LibGDX conversion is complete, but it is a big step towards that.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new WandOfLivingEarth(),\n\t\t\t\t\"The wand of living earth is performing fairly reasonably now, but the staff of living earth continues to be really strong. This has led me to re-evaluate the battlemage living earth ability, and to nerf it significantly:\\n\\n\" +\n\t\t\t\t\"_-_ Earthen armor generated from battlemage melee hits reduced to 0.25x damage from 1x damage.\\n\\n\" +\n\t\t\t\t\"_-_ Battlemage can no longer stack earthen armor past the max HP of the earthen guardian.\\n\\n\" +\n\t\t\t\t\"Additionally:\\n\" +\n\t\t\t\t\"_-_ Guardian armor is now equivalent to cloth armor when 'faith is my armor' challenge is enabled.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Updated hero icons in rankings and saved game screens.\\n\\n\" +\n\t\t\t\t\"_-_ Updated translations\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.7.4):\\n\" +\n\t\t\t\t\"_-_ Wards able to be placed in walls\\n\" +\n\t\t\t\t\"_-_ Allies incorrectly being lost after Tengu fight\\n\" +\n\t\t\t\t\"Fixed (existed prior to 0.7.4):\\n\" +\n\t\t\t\t\"_-_ Talisman of foresight warn effect not being saved/loaded\\n\" +\n\t\t\t\t\"_-_ Level visuals (e.g. prison torches) rarely bugging out\"));\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.4a\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_WARDING, null), \"New Wand Adjustments\",\n\t\t\t\t\"Wand of Warding:\\n\" +\n\t\t\t\t\"The direct power of this wand is working well, but is a bit too hard to access. I'm making a few tweaks to make it a bit easier to access that power:\\n\" +\n\t\t\t\t\"_-_ The wand of warding can now target any location the hero can see, even through walls.\\n\" +\n\t\t\t\t\"_-_ Rather than wasting a charge, the wand now 'fizzles' if ward capacity is reached.\\n\\n\" +\n\t\t\t\t\"Wand of Living Earth:\\n\" +\n\t\t\t\t\"This wand is doing a bit too well at the moment, so I'm slightly scaling back its power at higher levels while very lightly buffing its base strength.\\n\" +\n\t\t\t\t\"_-_ Earth armor granted per shot reduced to 1x damage from 1.33x damage.\\n\" +\n\t\t\t\t\"_-_ Earth guardian max HP reduced to 16+8*lvl from 20+10*lvl.\\n\" +\n\t\t\t\t\"_-_ Wand base damage increased to 3-6 from 2-4.\\n\" +\n\t\t\t\t\"_-_ Earth guardian damage increased by 12.5%.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.MAGE, 0, 90, 12, 15), \"Subclass Adjustments\",\n\t\t\t\t\"The Warlock is intended to require a source of physical damage in addition to a wand to be successful. Upgradeable ally wands are problematic for warlock as you can get magical power and physical damage in one item, which makes his abilities absurdly useful with them. The warlock should synergize with allies, but I have scaled the amount down to more reasonable levels:\\n\\n\" +\n\t\t\t\t\"_-_ Soul mark healing increased to 40% of damage from 33%\\n\" +\n\t\t\t\t\"_-_ Soul mark is now 2/5 as effective when the damage-dealer isn't the hero.\\n\\n\" +\n\t\t\t\t\"I'm also making a few smaller adjustments to other subclasses which are overperforming:\\n\\n\" +\n\t\t\t\t\"_-_ Berserker rate of rage loss over time increased by 33% (it is now 2/3 of what it was pre-0.7.3).\\n\\n\" +\n\t\t\t\t\"_-_ Freerunner bonus evasion reduced by 20%.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Autotargeting now no longer targets ally characters, in any circumstances.\\n\\n\" +\n\t\t\t\t\"_-_ Most scrolls with an area of affect now no longer affect allies. More destructive ones will still damage them though.\\n\\n\" +\n\t\t\t\t\"_-_ Updated Translations.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.7.4):\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 0.7.4):\\n\" +\n\t\t\t\t\"_-_ Minor visual errors with ranged enemy attacks.\\n\" +\n\t\t\t\t\"_-_ Heavy boomerangs being lost when inventory is full.\\n\" +\n\t\t\t\t\"_-_ NPCs rarely getting hit by ranged attacks.\\n\" +\n\t\t\t\t\"_-_ Enemies rarely spawning on top of each other on boss levels.\\n\" +\n\t\t\t\t\"_-_ Elixir of aquatic rejuvenation being able to heal slightly over max hp.\\n\" +\n\t\t\t\t\"_-_ Prismatic images not being affected by brimstone and antimagic glyphs.\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released July 18th, 2019\\n\" +\n\t\t\t\t\"_-_ 56 days after Shattered v0.7.3\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"This brand new wand spawns autonomous wards which attack enemies. Wards can be upgraded by being zapped again, and eventually form up into sentry turrets.\\n\\n\" +\n\t\t\t\t\"The Wand of Warding does very consistent damage, but requires some setup first.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfLivingEarth(),\n\t\t\t\t\"This new wand has a lower damage output, but grants significant defensive power. The rocks the wand shoots at enemies reform around the hero and absorb damage. If enough rock is built, it will form up into a rock guardian which fights with the player.\\n\\n\" +\n\t\t\t\t\"The Wand of Living Earth is lacking in offensive output, but does a great job of pulling focus and damage away from the player.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_BERKANAN), \"Ally AI improvements\",\n\t\t\t\t\"Allies which follow the player are now considered to be 'intelligent', and have the following improved behaviours:\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will not attack enemies which are asleep, or which haven't noticed the player yet.\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will follow the hero through stairs so long as they are near to them.\\n\\n\" +\n\t\t\t\t\"Lastly, the hero can now swap places with any ally, even unintelligent ones.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Overhauled main menu interface to allow for more expandability.\\n\\n\" +\n\t\t\t\t\"_-_ Ring of elements and antimagic effects now apply to damage from wands.\\n\\n\" +\n\t\t\t\t\"_-_ Added a little surprise if you reach the surface with an upgraded ally item.\\n\\n\" +\n\t\t\t\t\"_-_ The great crab can now only block one enemy at a time.\\n\\n\" +\n\t\t\t\t\"_-_ Shattered Pixel Dungeon now requires Android 2.3+ to run, up from Android 2.2+.\\n\\n\" +\n\t\t\t\t\"_-_ Google Play Games and sharing gameplay data now requires android 4.1+, up from 4.0+.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Shattered pots being lost if the player has a full inventory\\n\" +\n\t\t\t\t\"_-_ Doors incorrectly closing when swapping places with an ally\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with heavy boomerangs\\n\" +\n\t\t\t\t\"_-_ Various minor text errors\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new DriedRose(),\n\t\t\t\t\"The Dried Rose's ghost hero has received some buffs and adjustments to go along with other ally improvements:\\n\\n\" +\n\t\t\t\t\"_-_ The ghost hero can now be given instructions by using the rose after summoning them, and tapping on a location.\\n\\n\" +\n\t\t\t\t\"_-_ Ghost HP scaling increased to 8 per petal, from 4.\\n\" +\n\t\t\t\t\"_-_ Ghost evasion reduced to 1x hero evasion from 2x.\\n\" +\n\t\t\t\t\"_-_ Ghost now heals over time while they are summoned.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.NOISEMAKER, null), \"Enhanced Bomb Buffs\",\n\t\t\t\t\"Many enchant bombs are performing poorly compared to some of the more popular ones, such as holy bombs and boss bombs. While I am toning down the strongest bombs a bit, I'm also making some pretty significant buffs to weaker bombs:\\n\\n\" +\n\t\t\t\t\"_-_ Frost bomb cost down to 2 from 3, now instantly freezes enemies caught in the blast in addition to chilling.\\n\" +\n\t\t\t\t\"_-_ Woolly bomb cost down to 2 from 3, now does regular bomb damage in addition to spawning sheep.\\n\" +\n\t\t\t\t\"_-_ Noisemaker now explodes when an enemy is attracted to its location.\\n\" +\n\t\t\t\t\"_-_ Flashbang cost increased to 6 from 5, now deals regular bomb damage and debuffs in a smaller AOE.\\n\" +\n\t\t\t\t\"_-_ Shock bomb cost increased to 6 from 5, now stuns/damages immediately instead of over time with electricity.\\n\" +\n\t\t\t\t\"_-_ Regrowth bomb cost increased to 8 from 6, now heals significantly more and spawns more plants.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing(0xFF4400)), \"Enchant/Glyph Buffs\",\n\t\t\t\t\"Continuing from the changes in 0.7.3, I'm still watching enchantment balance and making buffs where there's room to do so:\\n\\n\" +\n\t\t\t\t\"_-_ Blazing Enchantment bonus damage increased to 2/3 of burning damage, from 1-3.\\n\" +\n\t\t\t\t\"_-_ Shocking Enchantment damage increased to 40% from 33%.\\n\" +\n\t\t\t\t\"_-_ Blooming Enchantment chance for a second tile of grass increased to 10% per level, from 5%.\\n\" +\n\t\t\t\t\"_-_ Lucky Enchantment proc chance scaling with levels increased by ~2x.\\n\" +\n\t\t\t\t\"_-_ Corrupting Enchantment base proc chance increased to 15% from 10%, scaling reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Flow now grants a flat 2x speed boost in water, up from 1.5x + 0.1x per level.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WILD_ENERGY, null), \"Misc Item Buffs\",\n\t\t\t\t\"_-_ Wild energy now gives 4 turns of charging instantly, and 8 turns over time. Up from 10 turns over time.\\n\\n\" +\n\t\t\t\t\"_-_ Stone of Clairvoyance radius increased to 12 from 8. This increases the area by ~2.25x.\\n\\n\" +\n\t\t\t\t\"_-_ Allies are now healed by magical sleep, just like the hero.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_MAIL, new ItemSprite.Glowing(0x88EEFF)), \"Glyph Nerfs\",\n\t\t\t\t\"_-_ Glyph of Thorns bleed amount reduced to 4+lvl from 4+2*lvl, proc rate increased.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Antimagic base damage reduction reduced to 0-4 from 2-4.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Brimstone shield generation removed. The glyph now only protects the user from fire and does not also grant shielding when the user is aflame.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARCANE_BOMB, null), \"Enhanced Bomb Nerfs\",\n\t\t\t\t\"_-_ Holy Bomb no longer blinds characters caught in the blast, recipe cost up to 8 from 6.\\n\\n\" +\n\t\t\t\t\"_-_ Arcane Bomb damage now falls off based on distance. Reduced to 100%/83%/67% from all 100%.\\n\\n\" +\n\t\t\t\t\"_-_ Shrapnel Bomb damage now slightly falls off based on distance. Damage is reduced by 5% per tile of distance.\"));\n\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v0_7_4_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.4\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released July 18th, 2019\\n\" +\n\t\t\t\t\"_-_ 56 days after Shattered v0.7.3\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"This brand new wand spawns autonomous wards which attack enemies. Wards can be upgraded by being zapped again, and eventually form up into sentry turrets.\\n\\n\" +\n\t\t\t\t\"The Wand of Warding does very consistent damage, but requires some setup first.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfLivingEarth(),\n\t\t\t\t\"This new wand has a lower damage output, but grants significant defensive power. The rocks the wand shoots at enemies reform around the hero and absorb damage. If enough rock is built, it will form up into a rock guardian which fights with the player.\\n\\n\" +\n\t\t\t\t\"The Wand of Living Earth is lacking in offensive output, but does a great job of pulling focus and damage away from the player.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LIBGDX), \"LibGDX\",\n\t\t\t\t\"Large sections of Shattered's codebase is now using the multiplatform game library _LibGDX._ Making the game's codebase less heavily tied to Android is a big step towards making the game available on other platforms!\\n\\n\" +\n\t\t\t\t\"Keyboard input handling and text rendering are still coupled to Android however. I will convert these game systems to use LibGDX in a later update.\\n\\n\" +\n\t\t\t\t\"Note that Shattered will not immediately release on other platforms once LibGDX conversion is complete, but it is a big step towards that.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_BERKANAN), \"Ally AI improvements\",\n\t\t\t\t\"Allies which follow the player are now considered to be 'intelligent', and have the following improved behaviours:\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will not attack enemies which are asleep, or which haven't noticed the player yet.\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will follow the hero through stairs so long as they are near to them.\\n\\n\" +\n\t\t\t\t\"Lastly, the hero can now swap places with any ally, even unintelligent ones.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Overhauled main menu interface to allow for more expandability.\\n\" +\n\t\t\t\t\"_-_ Updated hero icons in rankings and saved game screens.\\n\\n\" +\n\t\t\t\t\"_-_ Class armor abilities no longer affect allies\\n\" +\n\t\t\t\t\"_-_ Autotargeting now no longer targets ally characters, in any circumstances.\\n\" +\n\t\t\t\t\"_-_ Most scrolls with an area of affect now no longer affect allies. More destructive ones will still damage them though.\\n\" +\n\t\t\t\t\"_-_ Added a little surprise if you reach the surface with an upgraded ally item.\\n\\n\" +\n\t\t\t\t\"_-_ Ring of elements and antimagic effects now apply to damage from wands.\\n\\n\" +\n\t\t\t\t\"_-_ The great crab can now only block one enemy at a time.\\n\\n\" +\n\t\t\t\t\"_-_ Shattered Pixel Dungeon now requires Android 2.3+ to run, up from Android 2.2+.\\n\" +\n\t\t\t\t\"_-_ Google Play Games and sharing gameplay data now requires android 4.1+, up from 4.0+.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Talisman of foresight warn effect not being saved/loaded\\n\" +\n\t\t\t\t\"_-_ Level visuals (e.g. prison torches) rarely bugging out\\n\" +\n\t\t\t\t\"_-_ Minor visual errors with ranged enemy attacks.\\n\" +\n\t\t\t\t\"_-_ Heavy boomerangs being lost when inventory is full\\n\" +\n\t\t\t\t\"_-_ NPCs rarely getting hit by ranged attacks\\n\" +\n\t\t\t\t\"_-_ Enemies rarely spawning on top of each other on boss levels\\n\" +\n\t\t\t\t\"_-_ Elixir of aquatic rejuvenation being able to heal slightly over max hp\\n\" +\n\t\t\t\t\"_-_ Prismatic images not being affected by brimstone and antimagic glyphs\\n\" +\n\t\t\t\t\"_-_ Shattered pots being lost if the player has a full inventory\\n\" +\n\t\t\t\t\"_-_ Doors incorrectly closing when swapping places with an ally\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with heavy boomerangs\\n\" +\n\t\t\t\t\"_-_ Various minor text errors\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new DriedRose(),\n\t\t\t\t\"The Dried Rose's ghost hero has received some buffs and adjustments to go along with other ally improvements:\\n\\n\" +\n\t\t\t\t\"_-_ The ghost hero can now be given instructions by using the rose after summoning them, and tapping on a location.\\n\\n\" +\n\t\t\t\t\"_-_ Ghost HP scaling increased to 8 per petal, from 4.\\n\" +\n\t\t\t\t\"_-_ Ghost evasion reduced to 1x hero evasion from 2x.\\n\" +\n\t\t\t\t\"_-_ Ghost now heals over time while they are summoned.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.NOISEMAKER, null), \"Enhanced Bomb Buffs\",\n\t\t\t\t\"Many enchant bombs are performing poorly compared to some of the more popular ones, such as holy bombs and boss bombs. While I am toning down the strongest bombs a bit, I'm also making some pretty significant buffs to weaker bombs:\\n\\n\" +\n\t\t\t\t\"_-_ Frost bomb cost down to 2 from 3, now instantly freezes enemies caught in the blast in addition to chilling.\\n\" +\n\t\t\t\t\"_-_ Woolly bomb cost down to 2 from 3, now does regular bomb damage in addition to spawning sheep.\\n\" +\n\t\t\t\t\"_-_ Noisemaker now explodes when an enemy is attracted to its location.\\n\" +\n\t\t\t\t\"_-_ Flashbang cost increased to 6 from 5, now deals regular bomb damage and debuffs in a smaller AOE.\\n\" +\n\t\t\t\t\"_-_ Shock bomb cost increased to 6 from 5, now stuns/damages immediately instead of over time with electricity.\\n\" +\n\t\t\t\t\"_-_ Regrowth bomb cost increased to 8 from 6, now heals significantly more and spawns more plants.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing(0xFF4400)), \"Enchant/Glyph Buffs\",\n\t\t\t\t\"Continuing from the changes in 0.7.3, I'm still watching enchantment balance and making buffs where there's room to do so:\\n\\n\" +\n\t\t\t\t\"_-_ Blazing Enchantment bonus damage increased to 2/3 of burning damage, from 1-3.\\n\" +\n\t\t\t\t\"_-_ Shocking Enchantment damage increased to 40% from 33%.\\n\" +\n\t\t\t\t\"_-_ Blooming Enchantment chance for a second tile of grass increased to 10% per level, from 5%.\\n\" +\n\t\t\t\t\"_-_ Lucky Enchantment proc chance scaling with levels increased by ~2x.\\n\" +\n\t\t\t\t\"_-_ Corrupting Enchantment base proc chance increased to 15% from 10%, scaling reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Flow now grants a flat 2x speed boost in water, up from 1.5x + 0.1x per level.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WILD_ENERGY, null), \"Misc Item Buffs\",\n\t\t\t\t\"_-_ Wild energy now gives 4 turns of charging instantly, and 8 turns over time. Up from 10 turns over time.\\n\\n\" +\n\t\t\t\t\"_-_ Stone of Clairvoyance radius increased to 12 from 8. This increases the area by ~2.25x.\\n\\n\" +\n\t\t\t\t\"_-_ Allies are now healed by magical sleep, just like the hero.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.MAGE, 0, 90, 12, 15), \"Subclass Adjustments\",\n\t\t\t\t\"The Warlock is intended to require a source of physical damage in addition to a wand to be successful. Upgradeable ally wands are problematic for warlock as you can get magical power and physical damage in one item, which makes his abilities absurdly useful with them. The warlock should synergize with allies, but I have scaled the amount down to more reasonable levels:\\n\\n\" +\n\t\t\t\t\"_-_ Soul mark healing increased to 40% of damage from 33%\\n\" +\n\t\t\t\t\"_-_ Soul mark is now 2/5 as effective when the damage-dealer isn't the hero.\\n\\n\" +\n\t\t\t\t\"I'm also making a few smaller adjustments to other subclasses which are overperforming:\\n\\n\" +\n\t\t\t\t\"_-_ Berserker rate of rage loss over time increased by 33% (it is now 2/3 of what it was pre-0.7.3).\\n\\n\" +\n\t\t\t\t\"_-_ Freerunner bonus evasion reduced by 20%.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_MAIL, new ItemSprite.Glowing(0x88EEFF)), \"Glyph Nerfs\",\n\t\t\t\t\"_-_ Glyph of Thorns bleed amount reduced to 4+lvl from 4+2*lvl, proc rate increased.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Antimagic base damage reduction reduced to 0-4 from 2-4.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Brimstone shield generation removed. The glyph now only protects the user from fire and does not also grant shielding when the user is aflame.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARCANE_BOMB, null), \"Enhanced Bomb Nerfs\",\n\t\t\t\t\"_-_ Holy Bomb no longer blinds characters caught in the blast, recipe cost up to 8 from 6.\\n\\n\" +\n\t\t\t\t\"_-_ Arcane Bomb damage now falls off based on distance. Reduced to 100%/83%/67% from all 100%.\\n\\n\" +\n\t\t\t\t\"_-_ Shrapnel Bomb damage now slightly falls off based on distance. Damage is reduced by 5% per tile of distance.\"));\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v0_7_5_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.5\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released October 2nd, 2019\\n\" +\n\t\t\t\t\"_-_ 76 days after Shattered v0.7.4\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SNAKE, 12, 0, 12, 11), \"Sewer Enemies\",\n\t\t\t\t\"Two new enemies have been added to the sewers!\\n\\n\" +\n\t\t\t\t\"_- Snakes_ are an evasive enemy which mainly shows up on early floors, they help teach the importance of surprise attacks.\\n\" +\n\t\t\t\t\"_- Slimes_ primarily appear on floor 4, and are an enemy type which rewards defense over damage.\\n\\n\" +\n\t\t\t\t\"Goo's level has also received significant changes. It now uses a new unique level layout pattern, and Goo itself always spawns in a new unique room type.\\n\\n\" +\n\t\t\t\t\"I have also made slight balance changes to the Goo fight itself. 1x1 pillars have been mostly removed from Goo's arena to reduce surprise-attack spam, but Goo's damage has been reduced by 20% to compensate.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.TENGU, 0, 0, 14, 16), \"Prison Enemies\",\n\t\t\t\t\"_Necromancers_ have been added to the prison! These powerful enemies fight by summoning and buffing undead.\\n\\n\" +\n\t\t\t\t\"The _Tengu_ boss fight has been totally reworked! The fight still takes place over 3 stages, and has a similar core theme, but I have totally ditched the tedious maze and chasing mechanics from stages 2&3, and have given Tengu several new abilities. Watch your step!\\n\\n\" +\n\t\t\t\t\"As a part of this rework, Tengu's stats have also been adjusted:\\n\" +\n\t\t\t\t\"_-_ HP up to 160 from 120\\n\" +\n\t\t\t\t\"_-_ Evasion reduced by 25%\\n\" +\n\t\t\t\t\"_-_ Damage reduced by 30%\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.RAT, 0, 15, 16, 15), \"Enemy Changes\",\n\t\t\t\t\"_-_ Significantly improved the consistency of enemy spawns (large numbers of the same enemy and large enemy groups should be less common)\\n\\n\" +\n\t\t\t\t\"_-_ Adjusted enemy spawn chances on floors 1-10 to make rooms for new enemies\\n\\n\" +\n\t\t\t\t\"_-_ Skeletons no longer rarely appear on floor 4\\n\\n\" +\n\t\t\t\t\"_-_ Guards no longer drop healing potions, they are now dropped by necromancers\\n\" +\n\t\t\t\t\"_-_ Guards now grant 7 exp, up from 6\\n\\n\" +\n\t\t\t\t\"_-_ Albino rats now grant 2 exp, up from 1\\n\" +\n\t\t\t\t\"_-_ Albino rats now drop mystery meat\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The game camera now smoothly follows the hero while they are moving, instead of snapping to their location.\\n\\n\" +\n\t\t\t\t\"_-_ Standardized word use when attacks miss to reduce confusion. Enemies now always 'block' or 'dodge'.\\n\\n\" +\n\t\t\t\t\"_-_ Various improvements to wording on the supporter menu for Google Play users.\\n\\n\" +\n\t\t\t\t\"_-_ Various internal code improvements\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Various stability issues caused by the LibGDX conversion\\n\" +\n\t\t\t\t\"_-_ Area-based effects behaving oddly in rare cases\\n\" +\n\t\t\t\t\"_-_ Thieves not escaping when they should in many cases\\n\" +\n\t\t\t\t\"_-_ A rare crash bug involving boomerangs\\n\" +\n\t\t\t\t\"_-_ Sai and gauntlets giving 1 more defense than what their descriptions stated\\n\" +\n\t\t\t\t\"_-_ Players rarely opening containers/doors from a distance\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Added new Language: Japanese!\\n\\n\" +\n\t\t\t\t\"Updated Translations and Translator Credits!\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WAND_BLAST_WAVE, null), \"Wand Buffs\",\n\t\t\t\t\"Blast wave is an excellent sidearm wand, but not as good when invested in. I'm making the wand a bit stronger and less risky to hopefully make it more worthy of upgrades.\\n\" +\n\t\t\t\t\"_-_ Increased AOE damage from 67% to 100%, AOE knockback force is unchanged\\n\" +\n\t\t\t\t\"_-_ AOE no longer damages hero/allies, but still knocks them back\\n\\n\" +\n\t\t\t\t\"Corrosion is a very powerful wand in the right hands, but is currently a bit too hard to use right. I'm lightly buffing it to make its power a bit more accessible.\\n\" +\n\t\t\t\t\"_-_ Corrosion gas starting damage increased to 2+lvl from 1+lvl\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_AMETHYST, null), \"Ring Buffs\",\n\t\t\t\t\"Based on their performance, I'm giving a light buff to ring of energy, and a more significant buff to ring of wealth:\\n\\n\" +\n\t\t\t\t\"_-_ Ring of energy charge boost increased to 30% per level, from 25%\\n\\n\" +\n\t\t\t\t\"_-_ Ring of wealth exclusive drops are 20% more common\\n\" +\n\t\t\t\t\"_-_ Rare ring of wealth exclusive drops are now 33% more common\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing( 0x440066 )), \"Glyph/Enchant Buffs\",\n\t\t\t\t\"I'm giving some significant buffs to underperforming rare enchants/glyphs:\\n\\n\" +\n\t\t\t\t\"_-_ Proc chance for corruption enchant increased by ~25% at all levels\\n\\n\" +\n\t\t\t\t\"_-_ Proc chance for glyph of affection increased by ~50% at +0, scaling to ~10% at +10\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new WandOfLivingEarth(),\n\t\t\t\t\"I'm continuing to adjust the wand of living earth to make it less able to stand on its own as a run-winning item. It should excel at providing defensive power, but shouldn't also give good offense.\\n\\n\" +\n\t\t\t\t\"_-_ Guardian average damage decreased by 33%\\n\" +\n\t\t\t\t\"_-_ Base wand damage up to 4-6 from 3-6\\n\" +\n\t\t\t\t\"_-_ Wand damage scaling down to 0-2 from 1-2\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new WandOfCorruption(),\n\t\t\t\t\"Corruption is performing extremely well when invested in, so I'm adjusting debuff influence on corruption chance to make it more difficult to corrupt enemies.\\n\\n\" +\n\t\t\t\t\"_-_ Corruption resistance reduction from minor debuffs reduced to 12.5% from 20%\\n\" +\n\t\t\t\t\"_-_ Corruption resistance reduction from major debuffs reduced to 25% from 33%\"));\n\t\t\n\t}",
          "uniqueId": "47fb795682081142add2762403750e4d1c055677_67_255_69_168_170_294"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "92f198a9b02cc8c7ab9186ba6b49ba8550c99da3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/92f198a9b02cc8c7ab9186ba6b49ba8550c99da3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndInfoItem( Heap heap ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tif (heap.type == Heap.Type.HEAP || heap.type == Heap.Type.FOR_SALE) {\n\t\t\t\n\t\t\tItem item = heap.peek();\n\t\t\t\n\t\t\tint color = TITLE_COLOR;\n\t\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t\t}\n\t\t\tfillFields( item.image(), item.glowing(), color, item.toString(), item.info() );\n\t\t\t\n\t\t} else {\n\n\t\t\tfillFields( heap.image(), heap.glowing(), TITLE_COLOR, heap.toString(), heap.info() );\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public WndInfoItem( Heap heap ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tif (heap.type == Heap.Type.HEAP || heap.type == Heap.Type.FOR_SALE) {\n\t\t\tfillFields( heap.peek() );\n\t\t\t\n\t\t} else {\n\t\t\tfillFields( heap );\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillFields( Item item ) {\n\t\t\n\t\tint color = TITLE_COLOR;\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t}\n\t\t\n\t\tint width = SPDSettings.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.color( color );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextMultiline txtInfo = PixelScene.renderMultiline( item.info(), 6 );\n\t\ttxtInfo.maxWidth(width);\n\t\ttxtInfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( txtInfo );\n\t\t\n\t\tresize( width, (int)(txtInfo.top() + txtInfo.height()) );\n\t}",
          "uniqueId": "92f198a9b02cc8c7ab9186ba6b49ba8550c99da3_41_62_78_100_41_52"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndInfoItem( Item item ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tint color = TITLE_COLOR;\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t}\n\t\t\n\t\tfillFields( item.image(), item.glowing(), color, item.toString(), item.info() );\n\t}",
          "sourceCodeAfterRefactoring": "public WndInfoItem( Item item ) {\n\t\tsuper();\n\t\t\n\t\tfillFields( item );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillFields( Item item ) {\n\t\t\n\t\tint color = TITLE_COLOR;\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\tcolor = ItemSlot.UPGRADED;\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\tcolor = ItemSlot.DEGRADED;\n\t\t}\n\t\t\n\t\tint width = SPDSettings.landscape() ? WIDTH_L : WIDTH_P;\n\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.color( color );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\t\t\n\t\tRenderedTextMultiline txtInfo = PixelScene.renderMultiline( item.info(), 6 );\n\t\ttxtInfo.maxWidth(width);\n\t\ttxtInfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( txtInfo );\n\t\t\n\t\tresize( width, (int)(txtInfo.top() + txtInfo.height()) );\n\t}",
          "uniqueId": "92f198a9b02cc8c7ab9186ba6b49ba8550c99da3_64_76_78_100_54_58"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f19ea6b62cf7b11819d887b14a2f3769d1dc0bd5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f19ea6b62cf7b11819d887b14a2f3769d1dc0bd5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean canUseAbility(){\n\t\t\n\t\tif (HP > HT/2) return false;\n\t\t\n\t\t//1 base ability use, plus 2 uses per jump\n\t\tint targetAbilityUses = 1 + 2*arenaJumps;\n\t\t\n\t\t//and ane extra 2 use for jumps 3 and 4\n\t\ttargetAbilityUses += Math.max(0, arenaJumps-2);\n\t\t\n\t\tif (abilitiesUsed >= targetAbilityUses){\n\t\t\treturn false;\n\t\t} else {\n\t\t\t\n\t\t\tabilityCooldown--;\n\t\t\t\n\t\t\tif (targetAbilityUses - abilitiesUsed >= 5){\n\t\t\t\t//Very behind in ability uses, use one right away!\n\t\t\t\tabilityCooldown = 0;\n\t\t\t} else if (targetAbilityUses - abilitiesUsed >= 3){\n\t\t\t\t//moderately behind in uses, use one every other action.\n\t\t\t\tif (abilityCooldown == -1 || abilityCooldown > 1) abilityCooldown = 1;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t//standard delay before ability use, 1-4 turns\n\t\t\t\tif (abilityCooldown == -1) abilityCooldown = Random.IntRange(1, 4);\n\t\t\t}\n\t\t\t\n\t\t\tif (abilityCooldown == 0){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public boolean canUseAbility(){\n\t\t\n\t\tif (HP > HT/2) return false;\n\t\t\n\t\tif (abilitiesUsed >= targetAbilityUses()){\n\t\t\treturn false;\n\t\t} else {\n\t\t\t\n\t\t\tabilityCooldown--;\n\t\t\t\n\t\t\tif (targetAbilityUses() - abilitiesUsed >= 4){\n\t\t\t\t//Very behind in ability uses, use one right away!\n\t\t\t\tabilityCooldown = 0;\n\t\t\t\t\n\t\t\t} else if (targetAbilityUses() - abilitiesUsed >= 3){\n\t\t\t\t//moderately behind in uses, use one every other action.\n\t\t\t\tif (abilityCooldown == -1 || abilityCooldown > 1) abilityCooldown = 1;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t//standard delay before ability use, 1-4 turns\n\t\t\t\tif (abilityCooldown == -1) abilityCooldown = Random.IntRange(1, 4);\n\t\t\t}\n\t\t\t\n\t\t\tif (abilityCooldown == 0){\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int targetAbilityUses(){\n\t\t//1 base ability use, plus 2 uses per jump\n\t\tint targetAbilityUses = 1 + 2*arenaJumps;\n\t\t\n\t\t//and ane extra 2 use for jumps 3 and 4\n\t\ttargetAbilityUses += Math.max(0, arenaJumps-2);\n\t\t\n\t\treturn targetAbilityUses;\n\t}",
          "uniqueId": "f19ea6b62cf7b11819d887b14a2f3769d1dc0bd5_404_438_431_439_400_429"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "96dd6eff82f38d7dedf55807d8d3973f431d7426",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/96dd6eff82f38d7dedf55807d8d3973f431d7426",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void draw() {\n\n\t\tsuper.draw();\n\n\t\tif (!updated.isEmpty()) {\n\t\t\tupdateVertices();\n\t\t\tif (buffer == null)\n\t\t\t\tbuffer = new Vertexbuffer(quads);\n\t\t\telse {\n\t\t\t\tif (fullUpdate) {\n\t\t\t\t\tbuffer.updateVertices(quads);\n\t\t\t\t\tfullUpdate = false;\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.updateVertices(quads,\n\t\t\t\t\t\t\ttopLeftUpdating * 16,\n\t\t\t\t\t\t\tbottomRightUpdating * 16);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttopLeftUpdating = -1;\n\t\t\tupdating.setEmpty();\n\t\t}\n\t\t\n\t\t//FIXME temporarily disabled this optimization as it is suspected to cause crashes\n\t\t/*Camera c = Camera.main;\n\t\t//we treat the position of the tilemap as (0,0) here\n\t\tcamX = (int)(c.scroll.x/cellW - x/cellW);\n\t\tcamY = (int)(c.scroll.y/cellH - y/cellH);\n\t\tcamW = (int)Math.ceil(c.width/cellW);\n\t\tcamH = (int)Math.ceil(c.height/cellH);\n\n\t\tif (camX >= mapWidth\n\t\t\t\t|| camY >= mapHeight\n\t\t\t\t|| camW + camW <= 0\n\t\t\t\t|| camH + camH <= 0)\n\t\t\treturn;\n\n\t\t//determines the top-left visible tile, the bottom-right one, and the buffer length\n\t\t//between them, this culls a good number of none-visible tiles while keeping to 1 draw\n\t\ttopLeft = Math.max(camX, 0)\n\t\t\t\t+ Math.max(camY*mapWidth, 0);\n\n\t\tbottomRight = Math.min(camX+camW, mapWidth-1)\n\t\t\t\t+ Math.min((camY+camH)*mapWidth, (mapHeight-1)*mapWidth);\n\n\t\tif (topLeft >= size || bottomRight < 0)\n\t\t\tlength = 0;\n\t\telse\n\t\t\tlength = bottomRight - topLeft + 1;\n\n\t\tif (length <= 0)\n\t\t\treturn;*/\n\n\t\tNoosaScript script = NoosaScriptNoLighting.get();\n\n\t\ttexture.bind();\n\n\t\tscript.uModel.valueM4( matrix );\n\n\t\tscript.camera( camera );\n\n\t\tscript.drawQuadSet( buffer, size, 0 );\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void draw() {\n\n\t\tsuper.draw();\n\n\t\tif (!updated.isEmpty()) {\n\t\t\tupdateVertices();\n\t\t\tif (buffer == null)\n\t\t\t\tbuffer = new Vertexbuffer(quads);\n\t\t\telse {\n\t\t\t\tif (fullUpdate) {\n\t\t\t\t\tbuffer.updateVertices(quads);\n\t\t\t\t\tfullUpdate = false;\n\t\t\t\t} else {\n\t\t\t\t\tbuffer.updateVertices(quads,\n\t\t\t\t\t\t\ttopLeftUpdating * 16,\n\t\t\t\t\t\t\tbottomRightUpdating * 16);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttopLeftUpdating = -1;\n\t\t\tupdating.setEmpty();\n\t\t}\n\t\t\n\t\t//FIXME temporarily disabled this optimization as it is suspected to cause crashes\n\t\t/*Camera c = Camera.main;\n\t\t//we treat the position of the tilemap as (0,0) here\n\t\tcamX = (int)(c.scroll.x/cellW - x/cellW);\n\t\tcamY = (int)(c.scroll.y/cellH - y/cellH);\n\t\tcamW = (int)Math.ceil(c.width/cellW);\n\t\tcamH = (int)Math.ceil(c.height/cellH);\n\n\t\tif (camX >= mapWidth\n\t\t\t\t|| camY >= mapHeight\n\t\t\t\t|| camW + camW <= 0\n\t\t\t\t|| camH + camH <= 0)\n\t\t\treturn;\n\n\t\t//determines the top-left visible tile, the bottom-right one, and the buffer length\n\t\t//between them, this culls a good number of none-visible tiles while keeping to 1 draw\n\t\ttopLeft = Math.max(camX, 0)\n\t\t\t\t+ Math.max(camY*mapWidth, 0);\n\n\t\tbottomRight = Math.min(camX+camW, mapWidth-1)\n\t\t\t\t+ Math.min((camY+camH)*mapWidth, (mapHeight-1)*mapWidth);\n\n\t\tif (topLeft >= size || bottomRight < 0)\n\t\t\tlength = 0;\n\t\telse\n\t\t\tlength = bottomRight - topLeft + 1;\n\n\t\tif (length <= 0)\n\t\t\treturn;*/\n\n\t\tNoosaScript script = script();\n\n\t\ttexture.bind();\n\n\t\tscript.uModel.valueM4( matrix );\n\t\tscript.lighting(\n\t\t\t\trm, gm, bm, am,\n\t\t\t\tra, ga, ba, aa );\n\n\t\tscript.camera( camera );\n\n\t\tscript.drawQuadSet( buffer, size, 0 );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected NoosaScript script(){\n\t\treturn NoosaScriptNoLighting.get();\n\t}",
          "uniqueId": "96dd6eff82f38d7dedf55807d8d3973f431d7426_195_258_263_265_195_261"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "59186a3840287e0d8d98def0dc2e05840a1fa417",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/59186a3840287e0d8d98def0dc2e05840a1fa417",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\t\tChar target = Actor.findChar(pos);\n\t\t\n\t\t//find the closest char that can be aimed at\n\t\tif (target == null){\n\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\tif (bolt.collisionPos == ch.pos &&\n\t\t\t\t\t\t(target == null || Dungeon.level.trueDistance(pos, ch.pos) < Dungeon.level.trueDistance(pos, target.pos))){\n\t\t\t\t\ttarget = ch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (target != null) {\n\t\t\tfinal Char finalTarget = target;\n\t\t\tfinal PoisonDartTrap trap = this;\n\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\tActor.add(new Actor() {\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\t//it's a visual effect, gets priority no matter what\n\t\t\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected boolean act() {\n\t\t\t\t\t\tfinal Actor toRemove = this;\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new PoisonDart(), new Callback() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\tint dmg = Random.NormalIntRange(1, 4) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, trap);\n\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero && !finalTarget.isAlive()){\n\t\t\t\t\t\t\t\t\t\tDungeon.fail( trap.getClass() );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class )\n\t\t\t\t\t\t\t\t\t\t\t.set( 8 + Math.round(2*Dungeon.depth / 3f) );\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\tActor.remove(toRemove);\n\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfinalTarget.damage(Random.NormalIntRange(1, 4) - finalTarget.drRoll(), trap);\n\t\t\t\tBuff.affect( finalTarget, Poison.class )\n\t\t\t\t\t\t.set( 8 + Math.round(2*Dungeon.depth / 3f) );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\t\tChar target = Actor.findChar(pos);\n\t\t\n\t\t//find the closest char that can be aimed at\n\t\tif (target == null){\n\t\t\tfor (Char ch : Actor.chars()){\n\t\t\t\tBallistica bolt = new Ballistica(pos, ch.pos, Ballistica.PROJECTILE);\n\t\t\t\tif (bolt.collisionPos == ch.pos &&\n\t\t\t\t\t\t(target == null || Dungeon.level.trueDistance(pos, ch.pos) < Dungeon.level.trueDistance(pos, target.pos))){\n\t\t\t\t\ttarget = ch;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (target != null) {\n\t\t\tfinal Char finalTarget = target;\n\t\t\tfinal PoisonDartTrap trap = this;\n\t\t\tif (Dungeon.level.heroFOV[pos] || Dungeon.level.heroFOV[target.pos]) {\n\t\t\t\tActor.add(new Actor() {\n\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\t//it's a visual effect, gets priority no matter what\n\t\t\t\t\t\tactPriority = VFX_PRIO;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected boolean act() {\n\t\t\t\t\t\tfinal Actor toRemove = this;\n\t\t\t\t\t\t((MissileSprite) ShatteredPixelDungeon.scene().recycle(MissileSprite.class)).\n\t\t\t\t\t\t\treset(pos, finalTarget.sprite, new PoisonDart(), new Callback() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\t\t\tint dmg = Random.NormalIntRange(1, 4) - finalTarget.drRoll();\n\t\t\t\t\t\t\t\t\tfinalTarget.damage(dmg, trap);\n\t\t\t\t\t\t\t\t\tif (finalTarget == Dungeon.hero && !finalTarget.isAlive()){\n\t\t\t\t\t\t\t\t\t\tDungeon.fail( trap.getClass() );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_HIT, 1, 1, Random.Float(0.8f, 1.25f));\n\t\t\t\t\t\t\t\t\tfinalTarget.sprite.bloodBurstA(finalTarget.sprite.center(), dmg);\n\t\t\t\t\t\t\t\t\tfinalTarget.sprite.flash();\n\t\t\t\t\t\t\t\t\tActor.remove(toRemove);\n\t\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfinalTarget.damage(Random.NormalIntRange(1, 4) - finalTarget.drRoll(), trap);\n\t\t\t\tBuff.affect( finalTarget, Poison.class ).set( poisonAmount() );\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int poisonAmount(){\n\t\treturn 8 + Math.round(2*Dungeon.depth / 3f);\n\t}",
          "uniqueId": "59186a3840287e0d8d98def0dc2e05840a1fa417_51_106_47_49_51_104"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "71b406c84d87328138c21a64feb3d6c5038eb8ae",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/71b406c84d87328138c21a64feb3d6c5038eb8ae",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void press( int cell, Char ch, boolean hard ) {\n\n\t\tif (ch != null && pit[cell] && !ch.flying) {\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tChasm.heroFall(cell);\n\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tTrap trap = null;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TRAP:\n\t\t\tif (hard) {\n\t\t\t\ttrap = traps.get( cell );\n\t\t\t\tGLog.i(Messages.get(Level.class, \"hidden_trap\", trap.name));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.TRAP:\n\t\t\ttrap = traps.get( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\tcase Terrain.FURROWED_GRASS:\n\t\t\tHighGrass.trample( this, cell, ch );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trap != null) {\n\t\t\t\n\t\t\tTimekeepersHourglass.timeFreeze timeFreeze =\n\t\t\t\t\tDungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);\n\t\t\t\n\t\t\tSwiftthistle.TimeBubble bubble =\n\t\t\t\t\tDungeon.hero.buff(Swiftthistle.TimeBubble.class);\n\t\t\t\n\t\t\tif (bubble != null){\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\t\t\t\t\n\t\t\t\tdiscover(cell);\n\t\t\t\t\n\t\t\t\tbubble.setDelayedPress(cell);\n\t\t\t\t\n\t\t\t} else if (timeFreeze != null){\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\t\t\t\t\n\t\t\t\tdiscover(cell);\n\t\t\t\t\n\t\t\t\ttimeFreeze.setDelayedPress(cell);\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\tDungeon.hero.interrupt();\n\t\t\t\t}\n\n\t\t\t\ttrap.trigger();\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.trigger();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void pressCell( int cell ){\n\t\tpressCell( cell, true );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void pressCell( int cell, boolean hard ) {\n\n\t\tTrap trap = null;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TRAP:\n\t\t\tif (hard) {\n\t\t\t\ttrap = traps.get( cell );\n\t\t\t\tGLog.i(Messages.get(Level.class, \"hidden_trap\", trap.name));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.TRAP:\n\t\t\ttrap = traps.get( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\tcase Terrain.FURROWED_GRASS:\n\t\t\tHighGrass.trample( this, cell);\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trap != null) {\n\t\t\t\n\t\t\tTimekeepersHourglass.timeFreeze timeFreeze =\n\t\t\t\t\tDungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);\n\t\t\t\n\t\t\tSwiftthistle.TimeBubble bubble =\n\t\t\t\t\tDungeon.hero.buff(Swiftthistle.TimeBubble.class);\n\t\t\t\n\t\t\tif (bubble != null){\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\t\t\t\t\n\t\t\t\tdiscover(cell);\n\t\t\t\t\n\t\t\t\tbubble.setDelayedPress(cell);\n\t\t\t\t\n\t\t\t} else if (timeFreeze != null){\n\t\t\t\t\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\t\t\t\t\n\t\t\t\tdiscover(cell);\n\t\t\t\t\n\t\t\t\ttimeFreeze.setDelayedPress(cell);\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (Dungeon.hero.pos == cell) {\n\t\t\t\t\tDungeon.hero.interrupt();\n\t\t\t\t}\n\n\t\t\t\ttrap.trigger();\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.trigger();\n\t\t}\n\t}",
          "uniqueId": "71b406c84d87328138c21a64feb3d6c5038eb8ae_796_875_813_883_807_809"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0077e36c17ad06573a7eca3c2d63c03b98cfec06",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0077e36c17ad06573a7eca3c2d63c03b98cfec06",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void paint( Level level ) {\n\t\t\n\t\tint floor = level.tunnelTile();\n\t\t\n\t\tArrayList<Point> pointsToFill = new ArrayList<>();\n\t\tfor (Point door : connected.values()) {\n\t\t\tPoint p = new Point(door);\n\t\t\tif (p.y == top){\n\t\t\t\tp.y++;\n\t\t\t} else if (p.y == bottom) {\n\t\t\t\tp.y--;\n\t\t\t} else if (p.x == left){\n\t\t\t\tp.x++;\n\t\t\t} else {\n\t\t\t\tp.x--;\n\t\t\t}\n\t\t\tpointsToFill.add( p );\n\t\t}\n\t\t\n\t\tArrayList<Point> pointsFilled = new ArrayList<>();\n\t\tpointsFilled.add(pointsToFill.remove(0));\n\t\t\n\t\tPoint from = null, to = null;\n\t\tint shortestDistance;\n\t\twhile(!pointsToFill.isEmpty()){\n\t\t\tshortestDistance = Integer.MAX_VALUE;\n\t\t\tfor (Point f : pointsFilled){\n\t\t\t\tfor (Point t : pointsToFill){\n\t\t\t\t\tint dist = distanceBetweenPoints(f, t);\n\t\t\t\t\tif (dist < shortestDistance){\n\t\t\t\t\t\tfrom = f;\n\t\t\t\t\t\tto = t;\n\t\t\t\t\t\tshortestDistance = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfillBetweenPoints(level, from, to, floor);\n\t\t\tpointsFilled.add(to);\n\t\t\tpointsToFill.remove(to);\n\t\t}\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.TUNNEL );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void paint( Level level ) {\n\t\t\n\t\tint floor = level.tunnelTile();\n\t\t\n\t\tfillPerimiterPaths(level, this, floor);\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.TUNNEL );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void fillPerimiterPaths( Level l, Room r, int floor ){\n\t\t\n\t\tcorners = null;\n\t\t\n\t\tArrayList<Point> pointsToFill = new ArrayList<>();\n\t\tfor (Point door : r.connected.values()) {\n\t\t\tPoint p = new Point(door);\n\t\t\tif (p.y == r.top){\n\t\t\t\tp.y++;\n\t\t\t} else if (p.y == r.bottom) {\n\t\t\t\tp.y--;\n\t\t\t} else if (p.x == r.left){\n\t\t\t\tp.x++;\n\t\t\t} else {\n\t\t\t\tp.x--;\n\t\t\t}\n\t\t\tpointsToFill.add( p );\n\t\t}\n\t\t\n\t\tArrayList<Point> pointsFilled = new ArrayList<>();\n\t\tpointsFilled.add(pointsToFill.remove(0));\n\t\t\n\t\tPoint from = null, to = null;\n\t\tint shortestDistance;\n\t\twhile(!pointsToFill.isEmpty()){\n\t\t\tshortestDistance = Integer.MAX_VALUE;\n\t\t\tfor (Point f : pointsFilled){\n\t\t\t\tfor (Point t : pointsToFill){\n\t\t\t\t\tint dist = distanceBetweenPoints(r, f, t);\n\t\t\t\t\tif (dist < shortestDistance){\n\t\t\t\t\t\tfrom = f;\n\t\t\t\t\t\tto = t;\n\t\t\t\t\t\tshortestDistance = dist;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfillBetweenPoints(l, r, from, to, floor);\n\t\t\tpointsFilled.add(to);\n\t\t\tpointsToFill.remove(to);\n\t\t}\n\t\t\n\t}",
          "uniqueId": "0077e36c17ad06573a7eca3c2d63c03b98cfec06_33_77_45_86_34_43"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2a523f2ea20c4097465ebfe0e5f6a078b9487e6e",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2a523f2ea20c4097465ebfe0e5f6a078b9487e6e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public int play( Object id, float leftVolume, float rightVolume, float rate ) {\n\t\tif (enabled && ids.containsKey( id )) {\n\t\t\treturn pool.play( ids.get( id ), leftVolume*volume, rightVolume*volume, 0, 0, rate );\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public long play( Object id, float volume, float pitch ) {\n\t\treturn play( id, volume, volume, pitch );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic long play( Object id, float leftVolume, float rightVolume, float pitch ) {\n\t\tfloat volume = Math.max(leftVolume, rightVolume);\n\t\tfloat pan = rightVolume - leftVolume;\n\t\tif (enabled && ids.containsKey( id )) {\n\t\t\treturn ids.get(id).play( globalVolume*volume, pitch, pan );\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}",
          "uniqueId": "2a523f2ea20c4097465ebfe0e5f6a078b9487e6e_128_134_92_100_88_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "7de9a8b2073a383e740276401b5ab62126f12d8a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/7de9a8b2073a383e740276401b5ab62126f12d8a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add_v0_7_3_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.3\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.3b\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton(new ChangeButton(Icons.get(Icons.WARNING), \"Android Froyo Support\",\n\t\t\t\t\"Unfortunately, v0.7.3 will be the last version of Shattered Pixel Dungeon which supports Android 2.2 Froyo.\\n\\n\" +\n\t\t\t\t\"While investigating future improvements to the game, I have discovered that it is not possible to support Android 2.2 devices while also implementing the technical improvements I have planned.\\n\\n\" +\n\t\t\t\t\"Android 2.2 was originally released in may 2010, and was succeeded by android 2.3 in december 2010.\\n\\n\" +\n\t\t\t\t\"I do not currently have any plans to drop support for other Android versions, and new versions of Shattered should hopefully support Android 2.3+ for the foreseeable future.\\n\\n\" +\n\t\t\t\t\"If you'd like to stay up to date with Shattered's development and do not have an Android 2.3+ device, you can still read about future updates over at: _www.ShatteredPixel.com_\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Shattered honeypots are now stackable, and can be sold for a small amount of gold.\\n\\n\" +\n\t\t\t\t\"_-_ The changes list has been split into three separate groups, so that the game's entire change history isn't loaded all at once.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.7.3):\\n\" +\n\t\t\t\t\"_-_ Additional cases where thrown weapons would be lost when fighting Tengu\\n\" +\n\t\t\t\t\"_-_ Poison dart traps dealing more damage when they were not visible\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 0.7.3):\\n\" +\n\t\t\t\t\"_-_ Odd behaviour when the player is killed by electricity or a grim weapon\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\t\t\n\t\tchanges = new ChangeInfo(\"v0.7.3a\", false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Tengu now throws his shurikens one at a time, just like other ranged enemies. The speed of the shurikens has been increased to compensate, so that the player doesn't need to keep waiting while Tengu's attacks are in flight.\\n\\n\" +\n\t\t\t\t\"_-_ After the tengu boss battle, any extra items now drop in tengu's cell, instead of a random prison cell.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed (caused by 0.7.3):\\n\" +\n\t\t\t\t\"_-_ Cases where tipping darts would result in some darts being lost\\n\" +\n\t\t\t\t\"_-_ Thrown weapons sometimes being lost in the Tengu fight\\n\\n\" +\n\t\t\t\t\"Fixed (existed prior to 0.7.3):\\n\" +\n\t\t\t\t\"_-_ Explosions destroying armor with the warrior's seal on it\\n\" +\n\t\t\t\t\"_-_ Various minor visual bugs\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released May 23rd, 2019\\n\" +\n\t\t\t\t\"_-_ 66 days after Shattered v0.7.2\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing(0xFFFF00)), \"Enchantment Changes\",\n\t\t\t\t\"Several changes have been made to enchantments, based on feedback from 0.7.2:\\n\\n\" +\n\t\t\t\t\"_-_ Precise and swift enchantments have been removed.\\n\\n\" +\n\t\t\t\t\"_-_ Lucky and blooming are now uncommon enchants, instead of rare and common.\\n\\n\" +\n\t\t\t\t\"_-_ Kinetic is a new common enchantment! This enchantment preserves excess damage when an enemy is killed and applies it to your next hit.\\n\\n\" +\n\t\t\t\t\"_-_ Corrupting is a new rare enchantment! When killing an enemy, there is a chance you will corrupt it instead.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.KUNAI, null), \"New Thrown Weapons\",\n\t\t\t\t\"Four new thrown weapons have been added!\\n\\n\" +\n\t\t\t\t\"_-_ Throwing clubs are a tier-2 weapon with extra durability\\n\\n\" +\n\t\t\t\t\"_-_ Kunai are a tier-3 weapon with bonus damage on sneak attacks\\n\\n\" +\n\t\t\t\t\"_-_ Heavy boomerangs are a tier-4 weapon which returns after being thrown\\n\\n\" +\n\t\t\t\t\"_-_ Force cubes are a tier-5 weapon which damage enemies in a 3x3 area\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ELIXIR_ARCANE, null), \"New Boss Recipes\",\n\t\t\t\t\"Two new recipes have been added, one which uses goo blobs and another which uses metal shards.\\n\\n\" +\n\t\t\t\t\"_-_ Elixir of arcane armor requires a goo blob and a potion of earthen armor. It grants a long-lasting resistance to magic.\\n\\n\" +\n\t\t\t\t\"_-_ Wild energy requires a metal shard and a scroll of mystical energy. It grants large amounts of recharging, but with some unpredictable effects attached!\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Dart(),\n\t\t\t\t\"Dart tipping has been removed from the alchemy system. Darts can instead be tipped right from the inventory.\\n\\n\" +\n\t\t\t\t\"Tipped darts have had their shop price reduced by 33%, and can now be cleaned if you don't wish to use the effect.\\n\\n\" +\n\t\t\t\t\"The alchemy guide has been adjusted due to the removal of dart tipping from alchemy. It now has 9 pages (down from 10), and the order of pages have been adjusted to put some simpler recipes earlier.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ The hero will no longer step onto visible traps if that trap wasn't discovered when movement started.\\n\\n\" +\n\t\t\t\t\"_-_ When the mage's staff is cursed, the wand within the staff will now also be cursed.\\n\\n\" +\n\t\t\t\t\"_-_ Scrolls of transmutation can now be used on thrown weapons.\\n\\n\" +\n\t\t\t\t\"_-_ Improved the coloration of crystal keys. They should now be more distinct from iron keys.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Prismatic images causing errors when falling into pits\\n\" +\n\t\t\t\t\"_-_ Secret rooms never spawning in the earlier parts of a region\\n\" +\n\t\t\t\t\"_-_ Curse of multiplicity not working correctly on boss floors\\n\" +\n\t\t\t\t\"_-_ Curse of multiplicity closing doors when it shouldn't\\n\" +\n\t\t\t\t\"_-_ Ring of wealth rarely generating items which are blocked by challenges\\n\" +\n\t\t\t\t\"_-_ Windows rarely appearing in places they shouldn't\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.WARRIOR, 0, 90, 12, 15), \"Berserker & Gladiator\",\n\t\t\t\t\"Because of nerfs I have made to the scaling of the warrior's shield regen, I have some power budget to give to his subclasses!\\n\\n\" +\n\t\t\t\t\"Berserker rate of rage loss decreased by 50%. It should now be easier to hold onto rage at higher health, but being injured will still help to retain it longer.\\n\\n\" +\n\t\t\t\t\"Gladiator is now significantly more flexible:\\n\" +\n\t\t\t\t\"_-_ Using items no longer resets combo\\n\" +\n\t\t\t\t\"_-_ Throwing weapons now increment combo\\n\" +\n\t\t\t\t\"_-_ Slam ability now deals damage based on armor, instead of simply increasing damage.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CURSE_INFUSE, null), \"Boss Recipe Buffs\",\n\t\t\t\t\"All recipes made with ingredients dropped by bosses have been buffed (except bombs):\\n\\n\" +\n\t\t\t\t\"_-_ Caustic brew now affects a 7x7 area, up from 5x5. Energy cost of caustic brew reduced to 4 from 8.\\n\\n\" +\n\t\t\t\t\"_-_ Elixir of aquatic rejuvenation now heals faster, and does not waste healing if the hero is not in water. Total amount of healing reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Curse Infusion now grants a single upgrade to wands/weapons/armor in addition to cursing. This upgrade is lost if the item is uncursed.\\n\\n\" +\n\t\t\t\t\"_-_ Reclaim trap no longer grants recharging, now stores the trap instead. The trap can then be triggered anywhere the player likes.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_EMERALD, null), \"Other Item Buffs\",\n\t\t\t\t\"_-_ Ring of elements now grants 20% resistance per level, up from 16%. However, ring of elements also no longer applies to melee attacks from magic-wielding enemies.\\n\\n\" +\n\t\t\t\t\"_-_ Throwing stone base damage increased to 2-5 from 1-5\\n\" +\n\t\t\t\t\"_-_ Throwing stone durability increased to 5 from 3\\n\\n\" +\n\t\t\t\t\"_-_ Throwing hammer base damage increased to 10-20 from 8-20\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_SCALE, new ItemSprite.Glowing( 0x663300 )), \"Enchant/Glyph Buffs\",\n\t\t\t\t\"_-_ Vampiric now has a chance to heal for large amounts, instead of always healing for small amounts.\\n\\n\" +\n\t\t\t\t\"_-_ Entanglement no longer roots, now only applies herbal armor buff. Amount of herbal armor granted reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Affection charm duration up to 8-12 from 4-12. This means an affection proc now guarantees a free hit.\\n\\n\" +\n\t\t\t\t\"_-_ Potential no longer grants small amounts of partial charge on every hit, now has a chance to grant one full charge instead. Overall amount of charge given increased by ~20%.\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Tomahawk(),\n\t\t\t\t\"The Tomahawk has been adjusted to make its damage more upfront, but also to reduce its extreme damage scaling with upgrades.\\n\\n\" +\n\t\t\t\t\"_-_ Tomahawk damage scaling increased to 2-4 per level, up from 2-2\\n\" +\n\t\t\t\t\"_-_ Tomahawk bleed damage now starts at 60% of damage, down from 100%\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.WARRIOR, 0, 15, 12, 15), \"Warrior Nerfs\",\n\t\t\t\t\"Warrior shielding regeneration scaling reduced. It is now a flat 1 shield every 30 turns. This is a very slight buff to the earlygame, and a significant nerf to the lategame.\\n\\n\" +\n\t\t\t\t\"I made this change as too much of the warrior's power was put into his base class, and into a passive ability that players tend to ignore. By removing this power, I can put more power into the warrior's subclasses, which should make the warrior feel more fun and interesting without significantly nerfing him overall.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.TERRAIN_FEATURES, 16, 0, 16, 16), \"Trap Adjustments!\",\n\t\t\t\t\"Several traps have been slightly adjusted due to reclaim trap's new functionality:\\n\\n\" +\n\t\t\t\t\"_-_ Disintegration trap no longer deals damage based on target HP\\n\" +\n\t\t\t\t\"_-_ Flock trap duration no longer scales with depth\\n\" +\n\t\t\t\t\"_-_ Bosses now resist grim traps, Yog is immune\\n\" +\n\t\t\t\t\"_-_ Pitfall traps do not work on boss floors\\n\" +\n\t\t\t\t\"_-_ Reduced poison dart trap damage scaling\\n\" +\n\t\t\t\t\"_-_ Rockfall traps trigger in a 5x5 AOE when cast from reclaim trap\\n\" +\n\t\t\t\t\"_-_ Bosses will resist weakening traps\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_PLATE, new ItemSprite.Glowing( 0x660022 )), \"Enchant/Glyph Nerfs\",\n\t\t\t\t\"_-_ Chilling now only stacks the chilled debuff up to 6 turns.\\n\\n\" +\n\t\t\t\t\"_-_ Thorns now bleeds enemies for a set amount based on armor level, instead of scaling with damage dealt.\\n\\n\" +\n\t\t\t\t\"_-_ Antimagic no longer affects the melee attacks of magic wielding enemies.\\n\" +\n\t\t\t\t\"_-_ Antimagic no longer bases its blocking power on armor directly, now uses its own calculation which scales on level. This is a slight boost for lower tier armors and a nerf for higher tier ones.\"));\n\t}",
          "sourceCodeAfterRefactoring": "public static void add_v0_7_3_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.3\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released May 23rd, 2019\\n\" +\n\t\t\t\t\"_-_ 66 days after Shattered v0.7.2\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing(0xFFFF00)), \"Enchantment Changes\",\n\t\t\t\t\"Several changes have been made to enchantments, based on feedback from 0.7.2:\\n\\n\" +\n\t\t\t\t\"_-_ Precise and swift enchantments have been removed.\\n\\n\" +\n\t\t\t\t\"_-_ Lucky and blooming are now uncommon enchants, instead of rare and common.\\n\\n\" +\n\t\t\t\t\"_-_ Kinetic is a new common enchantment! This enchantment preserves excess damage when an enemy is killed and applies it to your next hit.\\n\\n\" +\n\t\t\t\t\"_-_ Corrupting is a new rare enchantment! When killing an enemy, there is a chance you will corrupt it instead.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.KUNAI, null), \"New Thrown Weapons\",\n\t\t\t\t\"Four new thrown weapons have been added!\\n\\n\" +\n\t\t\t\t\"_-_ Throwing clubs are a tier-2 weapon with extra durability\\n\\n\" +\n\t\t\t\t\"_-_ Kunai are a tier-3 weapon with bonus damage on sneak attacks\\n\\n\" +\n\t\t\t\t\"_-_ Heavy boomerangs are a tier-4 weapon which returns after being thrown\\n\\n\" +\n\t\t\t\t\"_-_ Force cubes are a tier-5 weapon which damage enemies in a 3x3 area\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ELIXIR_ARCANE, null), \"New Boss Recipes\",\n\t\t\t\t\"Two new recipes have been added, one which uses goo blobs and another which uses metal shards.\\n\\n\" +\n\t\t\t\t\"_-_ Elixir of arcane armor requires a goo blob and a potion of earthen armor. It grants a long-lasting resistance to magic.\\n\\n\" +\n\t\t\t\t\"_-_ Wild energy requires a metal shard and a scroll of mystical energy. It grants large amounts of recharging, but with some unpredictable effects attached!\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Dart(),\n\t\t\t\t\"Dart tipping has been removed from the alchemy system. Darts can instead be tipped right from the inventory.\\n\\n\" +\n\t\t\t\t\"Tipped darts have had their shop price reduced by 33%, and can now be cleaned if you don't wish to use the effect.\\n\\n\" +\n\t\t\t\t\"The alchemy guide has been adjusted due to the removal of dart tipping from alchemy. It now has 9 pages (down from 10), and the order of pages have been adjusted to put some simpler recipes earlier.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Shattered honeypots are now stackable, and can be sold for a small amount of gold.\\n\\n\" +\n\t\t\t\t\"_-_ The changes list has been split into three separate groups, so that the game's entire change history isn't loaded all at once.\\n\\n\" +\n\t\t\t\t\"_-_ Tengu now throws his shurikens one at a time, just like other ranged enemies. The speed of the shurikens has been increased to compensate, so that the player doesn't need to keep waiting while Tengu's attacks are in flight.\\n\\n\" +\n\t\t\t\t\"_-_ After the tengu boss battle, any extra items now drop in tengu's cell, instead of a random prison cell.\\n\\n\" +\n\t\t\t\t\"_-_ The hero will no longer step onto visible traps if that trap wasn't discovered when movement started.\\n\\n\" +\n\t\t\t\t\"_-_ When the mage's staff is cursed, the wand within the staff will now also be cursed.\\n\\n\" +\n\t\t\t\t\"_-_ Scrolls of transmutation can now be used on thrown weapons.\\n\\n\" +\n\t\t\t\t\"_-_ Improved the coloration of crystal keys. They should now be more distinct from iron keys.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Prismatic images causing errors when falling into pits\\n\" +\n\t\t\t\t\"_-_ Secret rooms never spawning in the earlier parts of a region\\n\" +\n\t\t\t\t\"_-_ Curse of multiplicity not working correctly on boss floors\\n\" +\n\t\t\t\t\"_-_ Curse of multiplicity closing doors when it shouldn't\\n\" +\n\t\t\t\t\"_-_ Ring of wealth rarely generating items which are blocked by challenges\\n\" +\n\t\t\t\t\"_-_ Windows rarely appearing in places they shouldn't\\n\" +\n\t\t\t\t\"_-_ Odd behaviour when the player is killed by electricity or a grim weapon\\n\" +\n\t\t\t\t\"_-_ Explosions destroying armor with the warrior's seal on it\\n\" +\n\t\t\t\t\"_-_ Various minor visual bugs\\n\" +\n\t\t\t\t\"_-_ Various rare crash bugs\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.WARRIOR, 0, 90, 12, 15), \"Berserker & Gladiator\",\n\t\t\t\t\"Because of nerfs I have made to the scaling of the warrior's shield regen, I have some power budget to give to his subclasses!\\n\\n\" +\n\t\t\t\t\"Berserker rate of rage loss decreased by 50%. It should now be easier to hold onto rage at higher health, but being injured will still help to retain it longer.\\n\\n\" +\n\t\t\t\t\"Gladiator is now significantly more flexible:\\n\" +\n\t\t\t\t\"_-_ Using items no longer resets combo\\n\" +\n\t\t\t\t\"_-_ Throwing weapons now increment combo\\n\" +\n\t\t\t\t\"_-_ Slam ability now deals damage based on armor, instead of simply increasing damage.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.CURSE_INFUSE, null), \"Boss Recipe Buffs\",\n\t\t\t\t\"All recipes made with ingredients dropped by bosses have been buffed (except bombs):\\n\\n\" +\n\t\t\t\t\"_-_ Caustic brew now affects a 7x7 area, up from 5x5. Energy cost of caustic brew reduced to 4 from 8.\\n\\n\" +\n\t\t\t\t\"_-_ Elixir of aquatic rejuvenation now heals faster, and does not waste healing if the hero is not in water. Total amount of healing reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Curse Infusion now grants a single upgrade to wands/weapons/armor in addition to cursing. This upgrade is lost if the item is uncursed.\\n\\n\" +\n\t\t\t\t\"_-_ Reclaim trap no longer grants recharging, now stores the trap instead. The trap can then be triggered anywhere the player likes.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.RING_EMERALD, null), \"Other Item Buffs\",\n\t\t\t\t\"_-_ Ring of elements now grants 20% resistance per level, up from 16%. However, ring of elements also no longer applies to melee attacks from magic-wielding enemies.\\n\\n\" +\n\t\t\t\t\"_-_ Throwing stone base damage increased to 2-5 from 1-5\\n\" +\n\t\t\t\t\"_-_ Throwing stone durability increased to 5 from 3\\n\\n\" +\n\t\t\t\t\"_-_ Throwing hammer base damage increased to 10-20 from 8-20\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_SCALE, new ItemSprite.Glowing( 0x663300 )), \"Enchant/Glyph Buffs\",\n\t\t\t\t\"_-_ Vampiric now has a chance to heal for large amounts, instead of always healing for small amounts.\\n\\n\" +\n\t\t\t\t\"_-_ Entanglement no longer roots, now only applies herbal armor buff. Amount of herbal armor granted reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Affection charm duration up to 8-12 from 4-12. This means an affection proc now guarantees a free hit.\\n\\n\" +\n\t\t\t\t\"_-_ Potential no longer grants small amounts of partial charge on every hit, now has a chance to grant one full charge instead. Overall amount of charge given increased by ~20%.\"));\n\t\t\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(new Tomahawk(),\n\t\t\t\t\"The Tomahawk has been adjusted to make its damage more upfront, but also to reduce its extreme damage scaling with upgrades.\\n\\n\" +\n\t\t\t\t\"_-_ Tomahawk damage scaling increased to 2-4 per level, up from 2-2\\n\" +\n\t\t\t\t\"_-_ Tomahawk bleed damage now starts at 60% of damage, down from 100%\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.WARRIOR, 0, 15, 12, 15), \"Warrior Nerfs\",\n\t\t\t\t\"Warrior shielding regeneration scaling reduced. It is now a flat 1 shield every 30 turns. This is a very slight buff to the earlygame, and a significant nerf to the lategame.\\n\\n\" +\n\t\t\t\t\"I made this change as too much of the warrior's power was put into his base class, and into a passive ability that players tend to ignore. By removing this power, I can put more power into the warrior's subclasses, which should make the warrior feel more fun and interesting without significantly nerfing him overall.\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton( new Image(Assets.TERRAIN_FEATURES, 16, 0, 16, 16), \"Trap Adjustments!\",\n\t\t\t\t\"Several traps have been slightly adjusted due to reclaim trap's new functionality:\\n\\n\" +\n\t\t\t\t\"_-_ Disintegration trap no longer deals damage based on target HP\\n\" +\n\t\t\t\t\"_-_ Flock trap duration no longer scales with depth\\n\" +\n\t\t\t\t\"_-_ Bosses now resist grim traps, Yog is immune\\n\" +\n\t\t\t\t\"_-_ Pitfall traps do not work on boss floors\\n\" +\n\t\t\t\t\"_-_ Reduced poison dart trap damage scaling\\n\" +\n\t\t\t\t\"_-_ Rockfall traps trigger in a 5x5 AOE when cast from reclaim trap\\n\" +\n\t\t\t\t\"_-_ Bosses will resist weakening traps\"));\n\t\t\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_PLATE, new ItemSprite.Glowing( 0x660022 )), \"Enchant/Glyph Nerfs\",\n\t\t\t\t\"_-_ Chilling now only stacks the chilled debuff up to 6 turns.\\n\\n\" +\n\t\t\t\t\"_-_ Thorns now bleeds enemies for a set amount based on armor level, instead of scaling with damage dealt.\\n\\n\" +\n\t\t\t\t\"_-_ Antimagic no longer affects the melee attacks of magic wielding enemies.\\n\" +\n\t\t\t\t\"_-_ Antimagic no longer bases its blocking power on armor directly, now uses its own calculation which scales on level. This is a slight boost for lower tier armors and a nerf for higher tier ones.\"));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add_v0_7_4_Changes( ArrayList<ChangeInfo> changeInfos ){\n\t\tChangeInfo changes = new ChangeInfo(\"v0.7.4\", true, \"\");\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"new\"), false, null);\n\t\tchanges.hardlight( Window.TITLE_COLOR );\n\t\tchangeInfos.add(changes);\n\t\t\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.SHPX), \"Developer Commentary\",\n\t\t\t\t\"_-_ Released July 18th, 2019\\n\" +\n\t\t\t\t\"_-_ 56 days after Shattered v0.7.3\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"Dev commentary will be added here in the future.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfWarding(),\n\t\t\t\t\"This brand new wand spawns autonomous wards which attack enemies. Wards can be upgraded by being zapped again, and eventually form up into sentry turrets.\\n\\n\" +\n\t\t\t\t\"The Wand of Warding does very consistent damage, but requires some setup first.\"));\n\n\t\tchanges.addButton( new ChangeButton(new WandOfLivingEarth(),\n\t\t\t\t\"This new wand has a lower damage output, but grants significant defensive power. The rocks the wand shoots at enemies reform around the hero and absorb damage. If enough rock is built, it will form up into a rock guardian which fights with the player.\\n\\n\" +\n\t\t\t\t\"The Wand of Living Earth is lacking in offensive output, but does a great job of pulling focus and damage away from the player.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"changes\"), false, null);\n\t\tchanges.hardlight( CharSprite.WARNING );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.EXOTIC_BERKANAN), \"Ally AI improvements\",\n\t\t\t\t\"Allies which follow the player are now considered to be 'intelligent', and have the following improved behaviours:\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will not attack enemies which are asleep, or which haven't noticed the player yet.\\n\" +\n\t\t\t\t\"_-_ Intelligent allies will follow the hero through stairs so long as they are near to them.\\n\\n\" +\n\t\t\t\t\"Lastly, the hero can now swap places with any ally, even unintelligent ones.\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.PREFS), Messages.get(ChangesScene.class, \"misc\"),\n\t\t\t\t\"_-_ Overhauled main menu interface to allow for more expandability.\\n\\n\" +\n\t\t\t\t\"_-_ Ring of elements and antimagic effects now apply to damage from wands.\\n\\n\" +\n\t\t\t\t\"_-_ Added a little surprise if you reach the surface with an upgraded ally item.\\n\\n\" +\n\t\t\t\t\"_-_ The great crab can now only block one enemy at a time.\\n\\n\" +\n\t\t\t\t\"_-_ Shattered Pixel Dungeon now requires Android 2.3+ to run, up from Android 2.2+.\\n\\n\" +\n\t\t\t\t\"_-_ Google Play Games and sharing gameplay data now requires android 4.1+, up from 4.0+.\"));\n\n\t\tchanges.addButton( new ChangeButton(new Image(Assets.SPINNER, 144, 0, 16, 16), Messages.get(ChangesScene.class, \"bugfixes\"),\n\t\t\t\t\"Fixed:\\n\" +\n\t\t\t\t\"_-_ Shattered pots being lost if the player has a full inventory\\n\" +\n\t\t\t\t\"_-_ Doors incorrectly closing when swapping places with an ally\\n\" +\n\t\t\t\t\"_-_ Various rare bugs with heavy boomerangs\\n\" +\n\t\t\t\t\"_-_ Various minor text errors\"));\n\n\t\tchanges.addButton( new ChangeButton(Icons.get(Icons.LANGS), Messages.get(ChangesScene.class, \"language\"),\n\t\t\t\t\"Updated Translations\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"buffs\"), false, null);\n\t\tchanges.hardlight( CharSprite.POSITIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new DriedRose(),\n\t\t\t\t\"The Dried Rose's ghost hero has received some buffs and adjustments to go along with other ally improvements:\\n\\n\" +\n\t\t\t\t\"_-_ The ghost hero can now be given instructions by using the rose after summoning them, and tapping on a location.\\n\\n\" +\n\t\t\t\t\"_-_ Ghost HP scaling increased to 8 per petal, from 4.\\n\" +\n\t\t\t\t\"_-_ Ghost evasion reduced to 1x hero evasion from 2x.\\n\" +\n\t\t\t\t\"_-_ Ghost now heals over time while they are summoned.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.NOISEMAKER, null), \"Enhanced Bomb Buffs\",\n\t\t\t\t\"Many enchant bombs are performing poorly compared to some of the more popular ones, such as holy bombs and boss bombs. While I am toning down the strongest bombs a bit, I'm also making some pretty significant buffs to weaker bombs:\\n\\n\" +\n\t\t\t\t\"_-_ Frost bomb cost down to 2 from 3, now instantly freezes enemies caught in the blast in addition to chilling.\\n\" +\n\t\t\t\t\"_-_ Woolly bomb cost down to 2 from 3, now does regular bomb damage in addition to spawning sheep.\\n\" +\n\t\t\t\t\"_-_ Noisemaker now explodes when an enemy is attracted to its location.\\n\" +\n\t\t\t\t\"_-_ Flashbang cost increased to 6 from 5, now deals regular bomb damage and debuffs in a smaller AOE.\\n\" +\n\t\t\t\t\"_-_ Shock bomb cost increased to 6 from 5, now stuns/damages immediately instead of over time with electricity.\\n\" +\n\t\t\t\t\"_-_ Regrowth bomb cost increased to 8 from 6, now heals significantly more and spawns more plants.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.LONGSWORD, new ItemSprite.Glowing(0xFF4400)), \"Enchant/Glyph Buffs\",\n\t\t\t\t\"Continuing from the changes in 0.7.3, I'm still watching enchantment balance and making buffs where there's room to do so:\\n\\n\" +\n\t\t\t\t\"_-_ Blazing Enchantment bonus damage increased to 2/3 of burning damage, from 1-3.\\n\" +\n\t\t\t\t\"_-_ Shocking Enchantment damage increased to 40% from 33%.\\n\" +\n\t\t\t\t\"_-_ Blooming Enchantment chance for a second tile of grass increased to 10% per level, from 5%.\\n\" +\n\t\t\t\t\"_-_ Lucky Enchantment proc chance scaling with levels increased by ~2x.\\n\" +\n\t\t\t\t\"_-_ Corrupting Enchantment base proc chance increased to 15% from 10%, scaling reduced to compensate.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Flow now grants a flat 2x speed boost in water, up from 1.5x + 0.1x per level.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.WILD_ENERGY, null), \"Misc Item Buffs\",\n\t\t\t\t\"_-_ Wild energy now gives 4 turns of charging instantly, and 8 turns over time. Up from 10 turns over time.\\n\\n\" +\n\t\t\t\t\"_-_ Stone of Clairvoyance radius increased to 12 from 8. This increases the area by ~2.25x.\\n\\n\" +\n\t\t\t\t\"_-_ Allies are now healed by magical sleep, just like the hero.\"));\n\n\t\tchanges = new ChangeInfo(Messages.get(ChangesScene.class, \"nerfs\"), false, null);\n\t\tchanges.hardlight( CharSprite.NEGATIVE );\n\t\tchangeInfos.add(changes);\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARMOR_MAIL, new ItemSprite.Glowing(0x88EEFF)), \"Glyph Nerfs\",\n\t\t\t\t\"_-_ Glyph of Thorns bleed amount reduced to 4+lvl from 4+2*lvl, proc rate increased.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Antimagic base damage reduction reduced to 0-4 from 2-4.\\n\\n\" +\n\t\t\t\t\"_-_ Glyph of Brimstone shield generation removed. The glyph now only protects the user from fire and does not also grant shielding when the user is aflame.\"));\n\n\t\tchanges.addButton( new ChangeButton(new ItemSprite(ItemSpriteSheet.ARCANE_BOMB, null), \"Enhanced Bomb Nerfs\",\n\t\t\t\t\"_-_ Holy Bomb no longer blinds characters caught in the blast, recipe cost up to 8 from 6.\\n\\n\" +\n\t\t\t\t\"_-_ Arcane Bomb damage now falls off based on distance. Reduced to 100%/83%/67% from all 100%.\\n\\n\" +\n\t\t\t\t\"_-_ Shrapnel Bomb damage now slightly falls off based on distance. Damage is reduced by 5% per tile of distance.\"));\n\n\t}",
          "uniqueId": "7de9a8b2073a383e740276401b5ab62126f12d8a_63_229_68_167_169_297"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c174e998bc1b9d5ae67fe6dc9f22f73fd0154b0e",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c174e998bc1b9d5ae67fe6dc9f22f73fd0154b0e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void processSoulMark(Char target, int chargesUsed){\n\t\tif (target != Dungeon.hero &&\n\t\t\t\tDungeon.hero.subClass == HeroSubClass.WARLOCK &&\n\t\t\t\t//standard 1 - 0.92^x chance, plus 7%. Starts at 15%\n\t\t\t\tRandom.Float() > (Math.pow(0.92f, (level()*chargesUsed)+1) - 0.07f)){\n\t\t\tSoulMark.prolong(target, SoulMark.class, SoulMark.DURATION + level());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void processSoulMark(Char target, int chargesUsed){\n\t\tprocessSoulMark(target, level(), chargesUsed);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static void processSoulMark(Char target, int wandLevel, int chargesUsed){\n\t\tif (target != Dungeon.hero &&\n\t\t\t\tDungeon.hero.subClass == HeroSubClass.WARLOCK &&\n\t\t\t\t//standard 1 - 0.92^x chance, plus 7%. Starts at 15%\n\t\t\t\tRandom.Float() > (Math.pow(0.92f, (wandLevel*chargesUsed)+1) - 0.07f)){\n\t\t\tSoulMark.prolong(target, SoulMark.class, SoulMark.DURATION + wandLevel);\n\t\t}\n\t}",
          "uniqueId": "c174e998bc1b9d5ae67fe6dc9f22f73fd0154b0e_163_170_167_174_163_165"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ea3f4bb99e49b3f382b0208d5b251f3a2d3d3dbc",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ea3f4bb99e49b3f382b0208d5b251f3a2d3d3dbc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void rangedHit( Char enemy, int cell ){\n\t\t//if this weapon was thrown from a source stack, degrade that stack.\n\t\t//unless a weapon is about to break, then break the one being thrown\n\t\tif (parent != null){\n\t\t\tif (parent.durability <= parent.durabilityPerUse()){\n\t\t\t\tdurability = 0;\n\t\t\t\tparent.durability = MAX_DURABILITY;\n\t\t\t} else {\n\t\t\t\tparent.durability -= parent.durabilityPerUse();\n\t\t\t\tif (parent.durability > 0 && parent.durability <= parent.durabilityPerUse()){\n\t\t\t\t\tif (level() <= 0)GLog.w(Messages.get(this, \"about_to_break\"));\n\t\t\t\t\telse             GLog.n(Messages.get(this, \"about_to_break\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = null;\n\t\t} else {\n\t\t\tdurability -= durabilityPerUse();\n\t\t\tif (durability > 0 && durability <= durabilityPerUse()){\n\t\t\t\tif (level() <= 0)GLog.w(Messages.get(this, \"about_to_break\"));\n\t\t\t\telse             GLog.n(Messages.get(this, \"about_to_break\"));\n\t\t\t}\n\t\t}\n\t\tif (durability > 0){\n\t\t\t//attempt to stick the missile weapon to the enemy, just drop it if we can't.\n\t\t\tif (enemy.isAlive() && sticky) {\n\t\t\t\tPinCushion p = Buff.affect(enemy, PinCushion.class);\n\t\t\t\tif (p.target == enemy){\n\t\t\t\t\tp.stick(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDungeon.level.drop( this, enemy.pos ).sprite.drop();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void rangedHit( Char enemy, int cell ){\n\t\tdecrementDurability();\n\t\tif (durability > 0){\n\t\t\t//attempt to stick the missile weapon to the enemy, just drop it if we can't.\n\t\t\tif (enemy != null && enemy.isAlive() && sticky) {\n\t\t\t\tPinCushion p = Buff.affect(enemy, PinCushion.class);\n\t\t\t\tif (p.target == enemy){\n\t\t\t\t\tp.stick(this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDungeon.level.drop( this, cell ).sprite.drop();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void decrementDurability(){\n\t\t//if this weapon was thrown from a source stack, degrade that stack.\n\t\t//unless a weapon is about to break, then break the one being thrown\n\t\tif (parent != null){\n\t\t\tif (parent.durability <= parent.durabilityPerUse()){\n\t\t\t\tdurability = 0;\n\t\t\t\tparent.durability = MAX_DURABILITY;\n\t\t\t} else {\n\t\t\t\tparent.durability -= parent.durabilityPerUse();\n\t\t\t\tif (parent.durability > 0 && parent.durability <= parent.durabilityPerUse()){\n\t\t\t\t\tif (level() <= 0)GLog.w(Messages.get(this, \"about_to_break\"));\n\t\t\t\t\telse             GLog.n(Messages.get(this, \"about_to_break\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent = null;\n\t\t} else {\n\t\t\tdurability -= durabilityPerUse();\n\t\t\tif (durability > 0 && durability <= durabilityPerUse()){\n\t\t\t\tif (level() <= 0)GLog.w(Messages.get(this, \"about_to_break\"));\n\t\t\t\telse             GLog.n(Messages.get(this, \"about_to_break\"));\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "ea3f4bb99e49b3f382b0208d5b251f3a2d3d3dbc_200_233_235_257_200_213"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4ea4d1ddf05ac83c7c7130522be5aa36a80bd9f1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4ea4d1ddf05ac83c7c7130522be5aa36a80bd9f1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static TippedDart randomTipped(){\n\t\tPlant.Seed s;\n\t\tdo{\n\t\t\ts = (Plant.Seed) Generator.random(Generator.Category.SEED);\n\t\t} while (!types.containsKey(s.getClass()));\n\t\t\n\t\ttry{\n\t\t\treturn (TippedDart) types.get(s.getClass()).newInstance().quantity(2);\n\t\t} catch (Exception e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn null;\n\t\t}\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "public static TippedDart randomTipped( int quantity ){\n\t\tPlant.Seed s;\n\t\tdo{\n\t\t\ts = (Plant.Seed) Generator.random(Generator.Category.SEED);\n\t\t} while (!types.containsKey(s.getClass()));\n\t\t\n\t\treturn getTipped(s, quantity );\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static TippedDart getTipped( Plant.Seed s, int quantity ){\n\t\ttry {\n\t\t\treturn (TippedDart) types.get(s.getClass()).newInstance().quantity(quantity);\n\t\t} catch (Exception e){\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "4ea4d1ddf05ac83c7c7130522be5aa36a80bd9f1_107_120_161_168_170_178"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "39ffe663f49c4d46dad95e313736010636befd78",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/39ffe663f49c4d46dad95e313736010636befd78",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public MagesStaff(Wand wand){\n\t\tthis();\n\t\twand.identify();\n\t\twand.cursed = false;\n\t\tthis.wand = wand;\n\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\twand.curCharges = wand.maxCharges;\n\t\tname = Messages.get(wand, \"staff_name\");\n\t}",
          "sourceCodeAfterRefactoring": "public MagesStaff(Wand wand){\n\t\tthis();\n\t\twand.identify();\n\t\twand.cursed = false;\n\t\tthis.wand = wand;\n\t\tupdateWand(false);\n\t\twand.curCharges = wand.maxCharges;\n\t\tname = Messages.get(wand, \"staff_name\");\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateWand(boolean levelled){\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.level(level());\n\t\t\t//gives the wand one additional max charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = Math.min(curCharges + (levelled ? 1 : 0), wand.maxCharges);\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "uniqueId": "39ffe663f49c4d46dad95e313736010636befd78_85_93_234_243_86_94"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Item imbueWand(Wand wand, Char owner){\n\n\t\twand.cursed = false;\n\t\tthis.wand = null;\n\n\t\t//syncs the level of the two items.\n\t\tint targetLevel = Math.max(this.level(), wand.level());\n\n\t\t//if the staff's level is being overridden by the wand, preserve 1 upgrade\n\t\tif (wand.level() >= this.level() && this.level() > 0) targetLevel++;\n\n\t\tint staffLevelDiff = targetLevel - this.level();\n\t\tif (staffLevelDiff > 0)\n\t\t\tthis.upgrade(staffLevelDiff);\n\t\telse if (staffLevelDiff < 0)\n\t\t\tthis.degrade(Math.abs(staffLevelDiff));\n\n\t\tint wandLevelDiff = targetLevel - wand.level();\n\t\tif (wandLevelDiff > 0)\n\t\t\twand.upgrade(wandLevelDiff);\n\t\telse if (wandLevelDiff < 0)\n\t\t\twand.degrade(Math.abs(wandLevelDiff));\n\n\t\tthis.wand = wand;\n\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\twand.curCharges = wand.maxCharges;\n\t\twand.identify();\n\t\tif (owner != null) wand.charge(owner);\n\n\t\tname = Messages.get(wand, \"staff_name\");\n\n\t\t//This is necessary to reset any particles.\n\t\t//FIXME this is gross, should implement a better way to fully reset quickslot visuals\n\t\tint slot = Dungeon.quickslot.getSlot(this);\n\t\tif (slot != -1){\n\t\t\tDungeon.quickslot.clearSlot(slot);\n\t\t\tupdateQuickslot();\n\t\t\tDungeon.quickslot.setSlot( slot, this );\n\t\t\tupdateQuickslot();\n\t\t}\n\t\t\n\t\tBadges.validateItemLevelAquired(this);\n\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "public Item imbueWand(Wand wand, Char owner){\n\n\t\tthis.wand = null;\n\n\t\t//syncs the level of the two items.\n\t\tint targetLevel = Math.max(this.level() - (curseInfusionBonus ? 1 : 0), wand.level());\n\n\t\t//if the staff's level is being overridden by the wand, preserve 1 upgrade\n\t\tif (wand.level() >= this.level() && this.level() > (curseInfusionBonus ? 1 : 0)) targetLevel++;\n\t\t\n\t\tlevel(targetLevel);\n\t\tthis.wand = wand;\n\t\tupdateWand(false);\n\t\twand.curCharges = wand.maxCharges;\n\t\tif (owner != null) wand.charge(owner);\n\n\t\tname = Messages.get(wand, \"staff_name\");\n\n\t\t//This is necessary to reset any particles.\n\t\t//FIXME this is gross, should implement a better way to fully reset quickslot visuals\n\t\tint slot = Dungeon.quickslot.getSlot(this);\n\t\tif (slot != -1){\n\t\t\tDungeon.quickslot.clearSlot(slot);\n\t\t\tupdateQuickslot();\n\t\t\tDungeon.quickslot.setSlot( slot, this );\n\t\t\tupdateQuickslot();\n\t\t}\n\t\t\n\t\tBadges.validateItemLevelAquired(this);\n\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateWand(boolean levelled){\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.level(level());\n\t\t\t//gives the wand one additional max charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = Math.min(curCharges + (levelled ? 1 : 0), wand.maxCharges);\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "uniqueId": "39ffe663f49c4d46dad95e313736010636befd78_170_214_234_243_173_204"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Item upgrade(boolean enchant) {\n\t\tsuper.upgrade( enchant );\n\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.upgrade();\n\t\t\t//gives the wand one additional charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = Math.min(wand.curCharges + 1, 10);\n\t\t\tupdateQuickslot();\n\t\t}\n\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Item upgrade(boolean enchant) {\n\t\tsuper.upgrade( enchant );\n\n\t\tupdateWand(true);\n\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateWand(boolean levelled){\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.level(level());\n\t\t\t//gives the wand one additional max charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = Math.min(curCharges + (levelled ? 1 : 0), wand.maxCharges);\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "uniqueId": "39ffe663f49c4d46dad95e313736010636befd78_226_240_234_243_216_223"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Item degrade() {\n\t\tsuper.degrade();\n\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.degrade();\n\t\t\t//gives the wand one additional charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = curCharges-1;\n\t\t\tupdateQuickslot();\n\t\t}\n\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Item degrade() {\n\t\tsuper.degrade();\n\n\t\tupdateWand(false);\n\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateWand(boolean levelled){\n\t\tif (wand != null) {\n\t\t\tint curCharges = wand.curCharges;\n\t\t\twand.level(level());\n\t\t\t//gives the wand one additional max charge\n\t\t\twand.maxCharges = Math.min(wand.maxCharges + 1, 10);\n\t\t\twand.curCharges = Math.min(curCharges + (levelled ? 1 : 0), wand.maxCharges);\n\t\t\tupdateQuickslot();\n\t\t}\n\t}",
          "uniqueId": "39ffe663f49c4d46dad95e313736010636befd78_242_256_234_243_225_232"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f4c8a5336d1e53d71d4a0ae992dfaaa74ab17b8a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f4c8a5336d1e53d71d4a0ae992dfaaa74ab17b8a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reignite( Char ch ) {\n\t\tleft = DURATION;\n\t}",
          "sourceCodeAfterRefactoring": "public void reignite( Char ch ) {\n\t\treignite( ch, DURATION );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void reignite( Char ch, float duration ) {\n\t\tleft = duration;\n\t}",
          "uniqueId": "f4c8a5336d1e53d71d4a0ae992dfaaa74ab17b8a_172_174_176_178_172_174"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4fb394214d150f01449c283c57a773018c6bcb60",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4fb394214d150f01449c283c57a773018c6bcb60",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic String info() {\n\n\t\tString info = desc();\n\n\t\tif (levelKnown) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(MeleeWeapon.class, \"stats_known\", tier, augment.damageFactor(min()), augment.damageFactor(max()), STRReq());\n\t\t\tif (STRReq() > Dungeon.hero.STR()) {\n\t\t\t\tinfo += \" \" + Messages.get(Weapon.class, \"too_heavy\");\n\t\t\t} else if (Dungeon.hero.STR() > STRReq()){\n\t\t\t\tinfo += \" \" + Messages.get(Weapon.class, \"excess_str\", Dungeon.hero.STR() - STRReq());\n\t\t\t}\n\t\t} else {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(MeleeWeapon.class, \"stats_unknown\", tier, min(0), max(0), STRReq(0));\n\t\t\tif (STRReq(0) > Dungeon.hero.STR()) {\n\t\t\t\tinfo += \" \" + Messages.get(MeleeWeapon.class, \"probably_too_heavy\");\n\t\t\t}\n\t\t}\n\n\t\tString stats_desc = Messages.get(this, \"stats_desc\");\n\t\tif (!stats_desc.equals(\"\")) info+= \"\\n\\n\" + stats_desc;\n\n\t\tswitch (augment) {\n\t\t\tcase SPEED:\n\t\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"faster\");\n\t\t\t\tbreak;\n\t\t\tcase DAMAGE:\n\t\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"stronger\");\n\t\t\t\tbreak;\n\t\t\tcase NONE:\n\t\t}\n\n\t\tif (enchantment != null && (cursedKnown || !enchantment.curse())){\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"enchanted\", enchantment.name());\n\t\t\tinfo += \" \" + Messages.get(enchantment, \"desc\");\n\t\t}\n\n\t\tif (cursed && isEquipped( Dungeon.hero )) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"cursed_worn\");\n\t\t} else if (cursedKnown && cursed) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"cursed\");\n\t\t} else if (!isIdentified() && cursedKnown){\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"not_cursed\");\n\t\t}\n\t\t\n\t\treturn info;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic String info() {\n\n\t\tString info = desc();\n\n\t\tif (levelKnown) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(MeleeWeapon.class, \"stats_known\", tier, augment.damageFactor(min()), augment.damageFactor(max()), STRReq());\n\t\t\tif (STRReq() > Dungeon.hero.STR()) {\n\t\t\t\tinfo += \" \" + Messages.get(Weapon.class, \"too_heavy\");\n\t\t\t} else if (Dungeon.hero.STR() > STRReq()){\n\t\t\t\tinfo += \" \" + Messages.get(Weapon.class, \"excess_str\", Dungeon.hero.STR() - STRReq());\n\t\t\t}\n\t\t} else {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(MeleeWeapon.class, \"stats_unknown\", tier, min(0), max(0), STRReq(0));\n\t\t\tif (STRReq(0) > Dungeon.hero.STR()) {\n\t\t\t\tinfo += \" \" + Messages.get(MeleeWeapon.class, \"probably_too_heavy\");\n\t\t\t}\n\t\t}\n\n\t\tString statsInfo = statsInfo();\n\t\tif (!statsInfo.equals(\"\")) info += \"\\n\\n\" + statsInfo;\n\n\t\tswitch (augment) {\n\t\t\tcase SPEED:\n\t\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"faster\");\n\t\t\t\tbreak;\n\t\t\tcase DAMAGE:\n\t\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"stronger\");\n\t\t\t\tbreak;\n\t\t\tcase NONE:\n\t\t}\n\n\t\tif (enchantment != null && (cursedKnown || !enchantment.curse())){\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"enchanted\", enchantment.name());\n\t\t\tinfo += \" \" + Messages.get(enchantment, \"desc\");\n\t\t}\n\n\t\tif (cursed && isEquipped( Dungeon.hero )) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"cursed_worn\");\n\t\t} else if (cursedKnown && cursed) {\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"cursed\");\n\t\t} else if (!isIdentified() && cursedKnown){\n\t\t\tinfo += \"\\n\\n\" + Messages.get(Weapon.class, \"not_cursed\");\n\t\t}\n\t\t\n\t\treturn info;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String statsInfo(){\n\t\treturn Messages.get(this, \"stats_desc\");\n\t}",
          "uniqueId": "4fb394214d150f01449c283c57a773018c6bcb60_67_113_115_117_67_113"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "07ba48e8e06a9624533528152a32acaed617e5e5",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/07ba48e8e06a9624533528152a32acaed617e5e5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean act(){\n\t\t\n\t\tint healingThisTick = Math.round(healingLeft * percentHealPerTick) + flatHealPerTick;\n\t\t\n\t\thealingThisTick = (int)GameMath.gate(1, healingThisTick, healingLeft);\n\t\t\n\t\ttarget.HP = Math.min(target.HT, target.HP + healingThisTick);\n\t\t\n\t\ttarget.sprite.showStatus(CharSprite.POSITIVE, Messages.get(this, \"value\", healingThisTick));\n\t\t\n\t\thealingLeft -= healingThisTick;\n\t\t\n\t\tif (healingLeft <= 0){\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean act(){\n\t\t\n\t\ttarget.HP = Math.min(target.HT, target.HP + healingThisTick());\n\t\t\n\t\thealingLeft -= healingThisTick();\n\t\t\n\t\tif (healingLeft <= 0){\n\t\t\tdetach();\n\t\t}\n\t\t\n\t\tspend( TICK );\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int healingThisTick(){\n\t\treturn (int)GameMath.gate(1,\n\t\t\t\tMath.round(healingLeft * percentHealPerTick) + flatHealPerTick,\n\t\t\t\thealingLeft);\n\t}",
          "uniqueId": "07ba48e8e06a9624533528152a32acaed617e5e5_44_64_61_65_45_59"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e855617fe8c0557374c235e9ca956187c696ed00",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e855617fe8c0557374c235e9ca956187c696ed00",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void destroy() {\n\t\tsynchronized ( inputs ) {\n\t\t\tfor (int i = 0; i < inputs.length; i++) {\n\t\t\t\tif (inputs[i] != null && inputs[i].item != null) {\n\t\t\t\t\tif (!(inputs[i].item instanceof AlchemistsToolkit)) {\n\t\t\t\t\t\tif (!inputs[i].item.collect()) {\n\t\t\t\t\t\t\tDungeon.level.drop(inputs[i].item, Dungeon.hero.pos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinputs[i] = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tDungeon.saveAll();\n\t\t\tBadges.saveGlobal();\n\t\t\tJournal.saveGlobal();\n\t\t} catch (IOException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\t\tsuper.destroy();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void destroy() {\n\t\tsynchronized ( inputs ) {\n\t\t\tclearSlots();\n\t\t\tfor (int i = 0; i < inputs.length; i++) {\n\t\t\t\tinputs[i] = null;\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tDungeon.saveAll();\n\t\t\tBadges.saveGlobal();\n\t\t\tJournal.saveGlobal();\n\t\t} catch (IOException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t}\n\t\tsuper.destroy();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void clearSlots(){\n\t\tsynchronized ( inputs ) {\n\t\t\tfor (int i = 0; i < inputs.length; i++) {\n\t\t\t\tif (inputs[i] != null && inputs[i].item != null) {\n\t\t\t\t\tif (!(inputs[i].item instanceof AlchemistsToolkit)) {\n\t\t\t\t\t\tif (!inputs[i].item.collect()) {\n\t\t\t\t\t\t\tDungeon.level.drop(inputs[i].item, Dungeon.hero.pos);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "e855617fe8c0557374c235e9ca956187c696ed00_399_422_444_456_425_442"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "520257ea1f458576afd0ab9cc06b3cce9dc1ae5c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/520257ea1f458576afd0ab9cc06b3cce9dc1ae5c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void evolve() {\n\t\t\n\t\tboolean[] water = Dungeon.level.water;\n\t\tint cell;\n\t\t\n\t\tFire fire = (Fire)Dungeon.level.blobs.get( Fire.class );\n\t\t\n\t\tfor (int i = area.left-1; i <= area.right; i++) {\n\t\t\tfor (int j = area.top-1; j <= area.bottom; j++) {\n\t\t\t\tcell = i + j*Dungeon.level.width();\n\t\t\t\tif (cur[cell] > 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (fire != null && fire.volume > 0 && fire.cur[cell] > 0){\n\t\t\t\t\t\tfire.clear(cell);\n\t\t\t\t\t\toff[cell] = cur[cell] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tChar ch = Actor.findChar( cell );\n\t\t\t\t\tif (ch != null && !ch.isImmune(this.getClass())) {\n\t\t\t\t\t\tif (ch.buff(Frost.class) != null){\n\t\t\t\t\t\t\tBuff.affect(ch, Frost.class, 2f);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tBuff.affect(ch, Chill.class, water[cell] ? 5f : 3f);\n\t\t\t\t\t\t\tChill chill = ch.buff(Chill.class);\n\t\t\t\t\t\t\tif (chill != null && chill.cooldown() >= 10f){\n\t\t\t\t\t\t\t\tBuff.affect(ch, Frost.class, 5f);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tHeap heap = Dungeon.level.heaps.get( cell );\n\t\t\t\t\tif (heap != null) heap.freeze();\n\t\t\t\t\t\n\t\t\t\t\toff[cell] = cur[cell] - 1;\n\t\t\t\t\tvolume += off[cell];\n\t\t\t\t} else {\n\t\t\t\t\toff[cell] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void evolve() {\n\t\t\n\t\tint cell;\n\t\t\n\t\tFire fire = (Fire)Dungeon.level.blobs.get( Fire.class );\n\t\t\n\t\tfor (int i = area.left-1; i <= area.right; i++) {\n\t\t\tfor (int j = area.top-1; j <= area.bottom; j++) {\n\t\t\t\tcell = i + j*Dungeon.level.width();\n\t\t\t\tif (cur[cell] > 0) {\n\t\t\t\t\t\n\t\t\t\t\tif (fire != null && fire.volume > 0 && fire.cur[cell] > 0){\n\t\t\t\t\t\tfire.clear(cell);\n\t\t\t\t\t\toff[cell] = cur[cell] = 0;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tFreezing.freeze(cell);\n\t\t\t\t\t\n\t\t\t\t\toff[cell] = cur[cell] - 1;\n\t\t\t\t\tvolume += off[cell];\n\t\t\t\t} else {\n\t\t\t\t\toff[cell] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void freeze( int cell ){\n\t\tChar ch = Actor.findChar( cell );\n\t\tif (ch != null && !ch.isImmune(Freezing.class)) {\n\t\t\tif (ch.buff(Frost.class) != null){\n\t\t\t\tBuff.affect(ch, Frost.class, 2f);\n\t\t\t} else {\n\t\t\t\tBuff.affect(ch, Chill.class, Dungeon.level.water[cell] ? 5f : 3f);\n\t\t\t\tChill chill = ch.buff(Chill.class);\n\t\t\t\tif (chill != null && chill.cooldown() >= 10f){\n\t\t\t\t\tBuff.affect(ch, Frost.class, 5f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tHeap heap = Dungeon.level.heaps.get( cell );\n\t\tif (heap != null) heap.freeze();\n\t}",
          "uniqueId": "520257ea1f458576afd0ab9cc06b3cce9dc1ae5c_39_81_68_84_39_66"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "eece33925e38520fd1f6ded71428c6c57cb8328e",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/eece33925e38520fd1f6ded71428c6c57cb8328e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\t(hero.buff( Hunger.class )).satisfy( energy );\n\t\t\tGLog.i( message );\n\t\t\t\n\t\t\tswitch (hero.heroClass) {\n\t\t\tcase WARRIOR:\n\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\thero.HP = Math.min( hero.HP + 5, hero.HT );\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\t//1 charge\n\t\t\t\tBuff.affect( hero, Recharging.class, 4f );\n\t\t\t\tScrollOfRecharging.charge( hero );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\tcase HUNTRESS:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.SND_EAT );\n\t\t\t\n\t\t\thero.spend( TIME_TO_EAT );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( message );\n\t\t\t\n\t\t\tfoodProc( hero );\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.SND_EAT );\n\t\t\t\n\t\t\thero.spend( TIME_TO_EAT );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void satisfy( Hero hero ){\n\t\t(hero.buff( Hunger.class )).satisfy( energy );\n\t}",
          "uniqueId": "eece33925e38520fd1f6ded71428c6c57cb8328e_65_105_92_94_65_90"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\t(hero.buff( Hunger.class )).satisfy( energy );\n\t\t\tGLog.i( message );\n\t\t\t\n\t\t\tswitch (hero.heroClass) {\n\t\t\tcase WARRIOR:\n\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\thero.HP = Math.min( hero.HP + 5, hero.HT );\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\t//1 charge\n\t\t\t\tBuff.affect( hero, Recharging.class, 4f );\n\t\t\t\tScrollOfRecharging.charge( hero );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\tcase HUNTRESS:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.SND_EAT );\n\t\t\t\n\t\t\thero.spend( TIME_TO_EAT );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute( hero, action );\n\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tdetach( hero.belongings.backpack );\n\t\t\t\n\t\t\tsatisfy(hero);\n\t\t\tGLog.i( message );\n\t\t\t\n\t\t\tfoodProc( hero );\n\t\t\t\n\t\t\thero.sprite.operate( hero.pos );\n\t\t\thero.busy();\n\t\t\tSpellSprite.show( hero, SpellSprite.FOOD );\n\t\t\tSample.INSTANCE.play( Assets.SND_EAT );\n\t\t\t\n\t\t\thero.spend( TIME_TO_EAT );\n\t\t\t\n\t\t\tStatistics.foodEaten++;\n\t\t\tBadges.validateFoodEaten();\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void foodProc( Hero hero ){\n\t\tswitch (hero.heroClass) {\n\t\t\tcase WARRIOR:\n\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\thero.HP = Math.min( hero.HP + 5, hero.HT );\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase MAGE:\n\t\t\t\t//1 charge\n\t\t\t\tBuff.affect( hero, Recharging.class, 4f );\n\t\t\t\tScrollOfRecharging.charge( hero );\n\t\t\t\tbreak;\n\t\t\tcase ROGUE:\n\t\t\tcase HUNTRESS:\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "uniqueId": "eece33925e38520fd1f6ded71428c6c57cb8328e_65_105_96_113_65_90"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (action.equals(AC_EAT)){\n\n\t\t\tif (!isEquipped(hero)) GLog.i( Messages.get(Artifact.class, \"need_to_equip\") );\n\t\t\telse if (charge == 0)  GLog.i( Messages.get(this, \"no_food\") );\n\t\t\telse {\n\t\t\t\t//consume as many\n\t\t\t\tint chargesToUse = Math.max( 1, hero.buff(Hunger.class).hunger() / (int)(Hunger.STARVING/10));\n\t\t\t\tif (chargesToUse > charge) chargesToUse = charge;\n\t\t\t\thero.buff(Hunger.class).satisfy((Hunger.STARVING/10) * chargesToUse);\n\n\t\t\t\t//if you get at least 80 food energy from the horn\n\t\t\t\tswitch (hero.heroClass) {\n\t\t\t\t\tcase WARRIOR:\n\t\t\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\t\t\thero.HP = Math.min(hero.HP + 5, hero.HT);\n\t\t\t\t\t\t\thero.sprite.emitter().burst(Speck.factory(Speck.HEALING), 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAGE:\n\t\t\t\t\t\t//1 charge\n\t\t\t\t\t\tBuff.affect( hero, Recharging.class, 4f );\n\t\t\t\t\t\tScrollOfRecharging.charge(hero);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ROGUE:\n\t\t\t\t\tcase HUNTRESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tStatistics.foodEaten++;\n\n\t\t\t\tcharge -= chargesToUse;\n\n\t\t\t\thero.sprite.operate(hero.pos);\n\t\t\t\thero.busy();\n\t\t\t\tSpellSprite.show(hero, SpellSprite.FOOD);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_EAT);\n\t\t\t\tGLog.i( Messages.get(this, \"eat\") );\n\n\t\t\t\thero.spend(Food.TIME_TO_EAT);\n\n\t\t\t\tBadges.validateFoodEaten();\n\n\t\t\t\tif (charge >= 15)       image = ItemSpriteSheet.ARTIFACT_HORN4;\n\t\t\t\telse if (charge >= 10)  image = ItemSpriteSheet.ARTIFACT_HORN3;\n\t\t\t\telse if (charge >= 5)   image = ItemSpriteSheet.ARTIFACT_HORN2;\n\t\t\t\telse                    image = ItemSpriteSheet.ARTIFACT_HORN1;\n\n\t\t\t\tupdateQuickslot();\n\t\t\t}\n\n\t\t} else if (action.equals(AC_STORE)){\n\n\t\t\tGameScene.selectItem(itemSelector, mode, Messages.get(this, \"prompt\"));\n\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\n\t\tsuper.execute(hero, action);\n\n\t\tif (action.equals(AC_EAT)){\n\n\t\t\tif (!isEquipped(hero)) GLog.i( Messages.get(Artifact.class, \"need_to_equip\") );\n\t\t\telse if (charge == 0)  GLog.i( Messages.get(this, \"no_food\") );\n\t\t\telse {\n\t\t\t\t//consume as much food as it takes to be full, to a minimum of 1\n\t\t\t\tint chargesToUse = Math.max( 1, hero.buff(Hunger.class).hunger() / (int)(Hunger.STARVING/10));\n\t\t\t\tif (chargesToUse > charge) chargesToUse = charge;\n\t\t\t\thero.buff(Hunger.class).satisfy((Hunger.STARVING/10) * chargesToUse);\n\n\t\t\t\tFood.foodProc( hero );\n\n\t\t\t\tStatistics.foodEaten++;\n\n\t\t\t\tcharge -= chargesToUse;\n\n\t\t\t\thero.sprite.operate(hero.pos);\n\t\t\t\thero.busy();\n\t\t\t\tSpellSprite.show(hero, SpellSprite.FOOD);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_EAT);\n\t\t\t\tGLog.i( Messages.get(this, \"eat\") );\n\n\t\t\t\thero.spend(Food.TIME_TO_EAT);\n\n\t\t\t\tBadges.validateFoodEaten();\n\n\t\t\t\tif (charge >= 15)       image = ItemSpriteSheet.ARTIFACT_HORN4;\n\t\t\t\telse if (charge >= 10)  image = ItemSpriteSheet.ARTIFACT_HORN3;\n\t\t\t\telse if (charge >= 5)   image = ItemSpriteSheet.ARTIFACT_HORN2;\n\t\t\t\telse                    image = ItemSpriteSheet.ARTIFACT_HORN1;\n\n\t\t\t\tupdateQuickslot();\n\t\t\t}\n\n\t\t} else if (action.equals(AC_STORE)){\n\n\t\t\tGameScene.selectItem(itemSelector, mode, Messages.get(this, \"prompt\"));\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nhero.sprite.operate(hero.pos);\n\t\t\t\thero.busy();\n\t\t\t\tSpellSprite.show(hero, SpellSprite.FOOD);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_EAT);\n\t\t\t\tGLog.i( Messages.get(this, \"eat\") );\n\n\t\t\t\thero.spend(Food.TIME_TO_EAT);\n\n\t\t\t\tBadges.validateFoodEaten();\n\n\t\t\t\tif (charge >= 15)       image = ItemSpriteSheet.ARTIFACT_HORN4;\n\t\t\t\telse if (charge >= 10)  image = ItemSpriteSheet.ARTIFACT_HORN3;\n\t\t\t\telse if (charge >= 5)   image = ItemSpriteSheet.ARTIFACT_HORN2;\n\t\t\t\telse                    image = ItemSpriteSheet.ARTIFACT_HORN1;\n\n\t\t\t\tupdateQuickslot();\n\t\t\t}",
          "uniqueId": "eece33925e38520fd1f6ded71428c6c57cb8328e_80_140_96_113_76_120"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0184c86aadef43ef211d8886ad82f314dc35f2bf",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0184c86aadef43ef211d8886ad82f314dc35f2bf",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void splash( int cell ) {\n\n\t\tFire fire = (Fire)Dungeon.level.blobs.get( Fire.class );\n\t\tif (fire != null)\n\t\t\tfire.clear( cell );\n\n\t\tfinal int color = ItemSprite.pick( image, 8, 10 );\n\n\t\tChar ch = Actor.findChar(cell);\n\t\tif (ch != null) {\n\t\t\tBuff.detach(ch, Burning.class);\n\t\t\tBuff.detach(ch, Ooze.class);\n\t\t\tSplash.at( ch.sprite.center(), color, 5 );\n\t\t} else {\n\t\t\tSplash.at( cell, color, 5 );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void splash( int cell ) {\n\n\t\tFire fire = (Fire)Dungeon.level.blobs.get( Fire.class );\n\t\tif (fire != null)\n\t\t\tfire.clear( cell );\n\n\t\tfinal int color = splashColor();\n\n\t\tChar ch = Actor.findChar(cell);\n\t\tif (ch != null) {\n\t\t\tBuff.detach(ch, Burning.class);\n\t\t\tBuff.detach(ch, Ooze.class);\n\t\t\tSplash.at( ch.sprite.center(), color, 5 );\n\t\t} else {\n\t\t\tSplash.at( cell, color, 5 );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int splashColor(){\n\t\treturn ItemSprite.pick( image, 8, 10 );\n\t}",
          "uniqueId": "0184c86aadef43ef211d8886ad82f314dc35f2bf_383_399_383_385_387_403"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c95c5e93ad8ec824fcb0926006300bb42a458399",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c95c5e93ad8ec824fcb0926006300bb42a458399",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n\t\tpublic static Glyph random() {\n\t\t\ttry {\n\t\t\t\treturn ((Class<Glyph>)glyphs[ Random.chances( chances ) ]).newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\")\n\t\tpublic static Glyph random() {\n\t\t\tswitch(Random.chances(typeChances)){\n\t\t\t\tcase 0: default:\n\t\t\t\t\treturn randomCommon();\n\t\t\t\tcase 1:\n\t\t\t\t\treturn randomUncommon();\n\t\t\t\tcase 2:\n\t\t\t\t\treturn randomRare();\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"unchecked\")\n\t\tpublic static Glyph randomCommon(){\n\t\t\ttry {\n\t\t\t\treturn ((Class<Glyph>)Random.oneOf(common)).newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}",
          "uniqueId": "c95c5e93ad8ec824fcb0926006300bb42a458399_573_581_597_605_585_595"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n\t\tpublic static Enchantment random() {\n\t\t\ttry {\n\t\t\t\treturn ((Class<Enchantment>)enchants[ Random.chances( chances ) ]).newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\")\n\t\tpublic static Enchantment random() {\n\t\t\tswitch(Random.chances(typeChances)){\n\t\t\t\tcase 0: default:\n\t\t\t\t\treturn randomCommon();\n\t\t\t\tcase 1:\n\t\t\t\t\treturn randomUncommon();\n\t\t\t\tcase 2:\n\t\t\t\t\treturn randomRare();\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"unchecked\")\n\t\tpublic static Enchantment randomCommon() {\n\t\t\ttry {\n\t\t\t\treturn ((Class<Enchantment>)Random.oneOf(common)).newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}",
          "uniqueId": "c95c5e93ad8ec824fcb0926006300bb42a458399_314_322_334_342_322_332"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e3ec860e18a9498f1278d95f5414b265b49216d3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e3ec860e18a9498f1278d95f5414b265b49216d3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void reset(){\n\t\tsuper.reset();\n\t\tif (handler != null && handler.contains(this)) {\n\t\t\timage = handler.image(this);\n\t\t\tcolor = handler.label(this);\n\t\t}\n\t\tif (isKnown()){\n\t\t\tif (mustThrowPots.contains(this.getClass())) {\n\t\t\t\tdefaultAction = AC_THROW;\n\t\t\t} else if (canThrowPots.contains(this.getClass())){\n\t\t\t\tdefaultAction = AC_CHOOSE;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void reset(){\n\t\tsuper.reset();\n\t\tif (handler != null && handler.contains(this)) {\n\t\t\timage = handler.image(this);\n\t\t\tcolor = handler.label(this);\n\t\t}\n\t\tsetAction();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void setAction(){\n\t\tif (isKnown() && mustThrowPots.contains(this.getClass())) {\n\t\t\tdefaultAction = AC_THROW;\n\t\t} else if (isKnown() &&canThrowPots.contains(this.getClass())){\n\t\t\tdefaultAction = AC_CHOOSE;\n\t\t} else {\n\t\t\tdefaultAction = AC_DRINK;\n\t\t}\n\t}",
          "uniqueId": "e3ec860e18a9498f1278d95f5414b265b49216d3_164_178_186_194_166_174"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void setKnown() {\n\t\tif (!ownedByFruit) {\n\t\t\tif (!isKnown()) {\n\t\t\t\thandler.know(this);\n\t\t\t\tupdateQuickslot();\n\t\t\t\tif (mustThrowPots.contains(this.getClass())){\n\t\t\t\t\tdefaultAction = AC_THROW;\n\t\t\t\t} else if (canThrowPots.contains(this.getClass())){\n\t\t\t\t\tdefaultAction = AC_CHOOSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (Dungeon.hero.isAlive()) {\n\t\t\t\tCatalog.setSeen(getClass());\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void setKnown() {\n\t\tif (!ownedByFruit) {\n\t\t\tif (!isKnown()) {\n\t\t\t\thandler.know(this);\n\t\t\t\tupdateQuickslot();\n\t\t\t\tPotion p = Dungeon.hero.belongings.getItem(getClass());\n\t\t\t\tif (p != null)  p.setAction();\n\t\t\t\tp = Dungeon.hero.belongings.getItem(ExoticPotion.regToExo.get(getClass()));\n\t\t\t\tif (p != null)  p.setAction();\n\t\t\t}\n\t\t\t\n\t\t\tif (Dungeon.hero.isAlive()) {\n\t\t\t\tCatalog.setSeen(getClass());\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void setAction(){\n\t\tif (isKnown() && mustThrowPots.contains(this.getClass())) {\n\t\t\tdefaultAction = AC_THROW;\n\t\t} else if (isKnown() &&canThrowPots.contains(this.getClass())){\n\t\t\tdefaultAction = AC_CHOOSE;\n\t\t} else {\n\t\t\tdefaultAction = AC_DRINK;\n\t\t}\n\t}",
          "uniqueId": "e3ec860e18a9498f1278d95f5414b265b49216d3_293_309_186_194_309_324"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3d47e9a9e81f92da27f796612e083cffb288ca13",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3d47e9a9e81f92da27f796612e083cffb288ca13",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void doRead() {\n\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\t\t\n\t\tteleportHero( curUser );\n\t\tsetKnown();\n\n\t\treadAnimation();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void doRead() {\n\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\t\t\n\t\tteleportPreferringUnseen( curUser );\n\t\tsetKnown();\n\n\t\treadAnimation();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void teleportPreferringUnseen( Hero hero ){\n\t\t\n\t\tif (!(Dungeon.level instanceof RegularLevel)){\n\t\t\tteleportHero( hero );\n\t\t}\n\t\t\n\t\tRegularLevel level = (RegularLevel) Dungeon.level;\n\t\tArrayList<Integer> candidates = new ArrayList<>();\n\t\t\n\t\tRoom r;\n\t\tfor (int i = 0; i < level.length(); i++){\n\t\t\tif (!level.passable[i] || level.visited[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr = level.room(i);\n\t\t\tif (r == null || Actor.findChar(i) != null){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean locked = false;\n\t\t\tfor (Room.Door d : r.connected.values()){\n\t\t\t\tif (d.type == Room.Door.Type.LOCKED || d.type == Room.Door.Type.BARRICADE) {\n\t\t\t\t\tlocked = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (locked){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcandidates.add(i);\n\t\t}\n\t\t\n\t\tif (candidates.isEmpty()){\n\t\t\tteleportHero( hero );\n\t\t} else {\n\t\t\tint pos = Random.element(candidates);\n\t\t\tappear( hero, pos );\n\t\t\tDungeon.level.press( pos, hero );\n\t\t\tDungeon.observe();\n\t\t\tGameScene.updateFog();\n\t\t\tGLog.i( Messages.get(ScrollOfTeleportation.class, \"tele\") );\n\t\t}\n\t\t\n\t}",
          "uniqueId": "3d47e9a9e81f92da27f796612e083cffb288ca13_47_57_133_175_52_62"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0de59c01e9d46af0042f96be4913246d37dca7c1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0de59c01e9d46af0042f96be4913246d37dca7c1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Actor respawner() {\n\t\treturn new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = BUFF_PRIO; //as if it were a buff.\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (Mob mob : mobs.toArray(new Mob[0])){\n\t\t\t\t\tif (mob.alignment == Char.Alignment.ENEMY) count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (count < nMobs()) {\n\n\t\t\t\t\tMob mob = createMob();\n\t\t\t\t\tmob.state = mob.WANDERING;\n\t\t\t\t\tmob.pos = randomRespawnCell();\n\t\t\t\t\tif (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos, mob.pos) >= 4) {\n\t\t\t\t\t\tGameScene.add( mob );\n\t\t\t\t\t\tif (Statistics.amuletObtained) {\n\t\t\t\t\t\t\tmob.beckon( Dungeon.hero.pos );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (Statistics.amuletObtained){\n\t\t\t\t\tspend(TIME_TO_RESPAWN/2f);\n\t\t\t\t} else if (Dungeon.level.feeling == Feeling.DARK){\n\t\t\t\t\tspend(2*TIME_TO_RESPAWN/3f);\n\t\t\t\t} else {\n\t\t\t\t\tspend(TIME_TO_RESPAWN);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Actor respawner() {\n\t\treturn new Actor() {\n\n\t\t\t{\n\t\t\t\tactPriority = BUFF_PRIO; //as if it were a buff.\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected boolean act() {\n\t\t\t\tint count = 0;\n\t\t\t\tfor (Mob mob : mobs.toArray(new Mob[0])){\n\t\t\t\t\tif (mob.alignment == Char.Alignment.ENEMY) count++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (count < nMobs()) {\n\n\t\t\t\t\tMob mob = createMob();\n\t\t\t\t\tmob.state = mob.WANDERING;\n\t\t\t\t\tmob.pos = randomRespawnCell();\n\t\t\t\t\tif (Dungeon.hero.isAlive() && mob.pos != -1 && distance(Dungeon.hero.pos, mob.pos) >= 4) {\n\t\t\t\t\t\tGameScene.add( mob );\n\t\t\t\t\t\tif (Statistics.amuletObtained) {\n\t\t\t\t\t\t\tmob.beckon( Dungeon.hero.pos );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspend(respawnTime());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic float respawnTime(){\n\t\tif (Statistics.amuletObtained){\n\t\t\treturn TIME_TO_RESPAWN/2f;\n\t\t} else if (Dungeon.level.feeling == Feeling.DARK){\n\t\t\treturn 2*TIME_TO_RESPAWN/3f;\n\t\t} else {\n\t\t\treturn TIME_TO_RESPAWN;\n\t\t}\n\t}",
          "uniqueId": "0de59c01e9d46af0042f96be4913246d37dca7c1_467_503_499_507_467_497"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "bc14b0472b58f0d4f2c553bbc1bdbf87a6cd7e76",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/bc14b0472b58f0d4f2c553bbc1bdbf87a6cd7e76",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public int maxExp() {\n\t\treturn 5 + lvl * 5;\n\t}",
          "sourceCodeAfterRefactoring": "public int maxExp() {\n\t\treturn maxExp( lvl );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int maxExp( int lvl ){\n\t\treturn 5 + lvl * 5;\n\t}",
          "uniqueId": "bc14b0472b58f0d4f2c553bbc1bdbf87a6cd7e76_1258_1260_1268_1270_1264_1266"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\n\t\tsuper.create();\n\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\n\t\tuiCamera.visible = false;\n\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\n\t\tfloat width, height;\n\t\tif (SPDSettings.landscape()) {\n\t\t\twidth = WIDTH_L;\n\t\t\theight = HEIGHT_L;\n\t\t} else {\n\t\t\twidth = WIDTH_P;\n\t\t\theight = HEIGHT_P;\n\t\t}\n\n\t\tfloat left = (w - width) / 2;\n\t\tfloat top = (h - height) / 2;\n\t\tfloat bottom = h - top;\n\n\t\tArchs archs = new Archs();\n\t\tarchs.setSize( w, h );\n\t\tadd( archs );\n\n\t\tImage title = BannerSprites.get( Type.SELECT_YOUR_HERO );\n\t\ttitle.x = (w - title.width()) / 2;\n\t\ttitle.y = top;\n\t\talign( title );\n\t\tadd( title );\n\n\t\tbuttonX = left;\n\t\tbuttonY = bottom - BUTTON_HEIGHT;\n\n\t\tbtnNewGame = new GameButton( Messages.get(this, \"new\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tif (GamesInProgress.check( GamesInProgress.curSlot ) != null) {\n\t\t\t\t\tStartScene.this.add( new WndOptions(\n\t\t\t\t\t\t\tMessages.get(StartScene.class, \"really\"),\n\t\t\t\t\t\t\tMessages.get(StartScene.class, \"warning\"),\n\t\t\t\t\t\t\tMessages.get(StartScene.class, \"yes\"),\n\t\t\t\t\t\t\tMessages.get(StartScene.class, \"no\") ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void onSelect( int index ) {\n\t\t\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\t\t\tstartNewGame();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\tstartNewGame();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadd( btnNewGame );\n\n\t\tbtnLoad = new GameButton( Messages.get(this, \"load\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.CONTINUE;\n\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t}\n\t\t};\n\t\tadd( btnLoad );\n\n\t\tfloat centralHeight = buttonY - title.y - title.height();\n\n\t\tHeroClass[] classes = {\n\t\t\t\tHeroClass.WARRIOR, HeroClass.MAGE, HeroClass.ROGUE, HeroClass.HUNTRESS\n\t\t};\n\t\tfor (HeroClass cl : classes) {\n\t\t\tClassShield shield = new ClassShield( cl );\n\t\t\tshields.put( cl, shield );\n\t\t\tadd( shield );\n\t\t}\n\t\tif (SPDSettings.landscape()) {\n\t\t\tfloat shieldW = width / 4;\n\t\t\tfloat shieldH = Math.min( centralHeight, shieldW );\n\t\t\ttop = title.y + title.height + (centralHeight - shieldH) / 2;\n\t\t\tfor (int i=0; i < classes.length; i++) {\n\t\t\t\tClassShield shield = shields.get( classes[i] );\n\t\t\t\tshield.setRect( left + i * shieldW, top, shieldW, shieldH );\n\t\t\t\talign(shield);\n\t\t\t}\n\n\t\t\tChallengeButton challenge = new ChallengeButton();\n\t\t\tchallenge.setPos(\n\t\t\t\t\tw/2 - challenge.width()/2,\n\t\t\t\t\ttop + shieldH/2 - challenge.height()/2 );\n\t\t\tadd( challenge );\n\n\t\t} else {\n\t\t\tfloat shieldW = width / 2;\n\t\t\tfloat shieldH = Math.min( centralHeight / 2, shieldW * 1.2f );\n\t\t\ttop = title.y + title.height() + centralHeight / 2 - shieldH;\n\t\t\tfor (int i=0; i < classes.length; i++) {\n\t\t\t\tClassShield shield = shields.get( classes[i] );\n\t\t\t\tshield.setRect(\n\t\t\t\t\t\tleft + (i % 2) * shieldW,\n\t\t\t\t\t\ttop + (i / 2) * shieldH,\n\t\t\t\t\t\tshieldW, shieldH );\n\t\t\t\talign(shield);\n\t\t\t}\n\n\t\t\tChallengeButton challenge = new ChallengeButton();\n\t\t\tchallenge.setPos(\n\t\t\t\t\tw/2 - challenge.width()/2,\n\t\t\t\t\ttop + shieldH - challenge.height()/2 );\n\t\t\talign(challenge);\n\t\t\tadd( challenge );\n\n\t\t}\n\n\t\tunlock = new Group();\n\t\tadd( unlock );\n\n\t\tif (!(huntressUnlocked = Badges.isUnlocked( Badges.Badge.BOSS_SLAIN_3 ))) {\n\n\t\t\tRenderedTextMultiline text = PixelScene.renderMultiline( Messages.get(this, \"unlock\"), 9 );\n\t\t\ttext.maxWidth((int)width);\n\t\t\ttext.hardlight( 0xFFFF00 );\n\t\t\ttext.setPos(w / 2 - text.width() / 2, (bottom - BUTTON_HEIGHT) + (BUTTON_HEIGHT - text.height()) / 2);\n\t\t\talign(text);\n\t\t\tunlock.add(text);\n\n\t\t}\n\n\t\tExitButton btnExit = new ExitButton();\n\t\tbtnExit.setPos( Camera.main.width - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\n\t\tGamesInProgress.curSlot = 0;\n\t\tActionIndicator.action = null;\n\t\tupdateClass( HeroClass.values()[SPDSettings.lastClass()] );\n\n\t\tfadeIn();\n\n\t\tBadges.loadingListener = new Callback() {\n\t\t\t@Override\n\t\t\tpublic void call() {\n\t\t\t\tif (Game.scene() == StartScene.this) {\n\t\t\t\t\tShatteredPixelDungeon.switchNoFade( StartScene.class );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\t\t\n\t\tBadges.loadGlobal();\n\t\tJournal.loadGlobal();\n\t\t\n\t\tuiCamera.visible = false;\n\t\t\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\t\t\n\t\tArchs archs = new Archs();\n\t\tarchs.setSize( w, h );\n\t\tadd( archs );\n\t\t\n\t\tExitButton btnExit = new ExitButton();\n\t\tbtnExit.setPos( w - btnExit.width(), 0 );\n\t\tadd( btnExit );\n\t\t\n\t\tRenderedText title = PixelScene.renderText( Messages.get(this, \"title\"), 9);\n\t\ttitle.hardlight(Window.TITLE_COLOR);\n\t\ttitle.x = (w - title.width()) / 2f;\n\t\ttitle.y = (16 - title.baseLine()) / 2f;\n\t\talign(title);\n\t\tadd(title);\n\t\t\n\t\tArrayList<GamesInProgress.Info> games = GamesInProgress.checkAll();\n\t\t\n\t\tint slotGap = SPDSettings.landscape() ? 5 : 10;\n\t\tint slotCount = Math.min(GamesInProgress.MAX_SLOTS, games.size()+1);\n\t\tint slotsHeight = slotCount*SLOT_HEIGHT + (slotCount-1)* slotGap;\n\t\t\n\t\tfloat yPos = (h - slotsHeight)/2f;\n\t\tif (SPDSettings.landscape()) yPos += 8;\n\t\t\n\t\tfor (GamesInProgress.Info game : games) {\n\t\t\tSaveSlotButton existingGame = new SaveSlotButton();\n\t\t\texistingGame.set(game.slot);\n\t\t\texistingGame.setRect((w - SLOT_WIDTH) / 2f, yPos, SLOT_WIDTH, SLOT_HEIGHT);\n\t\t\tyPos += SLOT_HEIGHT + slotGap;\n\t\t\talign(existingGame);\n\t\t\tadd(existingGame);\n\t\t\t\n\t\t}\n\t\t\n\t\tif (games.size() < GamesInProgress.MAX_SLOTS){\n\t\t\tSaveSlotButton newGame = new SaveSlotButton();\n\t\t\tnewGame.set(GamesInProgress.firstEmpty());\n\t\t\tnewGame.setRect((w - SLOT_WIDTH) / 2f, yPos, SLOT_WIDTH, SLOT_HEIGHT);\n\t\t\tyPos += SLOT_HEIGHT + slotGap;\n\t\t\talign(newGame);\n\t\t\tadd(newGame);\n\t\t}\n\t\t\n\t\tIconButton challengeButton = new IconButton(\n\t\t\t\tIcons.get( SPDSettings.challenges() > 0 ? Icons.CHALLENGE_ON :Icons.CHALLENGE_OFF)){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tShatteredPixelDungeon.scene().add(new WndChallenges(SPDSettings.challenges(), true) {\n\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\tsuper.onBackPressed();\n\t\t\t\t\t\ticon( Icons.get( SPDSettings.challenges() > 0 ?\n\t\t\t\t\t\t\t\tIcons.CHALLENGE_ON :Icons.CHALLENGE_OFF ) );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\t\t\n\t\tif (SPDSettings.landscape()){\n\t\t\tchallengeButton.setRect(4*slotGap + (w + SLOT_WIDTH - CHALLENGE_SIZE)/2, 8 + (h - CHALLENGE_SIZE)/2f,\n\t\t\t\t\tCHALLENGE_SIZE, CHALLENGE_SIZE);\n\t\t\t\n\t\t} else {\n\t\t\tchallengeButton.setRect((w - CHALLENGE_SIZE)/2f, yPos + 2*slotGap - CHALLENGE_SIZE/2f,\n\t\t\t\t\tCHALLENGE_SIZE, CHALLENGE_SIZE);\n\t\t\t\n\t\t}\n\t\talign(challengeButton);\n\t\t\n\t\tif (!Badges.isUnlocked(Badges.Badge.VICTORY)){\n\t\t\tadd(challengeButton);\n\t\t} else {\n\t\t\tDungeon.challenges = 0;\n\t\t\tSPDSettings.challenges(0);\n\t\t}\n\t\t\n\t\tGamesInProgress.curSlot = 0;\n\t\tActionIndicator.action = null;\n\t\t\n\t\tfadeIn();\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tprotected void onClick() {\n\t\t\tif (newGame) {\n\t\t\t\tShatteredPixelDungeon.scene().add( new WndStartGame(slot));\n\t\t\t} else {\n\t\t\t\tShatteredPixelDungeon.scene().add( new WndGameInProgress(slot));\n\t\t\t}\n\t\t}",
          "uniqueId": "bc14b0472b58f0d4f2c553bbc1bdbf87a6cd7e76_83_235_274_281_57_149"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8461500d669fac5123a7818847a266b9241a18b3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8461500d669fac5123a7818847a266b9241a18b3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\t\t\n\t\tsuper.die( cause );\n\n\t\tfloat lootChance = this.lootChance;\n\t\tlootChance *= RingOfWealth.dropChanceMultiplier( Dungeon.hero );\n\t\t\n\t\tif (Random.Float() < lootChance && Dungeon.hero.lvl <= maxLvl + 2) {\n\t\t\tItem loot = createLoot();\n\t\t\tif (loot != null)\n\t\t\t\tDungeon.level.drop( loot , pos ).sprite.drop();\n\t\t}\n\t\t\n\t\tif (alignment == Alignment.ENEMY && Dungeon.hero.lvl <= maxLvl + 2){\n\t\t\tint rolls = 1;\n\t\t\tif (properties.contains(Property.BOSS))             rolls = 15;\n\t\t\telse if (properties.contains(Property.MINIBOSS))    rolls = 5;\n\t\t\tArrayList<Item> bonus = RingOfWealth.tryRareDrop(Dungeon.hero, rolls);\n\t\t\tif (bonus != null){\n\t\t\t\tfor (Item b : bonus) Dungeon.level.drop( b , pos ).sprite.drop();\n\t\t\t\tnew Flare(8, 32).color(0xFFFF00, true).show(sprite, 2f);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Dungeon.hero.isAlive() && !Dungeon.level.heroFOV[pos]) {\n\t\t\tGLog.i( Messages.get(this, \"died\") );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void die( Object cause ) {\n\t\t\n\t\tsuper.die( cause );\n\n\t\tif (alignment == Alignment.ENEMY){\n\t\t\trollToDropLoot();\n\t\t}\n\t\t\n\t\tif (Dungeon.hero.isAlive() && !Dungeon.level.heroFOV[pos]) {\n\t\t\tGLog.i( Messages.get(this, \"died\") );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void rollToDropLoot(){\n\t\tif (Dungeon.hero.lvl > maxLvl + 2) return;\n\t\t\n\t\tfloat lootChance = this.lootChance;\n\t\tlootChance *= RingOfWealth.dropChanceMultiplier( Dungeon.hero );\n\t\t\n\t\tif (Random.Float() < lootChance) {\n\t\t\tItem loot = createLoot();\n\t\t\tif (loot != null) {\n\t\t\t\tDungeon.level.drop(loot, pos).sprite.drop();\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ring of wealth logic\n\t\tif (Ring.getBonus(Dungeon.hero, RingOfWealth.Wealth.class) > 0) {\n\t\t\tint rolls = 1;\n\t\t\tif (properties.contains(Property.BOSS)) rolls = 15;\n\t\t\telse if (properties.contains(Property.MINIBOSS)) rolls = 5;\n\t\t\tArrayList<Item> bonus = RingOfWealth.tryRareDrop(Dungeon.hero, rolls);\n\t\t\tif (bonus != null) {\n\t\t\t\tfor (Item b : bonus) Dungeon.level.drop(b, pos).sprite.drop();\n\t\t\t\tnew Flare(8, 32).color(0xFFFF00, true).show(sprite, 2f);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "8461500d669fac5123a7818847a266b9241a18b3_553_581_568_592_554_566"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ec724bea023daecbff2f62b58b4e12b9369a3a21",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ec724bea023daecbff2f62b58b4e12b9369a3a21",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean collect( Bag container ) {\n\t\t\n\t\tArrayList<Item> items = container.items;\n\t\t\n\t\tif (items.contains( this )) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor (Item item:items) {\n\t\t\tif (item instanceof Bag && ((Bag)item).grab( this )) {\n\t\t\t\treturn collect( (Bag)item );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (stackable) {\n\t\t\tfor (Item item:items) {\n\t\t\t\tif (isSimilar( item )) {\n\t\t\t\t\titem.quantity += quantity;\n\t\t\t\t\titem.updateQuickslot();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (items.size() < container.size) {\n\t\t\t\n\t\t\tif (Dungeon.hero != null && Dungeon.hero.isAlive()) {\n\t\t\t\tBadges.validateItemLevelAquired( this );\n\t\t\t}\n\t\t\t\n\t\t\titems.add( this );\n\t\t\tDungeon.quickslot.replacePlaceholder(this);\n\t\t\tupdateQuickslot();\n\t\t\tCollections.sort( items, itemComparator );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tGLog.n( Messages.get(Item.class, \"pack_full\", name()) );\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public boolean collect( Bag container ) {\n\t\t\n\t\tArrayList<Item> items = container.items;\n\t\t\n\t\tif (items.contains( this )) {\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor (Item item:items) {\n\t\t\tif (item instanceof Bag && ((Bag)item).grab( this )) {\n\t\t\t\treturn collect( (Bag)item );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (stackable) {\n\t\t\tfor (Item item:items) {\n\t\t\t\tif (isSimilar( item )) {\n\t\t\t\t\titem.merge( this );\n\t\t\t\t\titem.updateQuickslot();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (items.size() < container.size) {\n\t\t\t\n\t\t\tif (Dungeon.hero != null && Dungeon.hero.isAlive()) {\n\t\t\t\tBadges.validateItemLevelAquired( this );\n\t\t\t}\n\t\t\t\n\t\t\titems.add( this );\n\t\t\tDungeon.quickslot.replacePlaceholder(this);\n\t\t\tupdateQuickslot();\n\t\t\tCollections.sort( items, itemComparator );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tGLog.n( Messages.get(Item.class, \"pack_full\", name()) );\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Item merge( Item other ){\n\t\tif (isSimilar( other )){\n\t\t\tquantity += other.quantity;\n\t\t\tother.quantity = 0;\n\t\t}\n\t\treturn this;\n\t}",
          "uniqueId": "ec724bea023daecbff2f62b58b4e12b9369a3a21_162_204_161_167_169_211"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public final Item detach( Bag container ) {\n\t\t\n\t\tif (quantity <= 0) {\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t} else\n\t\tif (quantity == 1) {\n\n\t\t\tif (stackable || this instanceof Boomerang){\n\t\t\t\tDungeon.quickslot.convertToPlaceholder(this);\n\t\t\t}\n\n\t\t\treturn detachAll( container );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tquantity--;\n\t\t\tupdateQuickslot();\n\t\t\t\n\t\t\ttry {\n\n\t\t\t\t//pssh, who needs copy constructors?\n\t\t\t\tItem detached = getClass().newInstance();\n\t\t\t\tBundle copy = new Bundle();\n\t\t\t\tthis.storeInBundle(copy);\n\t\t\t\tdetached.restoreFromBundle(copy);\n\t\t\t\tdetached.quantity(1);\n\n\t\t\t\tdetached.onDetach( );\n\t\t\t\treturn detached;\n\t\t\t} catch (Exception e) {\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public final Item detach( Bag container ) {\n\t\t\n\t\tif (quantity <= 0) {\n\t\t\t\n\t\t\treturn null;\n\t\t\t\n\t\t} else\n\t\tif (quantity == 1) {\n\n\t\t\tif (stackable || this instanceof Boomerang){\n\t\t\t\tDungeon.quickslot.convertToPlaceholder(this);\n\t\t\t}\n\n\t\t\treturn detachAll( container );\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t\n\t\t\tItem detached = split(1);\n\t\t\tupdateQuickslot();\n\t\t\tif (detached != null) detached.onDetach( );\n\t\t\treturn detached;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Item split( int amount ){\n\t\tif (amount <= 0 || amount >= quantity()) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\t//pssh, who needs copy constructors?\n\t\t\t\tItem split = getClass().newInstance();\n\t\t\t\tBundle copy = new Bundle();\n\t\t\t\tthis.storeInBundle(copy);\n\t\t\t\tsplit.restoreFromBundle(copy);\n\t\t\t\tsplit.quantity(amount);\n\t\t\t\tquantity -= amount;\n\t\t\t\t\n\t\t\t\treturn split;\n\t\t\t} catch (Exception e){\n\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "ec724bea023daecbff2f62b58b4e12b9369a3a21_210_246_218_238_240_264"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void cast( final Hero user, int dst ) {\n\t\t\n\t\tfinal int cell = throwPos( user, dst );\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tSample.INSTANCE.play( Assets.SND_MISS, 0.6f, 0.6f, 1.5f );\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\n\t\t// FIXME!!!\n\t\tfloat delay = TIME_TO_THROW;\n\t\tif (this instanceof MissileWeapon) {\n\t\t\tdelay *= ((MissileWeapon)this).speedFactor( user );\n\t\t\tif (enemy != null) {\n\t\t\t\tSnipersMark mark = user.buff( SnipersMark.class );\n\t\t\t\tif (mark != null) {\n\t\t\t\t\tif (mark.object == enemy.id()) {\n\t\t\t\t\t\tdelay *= 0.5f;\n\t\t\t\t\t}\n\t\t\t\t\tuser.remove( mark );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinal float finalDelay = delay;\n\n\t\tif (enemy != null) {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tenemy.sprite,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(finalDelay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} else {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(finalDelay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void cast( final Hero user, final int dst ) {\n\t\t\n\t\tfinal int cell = throwPos( user, dst );\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tSample.INSTANCE.play( Assets.SND_MISS, 0.6f, 0.6f, 1.5f );\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\t\t\n\t\tfinal float delay = castDelay(user, dst);\n\n\t\tif (enemy != null) {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tenemy.sprite,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t} else {\n\t\t\t((MissileSprite) user.sprite.parent.recycle(MissileSprite.class)).\n\t\t\t\t\treset(user.sprite,\n\t\t\t\t\t\t\tcell,\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\tnew Callback() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\t\tItem.this.detach(user.belongings.backpack).onThrow(cell);\n\t\t\t\t\t\t\tuser.spendAndNext(delay);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic float castDelay( Char user, int dst ){\n\t\treturn TIME_TO_THROW;\n\t}",
          "uniqueId": "ec724bea023daecbff2f62b58b4e12b9369a3a21_477_529_535_537_495_533"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onThrow( int cell ) {\n\t\tChar enemy = Actor.findChar( cell );\n\t\tif (enemy == null || enemy == curUser) {\n\t\t\tif (this instanceof Boomerang)\n\t\t\t\tsuper.onThrow( cell );\n\t\t\telse\n\t\t\t\tmiss( cell );\n\t\t} else {\n\t\t\tif (!curUser.shoot( enemy, this )) {\n\t\t\t\tmiss( cell );\n\t\t\t} else if (!(this instanceof Boomerang)){\n\n\t\t\t\tint bonus = RingOfSharpshooting.getBonus(curUser, RingOfSharpshooting.Aim.class);\n\n\t\t\t\tif (curUser.heroClass == HeroClass.HUNTRESS && enemy.buff(PinCushion.class) == null)\n\t\t\t\t\tbonus += 3;\n\n\t\t\t\tif (Random.Float() > Math.pow(0.7, bonus)){\n\t\t\t\t\tif (enemy.isAlive())\n\t\t\t\t\t\tBuff.affect(enemy, PinCushion.class).stick(this);\n\t\t\t\t\telse\n\t\t\t\t\t\tDungeon.level.drop( this, enemy.pos).sprite.drop();\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onThrow( int cell ) {\n\t\tChar enemy = Actor.findChar( cell );\n\t\tif (enemy == null || enemy == curUser) {\n\t\t\t\tsuper.onThrow( cell );\n\t\t} else {\n\t\t\tif (!curUser.shoot( enemy, this )) {\n\t\t\t\trangedMiss( cell );\n\t\t\t} else {\n\n\t\t\t\t//int bonus = RingOfSharpshooting.getBonus(curUser, RingOfSharpshooting.Aim.class);\n\n\t\t\t\t//if (curUser.heroClass == HeroClass.HUNTRESS && enemy.buff(PinCushion.class) == null)\n\t\t\t\t//\tbonus += 3;\n\t\t\t\t\n\t\t\t\trangedHit( enemy );\n\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void rangedHit(Char enemy ){\n\t\treduceDurability();\n\t\tif (durability > 0){\n\t\t\tif (enemy.isAlive())\n\t\t\t\tBuff.affect(enemy, PinCushion.class).stick(this);\n\t\t\telse\n\t\t\t\tDungeon.level.drop( this, enemy.pos).sprite.drop();\n\t\t}\n\t}",
          "uniqueId": "ec724bea023daecbff2f62b58b4e12b9369a3a21_67_94_111_119_72_91"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void drop( Item item ) {\n\t\t\n\t\tif (item.stackable && type != Type.FOR_SALE) {\n\t\t\t\n\t\t\tfor (Item i : items) {\n\t\t\t\tif (i.isSimilar( item )) {\n\t\t\t\t\ti.quantity += item.quantity;\n\t\t\t\t\titem = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems.remove( item );\n\t\t\t\n\t\t}\n\t\t\n\t\tif ((item instanceof Dewdrop || item instanceof DriedRose.Petal) && type != Type.FOR_SALE) {\n\t\t\titems.add( item );\n\t\t} else {\n\t\t\titems.addFirst( item );\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\tif (type == Type.HEAP || type == Type.FOR_SALE)\n\t\t\t\tsprite.view( items.peek() );\n\t\t\telse\n\t\t\t\tsprite.view( image(), glowing() );\n\t\t\tsprite.place( pos );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void drop( Item item ) {\n\t\t\n\t\tif (item.stackable && type != Type.FOR_SALE) {\n\t\t\t\n\t\t\tfor (Item i : items) {\n\t\t\t\tif (i.isSimilar( item )) {\n\t\t\t\t\titem = i.merge( item );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems.remove( item );\n\t\t\t\n\t\t}\n\t\t\n\t\tif ((item instanceof Dewdrop || item instanceof DriedRose.Petal) && type != Type.FOR_SALE) {\n\t\t\titems.add( item );\n\t\t} else {\n\t\t\titems.addFirst( item );\n\t\t}\n\t\t\n\t\tif (sprite != null) {\n\t\t\tif (type == Type.HEAP || type == Type.FOR_SALE)\n\t\t\t\tsprite.view( items.peek() );\n\t\t\telse\n\t\t\t\tsprite.view( image(), glowing() );\n\t\t\tsprite.place( pos );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Item pickUp() {\n\t\t\n\t\tItem item = items.removeFirst();\n\t\tif (items.isEmpty()) {\n\t\t\tdestroy();\n\t\t} else if (sprite != null) {\n\t\t\tsprite.view( image(), glowing() );",
          "uniqueId": "ec724bea023daecbff2f62b58b4e12b9369a3a21_178_206_161_167_178_205"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c290e5fe47101657b2d95c147e96684b8577fe2f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c290e5fe47101657b2d95c147e96684b8577fe2f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\t\tthis.visible = visible;\n\t\tthis.visited = visited;\n\t\tthis.mapped = mapped;\n\t\tthis.brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tmoveToUpdating();\n\n\t\tboolean fullUpdate = updating.height() == mapHeight && updating.width() == mapWidth;\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint cell;\n\t\tint[] colorArray = new int[PIX_PER_TILE*PIX_PER_TILE];\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tcell = mapWidth * i + updating.left;\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\n\t\t\t\tif (cell >= Dungeon.level.length()) continue; //do nothing\n\n\t\t\t\tif (!Dungeon.level.discoverable[cell]\n\t\t\t\t\t\t|| (!visible[cell] && !visited[cell] && !mapped[cell])){\n\t\t\t\t\t//we skip filling cells here if it isn't a full update\n\t\t\t\t\t// because they must already be dark\n\t\t\t\t\tif (fullUpdate)\n\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\tcell++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//wall tiles\n\t\t\t\tif (DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell])){\n\n\t\t\t\t\t//internal wall tiles\n\t\t\t\t\tif (cell + mapWidth >= mapLength){\n\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\n\t\t\t\t\t} else if (DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell + mapWidth])){\n\n\t\t\t\t\t\t//these tiles need to check both the left and right side, to account for only one half of them being seen\n\t\t\t\t\t\tif (cell % mapWidth != 0){\n\n\t\t\t\t\t\t\t//picks the darkest fog between current tile, left, and below-left(if left is a wall).\n\t\t\t\t\t\t\tif (cell + mapWidth < mapLength && DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell - 1])){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//if below-left is also a wall, then we should be dark no matter what.\n\t\t\t\t\t\t\t\tif (DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell + mapWidth - 1])){\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[INVISIBLE][brightness];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[Math.max(getCellFog(cell), Math.max(getCellFog(cell + mapWidth - 1), getCellFog(cell - 1)))][brightness];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell - 1))][brightness];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[0] = colorArray [2] = FOG_COLORS[INVISIBLE][brightness];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((cell+1) % mapWidth != 0){\n\n\t\t\t\t\t\t\t//picks the darkest fog between current tile, right, and below-right(if right is a wall).\n\t\t\t\t\t\t\tif (cell + mapWidth < mapLength && DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell + 1])){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//if below-right is also a wall, then we should be dark no matter what.\n\t\t\t\t\t\t\t\tif (DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell + mapWidth + 1])){\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[INVISIBLE][brightness];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[Math.max(getCellFog(cell), Math.max(getCellFog(cell + mapWidth + 1), getCellFog(cell + 1)))][brightness];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] =\n\t\t\t\t\t\t\t\t\t\tFOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell + 1))][brightness];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[1] = colorArray [3] = FOG_COLORS[INVISIBLE][brightness];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfillCell(j, i, colorArray);\n\n\t\t\t\t\t//camera-facing wall tiles\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell + mapWidth))][brightness]);\n\t\t\t\t\t}\n\n\t\t\t\t\t//other tiles\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, FOG_COLORS[getCellFog(cell)][brightness]);\n\t\t\t\t}\n\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\t\tthis.visible = visible;\n\t\tthis.visited = visited;\n\t\tthis.mapped = mapped;\n\t\tthis.brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tmoveToUpdating();\n\t\t\n\t\tboolean fullUpdate = false;\n\t\tif (updating.size() == 1){\n\t\t\tRect update = updating.get(0);\n\t\t\tif (update.height() == mapHeight && update.width() == mapWidth){\n\t\t\t\tfullUpdate = true;\n\t\t\t}\n\t\t}\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint cell;\n\t\t\n\t\tfor (Rect update : updating) {\n\t\t\tfor (int i = update.top; i <= update.bottom; i++) {\n\t\t\t\tcell = mapWidth * i + update.left;\n\t\t\t\tfor (int j = update.left; j <= update.right; j++) {\n\t\t\t\t\t\n\t\t\t\t\tif (cell >= Dungeon.level.length()) continue; //do nothing\n\t\t\t\t\t\n\t\t\t\t\tif (!Dungeon.level.discoverable[cell]\n\t\t\t\t\t\t\t|| (!visible[cell] && !visited[cell] && !mapped[cell])) {\n\t\t\t\t\t\t//we skip filling cells here if it isn't a full update\n\t\t\t\t\t\t// because they must already be dark\n\t\t\t\t\t\tif (fullUpdate)\n\t\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\tcell++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//wall tiles\n\t\t\t\t\tif (wall(cell)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//always dark if nothing is beneath them\n\t\t\t\t\t\tif (cell + mapWidth >= mapLength) {\n\t\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t//internal wall tiles, need to check both the left and right side,\n\t\t\t\t\t\t// to account for only one half of them being seen\n\t\t\t\t\t\t} else if (wall(cell + mapWidth)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//left side\n\t\t\t\t\t\t\tif (cell % mapWidth != 0) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//picks the darkest fog between current tile, left, and below-left(if left is a wall).\n\t\t\t\t\t\t\t\tif (wall(cell - 1)) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//if below-left is also a wall, then we should be dark no matter what.\n\t\t\t\t\t\t\t\t\tif (wall(cell + mapWidth - 1)) {\n\t\t\t\t\t\t\t\t\t\tfillLeft(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfillLeft(j, i, FOG_COLORS[Math.max(getCellFog(cell), Math.max(getCellFog(cell + mapWidth - 1), getCellFog(cell - 1)))][brightness]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfillLeft(j, i, FOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell - 1))][brightness]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfillLeft(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t//right side\n\t\t\t\t\t\t\tif ((cell + 1) % mapWidth != 0) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//picks the darkest fog between current tile, right, and below-right(if right is a wall).\n\t\t\t\t\t\t\t\tif (wall(cell + 1)) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t//if below-right is also a wall, then we should be dark no matter what.\n\t\t\t\t\t\t\t\t\tif (wall(cell + mapWidth + 1)) {\n\t\t\t\t\t\t\t\t\t\tfillRight(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfillRight(j, i, FOG_COLORS[Math.max(getCellFog(cell), Math.max(getCellFog(cell + mapWidth + 1), getCellFog(cell + 1)))][brightness]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfillRight(j, i, FOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell + 1))][brightness]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfillRight(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t//camera-facing wall tiles\n\t\t\t\t\t\t//darkest between themselves and the tile below them\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[Math.max(getCellFog(cell), getCellFog(cell + mapWidth))][brightness]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t//other tiles, just their direct value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfillCell(j, i, FOG_COLORS[getCellFog(cell)][brightness]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tcell++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (updating.size() == 1 && !fullUpdate){\n\t\t\tfog.update(updating.get(0).top * PIX_PER_TILE, updating.get(0).bottom * PIX_PER_TILE);\n\t\t} else {\n\t\t\tfog.update();\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean wall(int cell) {\n\t\treturn DungeonTileSheet.wallStitcheable(Dungeon.level.map[cell]);\n\t}",
          "uniqueId": "c290e5fe47101657b2d95c147e96684b8577fe2f_143_245_288_290_173_286"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "acc9fd33d2dca96d50a623b9a17d1792dd4f0627",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/acc9fd33d2dca96d50a623b9a17d1792dd4f0627",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void press( int cell, Char ch ) {\n\n\t\tif (ch != null && pit[cell] && !ch.flying) {\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tChasm.heroFall(cell);\n\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tTrap trap = null;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TRAP:\n\t\t\tGLog.i( Messages.get(Level.class, \"hidden_plate\") );\n\t\tcase Terrain.TRAP:\n\t\t\ttrap = traps.get( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\t\tHighGrass.trample( this, cell, ch );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\n\t\tTimekeepersHourglass.timeFreeze timeFreeze = Dungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);\n\n\t\tif (trap != null) {\n\t\t\tif (timeFreeze == null) {\n\n\t\t\t\tif (ch == Dungeon.hero)\n\t\t\t\t\tDungeon.hero.interrupt();\n\n\t\t\t\ttrap.trigger();\n\n\t\t\t} else {\n\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\n\t\t\t\tdiscover(cell);\n\n\t\t\t\ttimeFreeze.setDelayedPress(cell);\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.trigger();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void press( int cell, Char ch){\n\t\tpress( cell, ch, ch == Dungeon.hero);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void press( int cell, Char ch, boolean hard ) {\n\n\t\tif (ch != null && pit[cell] && !ch.flying) {\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tChasm.heroFall(cell);\n\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tTrap trap = null;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TRAP:\n\t\t\tif (hard) {\n\t\t\t\ttrap = traps.get( cell );\n\t\t\t\tGLog.i(Messages.get(Level.class, \"hidden_trap\", trap.name));\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.TRAP:\n\t\t\ttrap = traps.get( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\t\tHighGrass.trample( this, cell, ch );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\n\t\tif (trap != null) {\n\t\t\t\n\t\t\tTimekeepersHourglass.timeFreeze timeFreeze =\n\t\t\t\t\tch != null ? ch.buff(TimekeepersHourglass.timeFreeze.class) : null;\n\t\t\t\n\t\t\tif (timeFreeze == null) {\n\n\t\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\t\tDungeon.hero.interrupt();\n\t\t\t\t}\n\n\t\t\t\ttrap.trigger();\n\n\t\t\t} else {\n\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\n\t\t\t\tdiscover(cell);\n\n\t\t\t\ttimeFreeze.setDelayedPress(cell);\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.trigger();\n\t\t}\n\t}",
          "uniqueId": "acc9fd33d2dca96d50a623b9a17d1792dd4f0627_770_829_778_845_771_773"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "553badc118d04feda03efecaf9b68b4e8bc8842a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/553badc118d04feda03efecaf9b68b4e8bc8842a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\t\t\n\t\tnow = 0;\n\t\tpaused = false;\n\t\tview.onResume();\n\t\t\n\t\tMusic.INSTANCE.resume();\n\t\tSample.INSTANCE.resume();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onStart() {\n\t\tsuper.onStart();\n\t\t\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1){\n\t\t\tresumeGame();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void resumeGame(){\n\t\tif (!paused) return;\n\t\t\n\t\tnow = 0;\n\t\tpaused = false;\n\t\tview.onResume();\n\t\t\n\t\tMusic.INSTANCE.resume();\n\t\tSample.INSTANCE.resume();\n\t}",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_149_159_205_214_154_161"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t\tif (scene != null) {\n\t\t\tscene.pause();\n\t\t}\n\t\t\n\t\tpaused = true;\n\t\tview.onPause();\n\t\tScript.reset();\n\t\t\n\t\tMusic.INSTANCE.pause();\n\t\tSample.INSTANCE.pause();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t\tif (Build.VERSION.SDK_INT > Build.VERSION_CODES.GINGERBREAD_MR1){\n\t\t\tpauseGame();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void pauseGame(){\n\t\tif (paused) return;\n\t\t\n\t\tif (scene != null) {\n\t\t\tscene.pause();\n\t\t}\n\t\t\n\t\tpaused = true;\n\t\tview.onPause();\n\t\tScript.reset();\n\t\t\n\t\tMusic.INSTANCE.pause();\n\t\tSample.INSTANCE.pause();\n\t}",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_161_175_190_203_163_170"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "protected void onBackPressed() {\n\t\tGame.instance.finish();\n\t}",
          "sourceCodeAfterRefactoring": "protected void onBackPressed() {\n\t\tGame.quitGame();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_73_75_216_219_73_75"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private static void veryRareEffect(final Wand wand, final Hero user, final Ballistica bolt){\n\t\tswitch(Random.Int(4)){\n\n\t\t\t//great forest fire!\n\t\t\tcase 0:\n\t\t\t\tfor (int i = 0; i < Dungeon.level.length(); i++){\n\t\t\t\t\tint c = Dungeon.level.map[i];\n\t\t\t\t\tif (c == Terrain.EMPTY ||\n\t\t\t\t\t\t\tc == Terrain.EMBERS ||\n\t\t\t\t\t\t\tc == Terrain.EMPTY_DECO ||\n\t\t\t\t\t\t\tc == Terrain.GRASS ||\n\t\t\t\t\t\t\tc == Terrain.HIGH_GRASS) {\n\t\t\t\t\t\tGameScene.add( Blob.seed(i, 15, Regrowth.class));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tGameScene.add(Blob.seed(Dungeon.level.randomDestination(), 10, Fire.class));\n\t\t\t\t} while (Random.Int(5) != 0);\n\t\t\t\tnew Flare(8, 32).color(0xFFFF66, true).show(user.sprite, 2f);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TELEPORT);\n\t\t\t\tGLog.p(Messages.get(CursedWand.class, \"grass\"));\n\t\t\t\tGLog.w(Messages.get(CursedWand.class, \"fire\"));\n\t\t\t\twand.wandUsed();\n\t\t\t\tbreak;\n\n\t\t\t//superpowered mimic\n\t\t\tcase 1:\n\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tMimic mimic = Mimic.spawnAt(bolt.collisionPos, new ArrayList<Item>());\n\t\t\t\t\t\tif (mimic != null) {\n\t\t\t\t\t\t\tmimic.adjustStats(Dungeon.depth + 10);\n\t\t\t\t\t\t\tmimic.HP = mimic.HT;\n\t\t\t\t\t\t\tItem reward;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\treward = Generator.random(Random.oneOf(Generator.Category.WEAPON, Generator.Category.ARMOR,\n\t\t\t\t\t\t\t\t\t\tGenerator.Category.RING, Generator.Category.WAND));\n\t\t\t\t\t\t\t} while (reward.level() < 2 && !(reward instanceof MissileWeapon));\n\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_MIMIC, 1, 1, 0.5f);\n\t\t\t\t\t\t\tmimic.items.clear();\n\t\t\t\t\t\t\tmimic.items.add(reward);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twand.wandUsed();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t//crashes the game, yes, really.\n\t\t\tcase 2:\n\t\t\t\ttry {\n\t\t\t\t\tDungeon.saveAll();\n\t\t\t\t\tif(Messages.lang() != Languages.ENGLISH){\n\t\t\t\t\t\t//Don't bother doing this joke to none-english speakers, I doubt it would translate.\n\t\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\t\twand.wandUsed();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGameScene.show(\n\t\t\t\t\t\t\t\tnew WndOptions(\"CURSED WAND ERROR\", \"this application will now self-destruct\", \"abort\", \"retry\", \"fail\") {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\t\t\tGame.instance.finish();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\t\t\t\t\t//do nothing\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch(IOException e){\n\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t\t//oookay maybe don't kill the game if the save failed.\n\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\twand.wandUsed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t//random transmogrification\n\t\t\tcase 3:\n\t\t\t\twand.wandUsed();\n\t\t\t\twand.detach(user.belongings.backpack);\n\t\t\t\tItem result;\n\t\t\t\tdo {\n\t\t\t\t\tresult = Generator.random(Random.oneOf(Generator.Category.WEAPON, Generator.Category.ARMOR,\n\t\t\t\t\t\t\tGenerator.Category.RING, Generator.Category.ARTIFACT));\n\t\t\t\t} while (result.level() < 0 && !(result instanceof MissileWeapon));\n\t\t\t\tif (result.isUpgradable()) result.upgrade();\n\t\t\t\tresult.cursed = result.cursedKnown = true;\n\t\t\t\tGLog.w( Messages.get(CursedWand.class, \"transmogrify\") );\n\t\t\t\tDungeon.level.drop(result, user.pos).sprite.drop();\n\t\t\t\twand.wandUsed();\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private static void veryRareEffect(final Wand wand, final Hero user, final Ballistica bolt){\n\t\tswitch(Random.Int(4)){\n\n\t\t\t//great forest fire!\n\t\t\tcase 0:\n\t\t\t\tfor (int i = 0; i < Dungeon.level.length(); i++){\n\t\t\t\t\tint c = Dungeon.level.map[i];\n\t\t\t\t\tif (c == Terrain.EMPTY ||\n\t\t\t\t\t\t\tc == Terrain.EMBERS ||\n\t\t\t\t\t\t\tc == Terrain.EMPTY_DECO ||\n\t\t\t\t\t\t\tc == Terrain.GRASS ||\n\t\t\t\t\t\t\tc == Terrain.HIGH_GRASS) {\n\t\t\t\t\t\tGameScene.add( Blob.seed(i, 15, Regrowth.class));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tGameScene.add(Blob.seed(Dungeon.level.randomDestination(), 10, Fire.class));\n\t\t\t\t} while (Random.Int(5) != 0);\n\t\t\t\tnew Flare(8, 32).color(0xFFFF66, true).show(user.sprite, 2f);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_TELEPORT);\n\t\t\t\tGLog.p(Messages.get(CursedWand.class, \"grass\"));\n\t\t\t\tGLog.w(Messages.get(CursedWand.class, \"fire\"));\n\t\t\t\twand.wandUsed();\n\t\t\t\tbreak;\n\n\t\t\t//superpowered mimic\n\t\t\tcase 1:\n\t\t\t\tcursedFX(user, bolt, new Callback() {\n\t\t\t\t\tpublic void call() {\n\t\t\t\t\t\tMimic mimic = Mimic.spawnAt(bolt.collisionPos, new ArrayList<Item>());\n\t\t\t\t\t\tif (mimic != null) {\n\t\t\t\t\t\t\tmimic.adjustStats(Dungeon.depth + 10);\n\t\t\t\t\t\t\tmimic.HP = mimic.HT;\n\t\t\t\t\t\t\tItem reward;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\treward = Generator.random(Random.oneOf(Generator.Category.WEAPON, Generator.Category.ARMOR,\n\t\t\t\t\t\t\t\t\t\tGenerator.Category.RING, Generator.Category.WAND));\n\t\t\t\t\t\t\t} while (reward.level() < 2 && !(reward instanceof MissileWeapon));\n\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_MIMIC, 1, 1, 0.5f);\n\t\t\t\t\t\t\tmimic.items.clear();\n\t\t\t\t\t\t\tmimic.items.add(reward);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twand.wandUsed();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tbreak;\n\n\t\t\t//crashes the game, yes, really.\n\t\t\tcase 2:\n\t\t\t\ttry {\n\t\t\t\t\tDungeon.saveAll();\n\t\t\t\t\tif(Messages.lang() != Languages.ENGLISH){\n\t\t\t\t\t\t//Don't bother doing this joke to none-english speakers, I doubt it would translate.\n\t\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\t\twand.wandUsed();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGameScene.show(\n\t\t\t\t\t\t\t\tnew WndOptions(\"CURSED WAND ERROR\", \"this application will now self-destruct\", \"abort\", \"retry\", \"fail\") {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\t\t\tShatteredPixelDungeon.quitGame();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic void onBackPressed() {\n\t\t\t\t\t\t\t\t\t\t//do nothing\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} catch(IOException e){\n\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t\t//oookay maybe don't kill the game if the save failed.\n\t\t\t\t\tGLog.i(Messages.get(CursedWand.class, \"nothing\"));\n\t\t\t\t\twand.wandUsed();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t//random transmogrification\n\t\t\tcase 3:\n\t\t\t\twand.wandUsed();\n\t\t\t\twand.detach(user.belongings.backpack);\n\t\t\t\tItem result;\n\t\t\t\tdo {\n\t\t\t\t\tresult = Generator.random(Random.oneOf(Generator.Category.WEAPON, Generator.Category.ARMOR,\n\t\t\t\t\t\t\tGenerator.Category.RING, Generator.Category.ARTIFACT));\n\t\t\t\t} while (result.level() < 0 && !(result instanceof MissileWeapon));\n\t\t\t\tif (result.isUpgradable()) result.upgrade();\n\t\t\t\tresult.cursed = result.cursedKnown = true;\n\t\t\t\tGLog.w( Messages.get(CursedWand.class, \"transmogrify\") );\n\t\t\t\tDungeon.level.drop(result, user.pos).sprite.drop();\n\t\t\t\twand.wandUsed();\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (Actor.findChar(pos) != null && bolt.dist > 1) {\n\t\t\t\t\t\t\tpos = bolt.path.get(bolt.dist - 1);\n\t\t\t\t\t\t}",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_355_453_216_219_355_453"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onClick() {\n\t\tif (Game.scene() instanceof TitleScene) {\n\t\t\tGame.instance.finish();\n\t\t} else {\n\t\t\tShatteredPixelDungeon.switchNoFade( TitleScene.class );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onClick() {\n\t\tif (Game.scene() instanceof TitleScene) {\n\t\t\tShatteredPixelDungeon.quitGame();\n\t\t} else {\n\t\t\tShatteredPixelDungeon.switchNoFade( TitleScene.class );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_70_77_216_219_70_77"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public WndGame() {\n\t\t\n\t\tsuper();\n\t\t\n\t\taddButton( new RedButton( Messages.get(this, \"settings\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\thide();\n\t\t\t\tGameScene.show(new WndSettings());\n\t\t\t}\n\t\t});\n\n\t\t// Challenges window\n\t\tif (Dungeon.challenges > 0) {\n\t\t\taddButton( new RedButton( Messages.get(this, \"challenges\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\thide();\n\t\t\t\t\tGameScene.show( new WndChallenges( Dungeon.challenges, false ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Restart\n\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\t\n\t\t\tRedButton btnStart;\n\t\t\taddButton( btnStart = new RedButton( Messages.get(this, \"start\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tDungeon.hero = null;\n\t\t\t\t\tShatteredPixelDungeon.challenges( Dungeon.challenges );\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\t\t\t\t\tInterlevelScene.noStory = true;\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tbtnStart.icon( Icons.get( Dungeon.hero.heroClass ) );\n\t\t\t\n\t\t\taddButton( new RedButton( Messages.get(this, \"rankings\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\t\t\t\t\tGame.switchScene( RankingsScene.class );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\taddButtons(\n\t\t\t\t// Main menu\n\t\t\t\tnew RedButton( Messages.get(this, \"menu\") ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tDungeon.saveAll();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGame.switchScene(TitleScene.class);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Quit\n\t\t\t\tnew RedButton( Messages.get(this, \"exit\") ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\tGame.instance.finish();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\t// Cancel\n\t\taddButton( new RedButton( Messages.get(this, \"return\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\thide();\n\t\t\t}\n\t\t} );\n\n\t\tresize( WIDTH, pos );\n\t}",
          "sourceCodeAfterRefactoring": "public WndGame() {\n\t\t\n\t\tsuper();\n\t\t\n\t\taddButton( new RedButton( Messages.get(this, \"settings\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\thide();\n\t\t\t\tGameScene.show(new WndSettings());\n\t\t\t}\n\t\t});\n\n\t\t// Challenges window\n\t\tif (Dungeon.challenges > 0) {\n\t\t\taddButton( new RedButton( Messages.get(this, \"challenges\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\thide();\n\t\t\t\t\tGameScene.show( new WndChallenges( Dungeon.challenges, false ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Restart\n\t\tif (!Dungeon.hero.isAlive()) {\n\t\t\t\n\t\t\tRedButton btnStart;\n\t\t\taddButton( btnStart = new RedButton( Messages.get(this, \"start\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tDungeon.hero = null;\n\t\t\t\t\tShatteredPixelDungeon.challenges( Dungeon.challenges );\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\t\t\t\t\tInterlevelScene.noStory = true;\n\t\t\t\t\tGame.switchScene( InterlevelScene.class );\n\t\t\t\t}\n\t\t\t} );\n\t\t\tbtnStart.icon( Icons.get( Dungeon.hero.heroClass ) );\n\t\t\t\n\t\t\taddButton( new RedButton( Messages.get(this, \"rankings\") ) {\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tInterlevelScene.mode = InterlevelScene.Mode.DESCEND;\n\t\t\t\t\tGame.switchScene( RankingsScene.class );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\taddButtons(\n\t\t\t\t// Main menu\n\t\t\t\tnew RedButton( Messages.get(this, \"menu\") ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tDungeon.saveAll();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tGame.switchScene(TitleScene.class);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t// Quit\n\t\t\t\tnew RedButton( Messages.get(this, \"exit\") ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tDungeon.saveAll();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tShatteredPixelDungeon.quitGame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\n\t\t// Cancel\n\t\taddButton( new RedButton( Messages.get(this, \"return\") ) {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\thide();\n\t\t\t}\n\t\t} );\n\n\t\tresize( WIDTH, pos );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "553badc118d04feda03efecaf9b68b4e8bc8842a_46_125_216_219_46_130"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "126172d6618426274156a1800c3427b90212c113",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/126172d6618426274156a1800c3427b90212c113",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void set( int cell, int terrain ) {\n\t\tPainter.set( Dungeon.level, cell, terrain );\n\n\t\tif (terrain != Terrain.TRAP && terrain != Terrain.SECRET_TRAP && terrain != Terrain.INACTIVE_TRAP){\n\t\t\tDungeon.level.traps.remove( cell );\n\t\t}\n\n\t\tint flags = Terrain.flags[terrain];\n\t\tpassable[cell]\t\t= (flags & Terrain.PASSABLE) != 0;\n\t\tlosBlocking[cell]\t= (flags & Terrain.LOS_BLOCKING) != 0;\n\t\tflamable[cell]\t\t= (flags & Terrain.FLAMABLE) != 0;\n\t\tsecret[cell]\t\t= (flags & Terrain.SECRET) != 0;\n\t\tsolid[cell]\t\t\t= (flags & Terrain.SOLID) != 0;\n\t\tavoid[cell]\t\t\t= (flags & Terrain.AVOID) != 0;\n\t\tpit[cell]\t\t\t= (flags & Terrain.PIT) != 0;\n\t\twater[cell]\t\t\t= terrain == Terrain.WATER;\n\t}",
          "sourceCodeAfterRefactoring": "public static void set( int cell, int terrain ){\n\t\tset( cell, terrain, Dungeon.level );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void set( int cell, int terrain, Level level ) {\n\t\tPainter.set( level, cell, terrain );\n\n\t\tif (terrain != Terrain.TRAP && terrain != Terrain.SECRET_TRAP && terrain != Terrain.INACTIVE_TRAP){\n\t\t\tlevel.traps.remove( cell );\n\t\t}\n\n\t\tint flags = Terrain.flags[terrain];\n\t\tlevel.passable[cell]\t\t= (flags & Terrain.PASSABLE) != 0;\n\t\tlevel.losBlocking[cell]\t    = (flags & Terrain.LOS_BLOCKING) != 0;\n\t\tlevel.flamable[cell]\t\t= (flags & Terrain.FLAMABLE) != 0;\n\t\tlevel.secret[cell]\t\t    = (flags & Terrain.SECRET) != 0;\n\t\tlevel.solid[cell]\t\t\t= (flags & Terrain.SOLID) != 0;\n\t\tlevel.avoid[cell]\t\t\t= (flags & Terrain.AVOID) != 0;\n\t\tlevel.pit[cell]\t\t\t    = (flags & Terrain.PIT) != 0;\n\t\tlevel.water[cell]\t\t\t= terrain == Terrain.WATER;\n\t}",
          "uniqueId": "126172d6618426274156a1800c3427b90212c113_623_639_627_643_623_625"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8fb8061ee13575869a5a7e67554700e3479c316c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8fb8061ee13575869a5a7e67554700e3479c316c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n\tpublic static<T extends Blob> T seed( int cell, int amount, Class<T> type ) {\n\t\ttry {\n\t\t\t\n\t\t\tT gas = (T)Dungeon.level.blobs.get( type );\n\t\t\tif (gas == null) {\n\t\t\t\tgas = type.newInstance();\n\t\t\t\tDungeon.level.blobs.put( type, gas );\n\t\t\t}\n\t\t\t\n\t\t\tgas.seed( Dungeon.level, cell, amount );\n\t\t\t\n\t\t\treturn gas;\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn null;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static<T extends Blob> T seed( int cell, int amount, Class<T> type ) {\n\t\treturn seed(cell, amount, type, Dungeon.level);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"unchecked\")\n\tpublic static<T extends Blob> T seed( int cell, int amount, Class<T> type, Level level ) {\n\t\ttry {\n\t\t\t\n\t\t\tT gas = (T)level.blobs.get( type );\n\t\t\tif (gas == null) {\n\t\t\t\tgas = type.newInstance();\n\t\t\t\tlevel.blobs.put( type, gas );\n\t\t\t}\n\t\t\t\n\t\t\tgas.seed( level, cell, amount );\n\t\t\t\n\t\t\treturn gas;\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "8fb8061ee13575869a5a7e67554700e3479c316c_220_238_224_242_220_222"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void evolve() {\n\t\tvolume = off[pos] = cur[pos];\n\t\tarea.union(pos%Dungeon.level.width(), pos/Dungeon.level.width());\n\t\t\n\t\tif (Dungeon.visible[pos]) {\n\t\t\tif (this instanceof WaterOfAwareness) {\n\t\t\t\tNotes.add( Landmark.WELL_OF_AWARENESS );\n\t\t\t} else if (this instanceof WaterOfHealth) {\n\t\t\t\tNotes.add( Notes.Landmark.WELL_OF_HEALTH );\n\t\t\t} else if (this instanceof WaterOfTransmutation) {\n\t\t\t\tNotes.add( Landmark.WELL_OF_TRANSMUTATION );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void evolve() {\n\t\tint cell;\n\t\tboolean seen = false;\n\t\tfor (int i=area.top-1; i <= area.bottom; i++) {\n\t\t\tfor (int j = area.left-1; j <= area.right; j++) {\n\t\t\t\tcell = j + i* Dungeon.level.width();\n\t\t\t\tif (Dungeon.level.insideMap(cell)) {\n\t\t\t\t\toff[cell] = cur[cell];\n\t\t\t\t\tvolume += off[cell];\n\t\t\t\t\tif (off[cell] > 0 && Dungeon.level.visited[cell]) {\n\t\t\t\t\t\tseen = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (seen){\n\t\t\tNotes.add(record());\n\t\t} else {\n\t\t\tNotes.remove(record());\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nheap.sprite.link();\n\t\t\t\tcur[pos] = 0;\n\t\t\t\t\n\t\t\t\treturn true;",
          "uniqueId": "8fb8061ee13575869a5a7e67554700e3479c316c_54_68_89_92_39_60"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void evolve() {\n\t\tvolume = off[pos] = cur[pos];\n\t\tarea.union(pos%Dungeon.level.width(), pos/Dungeon.level.width());\n\t\t\n\t\tif (Dungeon.visible[pos]) {\n\t\t\tif (this instanceof WaterOfAwareness) {\n\t\t\t\tNotes.add( Landmark.WELL_OF_AWARENESS );\n\t\t\t} else if (this instanceof WaterOfHealth) {\n\t\t\t\tNotes.add( Notes.Landmark.WELL_OF_HEALTH );\n\t\t\t} else if (this instanceof WaterOfTransmutation) {\n\t\t\t\tNotes.add( Landmark.WELL_OF_TRANSMUTATION );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void evolve() {\n\t\tint cell;\n\t\tboolean seen = false;\n\t\tfor (int i=area.top-1; i <= area.bottom; i++) {\n\t\t\tfor (int j = area.left-1; j <= area.right; j++) {\n\t\t\t\tcell = j + i* Dungeon.level.width();\n\t\t\t\tif (Dungeon.level.insideMap(cell)) {\n\t\t\t\t\toff[cell] = cur[cell];\n\t\t\t\t\tvolume += off[cell];\n\t\t\t\t\tif (off[cell] > 0 && Dungeon.level.visited[cell]) {\n\t\t\t\t\t\tseen = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (seen){\n\t\t\tNotes.add(record());\n\t\t} else {\n\t\t\tNotes.remove(record());\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n} else {\n\t\t\t\t\n\t\t\t\tint newPlace;\n\t\t\t\tdo {",
          "uniqueId": "8fb8061ee13575869a5a7e67554700e3479c316c_54_68_94_97_39_60"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "ca077cefaed960b8dafc46076909db2ace914a38",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/ca077cefaed960b8dafc46076909db2ace914a38",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\n\t\tif (ch != null && !(ch instanceof NPC)){\n\n\t\t\tif(ch.buff(Corruption.class) != null){\n\t\t\t\tGLog.w( Messages.get(this, \"already_corrupted\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ch.properties().contains(Char.Property.BOSS) || ch.properties().contains(Char.Property.MINIBOSS)){\n\t\t\t\tGLog.w( Messages.get(this, \"boss\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint basePower = 10 + 2*level();\n\t\t\tint mobPower = Random.IntRange(0, ch.HT) + ch.HP*2;\n\t\t\tfor ( Buff buff : ch.buffs()){\n\t\t\t\tif (buff.type == Buff.buffType.NEGATIVE){\n\t\t\t\t\tmobPower *= 0.67;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint extraCharges = 0;\n\t\t\t//try to use extra charges to overpower the mob\n\t\t\twhile (basePower <= mobPower){\n\t\t\t\textraCharges++;\n\t\t\t\tbasePower += 5 + level();\n\t\t\t}\n\n\t\t\t//if we fail, lose all charges, remember we have 1 left to lose from using the wand.\n\t\t\tif (extraCharges >= curCharges){\n\t\t\t\tcurCharges = 1;\n\t\t\t\tGLog.w( Messages.get(this, \"fail\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//otherwise corrupt the mob & spend charges\n\t\t\tBuff.append(ch, Corruption.class);\n\t\t\tch.HP = ch.HT;\n\t\t\tcurCharges -= extraCharges;\n\t\t\tusagesToKnow -= extraCharges;\n\n\t\t\tprocessSoulMark(ch, extraCharges+chargesPerCast());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void debuffEnemy( Mob enemy, HashMap<Class<? extends Buff>, Float> category ){\n\t\tHashMap<Class<? extends Buff>, Float> debuffs = new HashMap<>(category);\n\t\tfor (Buff existing : enemy.buffs()){\n\t\t\tif (debuffs.containsKey(existing.getClass())) {\n\t\t\t\tdebuffs.put(existing.getClass(), 0f);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//all buffs with a > 0 chance are flavor buffs\n\t\tClass<?extends FlavourBuff> debuffCls = (Class<? extends FlavourBuff>) Random.chances(debuffs);\n\t\t\n\t\tif (debuffCls != null){\n\t\t\tBuff.append(enemy, debuffCls, 6 + level()*3);\n\t\t} else {\n\t\t\t//if no debuff can be applied (all are present), then go up one tier\n\t\t\tif (category == MINOR_DEBUFFS)          debuffEnemy( enemy, MAJOR_DEBUFFS);\n\t\t\telse if (category == MAJOR_DEBUFFS)     corruptEnemy( enemy );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void corruptEnemy( Mob enemy ){\n\t\t//cannot re-corrupt or doom an enemy, so give them a major debuff instead\n\t\tif(enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null){\n\t\t\tGLog.w( Messages.get(this, \"already_corrupted\") );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!enemy.properties().contains(Char.Property.BOSS) &&\n\t\t\t\t!enemy.properties().contains(Char.Property.MINIBOSS) &&\n\t\t\t\t!enemy.immunities().contains(Corruption.class)){\n\t\t\tenemy.HP = enemy.HT;\n\t\t\tfor (Buff buff : enemy.buffs()) {\n\t\t\t\tbuff.detach();\n\t\t\t}\n\t\t\tBuff.affect(enemy, Corruption.class);\n\t\t\tif (enemy.EXP > 0) {\n\t\t\t\tcurUser.sprite.showStatus(CharSprite.POSITIVE, Messages.get(enemy, \"exp\", enemy.EXP));\n\t\t\t\tcurUser.earnExp(enemy.EXP);\n\t\t\t\tenemy.EXP = 0;\n\t\t\t}\n\t\t\t//TODO perhaps enemies should also drop loot here\n\t\t} else {\n\t\t\tBuff.affect(enemy, Doom.class);\n\t\t}\n\t}",
          "uniqueId": "ca077cefaed960b8dafc46076909db2ace914a38_47_94_195_219_175_193"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\n\t\tif (ch != null && !(ch instanceof NPC)){\n\n\t\t\tif(ch.buff(Corruption.class) != null){\n\t\t\t\tGLog.w( Messages.get(this, \"already_corrupted\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ch.properties().contains(Char.Property.BOSS) || ch.properties().contains(Char.Property.MINIBOSS)){\n\t\t\t\tGLog.w( Messages.get(this, \"boss\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint basePower = 10 + 2*level();\n\t\t\tint mobPower = Random.IntRange(0, ch.HT) + ch.HP*2;\n\t\t\tfor ( Buff buff : ch.buffs()){\n\t\t\t\tif (buff.type == Buff.buffType.NEGATIVE){\n\t\t\t\t\tmobPower *= 0.67;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint extraCharges = 0;\n\t\t\t//try to use extra charges to overpower the mob\n\t\t\twhile (basePower <= mobPower){\n\t\t\t\textraCharges++;\n\t\t\t\tbasePower += 5 + level();\n\t\t\t}\n\n\t\t\t//if we fail, lose all charges, remember we have 1 left to lose from using the wand.\n\t\t\tif (extraCharges >= curCharges){\n\t\t\t\tcurCharges = 1;\n\t\t\t\tGLog.w( Messages.get(this, \"fail\") );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//otherwise corrupt the mob & spend charges\n\t\t\tBuff.append(ch, Corruption.class);\n\t\t\tch.HP = ch.HT;\n\t\t\tcurCharges -= extraCharges;\n\t\t\tusagesToKnow -= extraCharges;\n\n\t\t\tprocessSoulMark(ch, extraCharges+chargesPerCast());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onZap(Ballistica bolt) {\n\t\tChar ch = Actor.findChar(bolt.collisionPos);\n\n\t\tif (ch != null && ch instanceof Mob && !(ch instanceof NPC)){\n\n\t\t\tMob enemy = (Mob) ch;\n\n\t\t\tfloat corruptingPower = 2 + level();\n\t\t\t\n\t\t\t//base enemy resistance is usually based on their exp, but in special cases it is based on other criteria\n\t\t\tfloat enemyResist = 1 + enemy.EXP;\n\t\t\tif (ch instanceof Mimic || ch instanceof Statue){\n\t\t\t\tenemyResist = 1 + Dungeon.depth;\n\t\t\t} else if (ch instanceof Piranha) {\n\t\t\t\tenemyResist = 1 + Dungeon.depth/2f;\n\t\t\t} else if (ch instanceof Wraith) {\n\t\t\t\tenemyResist = 1 + Dungeon.depth/4f;\n\t\t\t} else if (ch instanceof Yog.BurningFist || ch instanceof Yog.RottingFist) {\n\t\t\t\tenemyResist = 1 + 30;\n\t\t\t} else if (ch instanceof Yog.Larva || ch instanceof King.Undead){\n\t\t\t\tenemyResist = 1 + 5;\n\t\t\t} else if (ch instanceof Swarm){\n\t\t\t\t//child swarms don't give exp, so we force this here.\n\t\t\t\tenemyResist = 1 + 3;\n\t\t\t}\n\t\t\t\n\t\t\t//100% health: 3x resist   75%: 2.1x resist   50%: 1.5x resist   25%: 1.1x resist\n\t\t\tenemyResist *= 1 + 2*Math.pow(enemy.HP/(float)enemy.HT, 2);\n\t\t\t\n\t\t\t//debuffs placed on the enemy reduce their resistance\n\t\t\tfor (Buff buff : enemy.buffs()){\n\t\t\t\tif (MAJOR_DEBUFFS.containsKey(buff.getClass()))         enemyResist *= MAJOR_DEBUFF_WEAKEN;\n\t\t\t\telse if (MINOR_DEBUFFS.containsKey(buff.getClass()))    enemyResist *= MINOR_DEBUFF_WEAKEN;\n\t\t\t\telse if (buff.type == Buff.buffType.NEGATIVE)           enemyResist *= MINOR_DEBUFF_WEAKEN;\n\t\t\t}\n\t\t\t\n\t\t\t//cannot re-corrupt or doom an enemy, so give them a major debuff instead\n\t\t\tif(enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null){\n\t\t\t\tenemyResist = corruptingPower*.99f;\n\t\t\t}\n\t\t\t\n\t\t\tif (corruptingPower > enemyResist){\n\t\t\t\tcorruptEnemy( enemy );\n\t\t\t} else {\n\t\t\t\tfloat debuffChance = corruptingPower / enemyResist;\n\t\t\t\tif (Random.Float() < debuffChance){\n\t\t\t\t\tdebuffEnemy( enemy, MAJOR_DEBUFFS);\n\t\t\t\t} else {\n\t\t\t\t\tdebuffEnemy( enemy, MINOR_DEBUFFS);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprocessSoulMark(ch, chargesPerCast());\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void corruptEnemy( Mob enemy ){\n\t\t//cannot re-corrupt or doom an enemy, so give them a major debuff instead\n\t\tif(enemy.buff(Corruption.class) != null || enemy.buff(Doom.class) != null){\n\t\t\tGLog.w( Messages.get(this, \"already_corrupted\") );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!enemy.properties().contains(Char.Property.BOSS) &&\n\t\t\t\t!enemy.properties().contains(Char.Property.MINIBOSS) &&\n\t\t\t\t!enemy.immunities().contains(Corruption.class)){\n\t\t\tenemy.HP = enemy.HT;\n\t\t\tfor (Buff buff : enemy.buffs()) {\n\t\t\t\tbuff.detach();\n\t\t\t}\n\t\t\tBuff.affect(enemy, Corruption.class);\n\t\t\tif (enemy.EXP > 0) {\n\t\t\t\tcurUser.sprite.showStatus(CharSprite.POSITIVE, Messages.get(enemy, \"exp\", enemy.EXP));\n\t\t\t\tcurUser.earnExp(enemy.EXP);\n\t\t\t\tenemy.EXP = 0;\n\t\t\t}\n\t\t\t//TODO perhaps enemies should also drop loot here\n\t\t} else {\n\t\t\tBuff.affect(enemy, Doom.class);\n\t\t}\n\t}",
          "uniqueId": "ca077cefaed960b8dafc46076909db2ace914a38_47_94_195_219_118_173"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0e033720c729e84eb12ac4d51c4cee7222992689",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0e033720c729e84eb12ac4d51c4cee7222992689",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected static float angleBetweenRooms( Room from, Room to){\n\t\tPointF fromCenter = new PointF((from.left + from.right)/2f, (from.top + from.bottom)/2f);\n\t\tPointF toCenter = new PointF((to.left + to.right)/2f, (to.top + to.bottom)/2f);\n\t\tdouble m = (toCenter.y - fromCenter.y)/(toCenter.x - fromCenter.x);\n\t\t\n\t\tfloat angle = (float)(A*(Math.atan(m) + Math.PI/2.0));\n\t\tif (fromCenter.x > toCenter.x) angle -= 180f;\n\t\treturn angle;\n\t}",
          "sourceCodeAfterRefactoring": "protected static float angleBetweenRooms( Room from, Room to){\n\t\tPointF fromCenter = new PointF((from.left + from.right)/2f, (from.top + from.bottom)/2f);\n\t\tPointF toCenter = new PointF((to.left + to.right)/2f, (to.top + to.bottom)/2f);\n\t\treturn angleBetweenPoints(fromCenter, toCenter);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static float angleBetweenPoints( PointF from, PointF to ){\n\t\tdouble m = (to.y - from.y)/(to.x - from.x);\n\t\t\n\t\tfloat angle = (float)(A*(Math.atan(m) + Math.PI/2.0));\n\t\tif (from.x > to.x) angle -= 180f;\n\t\treturn angle;\n\t}",
          "uniqueId": "0e033720c729e84eb12ac4d51c4cee7222992689_146_154_152_158_146_150"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "058803664387cb5666e96304f25b21f98d57a30e",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/058803664387cb5666e96304f25b21f98d57a30e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ItemSprite view( int image, Glowing glowing ) {\n\t\tif (this.emitter != null) this.emitter.killAndErase();\n\t\temitter = null;\n\t\tframe( image );\n\t\tif ((this.glowing = glowing) == null) {\n\t\t\tresetColor();\n\t\t}\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "public ItemSprite view( int image, Glowing glowing ) {\n\t\tif (this.emitter != null) this.emitter.killAndErase();\n\t\temitter = null;\n\t\tframe( image );\n\t\tglow( glowing );\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void glow( Glowing glowing ){\n\t\tthis.glowing = glowing;\n\t\tif (glowing == null) resetColor();\n\t}",
          "uniqueId": "058803664387cb5666e96304f25b21f98d57a30e_194_202_212_215_194_200"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "b294155fb1dfe0351b9bef2509d25b668e41d734",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/b294155fb1dfe0351b9bef2509d25b668e41d734",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean completed(){\n\t\t\treturn spawned && processed;\n\t\t}",
          "sourceCodeAfterRefactoring": "public static boolean completed(){\n\t\t\treturn processed() && weapon == null && armor == null;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean processed(){\n\t\t\treturn spawned && processed;\n\t\t}",
          "uniqueId": "b294155fb1dfe0351b9bef2509d25b668e41d734_348_350_347_349_351_353"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "dc4d928da0ae410db64b390e6a0491bebb0d06ac",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/dc4d928da0ae410db64b390e6a0491bebb0d06ac",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic int compareTo( Record another ) {\n\t\t\treturn another.depth - depth;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic int compareTo( Record another ) {\n\t\t\treturn another.depth() - depth();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int depth(){\n\t\t\treturn depth;\n\t\t}",
          "uniqueId": "dc4d928da0ae410db64b390e6a0491bebb0d06ac_72_75_39_41_48_51"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void add( Landmark landmark ) {\n\t\tint size = records.size();\n\t\tfor (int i=0; i < size; i++) {\n\t\t\tRecord rec = records.get( i );\n\t\t\tif (rec.landmark == landmark && rec.depth == Dungeon.depth) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\trecords.add( new Record(landmark, Dungeon.depth ) );\n\t}",
          "sourceCodeAfterRefactoring": "public static void add( Landmark landmark ) {\n\t\tLandmarkRecord l = new LandmarkRecord( landmark, Dungeon.depth );\n\t\tif (!records.contains(l)) {\n\t\t\trecords.add(new LandmarkRecord(landmark, Dungeon.depth));\n\t\t\tCollections.sort(records);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void add( Key key ){\n\t\tKeyRecord k = new KeyRecord(key);\n\t\tif (!records.contains(k)){\n\t\t\trecords.add(k);\n\t\t\tCollections.sort(records);\n\t\t} else {\n\t\t\tk = (KeyRecord) records.get(records.indexOf(k));\n\t\t\tk.quantity(k.quantity() + key.quantity());\n\t\t}\n\t}",
          "uniqueId": "dc4d928da0ae410db64b390e6a0491bebb0d06ac_113_123_206_215_194_200"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9af6e712665ea3c1dff7efb54d87099ea9f065a9",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9af6e712665ea3c1dff7efb54d87099ea9f065a9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected boolean act() {\n\t\t\tif (rose == null) {\n\t\t\t\trose = Dungeon.hero.belongings.getItem(DriedRose.class);\n\t\t\t}\n\t\t\tif (rose == null || !rose.isEquipped(Dungeon.hero)){\n\t\t\t\tdamage(1, this);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isAlive())\n\t\t\t\treturn true;\n\t\t\tif (!Dungeon.hero.isAlive()){\n\t\t\t\tsayHeroKilled();\n\t\t\t\tsprite.die();\n\t\t\t\tdestroy();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn super.act();\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected boolean act() {\n\t\t\tupdateRose();\n\t\t\tif (rose == null || !rose.isEquipped(Dungeon.hero)){\n\t\t\t\tdamage(1, this);\n\t\t\t}\n\t\t\t\n\t\t\tif (!isAlive())\n\t\t\t\treturn true;\n\t\t\tif (!Dungeon.hero.isAlive()){\n\t\t\t\tsayHeroKilled();\n\t\t\t\tsprite.die();\n\t\t\t\tdestroy();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn super.act();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateRose(){\n\t\t\tif (rose == null) {\n\t\t\t\trose = Dungeon.hero.belongings.getItem(DriedRose.class);\n\t\t\t}\n\t\t\t\n\t\t\tdefenseSkill = (Dungeon.hero.lvl+4)*2;\n\t\t\tif (rose == null) return;\n\t\t\tHT = 20 + 4*rose.level();\n\t\t}",
          "uniqueId": "9af6e712665ea3c1dff7efb54d87099ea9f065a9_378_396_380_388_422_438"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "24eb803e3f7debbb398aa1729c6be04d75c63d68",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/24eb803e3f7debbb398aa1729c6be04d75c63d68",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void doRead() {\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<Integer>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tint p = curUser.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\tif (Actor.findChar( p ) == null && (Level.passable[p] || Level.avoid[p])) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint nImages = NIMAGES;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( curUser );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t}\n\t\t\n\t\tif (nImages < NIMAGES) {\n\t\t\tsetKnown();\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\n\t\treadAnimation();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void doRead() {\n\t\tint spawnedImages = spawnImages(curUser, NIMAGES);\n\t\t\n\t\tif (spawnedImages > 0) {\n\t\t\tsetKnown();\n\t\t}\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\t\t\n\t\treadAnimation();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int spawnImages( Hero hero, int nImages ){\n\t\t\n\t\tArrayList<Integer> respawnPoints = new ArrayList<Integer>();\n\t\t\n\t\tfor (int i = 0; i < PathFinder.NEIGHBOURS8.length; i++) {\n\t\t\tint p = hero.pos + PathFinder.NEIGHBOURS8[i];\n\t\t\tif (Actor.findChar( p ) == null && (Level.passable[p] || Level.avoid[p])) {\n\t\t\t\trespawnPoints.add( p );\n\t\t\t}\n\t\t}\n\t\t\n\t\tint spawned = 0;\n\t\twhile (nImages > 0 && respawnPoints.size() > 0) {\n\t\t\tint index = Random.index( respawnPoints );\n\t\t\t\n\t\t\tMirrorImage mob = new MirrorImage();\n\t\t\tmob.duplicate( curUser );\n\t\t\tGameScene.add( mob );\n\t\t\tScrollOfTeleportation.appear( mob, respawnPoints.get( index ) );\n\t\t\t\n\t\t\trespawnPoints.remove( index );\n\t\t\tnImages--;\n\t\t\tspawned++;\n\t\t}\n\t\t\n\t\treturn spawned;\n\t}",
          "uniqueId": "24eb803e3f7debbb398aa1729c6be04d75c63d68_44_77_76_102_48_60"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "95dd291bfe0bd803ccb5e5a4d7b82277d690ce7f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/95dd291bfe0bd803ccb5e5a4d7b82277d690ce7f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndBag( Bag bag, Listener listener, Mode mode, String title ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tthis.listener = listener;\n\t\tthis.mode = mode;\n\t\tthis.title = title;\n\t\t\n\t\tlastMode = mode;\n\t\tlastBag = bag;\n\n\t\tnCols = ShatteredPixelDungeon.landscape() ? COLS_L : COLS_P;\n\t\tnRows = (int)Math.ceil((Belongings.BACKPACK_SIZE + 4 + 1) / (float)nCols);\n\n\t\tint slotsWidth = SLOT_WIDTH * nCols + SLOT_MARGIN * (nCols - 1);\n\t\tint slotsHeight = SLOT_HEIGHT * nRows + SLOT_MARGIN * (nRows - 1);\n\n\t\tRenderedText txtTitle = PixelScene.renderText( title != null ? title : Messages.titleCase( bag.name() ), 9 );\n\t\ttxtTitle.hardlight( TITLE_COLOR );\n\t\ttxtTitle.x = (int)(slotsWidth - txtTitle.width()) / 2;\n\t\ttxtTitle.y = (int)(TITLE_HEIGHT - txtTitle.height()) / 2;\n\t\tadd( txtTitle );\n\t\t\n\t\tplaceItems( bag );\n\n\t\tresize( slotsWidth, slotsHeight + TITLE_HEIGHT );\n\n\t\tBelongings stuff = Dungeon.hero.belongings;\n\t\tBag[] bags = {\n\t\t\tstuff.backpack,\n\t\t\tstuff.getItem( SeedPouch.class ),\n\t\t\tstuff.getItem( ScrollHolder.class ),\n\t\t\tstuff.getItem( PotionBandolier.class ),\n\t\t\tstuff.getItem( WandHolster.class )};\n\n\t\tfor (Bag b : bags) {\n\t\t\tif (b != null) {\n\t\t\t\tBagTab tab = new BagTab( b );\n\t\t\t\tadd( tab );\n\t\t\t\ttab.select( b == bag );\n\t\t\t}\n\t\t}\n\n\t\tlayoutTabs();\n\t}",
          "sourceCodeAfterRefactoring": "public WndBag( Bag bag, Listener listener, Mode mode, String title ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tthis.listener = listener;\n\t\tthis.mode = mode;\n\t\tthis.title = title;\n\t\t\n\t\tlastMode = mode;\n\t\tlastBag = bag;\n\n\t\tnCols = ShatteredPixelDungeon.landscape() ? COLS_L : COLS_P;\n\t\tnRows = (int)Math.ceil((Belongings.BACKPACK_SIZE + 4) / (float)nCols);\n\n\t\tint slotsWidth = SLOT_WIDTH * nCols + SLOT_MARGIN * (nCols - 1);\n\t\tint slotsHeight = SLOT_HEIGHT * nRows + SLOT_MARGIN * (nRows - 1);\n\n\t\tplaceTitle( bag, slotsWidth );\n\t\t\n\t\tplaceItems( bag );\n\n\t\tresize( slotsWidth, slotsHeight + TITLE_HEIGHT );\n\n\t\tBelongings stuff = Dungeon.hero.belongings;\n\t\tBag[] bags = {\n\t\t\tstuff.backpack,\n\t\t\tstuff.getItem( SeedPouch.class ),\n\t\t\tstuff.getItem( ScrollHolder.class ),\n\t\t\tstuff.getItem( PotionBandolier.class ),\n\t\t\tstuff.getItem( WandHolster.class )};\n\n\t\tfor (Bag b : bags) {\n\t\t\tif (b != null) {\n\t\t\t\tBagTab tab = new BagTab( b );\n\t\t\t\tadd( tab );\n\t\t\t\ttab.select( b == bag );\n\t\t\t}\n\t\t}\n\n\t\tlayoutTabs();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void placeTitle( Bag bag, int width ){\n\t\t\n\t\tRenderedText txtTitle = PixelScene.renderText(\n\t\t\t\ttitle != null ? Messages.titleCase(title) : Messages.titleCase( bag.name() ), 9 );\n\t\ttxtTitle.hardlight( TITLE_COLOR );\n\t\ttxtTitle.x = 1;\n\t\ttxtTitle.y = (int)(TITLE_HEIGHT - txtTitle.baseLine()) / 2f - 1;\n\t\tPixelScene.align(txtTitle);\n\t\tadd( txtTitle );\n\t\t\n\t\tItemSprite gold = new ItemSprite(ItemSpriteSheet.GOLD, null);\n\t\tgold.x = width - gold.width() - 1;\n\t\tgold.y = (TITLE_HEIGHT - gold.height())/2f - 1;\n\t\tPixelScene.align(gold);\n\t\tadd(gold);\n\t\t\n\t\tBitmapText amt = new BitmapText( Integer.toString(Dungeon.gold), PixelScene.pixelFont );\n\t\tamt.hardlight(TITLE_COLOR);\n\t\tamt.measure();\n\t\tamt.x = width - gold.width() - amt.width() - 2;\n\t\tamt.y = (TITLE_HEIGHT - amt.baseLine())/2f - 1;\n\t\tPixelScene.align(amt);\n\t\tadd(amt);\n\t}",
          "uniqueId": "95dd291bfe0bd803ccb5e5a4d7b82277d690ce7f_104_148_169_192_106_146"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "bb4d798a6b23cc7a7d16225ff2e42841b86e9a66",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/bb4d798a6b23cc7a7d16225ff2e42841b86e9a66",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected static float placeRoom( ArrayList<Room> collision, Room prev, Room next, float angle){\n\n\t\t//wrap angle around to always be [0-360)\n\t\tangle %= 360f;\n\t\tif (angle < 0){\n\t\t\tangle += 360f;\n\t\t}\n\n\t\tPointF prevCenter = new PointF((prev.left + prev.right)/2f, (prev.top + prev.bottom)/2f);\n\n\t\t// calculating using y = mx+b, straight line formula\n\t\tdouble m = Math.tan(angle/A + Math.PI/2.0);\n\t\tdouble b = prevCenter.y -m*prevCenter.x;\n\n\t\t//using the line equation, we find the point along the prev room where the line exists\n\t\tPoint start;\n\t\tint direction;\n\t\tif (Math.abs(m) >= 1){\n\t\t\tif (angle < 90 || angle > 270){\n\t\t\t\tdirection = Room.TOP;\n\t\t\t\tstart = new Point( (int)Math.round((prev.top - b)/m), prev.top);\n\t\t\t} else {\n\t\t\t\tdirection = Room.BOTTOM;\n\t\t\t\tstart = new Point( (int)Math.round((prev.bottom - b)/m), prev.bottom);\n\t\t\t}\n\t\t} else {\n\t\t\tif (angle < 180){\n\t\t\t\tdirection = Room.RIGHT;\n\t\t\t\tstart = new Point(prev.right, (int) Math.round(m * prev.right + b));\n\t\t\t} else {\n\t\t\t\tdirection = Room.LEFT;\n\t\t\t\tstart = new Point(prev.left, (int) Math.round(m * prev.left + b));\n\t\t\t}\n\t\t}\n\n\t\t//cap it to a valid connection point for most rooms\n\t\tif (direction == Room.TOP || direction == Room.BOTTOM) {\n\t\t\tstart.x = (int) GameMath.gate(prev.left + 1, start.x, prev.right - 1);\n\t\t} else {\n\t\t\tstart.y = (int) GameMath.gate(prev.top + 1, start.y, prev.bottom - 1);\n\t\t}\n\n\t\t//space checking\n\t\tRect space = findFreeSpace(start, collision, Math.max(next.maxWidth(), next.maxHeight()));\n\t\tif (!next.setSizeWithLimit(space.width()+1, space.height()+1)){\n\t\t\treturn -1;\n\t\t}\n\n\t\t//find the ideal center for this new room using the line equation and known dimensions\n\t\tPointF targetCenter = new PointF();\n\t\tif (direction == Room.TOP) {\n\t\t\ttargetCenter.y = prev.top - (next.height() - 1) / 2f;\n\t\t\ttargetCenter.x = (float) ((targetCenter.y - b) / m);\n\t\t\tnext.setPos(Math.round(targetCenter.x - (next.width() - 1) / 2f), prev.top - (next.height() - 1));\n\n\t\t} else if (direction == Room.BOTTOM) {\n\t\t\ttargetCenter.y = prev.bottom + (next.height() - 1) / 2f;\n\t\t\ttargetCenter.x = (float) ((targetCenter.y - b) / m);\n\t\t\tnext.setPos(Math.round(targetCenter.x - (next.width() - 1) / 2f), prev.bottom);\n\n\t\t} else if (direction == Room.RIGHT) {\n\t\t\ttargetCenter.x = prev.right + (next.width()-1)/2f;\n\t\t\ttargetCenter.y = (float)(m*targetCenter.x + b);\n\t\t\tnext.setPos( prev.right, Math.round(targetCenter.y - (next.height()-1)/2f));\n\n\t\t} else if (direction == Room.LEFT) {\n\t\t\ttargetCenter.x = prev.left - (next.width()-1)/2f;\n\t\t\ttargetCenter.y = (float)(m*targetCenter.x + b);\n\t\t\tnext.setPos( prev.left - (next.width() - 1), Math.round(targetCenter.y - (next.height()-1)/2f));\n\n\t\t}\n\n\t\t//perform connection bounds and target checking, move the room if necessary\n\t\tif (direction == Room.TOP || direction == Room.BOTTOM){\n\t\t\tif (next.right < prev.left+2)\t    next.shift(prev.left+2-next.right, 0);\n\t\t\telse if (next.left > prev.right-2)  next.shift(prev.right-2-next.left, 0);\n\n\t\t\tif (next.right > space.right)       next.shift( space.right - next.right, 0);\n\t\t\telse if (next.left < space.left)    next.shift( space.left - next.left, 0);\n\t\t} else {\n\t\t\tif (next.bottom < prev.top+2)\t    next.shift(0, prev.top+2-next.bottom);\n\t\t\telse if (next.top > prev.bottom-2)  next.shift(0, prev.bottom-2-next.top);\n\n\t\t\tif (next.bottom > space.bottom)     next.shift( 0, space.bottom - next.bottom);\n\t\t\telse if (next.top < space.top)      next.shift( 0, space.top - next.top);\n\t\t}\n\n\t\t//attempt to connect, return the result angle if successful.\n\t\tif (next.connect(prev)){\n\t\t\tPointF nextCenter = new PointF((next.left + next.right)/2f, (next.top + next.bottom)/2f);\n\t\t\tdouble trueM = (nextCenter.y - prevCenter.y)/(nextCenter.x - prevCenter.x);\n\t\t\treturn (float)(A*(Math.atan(trueM) + Math.PI/2f));\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected static float placeRoom( ArrayList<Room> collision, Room prev, Room next, float angle){\n\n\t\t//wrap angle around to always be [0-360)\n\t\tangle %= 360f;\n\t\tif (angle < 0){\n\t\t\tangle += 360f;\n\t\t}\n\n\t\tPointF prevCenter = new PointF((prev.left + prev.right)/2f, (prev.top + prev.bottom)/2f);\n\n\t\t// calculating using y = mx+b, straight line formula\n\t\tdouble m = Math.tan(angle/A + Math.PI/2.0);\n\t\tdouble b = prevCenter.y -m*prevCenter.x;\n\n\t\t//using the line equation, we find the point along the prev room where the line exists\n\t\tPoint start;\n\t\tint direction;\n\t\tif (Math.abs(m) >= 1){\n\t\t\tif (angle < 90 || angle > 270){\n\t\t\t\tdirection = Room.TOP;\n\t\t\t\tstart = new Point( (int)Math.round((prev.top - b)/m), prev.top);\n\t\t\t} else {\n\t\t\t\tdirection = Room.BOTTOM;\n\t\t\t\tstart = new Point( (int)Math.round((prev.bottom - b)/m), prev.bottom);\n\t\t\t}\n\t\t} else {\n\t\t\tif (angle < 180){\n\t\t\t\tdirection = Room.RIGHT;\n\t\t\t\tstart = new Point(prev.right, (int) Math.round(m * prev.right + b));\n\t\t\t} else {\n\t\t\t\tdirection = Room.LEFT;\n\t\t\t\tstart = new Point(prev.left, (int) Math.round(m * prev.left + b));\n\t\t\t}\n\t\t}\n\n\t\t//cap it to a valid connection point for most rooms\n\t\tif (direction == Room.TOP || direction == Room.BOTTOM) {\n\t\t\tstart.x = (int) GameMath.gate(prev.left + 1, start.x, prev.right - 1);\n\t\t} else {\n\t\t\tstart.y = (int) GameMath.gate(prev.top + 1, start.y, prev.bottom - 1);\n\t\t}\n\n\t\t//space checking\n\t\tRect space = findFreeSpace(start, collision, Math.max(next.maxWidth(), next.maxHeight()));\n\t\tif (!next.setSizeWithLimit(space.width()+1, space.height()+1)){\n\t\t\treturn -1;\n\t\t}\n\n\t\t//find the ideal center for this new room using the line equation and known dimensions\n\t\tPointF targetCenter = new PointF();\n\t\tif (direction == Room.TOP) {\n\t\t\ttargetCenter.y = prev.top - (next.height() - 1) / 2f;\n\t\t\ttargetCenter.x = (float) ((targetCenter.y - b) / m);\n\t\t\tnext.setPos(Math.round(targetCenter.x - (next.width() - 1) / 2f), prev.top - (next.height() - 1));\n\n\t\t} else if (direction == Room.BOTTOM) {\n\t\t\ttargetCenter.y = prev.bottom + (next.height() - 1) / 2f;\n\t\t\ttargetCenter.x = (float) ((targetCenter.y - b) / m);\n\t\t\tnext.setPos(Math.round(targetCenter.x - (next.width() - 1) / 2f), prev.bottom);\n\n\t\t} else if (direction == Room.RIGHT) {\n\t\t\ttargetCenter.x = prev.right + (next.width()-1)/2f;\n\t\t\ttargetCenter.y = (float)(m*targetCenter.x + b);\n\t\t\tnext.setPos( prev.right, Math.round(targetCenter.y - (next.height()-1)/2f));\n\n\t\t} else if (direction == Room.LEFT) {\n\t\t\ttargetCenter.x = prev.left - (next.width()-1)/2f;\n\t\t\ttargetCenter.y = (float)(m*targetCenter.x + b);\n\t\t\tnext.setPos( prev.left - (next.width() - 1), Math.round(targetCenter.y - (next.height()-1)/2f));\n\n\t\t}\n\n\t\t//perform connection bounds and target checking, move the room if necessary\n\t\tif (direction == Room.TOP || direction == Room.BOTTOM){\n\t\t\tif (next.right < prev.left+2)\t    next.shift(prev.left+2-next.right, 0);\n\t\t\telse if (next.left > prev.right-2)  next.shift(prev.right-2-next.left, 0);\n\n\t\t\tif (next.right > space.right)       next.shift( space.right - next.right, 0);\n\t\t\telse if (next.left < space.left)    next.shift( space.left - next.left, 0);\n\t\t} else {\n\t\t\tif (next.bottom < prev.top+2)\t    next.shift(0, prev.top+2-next.bottom);\n\t\t\telse if (next.top > prev.bottom-2)  next.shift(0, prev.bottom-2-next.top);\n\n\t\t\tif (next.bottom > space.bottom)     next.shift( 0, space.bottom - next.bottom);\n\t\t\telse if (next.top < space.top)      next.shift( 0, space.top - next.top);\n\t\t}\n\n\t\t//attempt to connect, return the result angle if successful.\n\t\tif (next.connect(prev)){\n\t\t\treturn angleBetweenRooms(prev, next);\n\t\t} else {\n\t\t\treturn -1;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static float angleBetweenRooms( Room from, Room to){\n\t\tPointF fromCenter = new PointF((from.left + from.right)/2f, (from.top + from.bottom)/2f);\n\t\tPointF toCenter = new PointF((to.left + to.right)/2f, (to.top + to.bottom)/2f);\n\t\tdouble m = (toCenter.y - fromCenter.y)/(toCenter.x - fromCenter.x);\n\t\treturn (float)(A*(Math.atan(m) + Math.PI/2f));\n\t}",
          "uniqueId": "bb4d798a6b23cc7a7d16225ff2e42841b86e9a66_133_228_139_144_150_243"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "85d9c94f93002cf23e33ac8b784167bcf62cae53",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/85d9c94f93002cf23e33ac8b784167bcf62cae53",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void paint( Level level ) {\n\t\t\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\t\t\n\t\tpasWidth = width() - 3;\n\t\tpasHeight = height() - 3;\n\t\tint per = pasWidth * 2 + pasHeight * 2;\n\t\t\n\t\tif (itemsToSpawn == null)\n\t\t\tgenerateItems();\n\t\t\n\t\tint pos = xy2p( this, entrance() ) + (per - itemsToSpawn.size()) / 2;\n\t\tfor (Item item : itemsToSpawn) {\n\t\t\t\n\t\t\tPoint xy = p2xy( this, (pos + per) % per );\n\t\t\tint cell = xy.x + xy.y * level.width();\n\t\t\t\n\t\t\tif (level.heaps.get( cell ) != null) {\n\t\t\t\tdo {\n\t\t\t\t\tcell = level.pointToCell(random());\n\t\t\t\t} while (level.heaps.get( cell ) != null);\n\t\t\t}\n\t\t\t\n\t\t\tlevel.drop( item, cell ).type = Heap.Type.FOR_SALE;\n\t\t\t\n\t\t\tpos++;\n\t\t}\n\t\t\n\t\tplaceShopkeeper( level, this );\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.REGULAR );\n\t\t}\n\n\t\titemsToSpawn = null;\n\t}",
          "sourceCodeAfterRefactoring": "public void paint( Level level ) {\n\t\t\n\t\tPainter.fill( level, this, Terrain.WALL );\n\t\tPainter.fill( level, this, 1, Terrain.EMPTY_SP );\n\n\t\tplaceShopkeeper( level );\n\n\t\tplaceItems( level );\n\t\t\n\t\tfor (Door door : connected.values()) {\n\t\t\tdoor.set( Door.Type.REGULAR );\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void placeItems( Level level ){\n\n\t\tif (itemsToSpawn == null)\n\t\t\titemsToSpawn = generateItems();\n\n\t\tPoint itemPlacement = new Point(entrance());\n\t\tif (itemPlacement.y == top){\n\t\t\titemPlacement.y++;\n\t\t} else if (itemPlacement.y == bottom) {\n\t\t\titemPlacement.y--;\n\t\t} else if (itemPlacement.x == left){\n\t\t\titemPlacement.x++;\n\t\t} else {\n\t\t\titemPlacement.x--;\n\t\t}\n\n\t\tfor (Item item : itemsToSpawn) {\n\n\t\t\tif (itemPlacement.x == left+1 && itemPlacement.y != top+1){\n\t\t\t\titemPlacement.y--;\n\t\t\t} else if (itemPlacement.y == top+1 && itemPlacement.x != right-1){\n\t\t\t\titemPlacement.x++;\n\t\t\t} else if (itemPlacement.x == right-1 && itemPlacement.y != bottom-1){\n\t\t\t\titemPlacement.y++;\n\t\t\t} else {\n\t\t\t\titemPlacement.x--;\n\t\t\t}\n\n\t\t\tint cell = level.pointToCell(itemPlacement);\n\n\t\t\tif (level.heaps.get( cell ) != null) {\n\t\t\t\tdo {\n\t\t\t\t\tcell = level.pointToCell(random());\n\t\t\t\t} while (level.heaps.get( cell ) != null || level.findMob( cell ) != null);\n\t\t\t}\n\n\t\t\tlevel.drop( item, cell ).type = Heap.Type.FOR_SALE;\n\t\t}\n\n\t}",
          "uniqueId": "85d9c94f93002cf23e33ac8b784167bcf62cae53_107_143_124_163_99_112"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c120a78239967e17fa6e6749a2ff7cdf66ba9ab2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tfill( level, room, Terrain.WALL );\n\t\tfill( level, room, 1, Terrain.HIGH_GRASS );\n\t\tfill( level, room, 2, Terrain.GRASS );\n\t\t\n\t\troom.entrance().set( Room.Door.Type.REGULAR );\n\n\t\tif (Dungeon.isChallenged(Challenges.NO_FOOD)) {\n\t\t\tif (Random.Int(2) == 0){\n\t\t\t\tlevel.plant(new Sungrass.Seed(), level.pointToCell(room.random()));\n\t\t\t}\n\t\t} else {\n\t\t\tint bushes = Random.Int(3);\n\t\t\tif (bushes == 0) {\n\t\t\t\tlevel.plant(new Sungrass.Seed(), level.pointToCell(room.random()));\n\t\t\t} else if (bushes == 1) {\n\t\t\t\tlevel.plant(new BlandfruitBush.Seed(), level.pointToCell(room.random()));\n\t\t\t} else if (Random.Int(5) == 0) {\n\t\t\t\tint plant1, plant2;\n\t\t\t\tplant1 = level.pointToCell(room.random());\n\t\t\t\tlevel.plant(new Sungrass.Seed(), plant1);\n\t\t\t\tdo {\n\t\t\t\t\tplant2 = level.pointToCell(room.random());\n\t\t\t\t} while (plant2 == plant1);\n\t\t\t\tlevel.plant(new BlandfruitBush.Seed(), plant2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFoliage light = (Foliage)level.blobs.get( Foliage.class );\n\t\tif (light == null) {\n\t\t\tlight = new Foliage();\n\t\t}\n\t\tfor (int i=room.top + 1; i < room.bottom; i++) {\n\t\t\tfor (int j=room.left + 1; j < room.right; j++) {\n\t\t\t\tlight.seed( level, j + level.width() * i, 1 );\n\t\t\t}\n\t\t}\n\t\tlevel.blobs.put( Foliage.class, light );\n\t}",
          "sourceCodeAfterRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tPainter.fill( level, room, Terrain.WALL );\n\t\tfor (Room.Door door : room.connected.values()) {\n\t\t\tdoor.set( Room.Door.Type.REGULAR );\n\t\t}\n\t\t\n\t\tif (!Dungeon.bossLevel() && Random.Int( 5 ) == 0) {\n\t\t\tswitch (Random.Int( 6 )) {\n\t\t\tcase 0:\n\t\t\t\tif (level.feeling != Level.Feeling.GRASS) {\n\t\t\t\t\tif (Math.min( room.width(), room.height() ) >= 4 && Math.max( room.width(), room.height() ) >= 6) {\n\t\t\t\t\t\tpaintGraveyard( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Burned room\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tif (Dungeon.depth > 1) {\n\t\t\t\t\tpaintBurned( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Math.max( room.width(), room.height() ) >= 4) {\n\t\t\t\t\tpaintStriped( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (room.width() >= 6 && room.height() >= 6) {\n\t\t\t\t\tpaintStudy( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (level.feeling != Level.Feeling.WATER) {\n\t\t\t\t\tif (room.connected.size() == 2 && room.width() >= 4 && room.height() >= 4) {\n\t\t\t\t\t\tpaintBridge( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Fissure\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tif (!Dungeon.bossLevel() && !Dungeon.bossLevel( Dungeon.depth + 1 ) &&\n\t\t\t\t\tMath.min( room.width(), room.height() ) >= 5) {\n\t\t\t\t\tpaintFissure( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPainter.fill( level, room, 1, Terrain.EMPTY );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void paintBurned( Level level, Room room ) {\n\t\tfor (int i=room.top + 1; i < room.bottom; i++) {\n\t\t\tfor (int j=room.left + 1; j < room.right; j++) {\n\t\t\t\tint cell = i * level.width() + j;\n\t\t\t\tint t = Terrain.EMBERS;\n\t\t\t\tswitch (Random.Int( 5 )) {\n\t\t\t\tcase 0:\n\t\t\t\t\tt = Terrain.EMPTY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tt = Terrain.TRAP;\n\t\t\t\t\tlevel.setTrap(new FireTrap().reveal(), cell);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tt = Terrain.SECRET_TRAP;\n\t\t\t\t\tlevel.setTrap(new FireTrap().hide(), cell);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tt = Terrain.INACTIVE_TRAP;\n\t\t\t\t\tFireTrap trap = new FireTrap();\n\t\t\t\t\ttrap.reveal().active = false;\n\t\t\t\t\tlevel.setTrap(trap, cell);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlevel.map[cell] = t;\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2_36_75_98_125_38_96"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tfill( level, room, Terrain.WALL );\n\t\tfill( level, room, 1, Terrain.HIGH_GRASS );\n\t\tfill( level, room, 2, Terrain.GRASS );\n\t\t\n\t\troom.entrance().set( Room.Door.Type.REGULAR );\n\n\t\tif (Dungeon.isChallenged(Challenges.NO_FOOD)) {\n\t\t\tif (Random.Int(2) == 0){\n\t\t\t\tlevel.plant(new Sungrass.Seed(), level.pointToCell(room.random()));\n\t\t\t}\n\t\t} else {\n\t\t\tint bushes = Random.Int(3);\n\t\t\tif (bushes == 0) {\n\t\t\t\tlevel.plant(new Sungrass.Seed(), level.pointToCell(room.random()));\n\t\t\t} else if (bushes == 1) {\n\t\t\t\tlevel.plant(new BlandfruitBush.Seed(), level.pointToCell(room.random()));\n\t\t\t} else if (Random.Int(5) == 0) {\n\t\t\t\tint plant1, plant2;\n\t\t\t\tplant1 = level.pointToCell(room.random());\n\t\t\t\tlevel.plant(new Sungrass.Seed(), plant1);\n\t\t\t\tdo {\n\t\t\t\t\tplant2 = level.pointToCell(room.random());\n\t\t\t\t} while (plant2 == plant1);\n\t\t\t\tlevel.plant(new BlandfruitBush.Seed(), plant2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFoliage light = (Foliage)level.blobs.get( Foliage.class );\n\t\tif (light == null) {\n\t\t\tlight = new Foliage();\n\t\t}\n\t\tfor (int i=room.top + 1; i < room.bottom; i++) {\n\t\t\tfor (int j=room.left + 1; j < room.right; j++) {\n\t\t\t\tlight.seed( level, j + level.width() * i, 1 );\n\t\t\t}\n\t\t}\n\t\tlevel.blobs.put( Foliage.class, light );\n\t}",
          "sourceCodeAfterRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tPainter.fill( level, room, Terrain.WALL );\n\t\tfor (Room.Door door : room.connected.values()) {\n\t\t\tdoor.set( Room.Door.Type.REGULAR );\n\t\t}\n\t\t\n\t\tif (!Dungeon.bossLevel() && Random.Int( 5 ) == 0) {\n\t\t\tswitch (Random.Int( 6 )) {\n\t\t\tcase 0:\n\t\t\t\tif (level.feeling != Level.Feeling.GRASS) {\n\t\t\t\t\tif (Math.min( room.width(), room.height() ) >= 4 && Math.max( room.width(), room.height() ) >= 6) {\n\t\t\t\t\t\tpaintGraveyard( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Burned room\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tif (Dungeon.depth > 1) {\n\t\t\t\t\tpaintBurned( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Math.max( room.width(), room.height() ) >= 4) {\n\t\t\t\t\tpaintStriped( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (room.width() >= 6 && room.height() >= 6) {\n\t\t\t\t\tpaintStudy( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (level.feeling != Level.Feeling.WATER) {\n\t\t\t\t\tif (room.connected.size() == 2 && room.width() >= 4 && room.height() >= 4) {\n\t\t\t\t\t\tpaintBridge( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Fissure\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tif (!Dungeon.bossLevel() && !Dungeon.bossLevel( Dungeon.depth + 1 ) &&\n\t\t\t\t\tMath.min( room.width(), room.height() ) >= 5) {\n\t\t\t\t\tpaintFissure( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPainter.fill( level, room, 1, Terrain.EMPTY );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void paintStriped( Level level, Room room ) {\n\t\tPainter.fill( level, room.left + 1, room.top + 1, room.width() - 1, room.height() - 1 , Terrain.EMPTY_SP );\n\n\t\tif (room.width() > room.height()) {\n\t\t\tfor (int i=room.left + 2; i < room.right; i += 2) {\n\t\t\t\tPainter.fill( level, i, room.top + 1, 1, room.height() - 1, Terrain.HIGH_GRASS );\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i=room.top + 2; i < room.bottom; i += 2) {\n\t\t\t\tPainter.fill( level, room.left + 1, i, room.width() - 1, 1, Terrain.HIGH_GRASS );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2_36_75_145_157_38_96"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void paint( Level level, Room room ) {\n\n\t\tfill( level, room, Terrain.WALL );\n\t\tfill( level, room, 1, Terrain.EMPTY );\n\n\t\tPoint c = room.center();\n\t\tint cx = c.x;\n\t\tint cy = c.y;\n\t\t\n\t\tRoom.Door door = room.entrance();\n\t\t\n\t\tdoor.set( Room.Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\t\t\n\t\tif (door.x == room.left) {\n\t\t\t\n\t\t\tfill( level, room.right - 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.right - 2;\n\t\t\t\n\t\t} else if (door.x == room.right) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.left + 2;\n\t\t\t\n\t\t} else if (door.y == room.top) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.bottom - 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.bottom - 2;\n\t\t\t\n\t\t} else if (door.y == room.bottom) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.top + 2;\n\t\t\t\n\t\t}\n\t\t\n\t\tStatue statue = new Statue();\n\t\tstatue.pos = cx + cy * level.width();\n\t\tlevel.mobs.add( statue );\n\t}",
          "sourceCodeAfterRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tPainter.fill( level, room, Terrain.WALL );\n\t\tfor (Room.Door door : room.connected.values()) {\n\t\t\tdoor.set( Room.Door.Type.REGULAR );\n\t\t}\n\t\t\n\t\tif (!Dungeon.bossLevel() && Random.Int( 5 ) == 0) {\n\t\t\tswitch (Random.Int( 6 )) {\n\t\t\tcase 0:\n\t\t\t\tif (level.feeling != Level.Feeling.GRASS) {\n\t\t\t\t\tif (Math.min( room.width(), room.height() ) >= 4 && Math.max( room.width(), room.height() ) >= 6) {\n\t\t\t\t\t\tpaintGraveyard( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Burned room\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tif (Dungeon.depth > 1) {\n\t\t\t\t\tpaintBurned( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Math.max( room.width(), room.height() ) >= 4) {\n\t\t\t\t\tpaintStriped( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (room.width() >= 6 && room.height() >= 6) {\n\t\t\t\t\tpaintStudy( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (level.feeling != Level.Feeling.WATER) {\n\t\t\t\t\tif (room.connected.size() == 2 && room.width() >= 4 && room.height() >= 4) {\n\t\t\t\t\t\tpaintBridge( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Fissure\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tif (!Dungeon.bossLevel() && !Dungeon.bossLevel( Dungeon.depth + 1 ) &&\n\t\t\t\t\tMath.min( room.width(), room.height() ) >= 5) {\n\t\t\t\t\tpaintFissure( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPainter.fill( level, room, 1, Terrain.EMPTY );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void paintStriped( Level level, Room room ) {\n\t\tPainter.fill( level, room.left + 1, room.top + 1, room.width() - 1, room.height() - 1 , Terrain.EMPTY_SP );\n\n\t\tif (room.width() > room.height()) {\n\t\t\tfor (int i=room.left + 2; i < room.right; i += 2) {\n\t\t\t\tPainter.fill( level, i, room.top + 1, 1, room.height() - 1, Terrain.HIGH_GRASS );\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i=room.top + 2; i < room.bottom; i += 2) {\n\t\t\t\tPainter.fill( level, room.left + 1, i, room.width() - 1, 1, Terrain.HIGH_GRASS );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2_34_73_145_157_38_96"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void paint( Level level, Room room ) {\n\n\t\tfill( level, room, Terrain.WALL );\n\t\tfill( level, room, 1, Terrain.EMPTY );\n\n\t\tPoint c = room.center();\n\t\tint cx = c.x;\n\t\tint cy = c.y;\n\t\t\n\t\tRoom.Door door = room.entrance();\n\t\t\n\t\tdoor.set( Room.Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\t\t\n\t\tif (door.x == room.left) {\n\t\t\t\n\t\t\tfill( level, room.right - 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.right - 2;\n\t\t\t\n\t\t} else if (door.x == room.right) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.left + 2;\n\t\t\t\n\t\t} else if (door.y == room.top) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.bottom - 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.bottom - 2;\n\t\t\t\n\t\t} else if (door.y == room.bottom) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.top + 2;\n\t\t\t\n\t\t}\n\t\t\n\t\tStatue statue = new Statue();\n\t\tstatue.pos = cx + cy * level.width();\n\t\tlevel.mobs.add( statue );\n\t}",
          "sourceCodeAfterRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tPainter.fill( level, room, Terrain.WALL );\n\t\tfor (Room.Door door : room.connected.values()) {\n\t\t\tdoor.set( Room.Door.Type.REGULAR );\n\t\t}\n\t\t\n\t\tif (!Dungeon.bossLevel() && Random.Int( 5 ) == 0) {\n\t\t\tswitch (Random.Int( 6 )) {\n\t\t\tcase 0:\n\t\t\t\tif (level.feeling != Level.Feeling.GRASS) {\n\t\t\t\t\tif (Math.min( room.width(), room.height() ) >= 4 && Math.max( room.width(), room.height() ) >= 6) {\n\t\t\t\t\t\tpaintGraveyard( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Burned room\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tif (Dungeon.depth > 1) {\n\t\t\t\t\tpaintBurned( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Math.max( room.width(), room.height() ) >= 4) {\n\t\t\t\t\tpaintStriped( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (room.width() >= 6 && room.height() >= 6) {\n\t\t\t\t\tpaintStudy( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (level.feeling != Level.Feeling.WATER) {\n\t\t\t\t\tif (room.connected.size() == 2 && room.width() >= 4 && room.height() >= 4) {\n\t\t\t\t\t\tpaintBridge( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Fissure\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tif (!Dungeon.bossLevel() && !Dungeon.bossLevel( Dungeon.depth + 1 ) &&\n\t\t\t\t\tMath.min( room.width(), room.height() ) >= 5) {\n\t\t\t\t\tpaintFissure( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPainter.fill( level, room, 1, Terrain.EMPTY );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void paintGraveyard( Level level, Room room ) {\n\t\tPainter.fill( level, room.left + 1, room.top + 1, room.width() - 1, room.height() - 1 , Terrain.GRASS );\n\t\t\n\t\tint w = room.width() - 1;\n\t\tint h = room.height() - 1;\n\t\tint nGraves = Math.max( w, h ) / 2;\n\t\t\n\t\tint index = Random.Int( nGraves );\n\t\t\n\t\tint shift = Random.Int( 2 );\n\t\tfor (int i=0; i < nGraves; i++) {\n\t\t\tint pos = w > h ?\n\t\t\t\troom.left + 1 + shift + i * 2 + (room.top + 2 + Random.Int( h-2 )) * level.width() :\n\t\t\t\t(room.left + 2 + Random.Int( w-2 )) + (room.top + 1 + shift + i * 2) * level.width();\n\t\t\tlevel.drop( i == index ? Generator.random() : new Gold().random(), pos ).type = Heap.Type.TOMB;\n\t\t}\n\t}",
          "uniqueId": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2_34_73_127_143_38_96"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void paint( Level level, Room room ) {\n\n\t\tfill( level, room, Terrain.WALL );\n\t\tfill( level, room, 1, Terrain.EMPTY );\n\n\t\tPoint c = room.center();\n\t\tint cx = c.x;\n\t\tint cy = c.y;\n\t\t\n\t\tRoom.Door door = room.entrance();\n\t\t\n\t\tdoor.set( Room.Door.Type.LOCKED );\n\t\tlevel.addItemToSpawn( new IronKey( Dungeon.depth ) );\n\t\t\n\t\tif (door.x == room.left) {\n\t\t\t\n\t\t\tfill( level, room.right - 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.right - 2;\n\t\t\t\n\t\t} else if (door.x == room.right) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, 1, room.height() - 1 , Terrain.STATUE );\n\t\t\tcx = room.left + 2;\n\t\t\t\n\t\t} else if (door.y == room.top) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.bottom - 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.bottom - 2;\n\t\t\t\n\t\t} else if (door.y == room.bottom) {\n\t\t\t\n\t\t\tfill( level, room.left + 1, room.top + 1, room.width() - 1, 1 , Terrain.STATUE );\n\t\t\tcy = room.top + 2;\n\t\t\t\n\t\t}\n\t\t\n\t\tStatue statue = new Statue();\n\t\tstatue.pos = cx + cy * level.width();\n\t\tlevel.mobs.add( statue );\n\t}",
          "sourceCodeAfterRefactoring": "public static void paint( Level level, Room room ) {\n\t\t\n\t\tPainter.fill( level, room, Terrain.WALL );\n\t\tfor (Room.Door door : room.connected.values()) {\n\t\t\tdoor.set( Room.Door.Type.REGULAR );\n\t\t}\n\t\t\n\t\tif (!Dungeon.bossLevel() && Random.Int( 5 ) == 0) {\n\t\t\tswitch (Random.Int( 6 )) {\n\t\t\tcase 0:\n\t\t\t\tif (level.feeling != Level.Feeling.GRASS) {\n\t\t\t\t\tif (Math.min( room.width(), room.height() ) >= 4 && Math.max( room.width(), room.height() ) >= 6) {\n\t\t\t\t\t\tpaintGraveyard( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Burned room\n\t\t\t\t}\n\t\t\tcase 1:\n\t\t\t\tif (Dungeon.depth > 1) {\n\t\t\t\t\tpaintBurned( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (Math.max( room.width(), room.height() ) >= 4) {\n\t\t\t\t\tpaintStriped( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif (room.width() >= 6 && room.height() >= 6) {\n\t\t\t\t\tpaintStudy( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (level.feeling != Level.Feeling.WATER) {\n\t\t\t\t\tif (room.connected.size() == 2 && room.width() >= 4 && room.height() >= 4) {\n\t\t\t\t\t\tpaintBridge( level, room );\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Fissure\n\t\t\t\t}\n\t\t\tcase 5:\n\t\t\t\tif (!Dungeon.bossLevel() && !Dungeon.bossLevel( Dungeon.depth + 1 ) &&\n\t\t\t\t\tMath.min( room.width(), room.height() ) >= 5) {\n\t\t\t\t\tpaintFissure( level, room );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPainter.fill( level, room, 1, Terrain.EMPTY );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void paintStudy( Level level, Room room ) {\n\t\tPainter.fill( level, room.left + 1, room.top + 1, room.width() - 1, room.height() - 1 , Terrain.BOOKSHELF );\n\t\tPainter.fill( level, room.left + 2, room.top + 2, room.width() - 3, room.height() - 3 , Terrain.EMPTY_SP );\n\n\t\tfor (Point door : room.connected.values()) {\n\t\t\tif (door.x == room.left) {\n\t\t\t\tPainter.set( level, door.x + 1, door.y, Terrain.EMPTY );\n\t\t\t} else if (door.x == room.right) {\n\t\t\t\tPainter.set( level, door.x - 1, door.y, Terrain.EMPTY );\n\t\t\t} else if (door.y == room.top) {\n\t\t\t\tPainter.set( level, door.x, door.y + 1, Terrain.EMPTY );\n\t\t\t} else if (door.y == room.bottom) {\n\t\t\t\tPainter.set( level, door.x , door.y - 1, Terrain.EMPTY );\n\t\t\t}\n\t\t}\n\t\tPoint center = room.center();\n\t\tPainter.set( level, center, Terrain.PEDESTAL );\n\t\tif (Random.Int(2) != 0){\n\t\t\tItem prize = level.findPrizeItem();\n\t\t\tif (prize != null) {\n\t\t\t\tlevel.drop(prize, (room.center().x + center.y * level.width()));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tlevel.drop(Generator.random( Random.oneOf(\n\t\t\t\tGenerator.Category.POTION,\n\t\t\t\tGenerator.Category.SCROLL)), (room.center().x + center.y * level.width()));\n\t}",
          "uniqueId": "c120a78239967e17fa6e6749a2ff7cdf66ba9ab2_34_73_160_188_38_96"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "91a920a14c5ed89d96e9459246629e03f951c55a",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/91a920a14c5ed89d96e9459246629e03f951c55a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void updateMap( int cell ) {\n\t\tif (scene != null) {\n\t\t\tscene.tiles.updateMapCell( cell );\n\t\t\tscene.visualGrid.updateMapCell( cell );\n\t\t\tscene.terrainFeatures.updateMapCell( cell );\n\t\t\tscene.walls.updateMapCell( cell );\n\t\t\tscene.fog.updateFogCell( cell );\n\t\t\tscene.wallBlocking.updateMapCell( cell );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void updateMap( int cell ) {\n\t\tif (scene != null) {\n\t\t\tscene.tiles.updateMapCell( cell );\n\t\t\tscene.visualGrid.updateMapCell( cell );\n\t\t\tscene.terrainFeatures.updateMapCell( cell );\n\t\t\tscene.walls.updateMapCell( cell );\n\t\t\tupdateFog( cell );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void updateFog( int cell ){\n\t\tif (scene != null) {\n\t\t\t//update in a 3x3 grid to account for neighbours which might also be affected\n\t\t\tif (Dungeon.level.insideMap(cell)) {\n\t\t\t\tfor (int i : PathFinder.NEIGHBOURS9) {\n\t\t\t\t\tscene.fog.updateFogCell( cell + i );\n\t\t\t\t\tscene.wallBlocking.updateMapCell( cell + i );\n\t\t\t\t}\n\n\t\t\t//unless we're at the level's edge, then just do the one tile.\n\t\t\t} else {\n\t\t\t\tscene.fog.updateFogCell( cell );\n\t\t\t\tscene.wallBlocking.updateMapCell( cell );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "91a920a14c5ed89d96e9459246629e03f951c55a_712_721_755_770_714_722"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "479c689196bcb0a035240436255323be4adc5711",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/479c689196bcb0a035240436255323be4adc5711",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset( PointF from, PointF to, Item item, Callback listener) {\n\t\trevive();\n\n\t\tint image;\n\t\tif (item == null){\n\t\t\tview( image = 0, null);;\n\t\t} else {\n\t\t\t//no particle effects\n\t\t\tview( image = item.image(), item.glowing() );\n\t\t}\n\n\t\tthis.callback = listener;\n\n\t\tpoint( from );\n\n\t\tPointF d = PointF.diff( to, from );\n\t\tspeed.set( d ).normalize().scale( SPEED );\n\n\t\tif (image == ItemSpriteSheet.DART || image == ItemSpriteSheet.INCENDIARY_DART\n\t\t\t\t|| image == ItemSpriteSheet.CURARE_DART  || image == ItemSpriteSheet.JAVELIN) {\n\n\t\t\tangularSpeed = 0;\n\t\t\tangle = 135 - (float)(Math.atan2( d.x, d.y ) / 3.1415926 * 180);\n\n\t\t} else {\n\n\t\t\tangularSpeed = image == 15 || image == 106 ? 1440 : 720;\n\n\t\t}\n\n\t\tPosTweener tweener = new PosTweener( this, to, d.length() / SPEED );\n\t\ttweener.listener = this;\n\t\tparent.add( tweener );\n\t}",
          "sourceCodeAfterRefactoring": "public void reset( PointF from, PointF to, Item item, Callback listener) {\n\t\trevive();\n\t\tint image;\n\n\t\tif (item == null)   view(image = 0, null);\n\t\telse                view(image = item.image(), item.glowing());\n\n\t\tsetup( from,\n\t\t\t\tto,\n\t\t\t\timage,\n\t\t\t\tlistener );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void setup( PointF from, PointF to, int image, Callback listener ){\n\n\t\toriginToCenter();\n\n\t\tthis.callback = listener;\n\n\t\tpoint( from );\n\n\t\tPointF d = PointF.diff( to, from );\n\t\tspeed.set( d ).normalize().scale( SPEED );\n\n\t\tif (image == ItemSpriteSheet.DART || image == ItemSpriteSheet.INCENDIARY_DART\n\t\t\t\t|| image == ItemSpriteSheet.CURARE_DART  || image == ItemSpriteSheet.JAVELIN) {\n\n\t\t\tangularSpeed = 0;\n\t\t\tangle = 135 - (float)(Math.atan2( d.y, d.x ) / 3.1415926 * 180);\n\n\t\t} else {\n\n\t\t\tangularSpeed = image == 15 || image == 106 ? 1440 : 720;\n\n\t\t}\n\n\t\tPosTweener tweener = new PosTweener( this, to, d.length() / SPEED );\n\t\ttweener.listener = this;\n\t\tparent.add( tweener );\n\t}",
          "uniqueId": "479c689196bcb0a035240436255323be4adc5711_63_96_89_115_76_87"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "26daff58b2668847f4ea533df283f429128e8957",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/26daff58b2668847f4ea533df283f429128e8957",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Arc(int from, int to){\n\t\t\tstart = DungeonTilemap.tileCenterToWorld(from);\n\t\t\tend = DungeonTilemap.tileCenterToWorld(to);\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\n\t\t}",
          "sourceCodeAfterRefactoring": "public Arc(PointF from, int to){\n\t\t\tthis( from, DungeonTilemap.tileCenterToWorld(to));\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Arc(PointF from, PointF to){\n\t\t\tstart = from;\n\t\t\tend = to;\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\t\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_106_120_131_144_123_125"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Arc(int from, int to){\n\t\t\tstart = DungeonTilemap.tileCenterToWorld(from);\n\t\t\tend = DungeonTilemap.tileCenterToWorld(to);\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\n\t\t}",
          "sourceCodeAfterRefactoring": "public Arc(int from, PointF to){\n\t\t\tthis( DungeonTilemap.tileCenterToWorld(from), to);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Arc(PointF from, PointF to){\n\t\t\tstart = from;\n\t\t\tend = to;\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\t\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_106_120_131_144_127_129"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Arc(int from, int to){\n\t\t\tstart = DungeonTilemap.tileCenterToWorld(from);\n\t\t\tend = DungeonTilemap.tileCenterToWorld(to);\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\n\t\t}",
          "sourceCodeAfterRefactoring": "public Arc(int from, int to){\n\t\t\tthis( DungeonTilemap.tileCenterToWorld(from),\n\t\t\t\t\tDungeonTilemap.tileCenterToWorld(to));\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Arc(PointF from, PointF to){\n\t\t\tstart = from;\n\t\t\tend = to;\n\n\t\t\tarc1 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc1.x = start.x - arc1.origin.x;\n\t\t\tarc1.y = start.y - arc1.origin.y;\n\t\t\tarc1.origin.set( 0, arc1.height()/2 );\n\t\t\tadd( arc1 );\n\n\t\t\tarc2 = new Image(Effects.get(Effects.Type.LIGHTNING));\n\t\t\tarc2.origin.set( 0, arc2.height()/2 );\n\t\t\tadd( arc2 );\n\t\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_106_120_131_144_118_121"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset( int from, int to, Item item, Callback listener ) {\n\t\tif (item == null) {\n\t\t\treset( from, to, 0, null, listener );\n\t\t} else {\n\t\t\treset( from, to, item.image(), item.glowing(), listener );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void reset( Visual from, Visual to, Item item, Callback listener ) {\n\t\treset( from.center(this),\n\t\t\t\tto.center(this),\n\t\t\t\titem,\n\t\t\t\tlistener);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void reset( PointF from, PointF to, Item item, Callback listener) {\n\t\trevive();\n\n\t\tint image;\n\t\tif (item == null){\n\t\t\tview( image = 0, null);;\n\t\t} else {\n\t\t\t//no particle effects\n\t\t\tview( image = item.image(), item.glowing() );\n\t\t}\n\n\t\tthis.callback = listener;\n\n\t\tpoint( from );\n\n\t\tPointF d = PointF.diff( to, from );\n\t\tspeed.set( d ).normalize().scale( SPEED );\n\n\t\tif (image == ItemSpriteSheet.DART || image == ItemSpriteSheet.INCENDIARY_DART\n\t\t\t\t|| image == ItemSpriteSheet.CURARE_DART  || image == ItemSpriteSheet.JAVELIN) {\n\n\t\t\tangularSpeed = 0;\n\t\t\tangle = 135 - (float)(Math.atan2( d.x, d.y ) / 3.1415926 * 180);\n\n\t\t} else {\n\n\t\t\tangularSpeed = image == 15 || image == 106 ? 1440 : 720;\n\n\t\t}\n\n\t\tPosTweener tweener = new PosTweener( this, to, d.length() / SPEED );\n\t\ttweener.listener = this;\n\t\tparent.add( tweener );\n\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_41_47_63_96_49_54"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset( int from, int to, Item item, Callback listener ) {\n\t\tif (item == null) {\n\t\t\treset( from, to, 0, null, listener );\n\t\t} else {\n\t\t\treset( from, to, item.image(), item.glowing(), listener );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void reset( Visual from, Visual to, Item item, Callback listener ) {\n\t\treset( from.center(this),\n\t\t\t\tto.center(this),\n\t\t\t\titem,\n\t\t\t\tlistener);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void reset( PointF from, PointF to, Item item, Callback listener) {\n\t\trevive();\n\n\t\tint image;\n\t\tif (item == null){\n\t\t\tview( image = 0, null);;\n\t\t} else {\n\t\t\t//no particle effects\n\t\t\tview( image = item.image(), item.glowing() );\n\t\t}\n\n\t\tthis.callback = listener;\n\n\t\tpoint( from );\n\n\t\tPointF d = PointF.diff( to, from );\n\t\tspeed.set( d ).normalize().scale( SPEED );\n\n\t\tif (image == ItemSpriteSheet.DART || image == ItemSpriteSheet.INCENDIARY_DART\n\t\t\t\t|| image == ItemSpriteSheet.CURARE_DART  || image == ItemSpriteSheet.JAVELIN) {\n\n\t\t\tangularSpeed = 0;\n\t\t\tangle = 135 - (float)(Math.atan2( d.x, d.y ) / 3.1415926 * 180);\n\n\t\t} else {\n\n\t\t\tangularSpeed = image == 15 || image == 106 ? 1440 : 720;\n\n\t\t}\n\n\t\tPosTweener tweener = new PosTweener( this, to, d.length() / SPEED );\n\t\ttweener.listener = this;\n\t\tparent.add( tweener );\n\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_41_47_63_96_49_54"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset( int from, int to, Item item, Callback listener ) {\n\t\tif (item == null) {\n\t\t\treset( from, to, 0, null, listener );\n\t\t} else {\n\t\t\treset( from, to, item.image(), item.glowing(), listener );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void reset( int from, int to, Item item, Callback listener ) {\n\t\treset( DungeonTilemap.tileToWorld( from ),\n\t\t\t\tDungeonTilemap.tileToWorld( to ),\n\t\t\t\titem,\n\t\t\t\tlistener);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void reset( PointF from, PointF to, Item item, Callback listener) {\n\t\trevive();\n\n\t\tint image;\n\t\tif (item == null){\n\t\t\tview( image = 0, null);;\n\t\t} else {\n\t\t\t//no particle effects\n\t\t\tview( image = item.image(), item.glowing() );\n\t\t}\n\n\t\tthis.callback = listener;\n\n\t\tpoint( from );\n\n\t\tPointF d = PointF.diff( to, from );\n\t\tspeed.set( d ).normalize().scale( SPEED );\n\n\t\tif (image == ItemSpriteSheet.DART || image == ItemSpriteSheet.INCENDIARY_DART\n\t\t\t\t|| image == ItemSpriteSheet.CURARE_DART  || image == ItemSpriteSheet.JAVELIN) {\n\n\t\t\tangularSpeed = 0;\n\t\t\tangle = 135 - (float)(Math.atan2( d.x, d.y ) / 3.1415926 * 180);\n\n\t\t} else {\n\n\t\t\tangularSpeed = image == 15 || image == 106 ? 1440 : 720;\n\n\t\t}\n\n\t\tPosTweener tweener = new PosTweener( this, to, d.length() / SPEED );\n\t\ttweener.listener = this;\n\t\tparent.add( tweener );\n\t}",
          "uniqueId": "26daff58b2668847f4ea533df283f429128e8957_41_47_63_96_42_47"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2ec6e414d322430a72a85c56cf754507288f9778",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2ec6e414d322430a72a85c56cf754507288f9778",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public int screenToTile(int x, int y ) {\n\t\tPoint p = camera().screenToCamera( x, y ).\n\t\t\toffset( this.point().negate() ).\n\t\t\tinvScale( SIZE ).\n\t\t\tfloor();\n\t\treturn p.x >= 0\n\t\t\t\t&& p.x < Dungeon.level.width()\n\t\t\t\t&& p.y >= 0\n\t\t\t\t&& p.y < Dungeon.level.height() ?\n\t\t\t\t\tp.x + p.y * Dungeon.level.width()\n\t\t\t\t\t: -1;\n\t}",
          "sourceCodeAfterRefactoring": "public int screenToTile(int x, int y ){\n\t\treturn screenToTile(x, y, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int screenToTile(int x, int y, boolean wallAssist ) {\n\t\tPointF p = camera().screenToCamera( x, y ).\n\t\t\toffset( this.point().negate() ).\n\t\t\tinvScale( SIZE );\n\t\tif (p.x < 0 || p.x >= Dungeon.level.width()\n\t\t\t\t|| p.y < 0\n\t\t\t\t|| p.y >= Dungeon.level.height())\n\t\t\treturn -1;\n\n\t\tint cell = (int)p.x + (int)p.y * Dungeon.level.width();\n\n\t\tif (wallAssist\n\t\t\t\t&& map != null\n\t\t\t\t&& DungeonTileSheet.wallStitcheable.contains(map[cell])){\n\n\t\t\tif (cell + mapWidth < size\n\t\t\t\t\t&& p.y % 1 >= 0.75f\n\t\t\t\t\t&& !DungeonTileSheet.wallStitcheable.contains(map[cell + mapWidth])){\n\t\t\t\tcell += mapWidth;\n\t\t\t}\n\n\t\t}\n\n\t\treturn cell;\n\t}",
          "uniqueId": "2ec6e414d322430a72a85c56cf754507288f9778_75_86_82_106_75_77"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "003951ab006b340a8326305281775f9c9dfef687",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/003951ab006b340a8326305281775f9c9dfef687",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic synchronized void updateMapCell(int cell) {\n\t\tint prev = data[cell];\n\t\tint curr;\n\n\t\t//no point in blocking tiles that are already obscured by fog\n\t\tif (fogHidden(cell) && fogHidden(cell - mapWidth)){\n\t\t\tcurr = BLOCK_NONE;\n\n\t\t} else if (DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell])) {\n\t\t\tif (cell + mapWidth < Dungeon.level.map.length) {\n\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + mapWidth])) {\n\t\t\t\t\tif (fogHidden(cell + mapWidth)) {\n\t\t\t\t\t\tcurr = BLOCK_ALL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\t\tif ((cell + 1) % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + 1])){\n\t\t\t\t\t\t\tif (fogHidden(cell + 1)) {\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell + 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cell % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell - 1])){\n\t\t\t\t\t\t\tif (fogHidden(cell - 1)) {\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell - 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\tif ((cell + 1) % mapWidth != 0 && fogHidden(cell + 1)) {\n\t\t\t\t\tcurr += 1;\n\t\t\t\t}\n\n\t\t\t\tif (cell % mapWidth != 0 && fogHidden(cell - 1)) {\n\t\t\t\t\tcurr += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tcurr = BLOCK_NONE;\n\t\t}\n\n\t\tif (prev != curr){\n\t\t\tdata[cell] = curr;\n\t\t\tsuper.updateMapCell(cell);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic synchronized void updateMapCell(int cell) {\n\t\tint prev = data[cell];\n\t\tint curr;\n\n\t\t//no point in blocking tiles that are already obscured by fog\n\t\tif (fogHidden(cell) && fogHidden(cell - mapWidth)){\n\t\t\tcurr = BLOCK_NONE;\n\n\t\t} else if (wall(cell)) {\n\t\t\tif (cell + mapWidth < Dungeon.level.map.length) {\n\t\t\t\tif (!wall(cell + mapWidth)) {\n\t\t\t\t\tif (!fogHidden(cell + mapWidth)){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else if ((cell + 1) % mapWidth != 0 && !fogHidden(cell + 1)\n\t\t\t\t\t\t\t&& !door(cell + 1) && !(wall(cell + 1) && wall(cell + 1 + mapWidth))){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else if (cell % mapWidth != 0 && !fogHidden(cell - 1)\n\t\t\t\t\t\t\t&& !door(cell - 1) && !(wall(cell - 1) && wall(cell - 1 + mapWidth))){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurr = BLOCK_ALL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\t\tif ((cell + 1) % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!wall(cell + 1) && !door(cell + 1)){\n\t\t\t\t\t\t\tif (fogHidden(cell + 1)) {\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell + 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cell % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!wall(cell - 1) && !door(cell - 1)){\n\t\t\t\t\t\t\tif (fogHidden(cell - 1)) {\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell - 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\tif ((cell + 1) % mapWidth != 0 && fogHidden(cell + 1)) {\n\t\t\t\t\tcurr += 1;\n\t\t\t\t}\n\n\t\t\t\tif (cell % mapWidth != 0 && fogHidden(cell - 1)) {\n\t\t\t\t\tcurr += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tcurr = BLOCK_NONE;\n\t\t}\n\n\t\tif (prev != curr){\n\t\t\tdata[cell] = curr;\n\t\t\tsuper.updateMapCell(cell);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean wall(int cell){\n\t\treturn DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell]);\n\t}",
          "uniqueId": "003951ab006b340a8326305281775f9c9dfef687_49_119_137_139_49_125"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic synchronized void updateMapCell(int cell) {\n\t\tint prev = data[cell];\n\t\tint curr;\n\n\t\t//no point in blocking tiles that are already obscured by fog\n\t\tif (fogHidden(cell) && fogHidden(cell - mapWidth)){\n\t\t\tcurr = BLOCK_NONE;\n\n\t\t} else if (DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell])) {\n\t\t\tif (cell + mapWidth < Dungeon.level.map.length) {\n\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + mapWidth])) {\n\t\t\t\t\tif (fogHidden(cell + mapWidth)) {\n\t\t\t\t\t\tcurr = BLOCK_ALL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\t\tif ((cell + 1) % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + 1])){\n\t\t\t\t\t\t\tif (fogHidden(cell + 1)) {\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell + 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cell % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell - 1])){\n\t\t\t\t\t\t\tif (fogHidden(cell - 1)) {\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell - 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\tif ((cell + 1) % mapWidth != 0 && fogHidden(cell + 1)) {\n\t\t\t\t\tcurr += 1;\n\t\t\t\t}\n\n\t\t\t\tif (cell % mapWidth != 0 && fogHidden(cell - 1)) {\n\t\t\t\t\tcurr += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tcurr = BLOCK_NONE;\n\t\t}\n\n\t\tif (prev != curr){\n\t\t\tdata[cell] = curr;\n\t\t\tsuper.updateMapCell(cell);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic synchronized void updateMapCell(int cell) {\n\t\tint prev = data[cell];\n\t\tint curr;\n\n\t\t//no point in blocking tiles that are already obscured by fog\n\t\tif (fogHidden(cell) && fogHidden(cell - mapWidth)){\n\t\t\tcurr = BLOCK_NONE;\n\n\t\t} else if (wall(cell)) {\n\t\t\tif (cell + mapWidth < Dungeon.level.map.length) {\n\t\t\t\tif (!wall(cell + mapWidth)) {\n\t\t\t\t\tif (!fogHidden(cell + mapWidth)){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else if ((cell + 1) % mapWidth != 0 && !fogHidden(cell + 1)\n\t\t\t\t\t\t\t&& !door(cell + 1) && !(wall(cell + 1) && wall(cell + 1 + mapWidth))){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else if (cell % mapWidth != 0 && !fogHidden(cell - 1)\n\t\t\t\t\t\t\t&& !door(cell - 1) && !(wall(cell - 1) && wall(cell - 1 + mapWidth))){\n\t\t\t\t\t\tcurr = BLOCK_NONE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurr = BLOCK_ALL;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\t\tif ((cell + 1) % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!wall(cell + 1) && !door(cell + 1)){\n\t\t\t\t\t\t\tif (fogHidden(cell + 1)) {\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell + 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cell % mapWidth != 0) {\n\n\t\t\t\t\t\tif (!wall(cell - 1) && !door(cell - 1)){\n\t\t\t\t\t\t\tif (fogHidden(cell - 1)) {\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (fogHidden(cell - 1 + mapWidth)){\n\t\t\t\t\t\t\t\tcurr += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tcurr = BLOCK_NONE;\n\n\t\t\t\tif ((cell + 1) % mapWidth != 0 && fogHidden(cell + 1)) {\n\t\t\t\t\tcurr += 1;\n\t\t\t\t}\n\n\t\t\t\tif (cell % mapWidth != 0 && fogHidden(cell - 1)) {\n\t\t\t\t\tcurr += 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tcurr = BLOCK_NONE;\n\t\t}\n\n\t\tif (prev != curr){\n\t\t\tdata[cell] = curr;\n\t\t\tsuper.updateMapCell(cell);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean door(int cell ) {\n\t\treturn DungeonTileSheet.doorTiles.contains(Dungeon.level.map[cell]);\n\t}",
          "uniqueId": "003951ab006b340a8326305281775f9c9dfef687_49_119_141_143_49_125"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d1f729500a8a4f23b2852cf8a551f223ce8b5419",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d1f729500a8a4f23b2852cf8a551f223ce8b5419",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\t//fog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell >= Dungeon.level.length()) {\n\t\t\t\t\t//do nothing\n\t\t\t\t} else if (visible[cell]) {\n\t\t\t\t\tfillCell(j, i, VISIBLE[brightness]);\n\t\t\t\t} else if (visited[cell]) {\n\t\t\t\t\tfillCell(j, i, VISITED[brightness]);\n\t\t\t\t} else if (mapped[cell] ) {\n\t\t\t\t\tfillCell(j, i, MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\t\tthis.visible = visible;\n\t\tthis.visited = visited;\n\t\tthis.mapped = mapped;\n\t\tthis.brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint cellIndex;\n\t\tint[] colorArray = new int[PIX_PER_TILE*PIX_PER_TILE];\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\n\t\t\t\tif (cell >= Dungeon.level.length()) continue; //do nothing\n\n\t\t\t\tif (!visible[cell] && !visited[cell] && !mapped[cell]){\n\t\t\t\t\tfillCell(j, i, FOG_COLORS[INVISIBLE][brightness]);\n\t\t\t\t\tcell++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//triggers on wall tiles or sideways doors\n\t\t\t\tif (DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell]) ||\n\t\t\t\t\t\t( DungeonTileSheet.doorTiles.contains(Dungeon.level.map[cell])\n\t\t\t\t\t\t\t\t&& cell + mapWidth < mapLength\n\t\t\t\t\t\t\t\t&& DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + mapWidth]))) {\n\t\t\t\t\tcellIndex = getColorIndexForCell(cell);\n\n\t\t\t\t\tif (cell + mapWidth < mapLength){\n\t\t\t\t\t\tif (!DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + mapWidth])\n\t\t\t\t\t\t\t\t&& getColorIndexForCell(cell + mapWidth) > cellIndex) {\n\t\t\t\t\t\t\tcellIndex = getColorIndexForCell(cell + mapWidth);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cell % mapWidth != 0){\n\t\t\t\t\t\t\tif (DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell - 1])){\n\t\t\t\t\t\t\t\tif (getColorIndexForCell(cell - 1 + mapWidth) > cellIndex)\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[getColorIndexForCell(cell - 1 + mapWidth)][brightness];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (getColorIndexForCell(cell - 1) > cellIndex)\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[getColorIndexForCell(cell - 1)][brightness];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((cell+1) % mapWidth != 0){\n\t\t\t\t\t\t\tif (DungeonTileSheet.wallStitcheable.contains(Dungeon.level.map[cell + 1])){\n\t\t\t\t\t\t\t\tif (getColorIndexForCell(cell + 1 + mapWidth) > cellIndex)\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[getColorIndexForCell(cell + 1 + mapWidth)][brightness];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (getColorIndexForCell(cell + 1) > cellIndex)\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[getColorIndexForCell(cell + 1)][brightness];\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cell % mapWidth != 0 && getColorIndexForCell(cell - 1) > cellIndex) {\n\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[getColorIndexForCell(cell - 1)][brightness];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[0] = colorArray[2] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ((cell+1) % mapWidth != 0 && getColorIndexForCell(cell + 1) > cellIndex) {\n\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[getColorIndexForCell(cell + 1)][brightness];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolorArray[1] = colorArray[3] = FOG_COLORS[cellIndex][brightness];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfillCell(j, i, colorArray);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, FOG_COLORS[getColorIndexForCell(cell)][brightness]);\n\t\t\t\t}\n\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int getColorIndexForCell( int cell ){\n\n\t\tif (visible[cell]) {\n\t\t\treturn VISIBLE;\n\t\t} else if (visited[cell]) {\n\t\t\treturn VISITED;\n\t\t} else if (mapped[cell] ) {\n\t\t\treturn MAPPED;\n\t\t} else {\n\t\t\treturn INVISIBLE;\n\t\t}\n\t}",
          "uniqueId": "d1f729500a8a4f23b2852cf8a551f223ce8b5419_117_149_236_247_137_234"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9a3ecbe0814a8ba016197f33cf3189a291bf12ad",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9a3ecbe0814a8ba016197f33cf3189a291bf12ad",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updating.left;\n\t\t\tfog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length() || j == 0 || j == pWidth-1) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED[brightness]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == pWidth && updating.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top, updating.bottom);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\t//fog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell >= Dungeon.level.length()) {\n\t\t\t\t\t//do nothing\n\t\t\t\t} else if (visible[cell]) {\n\t\t\t\t\tfillCell(j, i, VISIBLE[brightness]);\n\t\t\t\t} else if (visited[cell]) {\n\t\t\t\t\tfillCell(j, i, VISITED[brightness]);\n\t\t\t\t} else if (mapped[cell] ) {\n\t\t\t\t\tfillCell(j, i, MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillCell( int x, int y, int color){\n\t\tFogTexture fog = (FogTexture)texture;\n\t\tfor (int i = 0; i < PIX_PER_TILE; i++){\n\t\t\tfog.pixels.position(((y * PIX_PER_TILE)+i)*width2 + x * PIX_PER_TILE);\n\t\t\tfor (int j = 0; j < PIX_PER_TILE; j++) {\n\t\t\t\tfog.pixels.put(color);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "9a3ecbe0814a8ba016197f33cf3189a291bf12ad_110_149_150_158_116_148"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updating.left;\n\t\t\tfog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length() || j == 0 || j == pWidth-1) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED[brightness]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == pWidth && updating.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top, updating.bottom);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\t//fog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell >= Dungeon.level.length()) {\n\t\t\t\t\t//do nothing\n\t\t\t\t} else if (visible[cell]) {\n\t\t\t\t\tfillCell(j, i, VISIBLE[brightness]);\n\t\t\t\t} else if (visited[cell]) {\n\t\t\t\t\tfillCell(j, i, VISITED[brightness]);\n\t\t\t\t} else if (mapped[cell] ) {\n\t\t\t\t\tfillCell(j, i, MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillCell( int x, int y, int color){\n\t\tFogTexture fog = (FogTexture)texture;\n\t\tfor (int i = 0; i < PIX_PER_TILE; i++){\n\t\t\tfog.pixels.position(((y * PIX_PER_TILE)+i)*width2 + x * PIX_PER_TILE);\n\t\t\tfor (int j = 0; j < PIX_PER_TILE; j++) {\n\t\t\t\tfog.pixels.put(color);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "9a3ecbe0814a8ba016197f33cf3189a291bf12ad_110_149_150_158_116_148"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updating.left;\n\t\t\tfog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length() || j == 0 || j == pWidth-1) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED[brightness]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == pWidth && updating.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top, updating.bottom);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\t//fog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell >= Dungeon.level.length()) {\n\t\t\t\t\t//do nothing\n\t\t\t\t} else if (visible[cell]) {\n\t\t\t\t\tfillCell(j, i, VISIBLE[brightness]);\n\t\t\t\t} else if (visited[cell]) {\n\t\t\t\t\tfillCell(j, i, VISITED[brightness]);\n\t\t\t\t} else if (mapped[cell] ) {\n\t\t\t\t\tfillCell(j, i, MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillCell( int x, int y, int color){\n\t\tFogTexture fog = (FogTexture)texture;\n\t\tfor (int i = 0; i < PIX_PER_TILE; i++){\n\t\t\tfog.pixels.position(((y * PIX_PER_TILE)+i)*width2 + x * PIX_PER_TILE);\n\t\t\tfor (int j = 0; j < PIX_PER_TILE; j++) {\n\t\t\t\tfog.pixels.put(color);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "9a3ecbe0814a8ba016197f33cf3189a291bf12ad_110_149_150_158_116_148"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updating.left;\n\t\t\tfog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length() || j == 0 || j == pWidth-1) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE[brightness]);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED[brightness]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == pWidth && updating.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top, updating.bottom);\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tint brightness = ShatteredPixelDungeon.brightness() + 2;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = mapWidth * i + updating.left;\n\t\t\t//fog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell >= Dungeon.level.length()) {\n\t\t\t\t\t//do nothing\n\t\t\t\t} else if (visible[cell]) {\n\t\t\t\t\tfillCell(j, i, VISIBLE[brightness]);\n\t\t\t\t} else if (visited[cell]) {\n\t\t\t\t\tfillCell(j, i, VISITED[brightness]);\n\t\t\t\t} else if (mapped[cell] ) {\n\t\t\t\t\tfillCell(j, i, MAPPED[brightness]);\n\t\t\t\t} else {\n\t\t\t\t\tfillCell(j, i, INVISIBLE[brightness]);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == mapWidth && updating.height() == mapWidth)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top * PIX_PER_TILE, updating.bottom * PIX_PER_TILE);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void fillCell( int x, int y, int color){\n\t\tFogTexture fog = (FogTexture)texture;\n\t\tfor (int i = 0; i < PIX_PER_TILE; i++){\n\t\t\tfog.pixels.position(((y * PIX_PER_TILE)+i)*width2 + x * PIX_PER_TILE);\n\t\t\tfor (int j = 0; j < PIX_PER_TILE; j++) {\n\t\t\t\tfog.pixels.put(color);\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "9a3ecbe0814a8ba016197f33cf3189a291bf12ad_110_149_150_158_116_148"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9c87d9d47d15d8a14cd30e8c946fb4aa06d2af26",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9c87d9d47d15d8a14cd30e8c946fb4aa06d2af26",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Window( int width, int height, NinePatch chrome ) {\n\t\tsuper();\n\t\t\n\t\tblocker = new TouchArea( 0, 0, PixelScene.uiCamera.width, PixelScene.uiCamera.height ) {\n\t\t\t@Override\n\t\t\tprotected void onClick( Touch touch ) {\n\t\t\t\tif (Window.this.parent != null && !Window.this.chrome.overlapsScreenPoint(\n\t\t\t\t\t(int)touch.current.x,\n\t\t\t\t\t(int)touch.current.y )) {\n\t\t\t\t\t\n\t\t\t\t\tonBackPressed();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tblocker.camera = PixelScene.uiCamera;\n\t\tadd( blocker );\n\t\t\n\t\tthis.chrome = chrome;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tshadow = new ShadowBox();\n\t\tshadow.am = 0.5f;\n\t\tshadow.camera = PixelScene.uiCamera.visible ?\n\t\t\t\tPixelScene.uiCamera : Camera.main;\n\t\tadd( shadow );\n\n\t\tchrome.x = -chrome.marginLeft();\n\t\tchrome.y = -chrome.marginTop();\n\t\tchrome.size(\n\t\t\twidth - chrome.x + chrome.marginRight(),\n\t\t\theight - chrome.y + chrome.marginBottom() );\n\t\tadd( chrome );\n\t\t\n\t\tcamera = new Camera( 0, 0,\n\t\t\t(int)chrome.width,\n\t\t\t(int)chrome.height,\n\t\t\tPixelScene.defaultZoom );\n\t\tcamera.x = (int)(Game.width - camera.width * camera.zoom) / 2;\n\t\tcamera.y = (int)(Game.height - camera.height * camera.zoom) / 2;\n\t\tcamera.scroll.set( chrome.x, chrome.y );\n\t\tCamera.add( camera );\n\n\t\tshadow.boxRect(\n\t\t\t\tcamera.x / camera.zoom,\n\t\t\t\tcamera.y / camera.zoom,\n\t\t\t\tchrome.width(), chrome.height );\n\n\t\tKeys.event.add( this );\n\t}",
          "sourceCodeAfterRefactoring": "public Window( int width, int height, NinePatch chrome ) {\n\t\tthis(width, height, 0, chrome);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Window( int width, int height, int yOffset, NinePatch chrome ) {\n\t\tsuper();\n\n\t\tthis.yOffset = yOffset;\n\t\t\n\t\tblocker = new TouchArea( 0, 0, PixelScene.uiCamera.width, PixelScene.uiCamera.height ) {\n\t\t\t@Override\n\t\t\tprotected void onClick( Touch touch ) {\n\t\t\t\tif (Window.this.parent != null && !Window.this.chrome.overlapsScreenPoint(\n\t\t\t\t\t(int)touch.current.x,\n\t\t\t\t\t(int)touch.current.y )) {\n\t\t\t\t\t\n\t\t\t\t\tonBackPressed();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tblocker.camera = PixelScene.uiCamera;\n\t\tadd( blocker );\n\t\t\n\t\tthis.chrome = chrome;\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\n\t\tshadow = new ShadowBox();\n\t\tshadow.am = 0.5f;\n\t\tshadow.camera = PixelScene.uiCamera.visible ?\n\t\t\t\tPixelScene.uiCamera : Camera.main;\n\t\tadd( shadow );\n\n\t\tchrome.x = -chrome.marginLeft();\n\t\tchrome.y = -chrome.marginTop();\n\t\tchrome.size(\n\t\t\twidth - chrome.x + chrome.marginRight(),\n\t\t\theight - chrome.y + chrome.marginBottom() );\n\t\tadd( chrome );\n\t\t\n\t\tcamera = new Camera( 0, 0,\n\t\t\t(int)chrome.width,\n\t\t\t(int)chrome.height,\n\t\t\tPixelScene.defaultZoom );\n\t\tcamera.x = (int)(Game.width - camera.width * camera.zoom) / 2;\n\t\tcamera.y = (int)(Game.height - camera.height * camera.zoom) / 2;\n\t\tcamera.y -= yOffset * camera.zoom;\n\t\tcamera.scroll.set( chrome.x, chrome.y );\n\t\tCamera.add( camera );\n\n\t\tshadow.boxRect(\n\t\t\t\tcamera.x / camera.zoom,\n\t\t\t\tcamera.y / camera.zoom,\n\t\t\t\tchrome.width(), chrome.height );\n\n\t\tKeys.event.add( this );\n\t}",
          "uniqueId": "9c87d9d47d15d8a14cd30e8c946fb4aa06d2af26_56_106_62_115_58_60"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6ed1ec2214b768719a3f745ac63e0c28e65df463",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6ed1ec2214b768719a3f745ac63e0c28e65df463",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void draw() {\n\n\t\tif (texture == null)\n\t\t\treturn;\n\t\t\n\t\tsuper.draw();\n\n\t\tif (dirty) {\n\t\t\tverticesBuffer.position( 0 );\n\t\t\tverticesBuffer.put( vertices );\n\t\t\tif (buffer == null)\n\t\t\t\tbuffer = new Vertexbuffer( verticesBuffer );\n\t\t\telse\n\t\t\t\tbuffer.updateVertices( verticesBuffer );\n\t\t\tdirty = false;\n\t\t}\n\n\t\tNoosaScript script = NoosaScript.get();\n\t\t\n\t\ttexture.bind();\n\t\t\n\t\tscript.camera( camera() );\n\t\t\n\t\tscript.uModel.valueM4( matrix );\n\t\tscript.lighting(\n\t\t\trm, gm, bm, am,\n\t\t\tra, ga, ba, aa );\n\n\t\tscript.drawQuad( buffer );\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void draw() {\n\n\t\tif (texture == null)\n\t\t\treturn;\n\t\t\n\t\tsuper.draw();\n\n\t\tif (dirty) {\n\t\t\tverticesBuffer.position( 0 );\n\t\t\tverticesBuffer.put( vertices );\n\t\t\tif (buffer == null)\n\t\t\t\tbuffer = new Vertexbuffer( verticesBuffer );\n\t\t\telse\n\t\t\t\tbuffer.updateVertices( verticesBuffer );\n\t\t\tdirty = false;\n\t\t}\n\n\t\tNoosaScript script = script();\n\t\t\n\t\ttexture.bind();\n\t\t\n\t\tscript.camera( camera() );\n\t\t\n\t\tscript.uModel.valueM4( matrix );\n\t\tscript.lighting(\n\t\t\trm, gm, bm, am,\n\t\t\tra, ga, ba, aa );\n\n\t\tscript.drawQuad( buffer );\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected NoosaScript script(){\n\t\treturn NoosaScript.get();\n\t}",
          "uniqueId": "6ed1ec2214b768719a3f745ac63e0c28e65df463_149_180_182_184_149_180"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "5d9035e9d908fb4766e78e9dd86e96b25dd97dbf",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/5d9035e9d908fb4766e78e9dd86e96b25dd97dbf",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int flee( Char ch, int cur, int from, boolean pass[], boolean[] visible ) {\n\n\t\tboolean[] passable = new boolean[Dungeon.level.length()];\n\t\tif (ch.flying) {\n\t\t\tBArray.or( pass, Level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\t\t\n\t\tfor (Char c : Actor.chars()) {\n\t\t\tif (visible[c.pos]) {\n\t\t\t\tpassable[c.pos] = false;\n\t\t\t}\n\t\t}\n\t\tpassable[cur] = true;\n\t\t\n\t\treturn PathFinder.getStepBack( cur, from, passable );\n\t\t\n\t}",
          "sourceCodeAfterRefactoring": "public static int flee( Char ch, int cur, int from, boolean pass[], boolean[] visible ) {\n\n\t\tsetupPassable();\n\t\tif (ch.flying) {\n\t\t\tBArray.or( pass, Level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\t\t\n\t\tfor (Char c : Actor.chars()) {\n\t\t\tif (visible[c.pos]) {\n\t\t\t\tpassable[c.pos] = false;\n\t\t\t}\n\t\t}\n\t\tpassable[cur] = true;\n\t\t\n\t\treturn PathFinder.getStepBack( cur, from, passable );\n\t\t\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void setupPassable(){\n\t\tif (passable == null || passable.length != Dungeon.level.length())\n\t\t\tpassable = new boolean[Dungeon.level.length()];\n\t\telse\n\t\t\tBArray.setFalse(passable);\n\t}",
          "uniqueId": "5d9035e9d908fb4766e78e9dd86e96b25dd97dbf_719_737_699_704_748_766"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int findPath( Char ch, int from, int to, boolean pass[], boolean[] visible ) {\n\n\t\tif (level.adjacent( from, to )) {\n\t\t\treturn Actor.findChar( to ) == null && (pass[to] || Level.avoid[to]) ? to : -1;\n\t\t}\n\n\t\tboolean[] passable = new boolean[Dungeon.level.length()];\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\t\t\n\t\tfor (Char c : Actor.chars()) {\n\t\t\tif (visible[c.pos]) {\n\t\t\t\tpassable[c.pos] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn PathFinder.getStep( from, to, passable );\n\n\t}",
          "sourceCodeAfterRefactoring": "public static PathFinder.Path findPath(Char ch, int from, int to, boolean pass[], boolean[] visible ) {\n\n\t\tsetupPassable();\n\t\tif (ch.flying || ch.buff( Amok.class ) != null) {\n\t\t\tBArray.or( pass, Level.avoid, passable );\n\t\t} else {\n\t\t\tSystem.arraycopy( pass, 0, passable, 0, Dungeon.level.length() );\n\t\t}\n\n\t\tfor (Char c : Actor.chars()) {\n\t\t\tif (visible[c.pos]) {\n\t\t\t\tpassable[c.pos] = false;\n\t\t\t}\n\t\t}\n\n\t\treturn PathFinder.find( from, to, passable );\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void setupPassable(){\n\t\tif (passable == null || passable.length != Dungeon.level.length())\n\t\t\tpassable = new boolean[Dungeon.level.length()];\n\t\telse\n\t\t\tBArray.setFalse(passable);\n\t}",
          "uniqueId": "5d9035e9d908fb4766e78e9dd86e96b25dd97dbf_696_717_699_704_706_723"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4aba5afade20a8bc6bfd4fea8c797605dc618c7f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4aba5afade20a8bc6bfd4fea8c797605dc618c7f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void updateVisibility( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tif (updated.isEmpty())\n\t\t\treturn;\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tfor (int i=updated.top; i < updated.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updated.left;\n\t\t\tfog.pixels.position((width2) * i + updated.left);\n\t\t\tfor (int j=updated.left; j < updated.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length()) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updated.width() == pWidth && updated.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updated.top, updated.bottom);\n\t\tupdated.setEmpty();\n\n\t}",
          "sourceCodeAfterRefactoring": "private void updateTexture( boolean[] visible, boolean[] visited, boolean[] mapped ) {\n\n\t\tmoveToUpdating();\n\n\t\tFogTexture fog = (FogTexture)texture;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\t\t\tint cell = (pWidth - 1) * i + updating.left;\n\t\t\tfog.pixels.position((width2) * i + updating.left);\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\t\t\t\tif (cell < pWidth || cell >= Dungeon.level.length()) {\n\t\t\t\t\tfog.pixels.put(INVISIBLE);\n\t\t\t\t} else\n\t\t\t\tif (visible[cell] && visible[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisible[cell - 1] && visible[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISIBLE);\n\t\t\t\t} else\n\t\t\t\tif (visited[cell] && visited[cell - (pWidth - 1)] &&\n\t\t\t\t\tvisited[cell - 1] && visited[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(VISITED);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif (mapped[cell] && mapped[cell - (pWidth - 1)] &&\n\t\t\t\t\tmapped[cell - 1] && mapped[cell - (pWidth - 1) - 1]) {\n\t\t\t\t\tfog.pixels.put(MAPPED);\n\t\t\t\t} else {\n\t\t\t\t\tfog.pixels.put(INVISIBLE);\n\t\t\t\t}\n\t\t\t\tcell++;\n\t\t\t}\n\t\t}\n\n\t\tif (updating.width() == pWidth && updating.height() == pHeight)\n\t\t\tfog.update();\n\t\telse\n\t\t\tfog.update(updating.top, updating.bottom);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic synchronized void moveToUpdating(){\n\t\tupdating = new Rect(updated);\n\t\tupdated.setEmpty();\n\t}",
          "uniqueId": "4aba5afade20a8bc6bfd4fea8c797605dc618c7f_82_121_92_95_97_134"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void updateFog(){\n\t\tif (scene != null)\n\t\t\tscene.fog.updated.set(0, 0, Dungeon.level.width()+1, Dungeon.level.height()+1);\n\t}",
          "sourceCodeAfterRefactoring": "public static void updateFog(){\n\t\tif (scene != null)\n\t\t\tscene.fog.updateFog();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndInfoPlant;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndInfoTrap;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndMessage;",
          "uniqueId": "4aba5afade20a8bc6bfd4fea8c797605dc618c7f_708_711_83_85_707_710"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void updateFog(int x, int y, int w, int h){\n\t\tif (scene != null) {\n\t\t\tscene.fog.updated.union(x, y);\n\t\t\tscene.fog.updated.union(x + w, y + h);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void updateFog(int x, int y, int w, int h){\n\t\tif (scene != null) {\n\t\t\tscene.fog.updateFogArea(x, y, w, h);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndStory;\nimport com.shatteredpixel.shatteredpixeldungeon.windows.WndTradeItem;\nimport com.watabou.noosa.Camera;\nimport com.watabou.noosa.Game;",
          "uniqueId": "4aba5afade20a8bc6bfd4fea8c797605dc618c7f_713_718_87_90_712_716"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6bcccba062d4484ca99d8c08142a4ecb4187b8f1",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6bcccba062d4484ca99d8c08142a4ecb4187b8f1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void updateVertices() {\n\n\t\tfloat y1 = cellH * updated.top;\n\t\tfloat y2 = y1 + cellH;\n\n\t\tfor (int i=updated.top; i < updated.bottom; i++) {\n\n\t\t\tfloat x1 = cellW * updated.left;\n\t\t\tfloat x2 = x1 + cellW;\n\n\t\t\tint pos = i * mapWidth + updated.left;\n\n\t\t\tfor (int j=updated.left; j < updated.right; j++) {\n\n\t\t\t\t//Currently if a none-rendered tile becomes rendered it will mess with culling in draw()\n\t\t\t\t//However shifting the whole array is expensive, even with selective updating\n\t\t\t\t//So right now I'm accepting this as an engine limitation, but support could be added.\n\n\t\t\t\t//It's also worth noting that nothing is stopping the game from rendering tiles\n\t\t\t\t//which will need to be visible in future as transparent, and accepting the small\n\t\t\t\t//performance cost of rendering them before they become visible\n\t\t\t\tif (needsRender(pos) || bufferPositions[pos] != -1) {\n\t\t\t\t\tint bufferPos = bufferPositions[pos];\n\t\t\t\t\tif (bufferPos == -1){\n\t\t\t\t\t\tbufferPos = bufferPositions[pos] = bufferLength;\n\t\t\t\t\t\tbufferLength ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tquads.position(bufferPos*16);\n\t\t\t\t\tRectF uv = tileset.get( data[pos] );\n\n\t\t\t\t\tvertices[0] \t= x1;\n\t\t\t\t\tvertices[1] \t= y1;\n\n\t\t\t\t\tvertices[2]\t\t= uv.left;\n\t\t\t\t\tvertices[3]\t\t= uv.top;\n\n\t\t\t\t\tvertices[4] \t= x2;\n\t\t\t\t\tvertices[5] \t= y1;\n\n\t\t\t\t\tvertices[6]\t\t= uv.right;\n\t\t\t\t\tvertices[7]\t\t= uv.top;\n\n\t\t\t\t\tvertices[8] \t= x2;\n\t\t\t\t\tvertices[9] \t= y2;\n\n\t\t\t\t\tvertices[10]\t= uv.right;\n\t\t\t\t\tvertices[11]\t= uv.bottom;\n\n\t\t\t\t\tvertices[12]\t= x1;\n\t\t\t\t\tvertices[13]\t= y2;\n\n\t\t\t\t\tvertices[14]\t= uv.left;\n\t\t\t\t\tvertices[15]\t= uv.bottom;\n\n\t\t\t\t\tquads.put( vertices );\n\t\t\t\t}\n\n\t\t\t\tpos++;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 += cellW;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\ty1 = y2;\n\t\t\ty2 += cellH;\n\t\t}\n\t\t\n\t\tupdated.setEmpty();\n\t}",
          "sourceCodeAfterRefactoring": "protected void updateVertices() {\n\n\t\tmoveToUpdating();\n\n\t\tfloat y1 = cellH * updating.top;\n\t\tfloat y2 = y1 + cellH;\n\n\t\tfor (int i=updating.top; i < updating.bottom; i++) {\n\n\t\t\tfloat x1 = cellW * updating.left;\n\t\t\tfloat x2 = x1 + cellW;\n\n\t\t\tint pos = i * mapWidth + updating.left;\n\n\t\t\tfor (int j=updating.left; j < updating.right; j++) {\n\n\t\t\t\t//Currently if a none-rendered tile becomes rendered it will mess with culling in draw()\n\t\t\t\t//However shifting the whole array is expensive, even with selective updating\n\t\t\t\t//So right now I'm accepting this as an engine limitation, but support could be added.\n\n\t\t\t\t//It's also worth noting that nothing is stopping the game from rendering tiles\n\t\t\t\t//which will need to be visible in future as transparent, and accepting the small\n\t\t\t\t//performance cost of rendering them before they become visible\n\t\t\t\tif (needsRender(pos) || bufferPositions[pos] != -1) {\n\t\t\t\t\tint bufferPos = bufferPositions[pos];\n\t\t\t\t\tif (bufferPos == -1){\n\t\t\t\t\t\tbufferPos = bufferPositions[pos] = bufferLength;\n\t\t\t\t\t\tbufferLength ++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (topLeftUpdating == 0)\n\t\t\t\t\t\ttopLeftUpdating = bufferPos;\n\n\t\t\t\t\tbottomRightUpdating = bufferPos + 1;\n\n\t\t\t\t\tquads.position(bufferPos*16);\n\t\t\t\t\tRectF uv = tileset.get( data[pos] );\n\n\t\t\t\t\tvertices[0] \t= x1;\n\t\t\t\t\tvertices[1] \t= y1;\n\n\t\t\t\t\tvertices[2]\t\t= uv.left;\n\t\t\t\t\tvertices[3]\t\t= uv.top;\n\n\t\t\t\t\tvertices[4] \t= x2;\n\t\t\t\t\tvertices[5] \t= y1;\n\n\t\t\t\t\tvertices[6]\t\t= uv.right;\n\t\t\t\t\tvertices[7]\t\t= uv.top;\n\n\t\t\t\t\tvertices[8] \t= x2;\n\t\t\t\t\tvertices[9] \t= y2;\n\n\t\t\t\t\tvertices[10]\t= uv.right;\n\t\t\t\t\tvertices[11]\t= uv.bottom;\n\n\t\t\t\t\tvertices[12]\t= x1;\n\t\t\t\t\tvertices[13]\t= y2;\n\n\t\t\t\t\tvertices[14]\t= uv.left;\n\t\t\t\t\tvertices[15]\t= uv.bottom;\n\n\t\t\t\t\tquads.put( vertices );\n\t\t\t\t}\n\n\t\t\t\tpos++;\n\t\t\t\tx1 = x2;\n\t\t\t\tx2 += cellW;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\ty1 = y2;\n\t\t\ty2 += cellH;\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate synchronized void moveToUpdating(){\n\t\tupdating = new Rect(updated);\n\t\tupdated.setEmpty();\n\t}",
          "uniqueId": "6bcccba062d4484ca99d8c08142a4ecb4187b8f1_91_160_102_105_107_182"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "7a2e6c63c1187eaa2c472adea105f57dec676e86",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/7a2e6c63c1187eaa2c472adea105f57dec676e86",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void updateVertices( FloatBuffer vertices ){\n\t\tthis.vertices = vertices;\n\t\tneedsUpdate = true;\n\t}",
          "sourceCodeAfterRefactoring": "public void updateVertices( FloatBuffer vertices ){\n\t\tupdateVertices(vertices, 0, vertices.limit());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void updateVertices( FloatBuffer vertices, int start, int end){\n\t\tthis.vertices = vertices;\n\n\t\tif (updateStart == -1)\n\t\t\tupdateStart = start;\n\t\telse\n\t\t\tupdateStart = Math.min(start, updateStart);\n\n\t\tif (updateEnd == -1)\n\t\t\tupdateEnd = end;\n\t\telse\n\t\t\tupdateEnd = Math.max(end, updateEnd);\n\t}",
          "uniqueId": "7a2e6c63c1187eaa2c472adea105f57dec676e86_50_53_60_72_55_57"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c137a465c5241ae815aab65bcc06a88c1fffdf7b",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c137a465c5241ae815aab65bcc06a88c1fffdf7b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reload() {\n\t\tid = new SmartTexture( bitmap, NEAREST, CLAMP, premultiplied ).id;\n\t\tfilter( fModeMin, fModeMax );\n\t\twrap( wModeH, wModeV );\n\t}",
          "sourceCodeAfterRefactoring": "public void reload() {\n\t\tid = -1;\n\t\tgenerate();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tprotected void generate() {\n\t\tsuper.generate();\n\t\tbitmap( bitmap, premultiplied );\n\t\tfilter( fModeMin, fModeMax );\n\t\twrap( wModeH, wModeV );\n\t}",
          "uniqueId": "c137a465c5241ae815aab65bcc06a88c1fffdf7b_93_97_66_72_107_110"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void reload() {\n\t\t\tint[] ids = new int[1];\n\t\t\tGLES20.glGenTextures( 1, ids, 0 );\n\t\t\tid = ids[0];\n\t\t\tfilter( Texture.LINEAR, Texture.LINEAR );\n\t\t\tupdate();\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void reload() {\n\t\t\tgenerate();\n\t\t\tupdate();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tprotected void generate() {\n\t\t\tint[] ids = new int[1];\n\t\t\tGLES20.glGenTextures( 1, ids, 0 );\n\t\t\tid = ids[0];\n\t\t}",
          "uniqueId": "c137a465c5241ae815aab65bcc06a88c1fffdf7b_142_149_141_146_148_152"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "a54bb5fdc888c05bdb4dae8c7c08fe269209be2f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/a54bb5fdc888c05bdb4dae8c7c08fe269209be2f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void render(){\n\t\tif ( text == null || text.equals(\"\") ) {\n\t\t\ttext = \"\";\n\t\t\twidth=height=0;\n\t\t\tvisible = false;\n\t\t\treturn;\n\t\t} else {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tif (cache != null)\n\t\t\tcache.activeTexts.remove(this);\n\n\t\tString key = \"text:\" + size + \" \" + text;\n\t\tif (textCache.containsKey(key)){\n\t\t\tcache = textCache.get(key);\n\t\t\ttexture = cache.texture;\n\t\t\tframe(cache.rect);\n\t\t\tcache.activeTexts.add(this);\n\t\t} else {\n\n\t\t\tpainter.setTextSize(size);\n\t\t\tpainter.setAntiAlias(true);\n\n\t\t\tif (font != null) {\n\t\t\t\tpainter.setTypeface(font);\n\t\t\t} else {\n\t\t\t\tpainter.setTypeface(Typeface.DEFAULT);\n\t\t\t}\n\n\t\t\t//paint outer strokes\n\t\t\tpainter.setARGB(0xff, 0, 0, 0);\n\t\t\tpainter.setStyle(Paint.Style.STROKE);\n\t\t\tpainter.setStrokeWidth(size / 5f);\n\n\t\t\tint right = (int)(painter.measureText(text)+ (size/5f));\n\t\t\tint bottom = (int)(-painter.ascent() + painter.descent()+ (size/5f));\n\n\t\t\t//bitmap has to be in a power of 2 for some devices (as we're using openGL methods to render to texture)\n\t\t\tBitmap bitmap = Bitmap.createBitmap(Integer.highestOneBit(right)*2, Integer.highestOneBit(bottom)*2, Bitmap.Config.ARGB_4444);\n\t\t\tbitmap.eraseColor(0x00000000);\n\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t\tcanvas.drawText(text, (size/10f), size, painter);\n\n\t\t\t//paint inner text\n\t\t\tpainter.setARGB(0xff, 0xff, 0xff, 0xff);\n\t\t\tpainter.setStyle(Paint.Style.FILL);\n\n\t\t\tcanvas.drawText(text, (size/10f), size, painter);\n\n\t\t\ttexture = new SmartTexture(bitmap, Texture.NEAREST, Texture.CLAMP, true);\n\n\t\t\tRectF rect = texture.uvRect(0, 0, right, bottom);\n\t\t\tframe(rect);\n\n\t\t\tcache = new CachedText();\n\t\t\tcache.rect = rect;\n\t\t\tcache.texture = texture;\n\t\t\tcache.length = text.length();\n\t\t\tcache.activeTexts = new HashSet<>();\n\t\t\tcache.activeTexts.add(this);\n\t\t\ttextCache.put(\"text:\" + size + \" \" + text, cache);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void render(){\n\t\tneedsRender = false;\n\n\t\tif (cache != null)\n\t\t\tcache.activeTexts.remove(this);\n\n\t\tString key = \"text:\" + size + \" \" + text;\n\t\tif (textCache.containsKey(key)){\n\t\t\tcache = textCache.get(key);\n\t\t\ttexture = cache.texture;\n\t\t\tframe(cache.rect);\n\t\t\tcache.activeTexts.add(this);\n\t\t} else {\n\n\t\t\tmeasure();\n\n\t\t\tif (width == 0 || height == 0)\n\t\t\t\treturn;\n\n\t\t\t//bitmap has to be in a power of 2 for some devices (as we're using openGL methods to render to texture)\n\t\t\tBitmap bitmap = Bitmap.createBitmap(Integer.highestOneBit((int)width)*2, Integer.highestOneBit((int)height)*2, Bitmap.Config.ARGB_4444);\n\t\t\tbitmap.eraseColor(0x00000000);\n\n\t\t\tcanvas.setBitmap(bitmap);\n\t\t\tcanvas.drawText(text, (size/10f), size, painter);\n\n\t\t\t//paint inner text\n\t\t\tpainter.setARGB(0xff, 0xff, 0xff, 0xff);\n\t\t\tpainter.setStyle(Paint.Style.FILL);\n\n\t\t\tcanvas.drawText(text, (size/10f), size, painter);\n\n\t\t\ttexture = new SmartTexture(bitmap, Texture.NEAREST, Texture.CLAMP, true);\n\n\t\t\tRectF rect = texture.uvRect(0, 0, (int)width, (int)height);\n\t\t\tframe(rect);\n\n\t\t\tcache = new CachedText();\n\t\t\tcache.rect = rect;\n\t\t\tcache.texture = texture;\n\t\t\tcache.length = text.length();\n\t\t\tcache.activeTexts = new HashSet<>();\n\t\t\tcache.activeTexts.add(this);\n\t\t\ttextCache.put(\"text:\" + size + \" \" + text, cache);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void measure(){\n\n\t\tif ( text == null || text.equals(\"\") ) {\n\t\t\ttext = \"\";\n\t\t\twidth=height=0;\n\t\t\tvisible = false;\n\t\t\treturn;\n\t\t} else {\n\t\t\tvisible = true;\n\t\t}\n\n\t\tpainter.setTextSize(size);\n\t\tpainter.setAntiAlias(true);\n\n\t\tif (font != null) {\n\t\t\tpainter.setTypeface(font);\n\t\t} else {\n\t\t\tpainter.setTypeface(Typeface.DEFAULT);\n\t\t}\n\n\t\t//paint outer strokes\n\t\tpainter.setARGB(0xff, 0, 0, 0);\n\t\tpainter.setStyle(Paint.Style.STROKE);\n\t\tpainter.setStrokeWidth(size / 5f);\n\n\t\twidth = (painter.measureText(text)+ (size/5f));\n\t\theight = (-painter.ascent() + painter.descent()+ (size/5f));\n\t}",
          "uniqueId": "a54bb5fdc888c05bdb4dae8c7c08fe269209be2f_125_189_130_157_159_204"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "2bd1962b34f839372743e80e61c979bd773e16e0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/2bd1962b34f839372743e80e61c979bd773e16e0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void observe() {\n\n\t\tif (level == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlevel.updateFieldOfView(hero, visible);\n\n\t\tint cx = hero.pos % level.width();\n\t\tint cy = hero.pos / level.width();\n\n\t\t//Add one to account for hero's previous position\n\t\tint viewDist = hero.viewDistance+1;\n\t\tint ax = Math.max( 0, cx - viewDist );\n\t\tint bx = Math.min( cx + viewDist, level.width() - 1 );\n\t\tint ay = Math.max( 0, cy - viewDist );\n\t\tint by = Math.min( cy + viewDist, level.height() - 1 );\n\n\t\tint len = bx - ax + 1;\n\t\tint pos = ax + ay * level.width();\n\t\tfor (int y = ay; y <= by; y++, pos+=level.width()) {\n\t\t\tBArray.or( level.visited, visible, pos, len, level.visited );\n\t\t}\n\t\t\n\t\tGameScene.afterObserve();\n\t}",
          "sourceCodeAfterRefactoring": "public static void observe(){\n\t\tobserve( hero.viewDistance+1 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void observe( int dist ) {\n\n\t\tif (level == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlevel.updateFieldOfView(hero, visible);\n\n\t\tint cx = hero.pos % level.width();\n\t\tint cy = hero.pos / level.width();\n\n\t\tint ax = Math.max( 0, cx - dist );\n\t\tint bx = Math.min( cx + dist, level.width() - 1 );\n\t\tint ay = Math.max( 0, cy - dist );\n\t\tint by = Math.min( cy + dist, level.height() - 1 );\n\n\t\tint len = bx - ax + 1;\n\t\tint pos = ax + ay * level.width();\n\t\tfor (int y = ay; y <= by; y++, pos+=level.width()) {\n\t\t\tBArray.or( level.visited, visible, pos, len, level.visited );\n\t\t}\n\n\t\tif (hero.buff(MindVision.class) != null || hero.buff(Awareness.class) != null)\n\t\t\tGameScene.updateFog();\n\t\telse\n\t\t\tGameScene.updateFog(ax, ay, len, by-ay);\n\n\t\tGameScene.afterObserve();\n\t}",
          "uniqueId": "2bd1962b34f839372743e80e61c979bd773e16e0_660_685_666_694_662_664"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c21efe415653fe25028bbeb016a69920db40e594",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c21efe415653fe25028bbeb016a69920db40e594",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static boolean[] or( boolean[] a, boolean[] b, boolean[] result ) {\n\t\t\n\t\tint length = a.length;\n\t\t\n\t\tif (result == null) {\n\t\t\tresult = new boolean[length];\n\t\t}\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\tresult[i] = a[i] || b[i];\n\t\t}\n\t\t\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "public static boolean[] or( boolean[] a, boolean[] b, boolean[] result ){\n\t\treturn or( a, b, 0, a.length, result);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static boolean[] or( boolean[] a, boolean[] b, int offset, int length, boolean[] result ) {\n\t\t\n\t\tif (result == null) {\n\t\t\tresult = new boolean[length];\n\t\t}\n\t\t\n\t\tfor (int i=offset; i < offset+length; i++) {\n\t\t\tresult[i] = a[i] || b[i];\n\t\t}\n\t\t\n\t\treturn result;\n\t}",
          "uniqueId": "c21efe415653fe25028bbeb016a69920db40e594_50_63_54_65_50_52"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e770d13d39a3e835a158ce976d11d48d8c451008",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e770d13d39a3e835a158ce976d11d48d8c451008",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "int getInt( String key, int defValue  ) {\n\t\ttry {\n\t\t\treturn get().getInt( key, defValue );\n\t\t} catch (ClassCastException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn defValue;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "int getInt( String key, int defValue ) {\n\t\treturn getInt(key, defValue, Integer.MIN_VALUE, Integer.MAX_VALUE);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nint getInt( String key, int defValue, int min, int max ) {\n\t\ttry {\n\t\t\tint i = get().getInt( key, defValue );\n\t\t\tif (i < min || i > max){\n\t\t\t\tput(key, defValue);\n\t\t\t\treturn defValue;\n\t\t\t} else {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t} catch (ClassCastException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\tput(key, defValue);\n\t\t\treturn defValue;\n\t\t}\n\t}",
          "uniqueId": "e770d13d39a3e835a158ce976d11d48d8c451008_59_66_63_77_59_61"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "String getString( String key, String defValue  ) {\n\t\ttry {\n\t\t\treturn get().getString( key, defValue );\n\t\t} catch (ClassCastException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\treturn defValue;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "String getString( String key, String defValue ) {\n\t\treturn getString(key, defValue, Integer.MAX_VALUE);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nString getString( String key, String defValue, int maxLength ) {\n\t\ttry {\n\t\t\tString s = get().getString( key, defValue );\n\t\t\tif (s.length() > maxLength) {\n\t\t\t\tput(key, defValue);\n\t\t\t\treturn defValue;\n\t\t\t} else {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t} catch (ClassCastException e) {\n\t\t\tShatteredPixelDungeon.reportException(e);\n\t\t\tput(key, defValue);\n\t\t\treturn defValue;\n\t\t}\n\t}",
          "uniqueId": "e770d13d39a3e835a158ce976d11d48d8c451008_77_84_93_107_89_91"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3de8225f9bf5c67a972df4526a0f400b11dd87eb",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3de8225f9bf5c67a972df4526a0f400b11dd87eb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void item( Item item ) {\n\t\tif (bottomRightIcon != null){\n\t\t\tremove(bottomRightIcon);\n\t\t\tbottomRightIcon = null;\n\t\t}\n\n\t\tif (item == null) {\n\t\t\t\n\t\t\tactive = false;\n\t\t\ttopLeft.visible = topRight.visible = bottomRight.visible = false;\n\t\t\ticon.visible(false);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tactive = true;\n\t\t\ttopLeft.visible = topRight.visible = bottomRight.visible = true;\n\t\t\ticon.visible(true);\n\t\t\t\n\t\t\ticon.view( item );\n\t\t\t\n\t\t\ttopLeft.text( item.status()  );\n\t\t\t\n\t\t\tboolean isArmor = item instanceof Armor;\n\t\t\tboolean isWeapon = item instanceof Weapon;\n\t\t\tif (isArmor || isWeapon) {\n\t\t\t\t\n\t\t\t\tif (item.levelKnown || (isWeapon && !(item instanceof MeleeWeapon))) {\n\t\t\t\t\t\n\t\t\t\t\tint str = isArmor ? ((Armor)item).STRReq() : ((Weapon)item).STRReq();\n\t\t\t\t\ttopRight.text( Messages.format( TXT_STRENGTH, str ) );\n\t\t\t\t\tif (str > Dungeon.hero.STR()) {\n\t\t\t\t\t\ttopRight.hardlight( DEGRADED );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttopRight.resetColor();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\ttopRight.text( Messages.format( TXT_TYPICAL_STR, isArmor ?\n\t\t\t\t\t\t((Armor)item).STRReq(0) :\n\t\t\t\t\t\t((Weapon)item).STRReq(0) ) );\n\t\t\t\t\ttopRight.hardlight( WARNING );\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ttopRight.measure();\n\n\t\t\t} else if (item instanceof Key && !(item instanceof SkeletonKey)) {\n\t\t\t\ttopRight.text(Messages.format(TXT_KEY_DEPTH, ((Key) item).depth));\n\t\t\t\ttopRight.measure();\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\ttopRight.text( null );\n\t\t\t\t\n\t\t\t}\n\t\n\t\t\tint level = item.visiblyUpgraded();\n\n\t\t\tif (level != 0) {\n\t\t\t\tbottomRight.text( item.levelKnown ? Messages.format( TXT_LEVEL, level ) : TXT_CURSED );\n\t\t\t\tbottomRight.measure();\n\t\t\t\tbottomRight.hardlight( level > 0 ? UPGRADED : DEGRADED );\n\t\t\t} else if (item instanceof Scroll || item instanceof Potion) {\n\t\t\t\tbottomRight.text( null );\n\n\t\t\t\tInteger iconInt;\n\t\t\t\tif (item instanceof Scroll){\n\t\t\t\t\ticonInt = ((Scroll) item).initials();\n\t\t\t\t} else {\n\t\t\t\t\ticonInt = ((Potion) item).initials();\n\t\t\t\t}\n\t\t\t\tif (iconInt != null && iconVisible) {\n\t\t\t\t\tbottomRightIcon = new Image(Assets.CONS_ICONS);\n\t\t\t\t\tint left = iconInt*7;\n\t\t\t\t\tint top = item instanceof Potion ? 0 : 8;\n\t\t\t\t\tbottomRightIcon.frame(left, top, 7, 8);\n\t\t\t\t\tadd(bottomRightIcon);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tbottomRight.text( null );\n\t\t\t}\n\t\t\t\n\t\t\tlayout();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void item( Item item ) {\n\t\tif (this.item == item) {\n\t\t\tupdateText();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.item = item;\n\n\t\tif (item == null) {\n\t\t\t\n\t\t\tactive = false;\n\t\t\ticon.visible(false);\n\n\t\t\tupdateText();\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tactive = true;\n\t\t\ticon.visible(true);\n\n\t\t\ticon.view( item );\n\t\t\tupdateText();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateText(){\n\n\t\tif (bottomRightIcon != null){\n\t\t\tremove(bottomRightIcon);\n\t\t\tbottomRightIcon = null;\n\t\t}\n\n\t\tif (item == null){\n\t\t\ttopLeft.visible = topRight.visible = bottomRight.visible = false;\n\t\t\treturn;\n\t\t} else {\n\t\t\ttopLeft.visible = topRight.visible = bottomRight.visible = true;\n\t\t}\n\n\t\ttopLeft.text( item.status() );\n\n\t\tboolean isArmor = item instanceof Armor;\n\t\tboolean isWeapon = item instanceof Weapon;\n\t\tif (isArmor || isWeapon) {\n\n\t\t\tif (item.levelKnown || (isWeapon && !(item instanceof MeleeWeapon))) {\n\n\t\t\t\tint str = isArmor ? ((Armor)item).STRReq() : ((Weapon)item).STRReq();\n\t\t\t\ttopRight.text( Messages.format( TXT_STRENGTH, str ) );\n\t\t\t\tif (str > Dungeon.hero.STR()) {\n\t\t\t\t\ttopRight.hardlight( DEGRADED );\n\t\t\t\t} else {\n\t\t\t\t\ttopRight.resetColor();\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\ttopRight.text( Messages.format( TXT_TYPICAL_STR, isArmor ?\n\t\t\t\t\t\t((Armor)item).STRReq(0) :\n\t\t\t\t\t\t((Weapon)item).STRReq(0) ) );\n\t\t\t\ttopRight.hardlight( WARNING );\n\n\t\t\t}\n\t\t\ttopRight.measure();\n\n\t\t} else if (item instanceof Key && !(item instanceof SkeletonKey)) {\n\t\t\ttopRight.text(Messages.format(TXT_KEY_DEPTH, ((Key) item).depth));\n\t\t\ttopRight.measure();\n\t\t} else {\n\n\t\t\ttopRight.text( null );\n\n\t\t}\n\n\t\tint level = item.visiblyUpgraded();\n\n\t\tif (level != 0) {\n\t\t\tbottomRight.text( item.levelKnown ? Messages.format( TXT_LEVEL, level ) : TXT_CURSED );\n\t\t\tbottomRight.measure();\n\t\t\tbottomRight.hardlight( level > 0 ? UPGRADED : DEGRADED );\n\t\t} else if (item instanceof Scroll || item instanceof Potion) {\n\t\t\tbottomRight.text( null );\n\n\t\t\tInteger iconInt;\n\t\t\tif (item instanceof Scroll){\n\t\t\t\ticonInt = ((Scroll) item).initials();\n\t\t\t} else {\n\t\t\t\ticonInt = ((Potion) item).initials();\n\t\t\t}\n\t\t\tif (iconInt != null && iconVisible) {\n\t\t\t\tbottomRightIcon = new Image(Assets.CONS_ICONS);\n\t\t\t\tint left = iconInt*7;\n\t\t\t\tint top = item instanceof Potion ? 0 : 8;\n\t\t\t\tbottomRightIcon.frame(left, top, 7, 8);\n\t\t\t\tadd(bottomRightIcon);\n\t\t\t}\n\n\t\t} else {\n\t\t\tbottomRight.text( null );\n\t\t}\n\n\t\tlayout();\n\t}",
          "uniqueId": "3de8225f9bf5c67a972df4526a0f400b11dd87eb_140_224_168_245_143_166"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "db23db28c599d1411932d6a3583f9d18ac7b5159",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/db23db28c599d1411932d6a3583f9d18ac7b5159",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int autoAim(Char target){\n\t\t//first try to directly target\n\t\tif (new Ballistica(Dungeon.hero.pos, target.pos, Ballistica.PROJECTILE).collisionPos == target.pos) {\n\t\t\treturn target.pos;\n\t\t}\n\n\t\t//Otherwise pick nearby tiles to try and 'angle' the shot, auto-aim basically.\n\t\tfor (int i : Level.NEIGHBOURS9DIST2) {\n\t\t\tif (new Ballistica(Dungeon.hero.pos, target.pos+i, Ballistica.PROJECTILE).collisionPos == target.pos){\n\t\t\t\treturn target.pos+i;\n\t\t\t}\n\t\t}\n\n\t\t//couldn't find a cell, give up.\n\t\treturn -1;\n\t}",
          "sourceCodeAfterRefactoring": "public static int autoAim(Char target){\n\t\t//will use generic projectile logic if no item is specified\n\t\treturn autoAim(target, new Item());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int autoAim(Char target, Item item){\n\n\t\t//first try to directly target\n\t\tif (item.throwPos(Dungeon.hero, target.pos) == target.pos) {\n\t\t\treturn target.pos;\n\t\t}\n\n\t\t//Otherwise pick nearby tiles to try and 'angle' the shot, auto-aim basically.\n\t\tfor (int i : Level.NEIGHBOURS9DIST2) {\n\t\t\tif (item.throwPos(Dungeon.hero, target.pos) == target.pos){\n\t\t\t\treturn target.pos+i;\n\t\t\t}\n\t\t}\n\n\t\t//couldn't find a cell, give up.\n\t\treturn -1;\n\t}",
          "uniqueId": "db23db28c599d1411932d6a3583f9d18ac7b5159_193_208_197_213_192_195"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "497209236601b3f09277ff5abadb04149e3c50b0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/497209236601b3f09277ff5abadb04149e3c50b0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\t\tif (Dungeon.visible[ pos ]) {\n\t\t\tCellEmitter.get(pos).burst(ShadowParticle.UP, 5);\n\t\t\tSample.INSTANCE.play(Assets.SND_CURSED);\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\tif (heap != null){\n\t\t\tfor (Item item : heap.items){\n\t\t\t\tif (item.isUpgradable())\n\t\t\t\t\tcurse(item);\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.hero.pos == pos){\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\t//items the trap wants to curse because it will create a more negative effect\n\t\t\tArrayList<Item> priorityCurse = new ArrayList<>();\n\t\t\t//items the trap can curse if nothing else is available.\n\t\t\tArrayList<Item> canCurse = new ArrayList<>();\n\n\t\t\tKindOfWeapon weapon = hero.belongings.weapon;\n\t\t\tif (weapon instanceof Weapon && !weapon.cursed){\n\t\t\t\tif (((Weapon) weapon).enchantment == null)\n\t\t\t\t\tpriorityCurse.add(weapon);\n\t\t\t\telse\n\t\t\t\t\tcanCurse.add(weapon);\n\t\t\t}\n\n\t\t\tArmor armor = hero.belongings.armor;\n\t\t\tif (!armor.cursed){\n\t\t\t\tif (armor.glyph == null)\n\t\t\t\t\tpriorityCurse.add(armor);\n\t\t\t\telse\n\t\t\t\t\tcanCurse.add(armor);\n\t\t\t}\n\n\t\t\tKindofMisc misc1 = hero.belongings.misc1;\n\t\t\tif (misc1 instanceof Artifact){\n\t\t\t\tpriorityCurse.add(misc1);\n\t\t\t} else if (misc1 instanceof Ring){\n\t\t\t\tcanCurse.add(misc1);\n\t\t\t}\n\n\t\t\tKindofMisc misc2 = hero.belongings.misc2;\n\t\t\tif (misc2 instanceof Artifact){\n\t\t\t\tpriorityCurse.add(misc2);\n\t\t\t} else if (misc2 instanceof Ring){\n\t\t\t\tcanCurse.add(misc2);\n\t\t\t}\n\n\t\t\tCollections.shuffle(priorityCurse);\n\t\t\tCollections.shuffle(canCurse);\n\n\t\t\tint numCurses = Random.Int(3) == 0 ? 1 : 2;\n\n\t\t\tfor (int i = 0; i < numCurses; i++){\n\t\t\t\tif (!priorityCurse.isEmpty()){\n\t\t\t\t\tcurse(priorityCurse.remove(0));\n\t\t\t\t} else if (!canCurse.isEmpty()){\n\t\t\t\t\tcurse(canCurse.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tEquipableItem.equipCursed(hero);\n\t\t\tGLog.n( Messages.get(this, \"curse\") );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\t\tif (Dungeon.visible[ pos ]) {\n\t\t\tCellEmitter.get(pos).burst(ShadowParticle.UP, 5);\n\t\t\tSample.INSTANCE.play(Assets.SND_CURSED);\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\tif (heap != null){\n\t\t\tfor (Item item : heap.items){\n\t\t\t\tif (item.isUpgradable())\n\t\t\t\t\tcurse(item);\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.hero.pos == pos){\n\t\t\tcurse(Dungeon.hero);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void curse(Hero hero){\n\t\t//items the trap wants to curse because it will create a more negative effect\n\t\tArrayList<Item> priorityCurse = new ArrayList<>();\n\t\t//items the trap can curse if nothing else is available.\n\t\tArrayList<Item> canCurse = new ArrayList<>();\n\n\t\tKindOfWeapon weapon = hero.belongings.weapon;\n\t\tif (weapon instanceof Weapon && !weapon.cursed){\n\t\t\tif (((Weapon) weapon).enchantment == null)\n\t\t\t\tpriorityCurse.add(weapon);\n\t\t\telse\n\t\t\t\tcanCurse.add(weapon);\n\t\t}\n\n\t\tArmor armor = hero.belongings.armor;\n\t\tif (!armor.cursed){\n\t\t\tif (armor.glyph == null)\n\t\t\t\tpriorityCurse.add(armor);\n\t\t\telse\n\t\t\t\tcanCurse.add(armor);\n\t\t}\n\n\t\tKindofMisc misc1 = hero.belongings.misc1;\n\t\tif (misc1 instanceof Artifact){\n\t\t\tpriorityCurse.add(misc1);\n\t\t} else if (misc1 instanceof Ring){\n\t\t\tcanCurse.add(misc1);\n\t\t}\n\n\t\tKindofMisc misc2 = hero.belongings.misc2;\n\t\tif (misc2 instanceof Artifact){\n\t\t\tpriorityCurse.add(misc2);\n\t\t} else if (misc2 instanceof Ring){\n\t\t\tcanCurse.add(misc2);\n\t\t}\n\n\t\tCollections.shuffle(priorityCurse);\n\t\tCollections.shuffle(canCurse);\n\n\t\tint numCurses = Random.Int(3) == 0 ? 1 : 2;\n\n\t\tfor (int i = 0; i < numCurses; i++){\n\t\t\tif (!priorityCurse.isEmpty()){\n\t\t\t\tcurse(priorityCurse.remove(0));\n\t\t\t} else if (!canCurse.isEmpty()){\n\t\t\t\tcurse(canCurse.remove(0));\n\t\t\t}\n\t\t}\n\n\t\tEquipableItem.equipCursed(hero);\n\t\tGLog.n( Messages.get(CursingTrap.class, \"curse\") );\n\t}",
          "uniqueId": "497209236601b3f09277ff5abadb04149e3c50b0_53_122_73_124_53_71"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "6a3de8c7abadafab42f963101932a326065ed1a2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/6a3de8c7abadafab42f963101932a326065ed1a2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void activate() {\n\t\tif (Dungeon.visible[ pos ]) {\n\t\t\tCellEmitter.get(pos).burst(ShadowParticle.UP, 5);\n\t\t\tSample.INSTANCE.play(Assets.SND_CURSED);\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\tif (heap != null){\n\t\t\tfor (Item item : heap.items){\n\t\t\t\tif (item.isUpgradable())\n\t\t\t\t\titem.cursed = item.cursedKnown = true;\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.hero.pos == pos){\n\t\t\tHero hero = Dungeon.hero;\n\t\t\tKindOfWeapon weapon = hero.belongings.weapon;\n\t\t\tArmor armor = hero.belongings.armor;\n\t\t\tKindofMisc misc1 = hero.belongings.misc1;\n\t\t\tKindofMisc misc2 = hero.belongings.misc2;\n\t\t\tif (weapon != null) weapon.cursed = weapon.cursedKnown = true;\n\t\t\tif (armor != null)  armor.cursed = armor.cursedKnown = true;\n\t\t\tif (misc1 != null)  misc1.cursed = misc1.cursedKnown = true;\n\t\t\tif (misc2 != null)  misc2.cursed = misc2.cursedKnown = true;\n\t\t\tEquipableItem.equipCursed(hero);\n\t\t\tGLog.n( Messages.get(this, \"curse\") );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void activate() {\n\t\tif (Dungeon.visible[ pos ]) {\n\t\t\tCellEmitter.get(pos).burst(ShadowParticle.UP, 5);\n\t\t\tSample.INSTANCE.play(Assets.SND_CURSED);\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get( pos );\n\t\tif (heap != null){\n\t\t\tfor (Item item : heap.items){\n\t\t\t\tif (item.isUpgradable())\n\t\t\t\t\tcurse(item);\n\t\t\t}\n\t\t}\n\n\t\tif (Dungeon.hero.pos == pos){\n\t\t\tHero hero = Dungeon.hero;\n\n\t\t\t//items the trap wants to curse because it will create a more negative effect\n\t\t\tArrayList<Item> priorityCurse = new ArrayList<>();\n\t\t\t//items the trap can curse if nothing else is available.\n\t\t\tArrayList<Item> canCurse = new ArrayList<>();\n\n\t\t\tKindOfWeapon weapon = hero.belongings.weapon;\n\t\t\tif (weapon instanceof Weapon && !weapon.cursed){\n\t\t\t\tif (((Weapon) weapon).enchantment == null)\n\t\t\t\t\tpriorityCurse.add(weapon);\n\t\t\t\telse\n\t\t\t\t\tcanCurse.add(weapon);\n\t\t\t}\n\n\t\t\tArmor armor = hero.belongings.armor;\n\t\t\tif (!armor.cursed){\n\t\t\t\tif (armor.glyph == null)\n\t\t\t\t\tpriorityCurse.add(armor);\n\t\t\t\telse\n\t\t\t\t\tcanCurse.add(armor);\n\t\t\t}\n\n\t\t\tKindofMisc misc1 = hero.belongings.misc1;\n\t\t\tif (misc1 instanceof Artifact){\n\t\t\t\tpriorityCurse.add(misc1);\n\t\t\t} else if (misc1 instanceof Ring){\n\t\t\t\tcanCurse.add(misc1);\n\t\t\t}\n\n\t\t\tKindofMisc misc2 = hero.belongings.misc2;\n\t\t\tif (misc2 instanceof Artifact){\n\t\t\t\tpriorityCurse.add(misc2);\n\t\t\t} else if (misc2 instanceof Ring){\n\t\t\t\tcanCurse.add(misc2);\n\t\t\t}\n\n\t\t\tCollections.shuffle(priorityCurse);\n\t\t\tCollections.shuffle(canCurse);\n\n\t\t\tint numCurses = Random.Int(3) == 0 ? 1 : 2;\n\n\t\t\tfor (int i = 0; i < numCurses; i++){\n\t\t\t\tif (!priorityCurse.isEmpty()){\n\t\t\t\t\tcurse(priorityCurse.remove(0));\n\t\t\t\t} else if (!canCurse.isEmpty()){\n\t\t\t\t\tcurse(canCurse.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tEquipableItem.equipCursed(hero);\n\t\t\tGLog.n( Messages.get(this, \"curse\") );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void curse(Item item){\n\t\titem.cursed = item.cursedKnown = true;\n\n\t\tif (item instanceof Weapon){\n\t\t\tWeapon w = (Weapon) item;\n\t\t\tif (w.enchantment == null){\n\t\t\t\tw.enchantment = Weapon.Enchantment.randomCurse();\n\t\t\t}\n\t\t}\n\t\tif (item instanceof Armor){\n\t\t\tArmor a = (Armor) item;\n\t\t\tif (a.glyph == null){\n\t\t\t\ta.glyph = Armor.Glyph.randomCurse();\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "6a3de8c7abadafab42f963101932a326065ed1a2_46_74_124_139_53_122"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e3a3428f97ea17a3cd425982a12b16f68970bffa",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e3a3428f97ea17a3cd425982a12b16f68970bffa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void cast( final Hero user, int dst ) {\n\t\t\n\t\tfinal int cell = new Ballistica( user.pos, dst, Ballistica.PROJECTILE ).collisionPos;\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tSample.INSTANCE.play( Assets.SND_MISS, 0.6f, 0.6f, 1.5f );\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\n\t\t// FIXME!!!\n\t\tfloat delay = TIME_TO_THROW;\n\t\tif (this instanceof MissileWeapon) {\n\t\t\tdelay *= ((MissileWeapon)this).speedFactor( user );\n\t\t\tif (enemy != null) {\n\t\t\t\tSnipersMark mark = user.buff( SnipersMark.class );\n\t\t\t\tif (mark != null) {\n\t\t\t\t\tif (mark.object == enemy.id()) {\n\t\t\t\t\t\tdelay *= 0.5f;\n\t\t\t\t\t}\n\t\t\t\t\tuser.remove( mark );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinal float finalDelay = delay;\n\t\t\n\t\t((MissileSprite)user.sprite.parent.recycle( MissileSprite.class )).\n\t\t\treset( user.pos, cell, this, new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tItem.this.detach( user.belongings.backpack ).onThrow( cell );\n\t\t\t\t\tuser.spendAndNext( finalDelay );\n\t\t\t\t}\n\t\t\t} );\n\t}",
          "sourceCodeAfterRefactoring": "public void cast( final Hero user, int dst ) {\n\t\t\n\t\tfinal int cell = throwPos( user, dst );\n\t\tuser.sprite.zap( cell );\n\t\tuser.busy();\n\n\t\tSample.INSTANCE.play( Assets.SND_MISS, 0.6f, 0.6f, 1.5f );\n\n\t\tChar enemy = Actor.findChar( cell );\n\t\tQuickSlotButton.target(enemy);\n\n\t\t// FIXME!!!\n\t\tfloat delay = TIME_TO_THROW;\n\t\tif (this instanceof MissileWeapon) {\n\t\t\tdelay *= ((MissileWeapon)this).speedFactor( user );\n\t\t\tif (enemy != null) {\n\t\t\t\tSnipersMark mark = user.buff( SnipersMark.class );\n\t\t\t\tif (mark != null) {\n\t\t\t\t\tif (mark.object == enemy.id()) {\n\t\t\t\t\t\tdelay *= 0.5f;\n\t\t\t\t\t}\n\t\t\t\t\tuser.remove( mark );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinal float finalDelay = delay;\n\t\t\n\t\t((MissileSprite)user.sprite.parent.recycle( MissileSprite.class )).\n\t\t\treset( user.pos, cell, this, new Callback() {\n\t\t\t\t@Override\n\t\t\t\tpublic void call() {\n\t\t\t\t\tItem.this.detach( user.belongings.backpack ).onThrow( cell );\n\t\t\t\t\tuser.spendAndNext( finalDelay );\n\t\t\t\t}\n\t\t\t} );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int throwPos( Hero user, int dst){\n\t\treturn new Ballistica( user.pos, dst, Ballistica.PROJECTILE ).collisionPos;\n\t}",
          "uniqueId": "e3a3428f97ea17a3cd425982a12b16f68970bffa_473_508_473_475_477_512"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "83711cc83609cc153387097549babbe55fcffac4",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/83711cc83609cc153387097549babbe55fcffac4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void onSelect( final Item item ) {\n\t\t\tif (item != null) {\n\n\t\t\t\tif (!item.isIdentified()) {\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"id_first\"));\n\t\t\t\t\treturn;\n\t\t\t\t} else if (item.cursed){\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"cursed\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tGameScene.show(\n\t\t\t\t\t\tnew WndOptions(\"\",\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"warning\"),\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"yes\"),\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"no\")) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_EVOKE);\n\t\t\t\t\t\t\t\t\tScrollOfUpgrade.upgrade(curUser);\n\t\t\t\t\t\t\t\t\tevoke(curUser);\n\n\t\t\t\t\t\t\t\t\tDungeon.quickslot.clearItem(item);\n\n\t\t\t\t\t\t\t\t\titem.detach(curUser.belongings.backpack);\n\n\t\t\t\t\t\t\t\t\timbueWand((Wand) item, curUser);\n\n\t\t\t\t\t\t\t\t\tcurUser.spendAndNext(2f);\n\n\t\t\t\t\t\t\t\t\tupdateQuickslot();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void onSelect( final Item item ) {\n\t\t\tif (item != null) {\n\n\t\t\t\tif (!item.isIdentified()) {\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"id_first\"));\n\t\t\t\t\treturn;\n\t\t\t\t} else if (item.cursed){\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"cursed\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (wand == null){\n\t\t\t\t\tapplyWand((Wand)item);\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show(\n\t\t\t\t\t\t\tnew WndOptions(\"\",\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"warning\"),\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"yes\"),\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"no\")) {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\t\t\t\t\tapplyWand((Wand)item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void applyWand(Wand wand){\n\t\t\tSample.INSTANCE.play(Assets.SND_EVOKE);\n\t\t\tScrollOfUpgrade.upgrade(curUser);\n\t\t\tevoke(curUser);\n\n\t\t\tDungeon.quickslot.clearItem(wand);\n\n\t\t\twand.detach(curUser.belongings.backpack);\n\t\t\tBadges.validateTutorial();\n\n\t\t\timbueWand((Wand) wand, curUser);\n\n\t\t\tupdateQuickslot();\n\t\t}",
          "uniqueId": "83711cc83609cc153387097549babbe55fcffac4_265_303_308_321_276_306"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void onSelect( final Item item ) {\n\t\t\tif (item != null) {\n\n\t\t\t\tif (!item.isIdentified()) {\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"id_first\"));\n\t\t\t\t\treturn;\n\t\t\t\t} else if (item.cursed){\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"cursed\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tGameScene.show(\n\t\t\t\t\t\tnew WndOptions(\"\",\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"warning\"),\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"yes\"),\n\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"no\")) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\t\t\t\tSample.INSTANCE.play(Assets.SND_EVOKE);\n\t\t\t\t\t\t\t\t\tScrollOfUpgrade.upgrade(curUser);\n\t\t\t\t\t\t\t\t\tevoke(curUser);\n\n\t\t\t\t\t\t\t\t\tDungeon.quickslot.clearItem(item);\n\n\t\t\t\t\t\t\t\t\titem.detach(curUser.belongings.backpack);\n\n\t\t\t\t\t\t\t\t\timbueWand((Wand) item, curUser);\n\n\t\t\t\t\t\t\t\t\tcurUser.spendAndNext(2f);\n\n\t\t\t\t\t\t\t\t\tupdateQuickslot();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic void onSelect( final Item item ) {\n\t\t\tif (item != null) {\n\n\t\t\t\tif (!item.isIdentified()) {\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"id_first\"));\n\t\t\t\t\treturn;\n\t\t\t\t} else if (item.cursed){\n\t\t\t\t\tGLog.w(Messages.get(MagesStaff.class, \"cursed\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (wand == null){\n\t\t\t\t\tapplyWand((Wand)item);\n\t\t\t\t} else {\n\t\t\t\t\tGameScene.show(\n\t\t\t\t\t\t\tnew WndOptions(\"\",\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"warning\"),\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"yes\"),\n\t\t\t\t\t\t\t\t\tMessages.get(MagesStaff.class, \"no\")) {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\t\t\t\t\tif (index == 0) {\n\t\t\t\t\t\t\t\t\t\tapplyWand((Wand)item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void applyWand(Wand wand){\n\t\t\tSample.INSTANCE.play(Assets.SND_EVOKE);\n\t\t\tScrollOfUpgrade.upgrade(curUser);\n\t\t\tevoke(curUser);\n\n\t\t\tDungeon.quickslot.clearItem(wand);\n\n\t\t\twand.detach(curUser.belongings.backpack);\n\t\t\tBadges.validateTutorial();\n\n\t\t\timbueWand((Wand) wand, curUser);\n\n\t\t\tupdateQuickslot();\n\t\t}",
          "uniqueId": "83711cc83609cc153387097549babbe55fcffac4_265_303_308_321_276_306"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndItem( final WndBag owner, final Item item ) {\n\t\t\n\t\tsuper();\n\n\t\tint width = ShatteredPixelDungeon.landscape() ? WIDTH_L : WIDTH_P;\n\t\t\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\ttitlebar.color( ItemSlot.UPGRADED );\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\ttitlebar.color( ItemSlot.DEGRADED );\n\t\t}\n\t\t\n\t\tRenderedTextMultiline info = PixelScene.renderMultiline( item.info(), 6 );\n\t\tinfo.maxWidth(width);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( info );\n\t\n\t\tfloat y = info.top() + info.height() + GAP;\n\t\tfloat x = 0;\n\t\t\n\t\tif (Dungeon.hero.isAlive() && owner != null) {\n\t\t\tArrayList<RedButton> line = new ArrayList<>();\n\t\t\tfor (final String action:item.actions( Dungeon.hero )) {\n\t\t\t\t\n\t\t\t\tRedButton btn = new RedButton( Messages.get(item, \"ac_\" + action), 8 ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\thide();\n\t\t\t\t\t\towner.hide();\n\t\t\t\t\t\titem.execute( Dungeon.hero, action );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tbtn.setSize( btn.reqWidth(), BUTTON_HEIGHT );\n\t\t\t\tif (x + btn.width() > width || line.size() == 3) {\n\t\t\t\t\tlayoutButtons(line, width - x, y);\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += BUTTON_HEIGHT + 1;\n\t\t\t\t\tline = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tadd( btn );\n\t\t\t\tline.add( btn );\n\n\t\t\t\tif (action.equals(item.defaultAction)) {\n\t\t\t\t\tbtn.textColor( TITLE_COLOR );\n\t\t\t\t}\n\n\t\t\t\tx += btn.width();\n\t\t\t}\n\t\t\tlayoutButtons(line, width - x, y);\n\t\t}\n\t\t\n\t\tresize( width, (int)(y + (x > 0 ? BUTTON_HEIGHT : 0)) );\n\t}",
          "sourceCodeAfterRefactoring": "public WndItem( final WndBag owner, final Item item ){\n\t\tthis( owner, item, owner != null );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic WndItem( final WndBag owner, final Item item , final boolean options ) {\n\t\t\n\t\tsuper();\n\n\t\tint width = ShatteredPixelDungeon.landscape() ? WIDTH_L : WIDTH_P;\n\t\t\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\ttitlebar.color( ItemSlot.UPGRADED );\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\ttitlebar.color( ItemSlot.DEGRADED );\n\t\t}\n\t\t\n\t\tRenderedTextMultiline info = PixelScene.renderMultiline( item.info(), 6 );\n\t\tinfo.maxWidth(width);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( info );\n\t\n\t\tfloat y = info.top() + info.height() + GAP;\n\t\tfloat x = 0;\n\t\t\n\t\tif (Dungeon.hero.isAlive() && options) {\n\t\t\tArrayList<RedButton> line = new ArrayList<>();\n\t\t\tfor (final String action:item.actions( Dungeon.hero )) {\n\t\t\t\t\n\t\t\t\tRedButton btn = new RedButton( Messages.get(item, \"ac_\" + action), 8 ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\thide();\n\t\t\t\t\t\tif (owner != null) owner.hide();\n\t\t\t\t\t\titem.execute( Dungeon.hero, action );\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tbtn.setSize( btn.reqWidth(), BUTTON_HEIGHT );\n\t\t\t\tif (x + btn.width() > width || line.size() == 3) {\n\t\t\t\t\tlayoutButtons(line, width - x, y);\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += BUTTON_HEIGHT + 1;\n\t\t\t\t\tline = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tadd( btn );\n\t\t\t\tline.add( btn );\n\n\t\t\t\tif (action.equals(item.defaultAction)) {\n\t\t\t\t\tbtn.textColor( TITLE_COLOR );\n\t\t\t\t}\n\n\t\t\t\tx += btn.width();\n\t\t\t}\n\t\t\tlayoutButtons(line, width - x, y);\n\t\t}\n\t\t\n\t\tresize( width, (int)(y + (x > 0 ? BUTTON_HEIGHT : 0)) );\n\t}",
          "uniqueId": "83711cc83609cc153387097549babbe55fcffac4_46_103_50_107_46_48"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e8832722423c1657c1bb0127074afad70b91b140",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e8832722423c1657c1bb0127074afad70b91b140",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Emitter.Factory factory( final int type ) {\n\t\treturn factory( type, false );\n\t}",
          "sourceCodeAfterRefactoring": "public static Emitter.Factory factory( final int type ) {\n\t\treturn factory( type, false, 0 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Emitter.Factory factory( final int type, final boolean lightMode, final int tint ) {\n\n\t\tEmitter.Factory factory = factories.get( type );\n\n\t\tif (factory == null) {\n\t\t\tfactory = new Emitter.Factory() {\n\t\t\t\t@Override\n\t\t\t\tpublic void emit ( Emitter emitter, int index, float x, float y ) {\n\t\t\t\t\tSpeck p = (Speck)emitter.recycle( Speck.class );\n\t\t\t\t\tp.reset( index, x, y, type );\n\t\t\t\t\tif (tint != 0 ) p.tint( tint );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean lightMode() {\n\t\t\t\t\treturn lightMode;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfactories.put( type, factory );\n\t\t}\n\n\t\treturn factory;\n\t}",
          "uniqueId": "e8832722423c1657c1bb0127074afad70b91b140_441_443_451_472_439_441"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Emitter.Factory factory( final int type, final boolean lightMode ) {\n\n\t\tEmitter.Factory factory = factories.get( type );\n\n\t\tif (factory == null) {\n\t\t\tfactory = new Emitter.Factory() {\n\t\t\t\t@Override\n\t\t\t\tpublic void emit ( Emitter emitter, int index, float x, float y ) {\n\t\t\t\t\tSpeck p = (Speck)emitter.recycle( Speck.class );\n\t\t\t\t\tp.reset( index, x, y, type );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean lightMode() {\n\t\t\t\t\treturn lightMode;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfactories.put( type, factory );\n\t\t}\n\n\t\treturn factory;\n\t}",
          "sourceCodeAfterRefactoring": "public static Emitter.Factory factory( final int type, final boolean lightMode ) {\n\t\treturn factory( type, lightMode, 0 );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Emitter.Factory factory( final int type, final boolean lightMode, final int tint ) {\n\n\t\tEmitter.Factory factory = factories.get( type );\n\n\t\tif (factory == null) {\n\t\t\tfactory = new Emitter.Factory() {\n\t\t\t\t@Override\n\t\t\t\tpublic void emit ( Emitter emitter, int index, float x, float y ) {\n\t\t\t\t\tSpeck p = (Speck)emitter.recycle( Speck.class );\n\t\t\t\t\tp.reset( index, x, y, type );\n\t\t\t\t\tif (tint != 0 ) p.tint( tint );\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic boolean lightMode() {\n\t\t\t\t\treturn lightMode;\n\t\t\t\t}\n\t\t\t};\n\t\t\tfactories.put( type, factory );\n\t\t}\n\n\t\treturn factory;\n\t}",
          "uniqueId": "e8832722423c1657c1bb0127074afad70b91b140_445_465_451_472_443_445"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "97365b1ecfce58e07609e0a4bbeec1e342d25588",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/97365b1ecfce58e07609e0a4bbeec1e342d25588",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (armor == null) detach();\n\t\t\telse if (armor.isEquipped((Hero)target)) {\n\t\t\t\tint maxShield = 1 + armor.tier + armor.level();\n\t\t\t\tif (target.SHLD < maxShield){\n\t\t\t\t\tpartialShield += 1/(30*Math.pow(0.9f, (maxShield - target.SHLD)));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (partialShield >= 1){\n\t\t\t\ttarget.SHLD++;\n\t\t\t\tpartialShield--;\n\t\t\t}\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean act() {\n\t\t\tif (armor == null) detach();\n\t\t\telse if (armor.isEquipped((Hero)target)) {\n\t\t\t\tif (target.SHLD < maxShield()){\n\t\t\t\t\tpartialShield += 1/(30*Math.pow(0.9f, (maxShield() - target.SHLD)));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (partialShield >= 1){\n\t\t\t\ttarget.SHLD++;\n\t\t\t\tpartialShield--;\n\t\t\t}\n\t\t\tspend(TICK);\n\t\t\treturn true;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int maxShield() {\n\t\t\treturn 1 + armor.tier + armor.level();\n\t\t}",
          "uniqueId": "97365b1ecfce58e07609e0a4bbeec1e342d25588_76_91_96_98_76_90"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "7301217975115531a54024140f7e6560eeff6836",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/7301217975115531a54024140f7e6560eeff6836",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (cell < 0 || cell > Level.LENGTH || (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\tGameScene.show( new WndMessage( Messages.get(GameScene.class, \"dont_know\") ) ) ;\n\t\t\treturn;\n\t\t}\n\n\t\tif (cell == Dungeon.hero.pos) {\n\t\t\tGameScene.show( new WndHero() );\n\t\t\treturn;\n\t\t}\n\n\t\tif (Dungeon.visible[cell]) {\n\t\t\tMob mob = (Mob) Actor.findChar(cell);\n\t\t\tif (mob != null) {\n\t\t\t\tGameScene.show(new WndInfoMob(mob));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get(cell);\n\t\tif (heap != null && heap.seen) {\n\t\t\tif (heap.type == Heap.Type.FOR_SALE && heap.size() == 1 && heap.peek().price() > 0) {\n\t\t\t\tGameScene.show(new WndTradeItem(heap, false));\n\t\t\t} else {\n\t\t\t\tGameScene.show(new WndInfoItem(heap));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tPlant plant = Dungeon.level.plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tGameScene.show( new WndInfoPlant( plant ) );\n\t\t\treturn;\n\t\t}\n\n\t\tTrap trap = Dungeon.level.traps.get( cell );\n\t\tif (trap != null && trap.visible) {\n\t\t\tGameScene.show( new WndInfoTrap( trap ));\n\t\t\treturn;\n\t\t}\n\n\t\tGameScene.show( new WndInfoCell( cell ) );\n\t}",
          "sourceCodeAfterRefactoring": "public static void examineCell( Integer cell ) {\n\t\tif (cell == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (cell < 0 || cell > Level.LENGTH || (!Dungeon.level.visited[cell] && !Dungeon.level.mapped[cell])) {\n\t\t\tGameScene.show( new WndMessage( Messages.get(GameScene.class, \"dont_know\") ) ) ;\n\t\t\treturn;\n\t\t}\n\n\t\tArrayList<String> names = new ArrayList<>();\n\t\tfinal ArrayList<Object> objects = new ArrayList<>();\n\n\t\tif (cell == Dungeon.hero.pos) {\n\t\t\tobjects.add(Dungeon.hero);\n\t\t\tnames.add(Dungeon.hero.className().toUpperCase(Locale.ENGLISH));\n\t\t} else {\n\t\t\tif (Dungeon.visible[cell]) {\n\t\t\t\tMob mob = (Mob) Actor.findChar(cell);\n\t\t\t\tif (mob != null) objects.add(mob);\n\t\t\t\tnames.add(Messages.titleCase( mob.name ));\n\t\t\t}\n\t\t}\n\n\t\tHeap heap = Dungeon.level.heaps.get(cell);\n\t\tif (heap != null) {\n\t\t\tobjects.add(heap);\n\t\t\tnames.add(Messages.titleCase( heap.peek().toString() ));\n\t\t}\n\n\t\tPlant plant = Dungeon.level.plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tobjects.add(plant);\n\t\t\tnames.add(Messages.titleCase( plant.plantName ));\n\t\t}\n\n\t\tTrap trap = Dungeon.level.traps.get( cell );\n\t\tif (trap != null) {\n\t\t\tobjects.add(trap);\n\t\t\tnames.add(Messages.titleCase( trap.name ));\n\t\t}\n\n\t\tif (objects.isEmpty()) {\n\t\t\tGameScene.show(new WndInfoCell(cell));\n\t\t} else if (objects.size() == 1){\n\t\t\texamineObject(objects.get(0));\n\t\t} else {\n\t\t\tGameScene.show(new WndOptions(Messages.get(GameScene.class, \"choose_examine\"),\n\t\t\t\t\tMessages.get(GameScene.class, \"multiple_examine\"), names.toArray(new String[names.size()])){\n\t\t\t\t@Override\n\t\t\t\tprotected void onSelect(int index) {\n\t\t\t\t\texamineObject(objects.get(index));\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void examineObject(Object o){\n\t\tif (o == Dungeon.hero){\n\t\t\tGameScene.show( new WndHero() );\n\t\t} else if ( o instanceof Mob ){\n\t\t\tGameScene.show(new WndInfoMob((Mob) o));\n\t\t} else if ( o instanceof Heap ){\n\t\t\tHeap heap = (Heap)o;\n\t\t\tif (heap.type == Heap.Type.FOR_SALE && heap.size() == 1 && heap.peek().price() > 0) {\n\t\t\t\tGameScene.show(new WndTradeItem(heap, false));\n\t\t\t} else {\n\t\t\t\tGameScene.show(new WndInfoItem(heap));\n\t\t\t}\n\t\t} else if ( o instanceof Plant ){\n\t\t\tGameScene.show( new WndInfoPlant((Plant) o) );\n\t\t} else if ( o instanceof Trap ){\n\t\t\tGameScene.show( new WndInfoTrap((Trap) o));\n\t\t} else {\n\t\t\tGameScene.show( new WndMessage( Messages.get(GameScene.class, \"dont_know\") ) ) ;\n\t\t}\n\t}",
          "uniqueId": "7301217975115531a54024140f7e6560eeff6836_757_803_817_836_759_815"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "fae5fc7c6c228967a990df9a35e8c8b023ee1ea2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fae5fc7c6c228967a990df9a35e8c8b023ee1ea2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void level( float value ) {\n\t\tlevel = value;\n\t\tlayout();\n\t}",
          "sourceCodeAfterRefactoring": "public void level( float value ) {\n\t\tlevel( value, 0f );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void level( float health, float shield ){\n\t\tthis.health = health;\n\t\tthis.shield = shield;\n\t\tlayout();\n\t}",
          "uniqueId": "fae5fc7c6c228967a990df9a35e8c8b023ee1ea2_61_64_73_77_69_71"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "8ae4cd4fa510e5d8700c3e5baf1ec17da8abb317",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/8ae4cd4fa510e5d8700c3e5baf1ec17da8abb317",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void switchNoFade( Class<? extends PixelScene> c ) {\n\t\tPixelScene.noFade = true;\n\t\tswitchScene( c );\n\t}",
          "sourceCodeAfterRefactoring": "public static void switchNoFade(Class<? extends PixelScene> c){\n\t\tswitchNoFade(c, null);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void switchNoFade(Class<? extends PixelScene> c, SceneChangeCallback callback) {\n\t\tPixelScene.noFade = true;\n\t\tswitchScene( c, callback );\n\t}",
          "uniqueId": "8ae4cd4fa510e5d8700c3e5baf1ec17da8abb317_198_201_202_205_198_200"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "30e1947f182312706d6ce4321c4a66fd7dae0227",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/30e1947f182312706d6ce4321c4a66fd7dae0227",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tfinal int previousVersion = ShatteredPixelDungeon.version();\n\n\t\tif (ShatteredPixelDungeon.versionCode == previousVersion) {\n\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\treturn;\n\t\t}\n\n\t\tuiCamera.visible = false;\n\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\n\t\tImage title = BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON );\n\t\ttitle.brightness(0.5f);\n\t\tadd( title );\n\n\t\tfloat height = title.height +\n\t\t\t\t(ShatteredPixelDungeon.landscape() ? 48 : 96);\n\n\t\ttitle.x = (w - title.width()) / 2;\n\t\ttitle.y = (h - height) / 2;\n\n\t\tplaceTorch(title.x + 18, title.y + 20);\n\t\tplaceTorch(title.x + title.width - 18, title.y + 20);\n\n\t\tImage signs = new Image( BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON_SIGNS ) ) {\n\t\t\tprivate float time = 0;\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tam = (float)Math.sin( -(time += Game.elapsed) );\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void draw() {\n\t\t\t\tGLES20.glBlendFunc( GL10.GL_SRC_ALPHA, GL10.GL_ONE );\n\t\t\t\tsuper.draw();\n\t\t\t\tGLES20.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\t\t};\n\t\tsigns.x = title.x;\n\t\tsigns.y = title.y;\n\t\tadd( signs );\n\n\t\tRedButton okay = new RedButton(\"Continue\"){\n\n\t\t\t{\n\t\t\t\tbg.brightness(0.4f);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onTouchDown() {\n\t\t\t\tbg.brightness(0.5f);\n\t\t\t\tSample.INSTANCE.play( Assets.SND_CLICK );\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (previousVersion <= 32){\n\t\t\t\t\t//removes all bags bought badge from pre-0.2.4 saves.\n\t\t\t\t\tBadges.disown(Badges.Badge.ALL_BAGS_BOUGHT);\n\t\t\t\t\tBadges.saveGlobal();\n\n\t\t\t\t\t//imports new ranking data for pre-0.2.3 saves.\n\t\t\t\t\tif (previousVersion <= 29){\n\t\t\t\t\t\tRankings.INSTANCE.load();\n\t\t\t\t\t\tRankings.INSTANCE.save();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tShatteredPixelDungeon.version(ShatteredPixelDungeon.versionCode);\n\t\t\t\tShatteredPixelDungeon.switchScene(TitleScene.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onTouchUp() {\n\t\t\t\tsuper.onTouchUp();\n\t\t\t\tbg.brightness(0.4f);\n\t\t\t}\n\t\t};\n\n\t\tokay.setRect(title.x, h-22, title.width(), 20);\n\t\tokay.textColor(0xBBBB33);\n\t\tadd(okay);\n\n\t\tRenderedTextMultiline text = PixelScene.renderMultiline(6);\n\t\tif (previousVersion == 0) {\n\t\t\ttext.text(TXT_Welcome, w - 20);\n\t\t} else {\n\t\t\ttext.text(TXT_Update, w - 20);\n\t\t}\n\t\tfloat textSpace = h - title.y - (title.height() - 10) - okay.height() - 2;\n\t\ttext.setPos(10, title.y+(title.height() - 10) + ((textSpace - text.height()) / 2));\n\t\ttext.hardlight(0xAAAAAA);\n\t\tadd(text);\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tfinal int previousVersion = ShatteredPixelDungeon.version();\n\n\t\tif (ShatteredPixelDungeon.versionCode == previousVersion) {\n\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\treturn;\n\t\t}\n\n\t\tuiCamera.visible = false;\n\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\n\t\tImage title = BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON );\n\t\ttitle.brightness(0.5f);\n\t\tadd( title );\n\n\t\tfloat height = title.height +\n\t\t\t\t(ShatteredPixelDungeon.landscape() ? 48 : 96);\n\n\t\ttitle.x = (w - title.width()) / 2;\n\t\ttitle.y = (h - height) / 2;\n\n\t\tplaceTorch(title.x + 18, title.y + 20);\n\t\tplaceTorch(title.x + title.width - 18, title.y + 20);\n\n\t\tImage signs = new Image( BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON_SIGNS ) ) {\n\t\t\tprivate float time = 0;\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tam = (float)Math.sin( -(time += Game.elapsed) );\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void draw() {\n\t\t\t\tGLES20.glBlendFunc( GL10.GL_SRC_ALPHA, GL10.GL_ONE );\n\t\t\t\tsuper.draw();\n\t\t\t\tGLES20.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\t\t};\n\t\tsigns.x = title.x;\n\t\tsigns.y = title.y;\n\t\tadd( signs );\n\n\t\tDarkRedButton okay = new DarkRedButton(\"Continue\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tupdateVersion(previousVersion);\n\t\t\t\tShatteredPixelDungeon.switchScene(TitleScene.class);\n\t\t\t}\n\t\t};\n\n\t\tif (previousVersion != 0){\n\t\t\tDarkRedButton changes = new DarkRedButton(\"Changelist\"){\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tsuper.onClick();\n\t\t\t\t\tupdateVersion(previousVersion);\n\t\t\t\t\tShatteredPixelDungeon.switchScene(ChangesScene.class);\n\t\t\t\t}\n\t\t\t};\n\t\t\tokay.setRect(title.x, h-20, (title.width()/2)-2, 16);\n\t\t\tokay.textColor(0xBBBB33);\n\t\t\tadd(okay);\n\n\t\t\tchanges.setRect(okay.right()+2, h-20, (title.width()/2)-2, 16);\n\t\t\tchanges.textColor(0xBBBB33);\n\t\t\tadd(changes);\n\t\t} else {\n\t\t\tokay.setRect(title.x, h-20, title.width(), 16);\n\t\t\tokay.textColor(0xBBBB33);\n\t\t\tadd(okay);\n\t\t}\n\n\t\tRenderedTextMultiline text = PixelScene.renderMultiline(6);\n\t\tif (previousVersion == 0) {\n\t\t\ttext.text(TXT_Welcome, w - 20);\n\t\t} else {\n\t\t\ttext.text(TXT_Update, w - 20);\n\t\t}\n\t\tfloat textSpace = h - title.y - (title.height() - 10) - okay.height() - 2;\n\t\ttext.setPos(10, title.y+(title.height() - 10) + ((textSpace - text.height()) / 2));\n\t\ttext.hardlight(0xAAAAAA);\n\t\tadd(text);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateVersion(int previousVersion){\n\t\tif (previousVersion <= 32){\n\t\t\t//removes all bags bought badge from pre-0.2.4 saves.\n\t\t\tBadges.disown(Badges.Badge.ALL_BAGS_BOUGHT);\n\t\t\tBadges.saveGlobal();\n\n\t\t\t//imports new ranking data for pre-0.2.3 saves.\n\t\t\tif (previousVersion <= 29){\n\t\t\t\tRankings.INSTANCE.load();\n\t\t\t\tRankings.INSTANCE.save();\n\t\t\t}\n\t\t}\n\t\tShatteredPixelDungeon.version(ShatteredPixelDungeon.versionCode);\n\t}",
          "uniqueId": "30e1947f182312706d6ce4321c4a66fd7dae0227_31_133_122_135_31_120"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tfinal int previousVersion = ShatteredPixelDungeon.version();\n\n\t\tif (ShatteredPixelDungeon.versionCode == previousVersion) {\n\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\treturn;\n\t\t}\n\n\t\tuiCamera.visible = false;\n\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\n\t\tImage title = BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON );\n\t\ttitle.brightness(0.5f);\n\t\tadd( title );\n\n\t\tfloat height = title.height +\n\t\t\t\t(ShatteredPixelDungeon.landscape() ? 48 : 96);\n\n\t\ttitle.x = (w - title.width()) / 2;\n\t\ttitle.y = (h - height) / 2;\n\n\t\tplaceTorch(title.x + 18, title.y + 20);\n\t\tplaceTorch(title.x + title.width - 18, title.y + 20);\n\n\t\tImage signs = new Image( BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON_SIGNS ) ) {\n\t\t\tprivate float time = 0;\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tam = (float)Math.sin( -(time += Game.elapsed) );\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void draw() {\n\t\t\t\tGLES20.glBlendFunc( GL10.GL_SRC_ALPHA, GL10.GL_ONE );\n\t\t\t\tsuper.draw();\n\t\t\t\tGLES20.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\t\t};\n\t\tsigns.x = title.x;\n\t\tsigns.y = title.y;\n\t\tadd( signs );\n\n\t\tRedButton okay = new RedButton(\"Continue\"){\n\n\t\t\t{\n\t\t\t\tbg.brightness(0.4f);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onTouchDown() {\n\t\t\t\tbg.brightness(0.5f);\n\t\t\t\tSample.INSTANCE.play( Assets.SND_CLICK );\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\n\t\t\t\tif (previousVersion <= 32){\n\t\t\t\t\t//removes all bags bought badge from pre-0.2.4 saves.\n\t\t\t\t\tBadges.disown(Badges.Badge.ALL_BAGS_BOUGHT);\n\t\t\t\t\tBadges.saveGlobal();\n\n\t\t\t\t\t//imports new ranking data for pre-0.2.3 saves.\n\t\t\t\t\tif (previousVersion <= 29){\n\t\t\t\t\t\tRankings.INSTANCE.load();\n\t\t\t\t\t\tRankings.INSTANCE.save();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tShatteredPixelDungeon.version(ShatteredPixelDungeon.versionCode);\n\t\t\t\tShatteredPixelDungeon.switchScene(TitleScene.class);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onTouchUp() {\n\t\t\t\tsuper.onTouchUp();\n\t\t\t\tbg.brightness(0.4f);\n\t\t\t}\n\t\t};\n\n\t\tokay.setRect(title.x, h-22, title.width(), 20);\n\t\tokay.textColor(0xBBBB33);\n\t\tadd(okay);\n\n\t\tRenderedTextMultiline text = PixelScene.renderMultiline(6);\n\t\tif (previousVersion == 0) {\n\t\t\ttext.text(TXT_Welcome, w - 20);\n\t\t} else {\n\t\t\ttext.text(TXT_Update, w - 20);\n\t\t}\n\t\tfloat textSpace = h - title.y - (title.height() - 10) - okay.height() - 2;\n\t\ttext.setPos(10, title.y+(title.height() - 10) + ((textSpace - text.height()) / 2));\n\t\ttext.hardlight(0xAAAAAA);\n\t\tadd(text);\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void create() {\n\t\tsuper.create();\n\n\t\tfinal int previousVersion = ShatteredPixelDungeon.version();\n\n\t\tif (ShatteredPixelDungeon.versionCode == previousVersion) {\n\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\treturn;\n\t\t}\n\n\t\tuiCamera.visible = false;\n\n\t\tint w = Camera.main.width;\n\t\tint h = Camera.main.height;\n\n\t\tImage title = BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON );\n\t\ttitle.brightness(0.5f);\n\t\tadd( title );\n\n\t\tfloat height = title.height +\n\t\t\t\t(ShatteredPixelDungeon.landscape() ? 48 : 96);\n\n\t\ttitle.x = (w - title.width()) / 2;\n\t\ttitle.y = (h - height) / 2;\n\n\t\tplaceTorch(title.x + 18, title.y + 20);\n\t\tplaceTorch(title.x + title.width - 18, title.y + 20);\n\n\t\tImage signs = new Image( BannerSprites.get( BannerSprites.Type.PIXEL_DUNGEON_SIGNS ) ) {\n\t\t\tprivate float time = 0;\n\t\t\t@Override\n\t\t\tpublic void update() {\n\t\t\t\tsuper.update();\n\t\t\t\tam = (float)Math.sin( -(time += Game.elapsed) );\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void draw() {\n\t\t\t\tGLES20.glBlendFunc( GL10.GL_SRC_ALPHA, GL10.GL_ONE );\n\t\t\t\tsuper.draw();\n\t\t\t\tGLES20.glBlendFunc(GL10.GL_SRC_ALPHA, GL10.GL_ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\t\t};\n\t\tsigns.x = title.x;\n\t\tsigns.y = title.y;\n\t\tadd( signs );\n\n\t\tDarkRedButton okay = new DarkRedButton(\"Continue\"){\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tsuper.onClick();\n\t\t\t\tupdateVersion(previousVersion);\n\t\t\t\tShatteredPixelDungeon.switchScene(TitleScene.class);\n\t\t\t}\n\t\t};\n\n\t\tif (previousVersion != 0){\n\t\t\tDarkRedButton changes = new DarkRedButton(\"Changelist\"){\n\t\t\t\t@Override\n\t\t\t\tprotected void onClick() {\n\t\t\t\t\tsuper.onClick();\n\t\t\t\t\tupdateVersion(previousVersion);\n\t\t\t\t\tShatteredPixelDungeon.switchScene(ChangesScene.class);\n\t\t\t\t}\n\t\t\t};\n\t\t\tokay.setRect(title.x, h-20, (title.width()/2)-2, 16);\n\t\t\tokay.textColor(0xBBBB33);\n\t\t\tadd(okay);\n\n\t\t\tchanges.setRect(okay.right()+2, h-20, (title.width()/2)-2, 16);\n\t\t\tchanges.textColor(0xBBBB33);\n\t\t\tadd(changes);\n\t\t} else {\n\t\t\tokay.setRect(title.x, h-20, title.width(), 16);\n\t\t\tokay.textColor(0xBBBB33);\n\t\t\tadd(okay);\n\t\t}\n\n\t\tRenderedTextMultiline text = PixelScene.renderMultiline(6);\n\t\tif (previousVersion == 0) {\n\t\t\ttext.text(TXT_Welcome, w - 20);\n\t\t} else {\n\t\t\ttext.text(TXT_Update, w - 20);\n\t\t}\n\t\tfloat textSpace = h - title.y - (title.height() - 10) - okay.height() - 2;\n\t\ttext.setPos(10, title.y+(title.height() - 10) + ((textSpace - text.height()) / 2));\n\t\ttext.hardlight(0xAAAAAA);\n\t\tadd(text);\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateVersion(int previousVersion){\n\t\tif (previousVersion <= 32){\n\t\t\t//removes all bags bought badge from pre-0.2.4 saves.\n\t\t\tBadges.disown(Badges.Badge.ALL_BAGS_BOUGHT);\n\t\t\tBadges.saveGlobal();\n\n\t\t\t//imports new ranking data for pre-0.2.3 saves.\n\t\t\tif (previousVersion <= 29){\n\t\t\t\tRankings.INSTANCE.load();\n\t\t\t\tRankings.INSTANCE.save();\n\t\t\t}\n\t\t}\n\t\tShatteredPixelDungeon.version(ShatteredPixelDungeon.versionCode);\n\t}",
          "uniqueId": "30e1947f182312706d6ce4321c4a66fd7dae0227_31_133_122_135_31_120"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "31a8e50754ad61df28801d01f6d0c12daed1c3d4",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/31a8e50754ad61df28801d01f6d0c12daed1c3d4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Languages matchLocale(Locale locale){\n\t\t\tString code = locale.getLanguage();\n\t\t\tfor (Languages lang : Languages.values()){\n\t\t\t\tif (lang.code().equals(code))\n\t\t\t\t\treturn lang;\n\t\t\t}\n\t\t\treturn ENGLISH;\n\t\t}",
          "sourceCodeAfterRefactoring": "public static Languages matchLocale(Locale locale){\n\t\t\treturn matchCode(locale.getLanguage());\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Languages matchCode(String code){\n\t\t\tfor (Languages lang : Languages.values()){\n\t\t\t\tif (lang.code().equals(code))\n\t\t\t\t\treturn lang;\n\t\t\t}\n\t\t\treturn ENGLISH;\n\t\t}",
          "uniqueId": "31a8e50754ad61df28801d01f6d0c12daed1c3d4_75_82_80_86_76_78"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e27c0fba113de04bb49751c04095168d43fe013d",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e27c0fba113de04bb49751c04095168d43fe013d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void onClick() {\n\t\tparent.add( new WndOptions(\"Languages\", \"Select a language(proper menu soon)\", \"English\", \"Русский язык(99%)\", \"Português(99%)\", \"中文(99%)\", \"한국어(99%)\", \"Deutsch(93%)\", \"Polski(55%)\", \"Français(40%)\", \"Español(40%)\" ) {\n\t\t\t@Override\n\t\t\tprotected void onSelect(int index) {\n\t\t\t\tswitch(index){\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tMessages.setup(\"\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tMessages.setup(\"ru\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tMessages.setup(\"pt\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tMessages.setup(\"zh\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tMessages.setup(\"ko\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\tMessages.setup(\"de\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 6:\n\t\t\t\t\t\tMessages.setup(\"pl\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\tMessages.setup(\"fr\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tMessages.setup(\"es\");\n\t\t\t\t}\n\t\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\t\tRenderedText.clearCache();\n\t\t\t}\n\t\t});\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void onClick() {\n\t\tfinal Messages.Languages[] langs = Messages.Languages.values();\n\t\tfinal String[] names = new String[langs.length];\n\t\tfor (int i = 0; i < names.length; i++){\n\t\t\tnames[i] = Messages.titleCase(langs[i].nativeName());\n\t\t\tswitch(langs[i].status()){\n\t\t\t\tcase UNFINISHED:\n\t\t\t\t\tnames[i] += \" - UNFINISHED\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase INCOMPLETE:\n\t\t\t\t\tnames[i] += \" - INCOMPLETE\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tparent.add( new WndOptions(\"Languages\", \"Select a language(proper menu soon)\", names ) {\n\t\t\t@Override\n\t\t\tprotected void onSelect(int index) {\n\t\t\t\tMessages.setup(langs[index]);\n\t\t\t\tupdateIcon();\n\t\t\t\tShatteredPixelDungeon.switchNoFade(TitleScene.class);\n\t\t\t\tRenderedText.clearCache();\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void updateIcon(){\n\t\tswitch(Messages.lang().status()){\n\t\t\tcase UNFINISHED:\n\t\t\t\timage.tint(1, 0, 0, .4f);\n\t\t\t\tbreak;\n\t\t\tcase INCOMPLETE:\n\t\t\t\timage.tint(1, .5f, 0, .4f);\n\t\t\t\tbreak;\n\t\t\tcase UNREVIEWED:\n\t\t\t\timage.tint(1, 0.5f, 0, .25f);\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "uniqueId": "e27c0fba113de04bb49751c04095168d43fe013d_73_110_53_65_87_111"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d9dfa084f6c8f7b4be8a1d97468739f59c1a4648",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d9dfa084f6c8f7b4be8a1d97468739f59c1a4648",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WndItem( final WndBag owner, final Item item ) {\n\t\t\n\t\tsuper();\n\n\t\tint width = ShatteredPixelDungeon.landscape() ? WIDTH_L : WIDTH_P;\n\t\t\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\ttitlebar.color( ItemSlot.UPGRADED );\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\ttitlebar.color( ItemSlot.DEGRADED );\n\t\t}\n\t\t\n\t\tRenderedTextMultiline info = PixelScene.renderMultiline( item.info(), 6 );\n\t\tinfo.maxWidth(width);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( info );\n\t\n\t\tfloat y = info.top() + info.height() + GAP;\n\t\tfloat x = 0;\n\t\t\n\t\tif (Dungeon.hero.isAlive() && owner != null) {\n\t\t\tfor (final String action:item.actions( Dungeon.hero )) {\n\t\t\t\t\n\t\t\t\tRedButton btn = new RedButton( Messages.get(item, \"ac_\" + action), 8 ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\titem.execute( Dungeon.hero, action );\n\t\t\t\t\t\thide();\n\t\t\t\t\t\towner.hide();\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tbtn.setSize( Math.max( BUTTON_WIDTH, btn.reqWidth() ), BUTTON_HEIGHT );\n\t\t\t\tif (x + btn.width() > width) {\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += BUTTON_HEIGHT + 1;\n\t\t\t\t}\n\t\t\t\tbtn.setPos( x, y );\n\t\t\t\tadd( btn );\n\n\t\t\t\tif (action.equals(item.defaultAction)) {\n\t\t\t\t\tbtn.textColor( TITLE_COLOR );\n\t\t\t\t}\n\n\t\t\t\tx += btn.width() + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresize( width, (int)(y + (x > 0 ? BUTTON_HEIGHT : 0)) );\n\t}",
          "sourceCodeAfterRefactoring": "public WndItem( final WndBag owner, final Item item ) {\n\t\t\n\t\tsuper();\n\n\t\tint width = ShatteredPixelDungeon.landscape() ? WIDTH_L : WIDTH_P;\n\t\t\n\t\tIconTitle titlebar = new IconTitle( item );\n\t\ttitlebar.setRect( 0, 0, width, 0 );\n\t\tadd( titlebar );\n\n\t\tif (item.levelKnown && item.level() > 0) {\n\t\t\ttitlebar.color( ItemSlot.UPGRADED );\n\t\t} else if (item.levelKnown && item.level() < 0) {\n\t\t\ttitlebar.color( ItemSlot.DEGRADED );\n\t\t}\n\t\t\n\t\tRenderedTextMultiline info = PixelScene.renderMultiline( item.info(), 6 );\n\t\tinfo.maxWidth(width);\n\t\tinfo.setPos(titlebar.left(), titlebar.bottom() + GAP);\n\t\tadd( info );\n\t\n\t\tfloat y = info.top() + info.height() + GAP;\n\t\tfloat x = 0;\n\t\t\n\t\tif (Dungeon.hero.isAlive() && owner != null) {\n\t\t\tArrayList<RedButton> line = new ArrayList<>();\n\t\t\tfor (final String action:item.actions( Dungeon.hero )) {\n\t\t\t\t\n\t\t\t\tRedButton btn = new RedButton( Messages.get(item, \"ac_\" + action), 8 ) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onClick() {\n\t\t\t\t\t\titem.execute( Dungeon.hero, action );\n\t\t\t\t\t\thide();\n\t\t\t\t\t\towner.hide();\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t\tbtn.setSize( btn.reqWidth(), BUTTON_HEIGHT );\n\t\t\t\tif (x + btn.width() > width || line.size() == 3) {\n\t\t\t\t\tlayoutButtons(line, width - x, y);\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty += BUTTON_HEIGHT + 1;\n\t\t\t\t\tline = new ArrayList<>();\n\t\t\t\t}\n\t\t\t\tx++;\n\t\t\t\tadd( btn );\n\t\t\t\tline.add( btn );\n\n\t\t\t\tif (action.equals(item.defaultAction)) {\n\t\t\t\t\tbtn.textColor( TITLE_COLOR );\n\t\t\t\t}\n\n\t\t\t\tx += btn.width();\n\t\t\t}\n\t\t\tlayoutButtons(line, width - x, y);\n\t\t}\n\t\t\n\t\tresize( width, (int)(y + (x > 0 ? BUTTON_HEIGHT : 0)) );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void layoutButtons(ArrayList<RedButton> line, float extraWidth, float y){\n\t\tif (line == null || line.size() == 0 || extraWidth == 0) return;\n\t\tif (line.size() == 1){\n\t\t\tline.get(0).setSize(line.get(0).width()+extraWidth, BUTTON_HEIGHT);\n\t\t\treturn;\n\t\t}\n\t\tArrayList<RedButton> lineByWidths = new ArrayList<>(line);\n\t\tCollections.sort(lineByWidths, widthComparator);\n\t\tRedButton smallest, middle, largest;\n\t\tsmallest = lineByWidths.get(0);\n\t\tmiddle = lineByWidths.get(1);\n\t\tlargest = null;\n\t\tif (lineByWidths.size() == 3) {\n\t\t\tlargest = lineByWidths.get(2);\n\t\t}\n\n\t\tfloat btnDiff = middle.width() - smallest.width();\n\t\tsmallest.setSize(smallest.width() + Math.min(btnDiff, extraWidth), BUTTON_HEIGHT);\n\t\textraWidth -= btnDiff;\n\t\tif (extraWidth > 0) {\n\t\t\tif (largest == null) {\n\t\t\t\tsmallest.setSize(smallest.width() + extraWidth / 2, BUTTON_HEIGHT);\n\t\t\t\tmiddle.setSize(middle.width() + extraWidth / 2, BUTTON_HEIGHT);\n\t\t\t} else {\n\t\t\t\tbtnDiff = largest.width() - smallest.width();\n\t\t\t\tsmallest.setSize(smallest.width() + Math.min(btnDiff, extraWidth/2), BUTTON_HEIGHT);\n\t\t\t\tmiddle.setSize(middle.width() + Math.min(btnDiff, extraWidth/2), BUTTON_HEIGHT);\n\t\t\t\textraWidth -= btnDiff*2;\n\t\t\t\tif (extraWidth > 0){\n\t\t\t\t\tsmallest.setSize(smallest.width() + extraWidth / 3, BUTTON_HEIGHT);\n\t\t\t\t\tmiddle.setSize(middle.width() + extraWidth / 3, BUTTON_HEIGHT);\n\t\t\t\t\tlargest.setSize(largest.width() + extraWidth / 3, BUTTON_HEIGHT);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfloat x = 0;\n\t\tfor (RedButton btn : line){\n\t\t\tbtn.setPos( x , y );\n\t\t\tx += btn.width()+1;\n\t\t}\n\t}",
          "uniqueId": "d9dfa084f6c8f7b4be8a1d97468739f59c1a4648_43_95_107_148_46_103"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d9d6e45d040529306d827b419b9b2a4e88b258f8",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d9d6e45d040529306d827b419b9b2a4e88b258f8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static String get(Class c, String k, Object...args){\n\t\tString key;\n\t\tif (c != null){\n\t\t\tkey = c.getName().replace(\"com.shatteredpixel.shatteredpixeldungeon.\", \"\");\n\t\t\tkey += \".\" + k;\n\t\t} else\n\t\t\tkey = k;\n\n\t\tif (!strings.containsKey(key.toLowerCase())){\n\t\t\t//this is so child classes can inherit properties from their parents.\n\t\t\t//in cases where text is commonly grabbed as a utility from classes that aren't mean to be instantiated\n\t\t\t//(e.g. flavourbuff.dispTurns()) using .class directly is probably smarter to prevent unnecessary recursive calls.\n\t\t\tif (c != null && c.getSuperclass() != null){\n\t\t\t\treturn get(c.getSuperclass(), k, args);\n\t\t\t} else {\n\t\t\t\treturn \"!!!NO TEXT FOUND!!!\";\n\t\t\t}\n\t\t} else {\n\t\t\tif (args.length > 0) return String.format(Locale.ENGLISH, strings.get(key.toLowerCase()), args);\n\t\t\telse return strings.get(key.toLowerCase());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static String get(Class c, String k, Object...args){\n\t\tString key;\n\t\tif (c != null){\n\t\t\tkey = c.getName().replace(\"com.shatteredpixel.shatteredpixeldungeon.\", \"\");\n\t\t\tkey += \".\" + k;\n\t\t} else\n\t\t\tkey = k;\n\n\t\tif (!strings.containsKey(key.toLowerCase())){\n\t\t\t//this is so child classes can inherit properties from their parents.\n\t\t\t//in cases where text is commonly grabbed as a utility from classes that aren't mean to be instantiated\n\t\t\t//(e.g. flavourbuff.dispTurns()) using .class directly is probably smarter to prevent unnecessary recursive calls.\n\t\t\tif (c != null && c.getSuperclass() != null){\n\t\t\t\treturn get(c.getSuperclass(), k, args);\n\t\t\t} else {\n\t\t\t\treturn \"!!!NO TEXT FOUND!!!\";\n\t\t\t}\n\t\t} else {\n\t\t\tif (args.length > 0) return format(strings.get(key.toLowerCase()), args);\n\t\t\telse return strings.get(key.toLowerCase());\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static String format( String format, Object...args ) {\n\t\treturn String.format( Locale.ENGLISH, format, args );\n\t}",
          "uniqueId": "d9d6e45d040529306d827b419b9b2a4e88b258f8_94_115_84_86_98_119"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic String toString() {\n\t\t\n\t\tif (levelKnown && level != 0) {\n\t\t\tif (quantity > 1) {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_LVL_X, name(), level, quantity );\n\t\t\t} else {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_LVL, name(), level );\n\t\t\t}\n\t\t} else {\n\t\t\tif (quantity > 1) {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_X, name(), quantity );\n\t\t\t} else {\n\t\t\t\treturn Utils.format( TXT_TO_STRING, name() );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic String toString() {\n\t\t\n\t\tif (levelKnown && level != 0) {\n\t\t\tif (quantity > 1) {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_LVL_X, name(), level, quantity );\n\t\t\t} else {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_LVL, name(), level );\n\t\t\t}\n\t\t} else {\n\t\t\tif (quantity > 1) {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_X, name(), quantity );\n\t\t\t} else {\n\t\t\t\treturn Messages.format( TXT_TO_STRING, name() );\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n// whether an item can be included in heroes remains\n\tpublic boolean bones = false;",
          "uniqueId": "d9d6e45d040529306d827b419b9b2a4e88b258f8_343_359_84_86_342_358"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic String toString() {\n\n\t\tif (levelKnown && level()/levelCap != 0) {\n\t\t\tif (chargeCap > 0) {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_LVL_CHARGE, name(), visiblyUpgraded(), charge, chargeCap );\n\t\t\t} else {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_LVL, name(), visiblyUpgraded() );\n\t\t\t}\n\t\t} else {\n\t\t\tif (chargeCap > 0) {\n\t\t\t\treturn Utils.format( TXT_TO_STRING_CHARGE, name(), charge, chargeCap );\n\t\t\t} else {\n\t\t\t\treturn Utils.format( TXT_TO_STRING, name() );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic String toString() {\n\n\t\tif (levelKnown && level()/levelCap != 0) {\n\t\t\tif (chargeCap > 0) {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_LVL_CHARGE, name(), visiblyUpgraded(), charge, chargeCap );\n\t\t\t} else {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_LVL, name(), visiblyUpgraded() );\n\t\t\t}\n\t\t} else {\n\t\t\tif (chargeCap > 0) {\n\t\t\t\treturn Messages.format( TXT_TO_STRING_CHARGE, name(), charge, chargeCap );\n\t\t\t} else {\n\t\t\t\treturn Messages.format( TXT_TO_STRING, name() );\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nfinal Artifact art = this;\n\n\t\t\tShatteredPixelDungeon.scene().add(",
          "uniqueId": "d9d6e45d040529306d827b419b9b2a4e88b258f8_202_218_84_86_200_216"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "560070fcd079a5d5f7f1589db3cf1ea49b586368",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/560070fcd079a5d5f7f1589db3cf1ea49b586368",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public RedButton( String label ) {\n\t\tsuper();\n\t\t\n\t\ttext.text( label );\n\t}",
          "sourceCodeAfterRefactoring": "public RedButton( String label ) {\n\t\tthis(label, 9);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic RedButton( String label, int size ){\n\t\tsuper();\n\n\t\ttext = PixelScene.renderText( size );\n\t\ttext.text( label );\n\t\tadd( text );\n\t}",
          "uniqueId": "560070fcd079a5d5f7f1589db3cf1ea49b586368_38_42_42_48_38_40"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "861fa344201193e9d76cc44558e1bb37a8cde5f9",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/861fa344201193e9d76cc44558e1bb37a8cde5f9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\t\n\t\tsuper.execute( hero, action );\n\t\t\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tswitch (Random.Int( 5 )) {\n\t\t\tcase 0:\n\t\t\t\tGLog.i( \"You see your hands turn invisible!\" );\n\t\t\t\tBuff.affect( hero, Invisibility.class, Invisibility.DURATION );\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tGLog.i( \"You feel your skin harden!\" );\n\t\t\t\tBuff.affect( hero, Barkskin.class ).level( hero.HT / 4 );\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tGLog.i( \"Refreshing!\" );\n\t\t\t\tBuff.detach( hero, Poison.class );\n\t\t\t\tBuff.detach( hero, Cripple.class );\n\t\t\t\tBuff.detach( hero, Weakness.class );\n\t\t\t\tBuff.detach( hero, Bleeding.class );\n\t\t\t\tBuff.detach( hero, Drowsy.class );\n\t\t\t\tBuff.detach( hero, Slow.class );\n\t\t\t\tBuff.detach( hero, Vertigo.class);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tGLog.i( \"You feel better!\" );\n\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\thero.HP = Math.min( hero.HP + hero.HT / 4, hero.HT );\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\t\n\t\tsuper.execute( hero, action );\n\t\t\n\t\tif (action.equals( AC_EAT )) {\n\t\t\teffect(hero);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void effect(Hero hero){\n\t\tswitch (Random.Int( 5 )) {\n\t\t\tcase 0:\n\t\t\t\tGLog.i( Messages.get(FrozenCarpaccio.class, \"invis\") );\n\t\t\t\tBuff.affect( hero, Invisibility.class, Invisibility.DURATION );\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tGLog.i( Messages.get(FrozenCarpaccio.class, \"hard\") );\n\t\t\t\tBuff.affect( hero, Barkskin.class ).level( hero.HT / 4 );\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tGLog.i( Messages.get(FrozenCarpaccio.class, \"refresh\") );\n\t\t\t\tBuff.detach( hero, Poison.class );\n\t\t\t\tBuff.detach( hero, Cripple.class );\n\t\t\t\tBuff.detach( hero, Weakness.class );\n\t\t\t\tBuff.detach( hero, Bleeding.class );\n\t\t\t\tBuff.detach( hero, Drowsy.class );\n\t\t\t\tBuff.detach( hero, Slow.class );\n\t\t\t\tBuff.detach( hero, Vertigo.class);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tGLog.i( Messages.get(FrozenCarpaccio.class, \"better\") );\n\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\thero.HP = Math.min( hero.HP + hero.HT / 4, hero.HT );\n\t\t\t\t\thero.sprite.emitter().burst( Speck.factory( Speck.HEALING ), 1 );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "uniqueId": "861fa344201193e9d76cc44558e1bb37a8cde5f9_48_83_63_91_49_57"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\t\n\t\tsuper.execute( hero, action );\n\t\t\n\t\tif (action.equals( AC_EAT )) {\n\t\t\t\n\t\t\tswitch (Random.Int( 5 )) {\n\t\t\tcase 0:\n\t\t\t\tGLog.w( \"Oh it's hot!\" );\n\t\t\t\tBuff.affect( hero, Burning.class ).reignite( hero );\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tGLog.w( \"You can't feel your legs!\" );\n\t\t\t\tBuff.prolong( hero, Roots.class, Paralysis.duration( hero ) );\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tGLog.w( \"You are not feeling well.\" );\n\t\t\t\tBuff.affect( hero, Poison.class ).set( Poison.durationFactor( hero ) * hero.HT / 5 );\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tGLog.w( \"You are stuffed.\" );\n\t\t\t\tBuff.prolong( hero, Slow.class, Slow.duration( hero ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\t\n\t\tsuper.execute( hero, action );\n\t\t\n\t\tif (action.equals( AC_EAT )) {\n\t\t\teffect(hero);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void effect(Hero hero){\n\t\tswitch (Random.Int( 5 )) {\n\t\t\tcase 0:\n\t\t\t\tGLog.w( Messages.get(MysteryMeat.class, \"hot\") );\n\t\t\t\tBuff.affect( hero, Burning.class ).reignite( hero );\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tGLog.w( Messages.get(MysteryMeat.class, \"legs\") );\n\t\t\t\tBuff.prolong( hero, Roots.class, Paralysis.duration( hero ) );\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tGLog.w( Messages.get(MysteryMeat.class, \"not_well\") );\n\t\t\t\tBuff.affect( hero, Poison.class ).set( Poison.durationFactor( hero ) * hero.HT / 5 );\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tGLog.w( Messages.get(MysteryMeat.class, \"stuffed\") );\n\t\t\t\tBuff.prolong( hero, Slow.class, Slow.duration( hero ) );\n\t\t\t\tbreak;\n\t\t}\n\t}",
          "uniqueId": "861fa344201193e9d76cc44558e1bb37a8cde5f9_44_70_58_77_44_52"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tif (action.equals( AC_EAT )){\n\n\t\t\tif (potionAttrib == null) {\n\n\t\t\t\tdetach(hero.belongings.backpack);\n\n\t\t\t\t((Hunger) hero.buff(Hunger.class)).satisfy(energy);\n\t\t\t\tGLog.i(message);\n\n\t\t\t\thero.sprite.operate(hero.pos);\n\t\t\t\thero.busy();\n\t\t\t\tSpellSprite.show(hero, SpellSprite.FOOD);\n\t\t\t\tSample.INSTANCE.play(Assets.SND_EAT);\n\n\t\t\t\thero.spend(1f);\n\n\t\t\t\tStatistics.foodEaten++;\n\t\t\t\tBadges.validateFoodEaten();\n\t\t\t} else {\n\n\t\t\t\t((Hunger) hero.buff(Hunger.class)).satisfy(Hunger.HUNGRY);\n\n\t\t\t\tdetach(hero.belongings.backpack);\n\n\t\t\t\thero.spend(1f);\n\t\t\t\thero.busy();\n\n\t\t\t\tif (potionAttrib instanceof PotionOfFrost) {\n\t\t\t\t\tGLog.i(\"the Icefruit tastes a bit like Frozen Carpaccio.\");\n\t\t\t\t\tswitch (Random.Int(5)) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tGLog.i(\"You see your hands turn invisible!\");\n\t\t\t\t\t\t\tBuff.affect(hero, Invisibility.class, Invisibility.DURATION);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tGLog.i(\"You feel your skin harden!\");\n\t\t\t\t\t\t\tBuff.affect(hero, Barkskin.class).level(hero.HT / 4);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tGLog.i(\"Refreshing!\");\n\t\t\t\t\t\t\tBuff.detach(hero, Poison.class);\n\t\t\t\t\t\t\tBuff.detach(hero, Cripple.class);\n\t\t\t\t\t\t\tBuff.detach(hero, Weakness.class);\n\t\t\t\t\t\t\tBuff.detach(hero, Bleeding.class);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tGLog.i(\"You feel better!\");\n\t\t\t\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\t\t\t\thero.HP = Math.min(hero.HP + hero.HT / 4, hero.HT);\n\t\t\t\t\t\t\t\thero.sprite.emitter().burst(Speck.factory(Speck.HEALING), 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else if (potionAttrib instanceof PotionOfLiquidFlame){\n\t\t\t\t\tGLog.i(\"You feel a great fire burning within you!\");\n\t\t\t\t\tBuff.affect(hero, FireImbue.class).set(FireImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfToxicGas) {\n\t\t\t\t\tGLog.i(\"You are imbued with vile toxic power!\");\n\t\t\t\t\tBuff.affect(hero, ToxicImbue.class).set(ToxicImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfParalyticGas) {\n\t\t\t\t\tGLog.i(\"You feel the power of the earth coursing through you!\");\n\t\t\t\t\tBuff.affect(hero, EarthImbue.class, EarthImbue.DURATION);\n\t\t\t\t} else\n\t\t\t\t\tpotionAttrib.apply(hero);\n\n\t\t\t\tSample.INSTANCE.play( Assets.SND_EAT );\n\t\t\t\tSpellSprite.show(hero, SpellSprite.FOOD);\n\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\tswitch (hero.heroClass) {\n\t\t\t\t\tcase WARRIOR:\n\t\t\t\t\t\tif (hero.HP < hero.HT) {\n\t\t\t\t\t\t\thero.HP = Math.min( hero.HP + 5, hero.HT );\n\t\t\t\t\t\t\thero.sprite.emitter().burst( Speck.factory(Speck.HEALING), 1 );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MAGE:\n\t\t\t\t\t\t//1 charge\n\t\t\t\t\t\tBuff.affect(hero, Recharging.class, 4f);\n\t\t\t\t\t\tScrollOfRecharging.charge(hero);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ROGUE:\n\t\t\t\t\tcase HUNTRESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.execute(hero, action);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tif (action.equals( AC_EAT )){\n\t\t\tif (potionAttrib == null) {\n\n\t\t\t\tGLog.w( Messages.get(this, \"raw\"));\n\n\t\t\t} else {\n\n\t\t\t\tsuper.execute(hero, action);\n\n\t\t\t\tif (potionAttrib instanceof PotionOfFrost) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"ice_msg\"));\n\t\t\t\t\tFrozenCarpaccio.effect(hero);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfLiquidFlame){\n\t\t\t\t\tGLog.i(Messages.get(this, \"fire_msg\"));\n\t\t\t\t\tBuff.affect(hero, FireImbue.class).set(FireImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfToxicGas) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"toxic_msg\"));\n\t\t\t\t\tBuff.affect(hero, ToxicImbue.class).set(ToxicImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfParalyticGas) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"para_msg\"));\n\t\t\t\t\tBuff.affect(hero, EarthImbue.class, EarthImbue.DURATION);\n\t\t\t\t} else\n\t\t\t\t\tpotionAttrib.apply(hero);\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.execute(hero, action);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tif (action.equals( AC_EAT )){\n\t\t\tif (potionAttrib == null) {\n\n\t\t\t\tGLog.w( Messages.get(this, \"raw\"));\n\n\t\t\t} else {\n\n\t\t\t\tsuper.execute(hero, action);\n\n\t\t\t\tif (potionAttrib instanceof PotionOfFrost) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"ice_msg\"));\n\t\t\t\t\tFrozenCarpaccio.effect(hero);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfLiquidFlame){\n\t\t\t\t\tGLog.i(Messages.get(this, \"fire_msg\"));\n\t\t\t\t\tBuff.affect(hero, FireImbue.class).set(FireImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfToxicGas) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"toxic_msg\"));\n\t\t\t\t\tBuff.affect(hero, ToxicImbue.class).set(ToxicImbue.DURATION);\n\t\t\t\t} else if (potionAttrib instanceof PotionOfParalyticGas) {\n\t\t\t\t\tGLog.i(Messages.get(this, \"para_msg\"));\n\t\t\t\t\tBuff.affect(hero, EarthImbue.class, EarthImbue.DURATION);\n\t\t\t\t} else",
          "uniqueId": "861fa344201193e9d76cc44558e1bb37a8cde5f9_85_176_63_91_68_97"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/366dce1610cd2375a4ec7f5d1115fe0eb131cb16",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private int min() {\n\t\treturn tier;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int min() {\n\t\treturn minBase() + level();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int minBase() {\n\t\treturn tier;\n\t}",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_47_49_45_47_53_56"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private int max() {\n\t\treturn (int)((tier * tier - tier + 10) / ACU * DLY);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic int max() {\n\t\treturn maxBase() + level() * tier;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected int maxBase() {\n\t\treturn (int)((tier * tier - tier + 10) / ACU * DLY);\n\t}",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_51_53_49_51_58_61"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tif (action.equals(AC_SUMMON)) {\n\n\t\t\tif (spawned)                    GLog.n(\"sad ghost: \\\"I'm already here\\\"\");\n\t\t\telse if (!isEquipped( hero ))   GLog.i(\"You need to equip your rose to do that.\");\n\t\t\telse if (charge != chargeCap)   GLog.i(\"Your rose isn't fully charged yet.\");\n\t\t\telse if (cursed)                GLog.i(\"You cannot use a cursed rose.\");\n\t\t\telse {\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<Integer>();\n\t\t\t\tfor (int i = 0; i < Level.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = hero.pos + Level.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Level.passable[p] || Level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tGhostHero ghost = new GhostHero( level );\n\t\t\t\t\tghost.pos = Random.element(spawnPoints);\n\n\t\t\t\t\tGameScene.add(ghost, 1f);\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( ShaftParticle.FACTORY, 0.3f, 4 );\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( Speck.factory(Speck.LIGHT), 0.2f, 3 );\n\n\t\t\t\t\thero.spend(1f);\n\t\t\t\t\thero.busy();\n\t\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\t\tif (!firstSummon) {\n\t\t\t\t\t\tghost.yell(ghost.VOICE_HELLO + Dungeon.hero.givenName());\n\t\t\t\t\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\t\t\t\tfirstSummon = true;\n\t\t\t\t\t} else\n\t\t\t\t\t\tghost.saySpawned();\n\n\t\t\t\t\tspawned = true;\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tupdateQuickslot();\n\n\t\t\t\t} else\n\t\t\t\t\tGLog.i(\"There is no free space near you.\");\n\t\t\t}\n\n\t\t} else{\n\t\t\tsuper.execute(hero, action);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void execute( Hero hero, String action ) {\n\t\tif (action.equals(AC_SUMMON)) {\n\n\t\t\tif (spawned)                    GLog.n(\"sad ghost: \\\"I'm already here\\\"\");\n\t\t\telse if (!isEquipped( hero ))   GLog.i(\"You need to equip your rose to do that.\");\n\t\t\telse if (charge != chargeCap)   GLog.i(\"Your rose isn't fully charged yet.\");\n\t\t\telse if (cursed)                GLog.i(\"You cannot use a cursed rose.\");\n\t\t\telse {\n\t\t\t\tArrayList<Integer> spawnPoints = new ArrayList<Integer>();\n\t\t\t\tfor (int i = 0; i < Level.NEIGHBOURS8.length; i++) {\n\t\t\t\t\tint p = hero.pos + Level.NEIGHBOURS8[i];\n\t\t\t\t\tif (Actor.findChar(p) == null && (Level.passable[p] || Level.avoid[p])) {\n\t\t\t\t\t\tspawnPoints.add(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (spawnPoints.size() > 0) {\n\t\t\t\t\tGhostHero ghost = new GhostHero( level() );\n\t\t\t\t\tghost.pos = Random.element(spawnPoints);\n\n\t\t\t\t\tGameScene.add(ghost, 1f);\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( ShaftParticle.FACTORY, 0.3f, 4 );\n\t\t\t\t\tCellEmitter.get(ghost.pos).start( Speck.factory(Speck.LIGHT), 0.2f, 3 );\n\n\t\t\t\t\thero.spend(1f);\n\t\t\t\t\thero.busy();\n\t\t\t\t\thero.sprite.operate(hero.pos);\n\n\t\t\t\t\tif (!firstSummon) {\n\t\t\t\t\t\tghost.yell(ghost.VOICE_HELLO + Dungeon.hero.givenName());\n\t\t\t\t\t\tSample.INSTANCE.play( Assets.SND_GHOST );\n\t\t\t\t\t\tfirstSummon = true;\n\t\t\t\t\t} else\n\t\t\t\t\t\tghost.saySpawned();\n\n\t\t\t\t\tspawned = true;\n\t\t\t\t\tcharge = 0;\n\t\t\t\t\tupdateQuickslot();\n\n\t\t\t\t} else\n\t\t\t\t\tGLog.i(\"There is no free space near you.\");\n\t\t\t}\n\n\t\t} else{\n\t\t\tsuper.execute(hero, action);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nrose.upgrade();\n\t\t\t\tif (rose.level() == rose.levelCap) {\n\t\t\t\t\tGLog.p(\"The rose is completed!\");",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_88_135_268_270_87_134"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Item upgrade() {\n\t\tif (level >= 9)\n\t\t\timage = ItemSpriteSheet.ARTIFACT_ROSE3;\n\t\telse if (level >= 4)\n\t\t\timage = ItemSpriteSheet.ARTIFACT_ROSE2;\n\n\t\t//For upgrade transferring via well of transmutation\n\t\tdroppedPetals = Math.max( level, droppedPetals );\n\n\t\treturn super.upgrade();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Item upgrade() {\n\t\tif (level() >= 9)\n\t\t\timage = ItemSpriteSheet.ARTIFACT_ROSE3;\n\t\telse if (level() >= 4)\n\t\t\timage = ItemSpriteSheet.ARTIFACT_ROSE2;\n\n\t\t//For upgrade transferring via well of transmutation\n\t\tdroppedPetals = Math.max( level(), droppedPetals );\n\n\t\treturn super.upgrade();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nrose.upgrade();\n\t\t\t\tif (rose.level() == rose.levelCap) {\n\t\t\t\t\tGLog.p(\"The rose is completed!\");",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_168_179_268_270_167_178"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public RingBuff() {\n\t\t\tlevel = Ring.this.level;\n\t\t}",
          "sourceCodeAfterRefactoring": "public RingBuff() {\n\t\t\tlevel = Ring.this.level();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\tpublic Item identify() {",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_342_344_268_270_342_344"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void affectTarget(Char ch){\n\t\tint dmg = Random.NormalIntRange(level, (int) (8+(level*(level/5f))));\n\n\t\t//three in (5+lvl) chance of failing\n\t\tif (Random.Int(5+level) >= 3) {\n\t\t\tBuff.prolong(ch, Blindness.class, 2f + (level * 0.34f));\n\t\t\tch.sprite.emitter().burst(Speck.factory(Speck.LIGHT), 6 );\n\t\t}\n\n\t\tif (evilMobs.contains(ch.getClass())){\n\t\t\tch.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10+level );\n\t\t\tSample.INSTANCE.play(Assets.SND_BURNING);\n\n\t\t\tch.damage((int)(dmg*1.5), this);\n\t\t} else {\n\t\t\tch.sprite.centerEmitter().burst( RainbowParticle.BURST, 10+level );\n\n\t\t\tch.damage(dmg, this);\n\t\t}\n\n\t}",
          "sourceCodeAfterRefactoring": "private void affectTarget(Char ch){\n\t\tint dmg = Random.NormalIntRange(level(), (int) (8+(level()*(level()/5f))));\n\n\t\t//three in (5+lvl) chance of failing\n\t\tif (Random.Int(5+level()) >= 3) {\n\t\t\tBuff.prolong(ch, Blindness.class, 2f + (level() * 0.34f));\n\t\t\tch.sprite.emitter().burst(Speck.factory(Speck.LIGHT), 6 );\n\t\t}\n\n\t\tif (evilMobs.contains(ch.getClass())){\n\t\t\tch.sprite.emitter().start( ShadowParticle.UP, 0.05f, 10+level() );\n\t\t\tSample.INSTANCE.play(Assets.SND_BURNING);\n\n\t\t\tch.damage((int)(dmg*1.5), this);\n\t\t} else {\n\t\t\tch.sprite.centerEmitter().burst( RainbowParticle.BURST, 10+level() );\n\n\t\t\tch.damage(dmg, this);\n\t\t}\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_96_116_268_270_96_116"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public void guessBrew() {\n\t\tif (curGuess.size() != 3)\n\t\t\treturn;\n\n\t\tint numWrongPlace = 0;\n\t\tint numRight = 0;\n\n\t\tfor (String potion : curGuess) {\n\t\t\tif (combination.contains(potion)) {\n\t\t\t\tif (curGuess.indexOf(potion) == combination.indexOf(potion)) {\n\t\t\t\t\tnumRight++;\n\t\t\t\t} else {\n\t\t\t\t\tnumWrongPlace++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint score = (numRight *3) + numWrongPlace;\n\n\t\tif (score == 9)\n\t\t\tscore ++;\n\n\t\tif (score == 0){\n\n\t\t\tGLog.i(\"Your mixture is complete, but none of the potions you used seem to react well. \" +\n\t\t\t\t\t\"The brew is useless, you throw it away.\");\n\n\t\t} else if (score > level) {\n\n\t\t\tlevel = score;\n\t\t\tseedsToPotion = 0;\n\t\t\tbstGuess = curGuess;\n\t\t\tthis.numRight = numRight;\n\t\t\tthis.numWrongPlace = numWrongPlace;\n\n\t\t\tif (level == 10){\n\t\t\t\tbstGuess = new ArrayList<String>();\n\t\t\t\tGLog.p(\"The mixture you've created seems perfect, you don't think there is any way to improve it!\");\n\t\t\t} else {\n\t\t\t\tGLog.w(\"you finish mixing potions, \" + brewDesc(numWrongPlace, numRight) +\n\t\t\t\t\t\t\". This is your best brew yet!\");\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tGLog.w(\"you finish mixing potions, \" + brewDesc(numWrongPlace, numRight) +\n\t\t\t\t\t\". This brew isn't as good as the current one, you throw it away.\");\n\t\t}\n\t\tcurGuess = new ArrayList<String>();\n\n\t}",
          "sourceCodeAfterRefactoring": "public void guessBrew() {\n\t\tif (curGuess.size() != 3)\n\t\t\treturn;\n\n\t\tint numWrongPlace = 0;\n\t\tint numRight = 0;\n\n\t\tfor (String potion : curGuess) {\n\t\t\tif (combination.contains(potion)) {\n\t\t\t\tif (curGuess.indexOf(potion) == combination.indexOf(potion)) {\n\t\t\t\t\tnumRight++;\n\t\t\t\t} else {\n\t\t\t\t\tnumWrongPlace++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint score = (numRight *3) + numWrongPlace;\n\n\t\tif (score == 9)\n\t\t\tscore ++;\n\n\t\tif (score == 0){\n\n\t\t\tGLog.i(\"Your mixture is complete, but none of the potions you used seem to react well. \" +\n\t\t\t\t\t\"The brew is useless, you throw it away.\");\n\n\t\t} else if (score > level()) {\n\n\t\t\tlevel(score);\n\t\t\tseedsToPotion = 0;\n\t\t\tbstGuess = curGuess;\n\t\t\tthis.numRight = numRight;\n\t\t\tthis.numWrongPlace = numWrongPlace;\n\n\t\t\tif (level() == 10){\n\t\t\t\tbstGuess = new ArrayList<String>();\n\t\t\t\tGLog.p(\"The mixture you've created seems perfect, you don't think there is any way to improve it!\");\n\t\t\t} else {\n\t\t\t\tGLog.w(\"you finish mixing potions, \" + brewDesc(numWrongPlace, numRight) +\n\t\t\t\t\t\t\". This is your best brew yet!\");\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tGLog.w(\"you finish mixing potions, \" + brewDesc(numWrongPlace, numRight) +\n\t\t\t\t\t\". This brew isn't as good as the current one, you throw it away.\");\n\t\t}\n\t\tcurGuess = new ArrayList<String>();\n\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (curGuess.size() == 3){\n\t\t\t\t\t\tguessBrew();\n\t\t\t\t\t} else {",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_96_146_272_274_95_145"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Item random() {\n\t\tint n = 1;\n\t\tif (Random.Int(3) == 0) {\n\t\t\tn++;\n\t\t\tif (Random.Int(5) == 0){\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\n\t\tif (Random.Float() < 0.3f) {\n\t\t\tlevel = -n;\n\t\t\tcursed = true;\n\t\t} else\n\t\t\tlevel = n;\n\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Item random() {\n\t\tint n = 1;\n\t\tif (Random.Int(3) == 0) {\n\t\t\tn++;\n\t\t\tif (Random.Int(5) == 0){\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\n\t\tif (Random.Float() < 0.3f) {\n\t\t\tlevel(-n);\n\t\t\tcursed = true;\n\t\t} else\n\t\t\tlevel(n);\n\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nreturn super.identify();\n\t}",
          "uniqueId": "366dce1610cd2375a4ec7f5d1115fe0eb131cb16_275_292_272_274_275_292"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "3fdd6452db525873b7cee89133f2468e5bb796f2",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/3fdd6452db525873b7cee89133f2468e5bb796f2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void destroy() {\n\t\t\n\t\tsuper.destroy();\n\t\t\n\t\tDungeon.level.mobs.remove( this );\n\t\t\n\t\tif (Dungeon.hero.isAlive()) {\n\t\t\t\n\t\t\tif (hostile) {\n\t\t\t\tStatistics.enemiesSlain++;\n\t\t\t\tBadges.validateMonstersSlain();\n\t\t\t\tStatistics.qualifiedForNoKilling = false;\n\t\t\t\t\n\t\t\t\tif (Dungeon.level.feeling == Feeling.DARK) {\n\t\t\t\t\tStatistics.nightHunt++;\n\t\t\t\t} else {\n\t\t\t\t\tStatistics.nightHunt = 0;\n\t\t\t\t}\n\t\t\t\tBadges.validateNightHunter();\n\t\t\t}\n\t\t\t\n\t\t\tif (Dungeon.hero.lvl <= maxLvl && EXP > 0) {\n\t\t\t\tDungeon.hero.sprite.showStatus( CharSprite.POSITIVE, TXT_EXP, EXP );\n\t\t\t\tDungeon.hero.earnExp( EXP );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void destroy() {\n\t\t\n\t\tsuper.destroy();\n\t\t\n\t\tDungeon.level.mobs.remove( this );\n\t\t\n\t\tif (Dungeon.hero.isAlive()) {\n\t\t\t\n\t\t\tif (hostile) {\n\t\t\t\tStatistics.enemiesSlain++;\n\t\t\t\tBadges.validateMonstersSlain();\n\t\t\t\tStatistics.qualifiedForNoKilling = false;\n\t\t\t\t\n\t\t\t\tif (Dungeon.level.feeling == Feeling.DARK) {\n\t\t\t\t\tStatistics.nightHunt++;\n\t\t\t\t} else {\n\t\t\t\t\tStatistics.nightHunt = 0;\n\t\t\t\t}\n\t\t\t\tBadges.validateNightHunter();\n\t\t\t}\n\n\t\t\tint exp = exp();\n\t\t\tif (exp > 0) {\n\t\t\t\tDungeon.hero.sprite.showStatus( CharSprite.POSITIVE, TXT_EXP, exp );\n\t\t\t\tDungeon.hero.earnExp( exp );\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic int exp() {\n\t\treturn Dungeon.hero.lvl <= maxLvl ? EXP : 0;\n\t}",
          "uniqueId": "3fdd6452db525873b7cee89133f2468e5bb796f2_410_437_440_442_410_438"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "c36f6d4bcfb4082baef0f5fc2fce4618d7518f58",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/c36f6d4bcfb4082baef0f5fc2fce4618d7518f58",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset( int from, int to, Callback callback ) {\n\t\tthis.callback = callback;\n\t\t\n\t\trevive();\n\t\t\n\t\tPointF pf = DungeonTilemap.tileCenterToWorld( from );\n\t\tPointF pt = DungeonTilemap.tileCenterToWorld( to );\n\t\t\n\t\tx = pf.x;\n\t\ty = pf.y;\n\t\twidth = 0;\n\t\theight = 0;\n\t\t\n\t\tPointF d = PointF.diff( pt, pf );\n\t\tPointF speed = new PointF( d ).normalize().scale( SPEED );\n\t\tsx = speed.x;\n\t\tsy = speed.y;\n\t\ttime = d.length() / SPEED;\n\t}",
          "sourceCodeAfterRefactoring": "public void reset( int from, int to, Callback callback ) {\n\t\treset( from, to, SPEED, callback );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void reset( int from, int to, float velocity, Callback callback ) {\n\t\tthis.callback = callback;\n\t\t\n\t\trevive();\n\t\t\n\t\tPointF pf = DungeonTilemap.tileCenterToWorld( from );\n\t\tPointF pt = DungeonTilemap.tileCenterToWorld( to );\n\t\t\n\t\tx = pf.x;\n\t\ty = pf.y;\n\t\twidth = 0;\n\t\theight = 0;\n\t\t\n\t\tPointF d = PointF.diff( pt, pf );\n\t\tPointF speed = new PointF( d ).normalize().scale( velocity );\n\t\tsx = speed.x;\n\t\tsy = speed.y;\n\t\ttime = d.length() / velocity;\n\t}",
          "uniqueId": "c36f6d4bcfb4082baef0f5fc2fce4618d7518f58_50_68_54_72_50_52"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "648246641aa30a19a048b53c0bc422ecf03afbb9",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/648246641aa30a19a048b53c0bc422ecf03afbb9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void buildFlagMaps() {\n\t\t\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tint flags = Terrain.flags[map[i]];\n\t\t\tpassable[i]\t\t= (flags & Terrain.PASSABLE) != 0;\n\t\t\tlosBlocking[i]\t= (flags & Terrain.LOS_BLOCKING) != 0;\n\t\t\tflamable[i]\t\t= (flags & Terrain.FLAMABLE) != 0;\n\t\t\tsecret[i]\t\t= (flags & Terrain.SECRET) != 0;\n\t\t\tsolid[i]\t\t= (flags & Terrain.SOLID) != 0;\n\t\t\tavoid[i]\t\t= (flags & Terrain.AVOID) != 0;\n\t\t\twater[i]\t\t= (flags & Terrain.LIQUID) != 0;\n\t\t\tpit[i]\t\t\t= (flags & Terrain.PIT) != 0;\n\t\t}\n\t\t\n\t\tint lastRow = LENGTH - WIDTH;\n\t\tfor (int i=0; i < WIDTH; i++) {\n\t\t\tpassable[i] = avoid[i] = false;\n\t\t\tpassable[lastRow + i] = avoid[lastRow + i] = false;\n\t\t}\n\t\tfor (int i=WIDTH; i < lastRow; i += WIDTH) {\n\t\t\tpassable[i] = avoid[i] = false;\n\t\t\tpassable[i + WIDTH-1] = avoid[i + WIDTH-1] = false;\n\t\t}\n\t\t \n\t\tfor (int i=WIDTH; i < LENGTH - WIDTH; i++) {\n\t\t\t\n\t\t\tif (water[i]) {\n\t\t\t\tint t = Terrain.WATER_TILES;\n\t\t\t\tfor (int j=0; j < NEIGHBOURS4.length; j++) {\n\t\t\t\t\tif ((Terrain.flags[map[i + NEIGHBOURS4[j]]] & Terrain.UNSTITCHABLE) != 0) {\n\t\t\t\t\t\tt += 1 << j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmap[i] = t;\n\t\t\t}\n\t\t\t\n\t\t\tif (pit[i]) {\n\t\t\t\tif (!pit[i - WIDTH]) {\n\t\t\t\t\tint c = map[i - WIDTH];\n\t\t\t\t\tif (c == Terrain.EMPTY_SP || c == Terrain.STATUE_SP) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_FLOOR_SP;\n\t\t\t\t\t} else if (water[i - WIDTH]) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_WATER;\n\t\t\t\t\t} else if ((Terrain.flags[c] & Terrain.UNSTITCHABLE) != 0) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_WALL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_FLOOR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void buildFlagMaps() {\n\t\t\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tint flags = Terrain.flags[map[i]];\n\t\t\tpassable[i]\t\t= (flags & Terrain.PASSABLE) != 0;\n\t\t\tlosBlocking[i]\t= (flags & Terrain.LOS_BLOCKING) != 0;\n\t\t\tflamable[i]\t\t= (flags & Terrain.FLAMABLE) != 0;\n\t\t\tsecret[i]\t\t= (flags & Terrain.SECRET) != 0;\n\t\t\tsolid[i]\t\t= (flags & Terrain.SOLID) != 0;\n\t\t\tavoid[i]\t\t= (flags & Terrain.AVOID) != 0;\n\t\t\twater[i]\t\t= (flags & Terrain.LIQUID) != 0;\n\t\t\tpit[i]\t\t\t= (flags & Terrain.PIT) != 0;\n\t\t}\n\t\t\n\t\tint lastRow = LENGTH - WIDTH;\n\t\tfor (int i=0; i < WIDTH; i++) {\n\t\t\tpassable[i] = avoid[i] = false;\n\t\t\tpassable[lastRow + i] = avoid[lastRow + i] = false;\n\t\t}\n\t\tfor (int i=WIDTH; i < lastRow; i += WIDTH) {\n\t\t\tpassable[i] = avoid[i] = false;\n\t\t\tpassable[i + WIDTH-1] = avoid[i + WIDTH-1] = false;\n\t\t}\n\t\t \n\t\tfor (int i=WIDTH; i < LENGTH - WIDTH; i++) {\n\t\t\t\n\t\t\tif (water[i]) {\n\t\t\t\tmap[i] = getWaterTile( i );\n\t\t\t}\n\t\t\t\n\t\t\tif (pit[i]) {\n\t\t\t\tif (!pit[i - WIDTH]) {\n\t\t\t\t\tint c = map[i - WIDTH];\n\t\t\t\t\tif (c == Terrain.EMPTY_SP || c == Terrain.STATUE_SP) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_FLOOR_SP;\n\t\t\t\t\t} else if (water[i - WIDTH]) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_WATER;\n\t\t\t\t\t} else if ((Terrain.flags[c] & Terrain.UNSTITCHABLE) != 0) {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_WALL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i] = Terrain.CHASM_FLOOR;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int getWaterTile( int pos ) {\n\t\tint t = Terrain.WATER_TILES;\n\t\tfor (int j=0; j < NEIGHBOURS4.length; j++) {\n\t\t\tif ((Terrain.flags[map[pos + NEIGHBOURS4[j]]] & Terrain.UNSTITCHABLE) != 0) {\n\t\t\t\tt += 1 << j;\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}",
          "uniqueId": "648246641aa30a19a048b53c0bc422ecf03afbb9_591_642_638_646_591_636"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals(scene);\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tif (map[i] == Terrain.WALL_DECO) {\n\t\t\t\tscene.add( new Torch( i ) );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals() {\n\t\tsuper.addVisuals();\n\t\taddPrisonVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void addPrisonVisuals(Level level, Group group){\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tif (level.map[i] == Terrain.WALL_DECO) {\n\t\t\t\tgroup.add( new Torch( i ) );\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_158_166_165_171_158_163"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals(scene);\n\t\t//kill old torches before adding new ones\n\t\tfor (PrisonLevel.Torch t : torches.toArray(new PrisonLevel.Torch[torches.size()])){\n\t\t\tt.kill();\n\t\t\ttorches.remove(t);\n\t\t}\n\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tif (map[i] == Terrain.WALL_DECO) {\n\t\t\t\tPrisonLevel.Torch t = new PrisonLevel.Torch( i );\n\t\t\t\ttorches.add(t);\n\t\t\t\tscene.add( t );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals() {\n\t\tsuper.addVisuals();\n\t\tPrisonLevel.addPrisonVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nentrance = i;\n\t\t\telse if (map[i] == Terrain.EXIT)\n\t\t\t\texit = i;\n\n\t\tvisited = mapped = new boolean[LENGTH];\n\t\taddVisuals(); //this also resets existing visuals",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_344_360_237_242_341_346"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals( scene );\n\t\tHallsLevel.addVisuals( this, scene );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals () {\n\t\tsuper.addVisuals();\n\t\tHallsLevel.addHallsVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_171_175_266_271_171_176"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals( scene );\n\t\tCityLevel.addVisuals( this, scene );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals( ) {\n\t\tsuper.addVisuals();\n\t\tCityLevel.addCityVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_221_225_266_271_221_226"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals(scene);\n\t\t//kill old torches before adding new ones\n\t\tfor (PrisonLevel.Torch t : torches.toArray(new PrisonLevel.Torch[torches.size()])){\n\t\t\tt.kill();\n\t\t\ttorches.remove(t);\n\t\t}\n\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tif (map[i] == Terrain.WALL_DECO) {\n\t\t\t\tPrisonLevel.Torch t = new PrisonLevel.Torch( i );\n\t\t\t\ttorches.add(t);\n\t\t\t\tscene.add( t );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals() {\n\t\tsuper.addVisuals();\n\t\tPrisonLevel.addPrisonVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void createItems() {\n\t\tdrop(new IronKey(10), randomPrisonCell());\n\t}\n\n\tprivate int randomPrisonCell(){\n\t\tint pos = 1+8*32; //initial position at top-left room",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_344_360_144_149_341_346"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void addVisuals( Scene scene ) {\n\t\tsuper.addVisuals(scene);\n\t\t//kill old torches before adding new ones\n\t\tfor (PrisonLevel.Torch t : torches.toArray(new PrisonLevel.Torch[torches.size()])){\n\t\t\tt.kill();\n\t\t\ttorches.remove(t);\n\t\t}\n\n\t\tfor (int i=0; i < LENGTH; i++) {\n\t\t\tif (map[i] == Terrain.WALL_DECO) {\n\t\t\t\tPrisonLevel.Torch t = new PrisonLevel.Torch( i );\n\t\t\t\ttorches.add(t);\n\t\t\t\tscene.add( t );\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Group addVisuals() {\n\t\tsuper.addVisuals();\n\t\tPrisonLevel.addPrisonVisuals(this, visuals);\n\t\treturn visuals;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nif (ch == Dungeon.hero){\n\t\t\t//hero enters tengu's chamber\n\t\t\tif (state == State.START\n\t\t\t\t\t&& ((Room)new Room().set(2, 25, 8, 32)).inside(cell)){\n\t\t\t\tprogress();\n\t\t\t}",
          "uniqueId": "e2a57a0e31abfe0acee4ca0a6aa6f055b3353cd3_344_360_165_171_341_346"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "31c53c33d5704a5a004258e8c0964fbdba3f7d90",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/31c53c33d5704a5a004258e8c0964fbdba3f7d90",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void createItems() {\n\t\tint keyPos = 1+8*32; //initial position at top-left room\n\n\t\t//randomly assign a room.\n\t\tkeyPos += Random.Int(4)*(4*32); //one of the 4 rows\n\t\tkeyPos += Random.Int(2)*6; // one of the 2 columns\n\n\t\t//and then a certain tile in that room.\n\t\tkeyPos += Random.Int(3) + Random.Int(3)*32;\n\n\t\tdrop(new IronKey(10), keyPos);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void createItems() {\n\t\tdrop(new IronKey(10), randomPrisonCell());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate int randomPrisonCell(){\n\t\tint pos = 1+8*32; //initial position at top-left room\n\n\t\t//randomly assign a room.\n\t\tpos += Random.Int(4)*(4*32); //one of the 4 rows\n\t\tpos += Random.Int(2)*6; // one of the 2 columns\n\n\t\t//and then a certain tile in that room.\n\t\tpos += Random.Int(3) + Random.Int(3)*32;\n\n\t\treturn pos;\n\t}",
          "uniqueId": "31c53c33d5704a5a004258e8c0964fbdba3f7d90_136_148_151_162_146_149"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "81341c93d0875e8fce568e2728bfd0b93fafa09c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/81341c93d0875e8fce568e2728bfd0b93fafa09c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Tool( int x, int y, int width, int height ) {\n\t\t\tsuper();\n\t\t\t\n\t\t\tbase.frame( x, y, width, height );\n\t\t\t\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}",
          "sourceCodeAfterRefactoring": "public Tool( int x, int y, int width, int height ) {\n\t\t\tsuper();\n\t\t\t\n\t\t\tframe(x, y, width, height);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void frame( int x, int y, int width, int height) {\n\t\t\tbase.frame( x, y, width, height );\n\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\t\t}",
          "uniqueId": "81341c93d0875e8fce568e2728bfd0b93fafa09c_318_325_353_358_347_351"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "0416e7f16741628864aa920a00a04eb7c0ea247f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/0416e7f16741628864aa920a00a04eb7c0ea247f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void createChildren() {\n\t\tsuper.createChildren();\n\t\t\n\t\tslot = new ItemSlot() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tif (targeting) {\n\t\t\t\t\t//first try to directly target\n\t\t\t\t\tif (new Ballistica(Dungeon.hero.pos, lastTarget.pos, Ballistica.PROJECTILE).collisionPos == lastTarget.pos) {\n\t\t\t\t\t\tGameScene.handleCell(lastTarget.pos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Otherwise pick nearby tiles to try and 'angle' the shot, auto-aim basically.\n\t\t\t\t\tfor (int i : Level.NEIGHBOURS9DIST2) {\n\t\t\t\t\t\tif (new Ballistica(Dungeon.hero.pos, lastTarget.pos+i, Ballistica.PROJECTILE).collisionPos == lastTarget.pos){\n\t\t\t\t\t\t\tGameScene.handleCell( lastTarget.pos+i );\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//couldn't find anything, just have it directly target\n\t\t\t\t\tGameScene.handleCell( lastTarget.pos );\n\t\t\t\t} else {\n\t\t\t\t\tItem item = select(slotNum);\n\t\t\t\t\t//FIXME: sloppy, should have a better way to decide if an item uses targeting.\n\t\t\t\t\tif (item instanceof EquipableItem || item instanceof Wand)\n\t\t\t\t\t\tuseTargeting();\n\t\t\t\t\titem.execute( Dungeon.hero );\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected boolean onLongClick() {\n\t\t\t\treturn QuickSlotButton.this.onLongClick();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onTouchDown() {\n\t\t\t\ticon.lightness( 0.7f );\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onTouchUp() {\n\t\t\t\ticon.resetColor();\n\t\t\t}\n\t\t};\n\t\tslot.showParams( true, false, true );\n\t\tadd( slot );\n\t\t\n\t\tcrossB = Icons.TARGET.get();\n\t\tcrossB.visible = false;\n\t\tadd( crossB );\n\t\t\n\t\tcrossM = new Image();\n\t\tcrossM.copy( crossB );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void createChildren() {\n\t\tsuper.createChildren();\n\t\t\n\t\tslot = new ItemSlot() {\n\t\t\t@Override\n\t\t\tprotected void onClick() {\n\t\t\t\tif (targeting) {\n\t\t\t\t\tint cell = autoAim(lastTarget);\n\n\t\t\t\t\tif (cell != -1){\n\t\t\t\t\t\tGameScene.handleCell(cell);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//couldn't auto-aim, just target the position and hope for the best.\n\t\t\t\t\t\tGameScene.handleCell( lastTarget.pos );\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tItem item = select(slotNum);\n\t\t\t\t\tif (item.usesTargeting)\n\t\t\t\t\t\tuseTargeting();\n\t\t\t\t\titem.execute( Dungeon.hero );\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected boolean onLongClick() {\n\t\t\t\treturn QuickSlotButton.this.onLongClick();\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onTouchDown() {\n\t\t\t\ticon.lightness( 0.7f );\n\t\t\t}\n\t\t\t@Override\n\t\t\tprotected void onTouchUp() {\n\t\t\t\ticon.resetColor();\n\t\t\t}\n\t\t};\n\t\tslot.showParams( true, false, true );\n\t\tadd( slot );\n\t\t\n\t\tcrossB = Icons.TARGET.get();\n\t\tcrossB.visible = false;\n\t\tadd( crossB );\n\t\t\n\t\tcrossM = new Image();\n\t\tcrossM.copy( crossB );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int autoAim(Char target){\n\t\t//first try to directly target\n\t\tif (new Ballistica(Dungeon.hero.pos, target.pos, Ballistica.PROJECTILE).collisionPos == lastTarget.pos) {\n\t\t\treturn target.pos;\n\t\t}\n\n\t\t//Otherwise pick nearby tiles to try and 'angle' the shot, auto-aim basically.\n\t\tfor (int i : Level.NEIGHBOURS9DIST2) {\n\t\t\tif (new Ballistica(Dungeon.hero.pos, lastTarget.pos+i, Ballistica.PROJECTILE).collisionPos == lastTarget.pos){\n\t\t\t\treturn target.pos+i;\n\t\t\t}\n\t\t}\n\n\t\t//couldn't find a cell, give up.\n\t\treturn -1;\n\t}",
          "uniqueId": "0416e7f16741628864aa920a00a04eb7c0ea247f_74_128_189_204_74_119"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/85a907d14ea5eb1a9a25c8bf9facd2f64e143b70",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void press( int cell, Char ch ) {\n\n\t\tif (ch != null && pit[cell] && !ch.flying) {\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tChasm.heroFall(cell);\n\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tTimekeepersHourglass.timeFreeze timeFreeze = null;\n\n\t\tif (ch != null)\n\t\t\ttimeFreeze = ch.buff(TimekeepersHourglass.timeFreeze.class);\n\n\t\tboolean frozen = timeFreeze != null;\n\t\t\n\t\tboolean trap = false;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TOXIC_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.TOXIC_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new ToxicTrap().set(cell).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_FIRE_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.FIRE_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new FireTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_PARALYTIC_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.PARALYTIC_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new ParalyticTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_POISON_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.POISON_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new PoisonTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_ALARM_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.ALARM_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new AlarmTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_LIGHTNING_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.LIGHTNING_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new LightningTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_GRIPPING_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.GRIPPING_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new GrippingTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.SECRET_SUMMONING_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.SUMMONING_TRAP:\n\t\t\ttrap = true;\n\t\t\tif (!frozen) new SummoningTrap().set( cell ).activate();\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\t\tHighGrass.trample( this, cell, ch );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.ALCHEMY:\n\t\t\tif (ch == null) {\n\t\t\t\tAlchemy.transmute( cell );\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (trap && !frozen) {\n\n\t\t\tif (Dungeon.visible[cell])\n\t\t\t\tSample.INSTANCE.play( Assets.SND_TRAP );\n\n\t\t\tif (ch == Dungeon.hero)\n\t\t\t\tDungeon.hero.interrupt();\n\n\t\t\tset( cell, Terrain.INACTIVE_TRAP );\n\t\t\tGameScene.updateMap( cell );\n\n\t\t} else if (trap && frozen){\n\n\t\t\tSample.INSTANCE.play( Assets.SND_TRAP );\n\n\t\t\tLevel.set( cell, Terrain.discover( map[cell] ) );\n\t\t\tGameScene.updateMap( cell );\n\n\t\t\ttimeFreeze.setDelayedPress( cell );\n\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.activate( ch );\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void press( int cell, Char ch ) {\n\n\t\tif (ch != null && pit[cell] && !ch.flying) {\n\t\t\tif (ch == Dungeon.hero) {\n\t\t\t\tChasm.heroFall(cell);\n\t\t\t} else if (ch instanceof Mob) {\n\t\t\t\tChasm.mobFall( (Mob)ch );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tTimekeepersHourglass.timeFreeze timeFreeze = null;\n\n\t\tif (ch != null)\n\t\t\ttimeFreeze = ch.buff(TimekeepersHourglass.timeFreeze.class);\n\n\t\tboolean frozen = timeFreeze != null;\n\t\t\n\t\tTrap trap = null;\n\t\t\n\t\tswitch (map[cell]) {\n\t\t\n\t\tcase Terrain.SECRET_TRAP:\n\t\t\tGLog.i( TXT_HIDDEN_PLATE_CLICKS );\n\t\tcase Terrain.TRAP:\n\t\t\ttrap = traps.get( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.HIGH_GRASS:\n\t\t\tHighGrass.trample( this, cell, ch );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.WELL:\n\t\t\tWellWater.affectCell( cell );\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.ALCHEMY:\n\t\t\tif (ch == null) {\n\t\t\t\tAlchemy.transmute( cell );\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Terrain.DOOR:\n\t\t\tDoor.enter( cell );\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (trap != null && !frozen) {\n\n\t\t\tif (ch == Dungeon.hero)\n\t\t\t\tDungeon.hero.interrupt();\n\n\t\t\ttrap.trigger();\n\n\t\t} else if (trap != null && frozen){\n\n\t\t\tSample.INSTANCE.play(Assets.SND_TRAP);\n\n\t\t\tdiscover(cell);\n\n\t\t\ttimeFreeze.setDelayedPress( cell );\n\n\t\t}\n\t\t\n\t\tPlant plant = plants.get( cell );\n\t\tif (plant != null) {\n\t\t\tplant.activate( ch );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void discover( int cell ) {\n\t\tset( cell, Terrain.discover( map[cell] ) );\n\t\tTrap trap = traps.get( cell );\n\t\tif (trap != null)\n\t\t\ttrap.reveal();\n\t\tGameScene.updateMap( cell );\n\t}",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_708_831_744_750_756_824"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean affectHero( Hero hero ) {\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_DRINK );\n\t\temitter.parent.add( new Identification( DungeonTilemap.tileCenterToWorld( pos ) ) );\n\t\t\n\t\thero.belongings.observe();\n\t\t\n\t\tfor (int i=0; i < Level.LENGTH; i++) {\n\t\t\t\n\t\t\tint terr = Dungeon.level.map[i];\n\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\n\t\t\t\tLevel.set( i, Terrain.discover( terr ) );\t\t\t\t\t\t\n\t\t\t\tGameScene.updateMap( i );\n\t\t\t\t\n\t\t\t\tif (Dungeon.visible[i]) {\n\t\t\t\t\tGameScene.discoverTile( i, terr );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tBuff.affect( hero, Awareness.class, Awareness.DURATION );\n\t\tDungeon.observe();\n\n\t\tDungeon.hero.interrupt();\n\t\n\t\tGLog.p( TXT_PROCCED );\n\t\t\n\t\tJournal.remove( Feature.WELL_OF_AWARENESS );\n\t\t\n\t\treturn true;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean affectHero( Hero hero ) {\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_DRINK );\n\t\temitter.parent.add( new Identification( DungeonTilemap.tileCenterToWorld( pos ) ) );\n\t\t\n\t\thero.belongings.observe();\n\t\t\n\t\tfor (int i=0; i < Level.LENGTH; i++) {\n\t\t\t\n\t\t\tint terr = Dungeon.level.map[i];\n\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\n\t\t\t\tDungeon.level.discover( i );\n\t\t\t\t\n\t\t\t\tif (Dungeon.visible[i]) {\n\t\t\t\t\tGameScene.discoverTile( i, terr );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tBuff.affect( hero, Awareness.class, Awareness.DURATION );\n\t\tDungeon.observe();\n\n\t\tDungeon.hero.interrupt();\n\t\n\t\tGLog.p( TXT_PROCCED );\n\t\t\n\t\tJournal.remove( Feature.WELL_OF_AWARENESS );\n\t\t\n\t\treturn true;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_46_78_744_750_46_77"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static void reallyDie( Object cause ) {\n\t\t\n\t\tint length = Level.LENGTH;\n\t\tint[] map = Dungeon.level.map;\n\t\tboolean[] visited = Dungeon.level.visited;\n\t\tboolean[] discoverable = Level.discoverable;\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\t\n\t\t\tint terr = map[i];\n\t\t\t\n\t\t\tif (discoverable[i]) {\n\t\t\t\t\n\t\t\t\tvisited[i] = true;\n\t\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\tLevel.set( i, Terrain.discover( terr ) );\t\t\t\t\t\t\n\t\t\t\t\tGameScene.updateMap( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tBones.leave();\n\t\t\n\t\tDungeon.observe();\n\t\t\t\t\n\t\tDungeon.hero.belongings.identify();\n\n\t\tint pos = Dungeon.hero.pos;\n\n\t\tArrayList<Integer> passable = new ArrayList<Integer>();\n\t\tfor (Integer ofs : Level.NEIGHBOURS8) {\n\t\t\tint cell = pos + ofs;\n\t\t\tif ((Level.passable[cell] || Level.avoid[cell]) && Dungeon.level.heaps.get( cell ) == null) {\n\t\t\t\tpassable.add( cell );\n\t\t\t}\n\t\t}\n\t\tCollections.shuffle( passable );\n\n\t\tArrayList<Item> items = new ArrayList<Item>( Dungeon.hero.belongings.backpack.items );\n\t\tfor (Integer cell : passable) {\n\t\t\tif (items.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tItem item = Random.element( items );\n\t\t\tDungeon.level.drop( item, cell ).sprite.drop( pos );\n\t\t\titems.remove( item );\n\t\t}\n\n\t\tGameScene.gameOver();\n\t\t\n\t\tif (cause instanceof Hero.Doom) {\n\t\t\t((Hero.Doom)cause).onDeath();\n\t\t}\n\t\t\n\t\tDungeon.deleteGame( Dungeon.hero.heroClass, true );\n\t}",
          "sourceCodeAfterRefactoring": "public static void reallyDie( Object cause ) {\n\t\t\n\t\tint length = Level.LENGTH;\n\t\tint[] map = Dungeon.level.map;\n\t\tboolean[] visited = Dungeon.level.visited;\n\t\tboolean[] discoverable = Level.discoverable;\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\t\n\t\t\tint terr = map[i];\n\t\t\t\n\t\t\tif (discoverable[i]) {\n\t\t\t\t\n\t\t\t\tvisited[i] = true;\n\t\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\tDungeon.level.discover( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tBones.leave();\n\t\t\n\t\tDungeon.observe();\n\t\t\t\t\n\t\tDungeon.hero.belongings.identify();\n\n\t\tint pos = Dungeon.hero.pos;\n\n\t\tArrayList<Integer> passable = new ArrayList<Integer>();\n\t\tfor (Integer ofs : Level.NEIGHBOURS8) {\n\t\t\tint cell = pos + ofs;\n\t\t\tif ((Level.passable[cell] || Level.avoid[cell]) && Dungeon.level.heaps.get( cell ) == null) {\n\t\t\t\tpassable.add( cell );\n\t\t\t}\n\t\t}\n\t\tCollections.shuffle( passable );\n\n\t\tArrayList<Item> items = new ArrayList<Item>( Dungeon.hero.belongings.backpack.items );\n\t\tfor (Integer cell : passable) {\n\t\t\tif (items.isEmpty()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tItem item = Random.element( items );\n\t\t\tDungeon.level.drop( item, cell ).sprite.drop( pos );\n\t\t\titems.remove( item );\n\t\t}\n\n\t\tGameScene.gameOver();\n\t\t\n\t\tif (cause instanceof Hero.Doom) {\n\t\t\t((Hero.Doom)cause).onDeath();\n\t\t}\n\t\t\n\t\tDungeon.deleteGame( Dungeon.hero.heroClass, true );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n} else if (getCloser( doorCell )) {\n\n            return true;\n\n        } else {\n            ready();\n            return false;",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_1271_1327_744_750_1271_1326"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public boolean search( boolean intentional ) {\n\t\t\n\t\tboolean smthFound = false;\n\n\t\tint positive = 0;\n\t\tint negative = 0;\n\n\t\tint distance = 1 + positive + negative;\n\n\t\tfloat level = intentional ? (2 * awareness - awareness * awareness) : awareness;\n\t\tif (distance <= 0) {\n\t\t\tlevel /= 2 - distance;\n\t\t\tdistance = 1;\n\t\t}\n\t\t\n\t\tint cx = pos % Level.WIDTH;\n\t\tint cy = pos / Level.WIDTH;\n\t\tint ax = cx - distance;\n\t\tif (ax < 0) {\n\t\t\tax = 0;\n\t\t}\n\t\tint bx = cx + distance;\n\t\tif (bx >= Level.WIDTH) {\n\t\t\tbx = Level.WIDTH - 1;\n\t\t}\n\t\tint ay = cy - distance;\n\t\tif (ay < 0) {\n\t\t\tay = 0;\n\t\t}\n\t\tint by = cy + distance;\n\t\tif (by >= Level.HEIGHT) {\n\t\t\tby = Level.HEIGHT - 1;\n\t\t}\n\n        TalismanOfForesight.Foresight foresight = buff( TalismanOfForesight.Foresight.class );\n\n\t\t//cursed talisman of foresight makes unintentionally finding things impossible.\n\t\tif (foresight != null && foresight.isCursed()){\n\t\t\tlevel = -1;\n\t\t}\n\t\t\n\t\tfor (int y = ay; y <= by; y++) {\n\t\t\tfor (int x = ax, p = ax + y * Level.WIDTH; x <= bx; x++, p++) {\n\t\t\t\t\n\t\t\t\tif (Dungeon.visible[p]) {\n\t\t\t\t\t\n\t\t\t\t\tif (intentional) {\n\t\t\t\t\t\tsprite.parent.addToBack( new CheckedCell( p ) );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (Level.secret[p] && (intentional || Random.Float() < level)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint oldValue = Dungeon.level.map[p];\n\t\t\t\t\t\t\n\t\t\t\t\t\tGameScene.discoverTile( p, oldValue );\n\t\t\t\t\t\t\n\t\t\t\t\t\tLevel.set( p, Terrain.discover( oldValue ) );\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tGameScene.updateMap( p );\n\t\t\t\t\t\t\n\t\t\t\t\t\tScrollOfMagicMapping.discover( p );\n\t\t\t\t\t\t\n\t\t\t\t\t\tsmthFound = true;\n\n                        if (foresight != null && !foresight.isCursed())\n                            foresight.charge();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (intentional) {\n\t\t\tsprite.showStatus( CharSprite.DEFAULT, TXT_SEARCH );\n\t\t\tsprite.operate( pos );\n\t\t\tif (foresight != null && foresight.isCursed()){\n\t\t\t\tGLog.n(\"You can't concentrate, searching takes a while.\");\n\t\t\t\tspendAndNext(TIME_TO_SEARCH * 3);\n\t\t\t} else {\n\t\t\t\tspendAndNext(TIME_TO_SEARCH);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (smthFound) {\n\t\t\tGLog.w( TXT_NOTICED_SMTH );\n\t\t\tSample.INSTANCE.play( Assets.SND_SECRET );\n\t\t\tinterrupt();\n\t\t}\n\t\t\n\t\treturn smthFound;\n\t}",
          "sourceCodeAfterRefactoring": "public boolean search( boolean intentional ) {\n\t\t\n\t\tboolean smthFound = false;\n\n\t\tint positive = 0;\n\t\tint negative = 0;\n\n\t\tint distance = 1 + positive + negative;\n\n\t\tfloat level = intentional ? (2 * awareness - awareness * awareness) : awareness;\n\t\tif (distance <= 0) {\n\t\t\tlevel /= 2 - distance;\n\t\t\tdistance = 1;\n\t\t}\n\t\t\n\t\tint cx = pos % Level.WIDTH;\n\t\tint cy = pos / Level.WIDTH;\n\t\tint ax = cx - distance;\n\t\tif (ax < 0) {\n\t\t\tax = 0;\n\t\t}\n\t\tint bx = cx + distance;\n\t\tif (bx >= Level.WIDTH) {\n\t\t\tbx = Level.WIDTH - 1;\n\t\t}\n\t\tint ay = cy - distance;\n\t\tif (ay < 0) {\n\t\t\tay = 0;\n\t\t}\n\t\tint by = cy + distance;\n\t\tif (by >= Level.HEIGHT) {\n\t\t\tby = Level.HEIGHT - 1;\n\t\t}\n\n        TalismanOfForesight.Foresight foresight = buff( TalismanOfForesight.Foresight.class );\n\n\t\t//cursed talisman of foresight makes unintentionally finding things impossible.\n\t\tif (foresight != null && foresight.isCursed()){\n\t\t\tlevel = -1;\n\t\t}\n\t\t\n\t\tfor (int y = ay; y <= by; y++) {\n\t\t\tfor (int x = ax, p = ax + y * Level.WIDTH; x <= bx; x++, p++) {\n\t\t\t\t\n\t\t\t\tif (Dungeon.visible[p]) {\n\t\t\t\t\t\n\t\t\t\t\tif (intentional) {\n\t\t\t\t\t\tsprite.parent.addToBack( new CheckedCell( p ) );\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (Level.secret[p] && (intentional || Random.Float() < level)) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint oldValue = Dungeon.level.map[p];\n\t\t\t\t\t\t\n\t\t\t\t\t\tGameScene.discoverTile( p, oldValue );\n\t\t\t\t\t\t\n\t\t\t\t\t\tDungeon.level.discover( p );\n\t\t\t\t\t\t\n\t\t\t\t\t\tScrollOfMagicMapping.discover( p );\n\t\t\t\t\t\t\n\t\t\t\t\t\tsmthFound = true;\n\n                        if (foresight != null && !foresight.isCursed())\n                            foresight.charge();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (intentional) {\n\t\t\tsprite.showStatus( CharSprite.DEFAULT, TXT_SEARCH );\n\t\t\tsprite.operate( pos );\n\t\t\tif (foresight != null && foresight.isCursed()){\n\t\t\t\tGLog.n(\"You can't concentrate, searching takes a while.\");\n\t\t\t\tspendAndNext(TIME_TO_SEARCH * 3);\n\t\t\t} else {\n\t\t\t\tspendAndNext(TIME_TO_SEARCH);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tif (smthFound) {\n\t\t\tGLog.w( TXT_NOTICED_SMTH );\n\t\t\tSample.INSTANCE.play( Assets.SND_SECRET );\n\t\t\tinterrupt();\n\t\t}\n\t\t\n\t\treturn smthFound;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n} else if (getCloser( doorCell )) {\n\n            return true;\n\n        } else {\n            ready();\n            return false;",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_1399_1490_744_750_1398_1487"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void doRead() {\n\t\t\n\t\tint length = Level.LENGTH;\n\t\tint[] map = Dungeon.level.map;\n\t\tboolean[] mapped = Dungeon.level.mapped;\n\t\tboolean[] discoverable = Level.discoverable;\n\t\t\n\t\tboolean noticed = false;\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\t\n\t\t\tint terr = map[i];\n\t\t\t\n\t\t\tif (discoverable[i]) {\n\t\t\t\t\n\t\t\t\tmapped[i] = true;\n\t\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\t\n\t\t\t\t\tLevel.set( i, Terrain.discover( terr ) );\t\t\t\t\t\t\n\t\t\t\t\tGameScene.updateMap( i );\n\t\t\t\t\t\n\t\t\t\t\tif (Dungeon.visible[i]) {\n\t\t\t\t\t\tGameScene.discoverTile( i, terr );\n\t\t\t\t\t\tdiscover( i );\n\t\t\t\t\t\t\n\t\t\t\t\t\tnoticed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDungeon.observe();\n\t\t\n\t\tGLog.i( TXT_LAYOUT );\n\t\tif (noticed) {\n\t\t\tSample.INSTANCE.play( Assets.SND_SECRET );\n\t\t}\n\t\t\n\t\tSpellSprite.show( curUser, SpellSprite.MAP );\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\t\t\n\t\tsetKnown();\n\t\t\n\t\tcurUser.spendAndNext( TIME_TO_READ );\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void doRead() {\n\t\t\n\t\tint length = Level.LENGTH;\n\t\tint[] map = Dungeon.level.map;\n\t\tboolean[] mapped = Dungeon.level.mapped;\n\t\tboolean[] discoverable = Level.discoverable;\n\t\t\n\t\tboolean noticed = false;\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\t\n\t\t\tint terr = map[i];\n\t\t\t\n\t\t\tif (discoverable[i]) {\n\t\t\t\t\n\t\t\t\tmapped[i] = true;\n\t\t\t\tif ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\t\t\t\t\t\n\t\t\t\t\tDungeon.level.discover( i );\n\t\t\t\t\t\n\t\t\t\t\tif (Dungeon.visible[i]) {\n\t\t\t\t\t\tGameScene.discoverTile( i, terr );\n\t\t\t\t\t\tdiscover( i );\n\t\t\t\t\t\t\n\t\t\t\t\t\tnoticed = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDungeon.observe();\n\t\t\n\t\tGLog.i( TXT_LAYOUT );\n\t\tif (noticed) {\n\t\t\tSample.INSTANCE.play( Assets.SND_SECRET );\n\t\t}\n\t\t\n\t\tSpellSprite.show( curUser, SpellSprite.MAP );\n\t\tSample.INSTANCE.play( Assets.SND_READ );\n\t\tInvisibility.dispel();\n\t\t\n\t\tsetKnown();\n\t\t\n\t\tcurUser.spendAndNext( TIME_TO_READ );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_41_86_744_750_41_85"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void affectMap(Ballistica beam){\n        boolean noticed = false;\n        for (int c: beam.subPath(0, beam.dist)){\n            for (int n : Level.NEIGHBOURS9DIST2){\n                int cell = c+n;\n                if (!Level.insideMap(cell))\n                    continue;\n\n                if (Level.discoverable[cell])\n                    Dungeon.level.mapped[cell] = true;\n\n                int terr = Dungeon.level.map[cell];\n                if ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\n                    Level.set( cell, Terrain.discover( terr ) );\n                    GameScene.updateMap(cell);\n\n                    GameScene.discoverTile( cell, terr );\n                    ScrollOfMagicMapping.discover(cell);\n\n                    noticed = true;\n                }\n            }\n\n            CellEmitter.center(c).burst( RainbowParticle.BURST, Random.IntRange( 1, 2 ) );\n        }\n        if (noticed)\n            Sample.INSTANCE.play( Assets.SND_SECRET );\n\n        Dungeon.observe();\n    }",
          "sourceCodeAfterRefactoring": "private void affectMap(Ballistica beam){\n        boolean noticed = false;\n        for (int c: beam.subPath(0, beam.dist)){\n            for (int n : Level.NEIGHBOURS9DIST2){\n                int cell = c+n;\n                if (!Level.insideMap(cell))\n                    continue;\n\n                if (Level.discoverable[cell])\n                    Dungeon.level.mapped[cell] = true;\n\n                int terr = Dungeon.level.map[cell];\n                if ((Terrain.flags[terr] & Terrain.SECRET) != 0) {\n\n                    Dungeon.level.discover( cell );\n\n                    GameScene.discoverTile( cell, terr );\n                    ScrollOfMagicMapping.discover(cell);\n\n                    noticed = true;\n                }\n            }\n\n            CellEmitter.center(c).burst( RainbowParticle.BURST, Random.IntRange( 1, 2 ) );\n        }\n        if (noticed)\n            Sample.INSTANCE.play( Assets.SND_SECRET );\n\n        Dungeon.observe();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "85a907d14ea5eb1a9a25c8bf9facd2f64e143b70_98_128_744_750_98_127"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4b680c93add3a67245130e6102a71837cd3528cc",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4b680c93add3a67245130e6102a71837cd3528cc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Lightning( int[] cells, int length, Callback callback ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tthis.callback = callback;\n\t\t\n\t\tImage proto = Effects.get( Effects.Type.LIGHTNING );\n\t\tfloat ox = 0;\n\t\tfloat oy = proto.height / 2;\n\t\t\n\t\tthis.length = length;\n\t\tcx = new float[length];\n\t\tcy = new float[length];\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\tint c = cells[i];\n\t\t\tcx[i] = (c % Level.WIDTH + 0.5f) * DungeonTilemap.SIZE;\n\t\t\tcy[i] = (c / Level.WIDTH + 0.5f) * DungeonTilemap.SIZE;\n\t\t}\n\t\t\n\t\tarcsS = new Image[length - 1];\n\t\tarcsE = new Image[length - 1];\n\t\tfor (int i=0; i < length - 1; i++) {\n\t\t\t\n\t\t\tImage arc = arcsS[i] = new Image( proto );\n\t\t\t\n\t\t\tarc.x = cx[i] - arc.origin.x;\n\t\t\tarc.y = cy[i] - arc.origin.y;\n\t\t\tarc.origin.set( ox, oy );\n\t\t\tadd( arc );\n\t\t\t\n\t\t\tarc = arcsE[i] = new Image( proto );\n\t\t\tarc.origin.set( ox, oy );\n\t\t\tadd( arc );\n\t\t}\n\t\t\n\t\tlife = DURATION;\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_LIGHTNING );\n\t}",
          "sourceCodeAfterRefactoring": "public Lightning(int from, int to, Callback callback){\n\t\tthis(Arrays.asList(new Arc(from, to)), callback);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Lightning( List<Arc> arcs, Callback callback ) {\n\t\t\n\t\tsuper();\n\n\t\tthis.arcs = arcs;\n\t\tfor (Arc arc : this.arcs)\n\t\t\tadd(arc);\n\n\t\tthis.callback = callback;\n\t\t\n\t\tlife = DURATION;\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_LIGHTNING );\n\t}",
          "uniqueId": "4b680c93add3a67245130e6102a71837cd3528cc_49_88_51_64_47_49"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public Lightning( int[] cells, int length, Callback callback ) {\n\t\t\n\t\tsuper();\n\t\t\n\t\tthis.callback = callback;\n\t\t\n\t\tImage proto = Effects.get( Effects.Type.LIGHTNING );\n\t\tfloat ox = 0;\n\t\tfloat oy = proto.height / 2;\n\t\t\n\t\tthis.length = length;\n\t\tcx = new float[length];\n\t\tcy = new float[length];\n\t\t\n\t\tfor (int i=0; i < length; i++) {\n\t\t\tint c = cells[i];\n\t\t\tcx[i] = (c % Level.WIDTH + 0.5f) * DungeonTilemap.SIZE;\n\t\t\tcy[i] = (c / Level.WIDTH + 0.5f) * DungeonTilemap.SIZE;\n\t\t}\n\t\t\n\t\tarcsS = new Image[length - 1];\n\t\tarcsE = new Image[length - 1];\n\t\tfor (int i=0; i < length - 1; i++) {\n\t\t\t\n\t\t\tImage arc = arcsS[i] = new Image( proto );\n\t\t\t\n\t\t\tarc.x = cx[i] - arc.origin.x;\n\t\t\tarc.y = cy[i] - arc.origin.y;\n\t\t\tarc.origin.set( ox, oy );\n\t\t\tadd( arc );\n\t\t\t\n\t\t\tarc = arcsE[i] = new Image( proto );\n\t\t\tarc.origin.set( ox, oy );\n\t\t\tadd( arc );\n\t\t}\n\t\t\n\t\tlife = DURATION;\n\t\t\n\t\tSample.INSTANCE.play( Assets.SND_LIGHTNING );\n\t}",
          "sourceCodeAfterRefactoring": "public Lightning(int from, int to, Callback callback){\n\t\tthis(Arrays.asList(new Arc(from, to)), callback);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void alpha(float alpha) {\n\t\t\tarc1.am = arc2.am = alpha;\n\t\t}",
          "uniqueId": "4b680c93add3a67245130e6102a71837cd3528cc_49_88_121_123_47_49"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f844ee05d41d4d6f8534e8bccb051f7df516b14c",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f844ee05d41d4d6f8534e8bccb051f7df516b14c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void satisfy( float energy ) {\n\t\tArtifact.ArtifactBuff buff = target.buff( HornOfPlenty.hornRecharge.class );\n\t\tif (buff != null && buff.isCursed()){\n\t\t\tenergy = Math.round(energy*0.67f);\n\t\t\tGLog.n(\"The cursed horn steals some of the food energy as you eat.\");\n\t\t}\n\t\tlevel -= energy;\n\t\tif (level < 0) {\n\t\t\tlevel = 0;\n\t\t} else if (level > STARVING) {\n\t\t\tlevel = STARVING;\n\t\t}\n\t\t\n\t\tBuffIndicator.refreshHero();\n\t}",
          "sourceCodeAfterRefactoring": "public void satisfy( float energy ) {\n\t\tif (((Hero) target).subClass == HeroSubClass.WARLOCK)\n\t\t\treturn;\n\n\t\tArtifact.ArtifactBuff buff = target.buff( HornOfPlenty.hornRecharge.class );\n\t\tif (buff != null && buff.isCursed()){\n\t\t\tenergy *= 0.67f;\n\t\t\tGLog.n(\"The cursed horn steals some of the food energy as you eat.\");\n\t\t}\n\n\t\treduceHunger( energy );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void reduceHunger( float energy ) {\n\t\tif (Dungeon.isChallenged(Challenges.NO_FOOD))\n\t\t\treturn;\n\n\t\tlevel -= energy;\n\t\tif (level < 0) {\n\t\t\tlevel = 0;\n\t\t} else if (level > STARVING) {\n\t\t\tlevel = STARVING;\n\t\t}\n\n\t\tBuffIndicator.refreshHero();\n\t}",
          "uniqueId": "f844ee05d41d4d6f8534e8bccb051f7df516b14c_117_131_141_153_118_129"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "99f853c1901c98bbebf6bbf53dcdcf63c828c2bd",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/99f853c1901c98bbebf6bbf53dcdcf63c828c2bd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static int cast( int from, int to, boolean magic, boolean hitChars ) {\n\t\t\n\t\tint w = Level.WIDTH;\n\t\t\n\t\tint x0 = from % w;\n\t\tint x1 = to % w;\n\t\tint y0 = from / w;\n\t\tint y1 = to / w;\n\t\t\n\t\tint dx = x1 - x0;\n\t\tint dy = y1 - y0;\n\t\t\n\t\tint stepX = dx > 0 ? +1 : -1;\n\t\tint stepY = dy > 0 ? +1 : -1;\n\t\t\n\t\tdx = Math.abs( dx );\n\t\tdy = Math.abs( dy );\n\t\t\n\t\tint stepA;\n\t\tint stepB;\n\t\tint dA;\n\t\tint dB;\n\t\t\n\t\tif (dx > dy) {\n\t\t\t\n\t\t\tstepA = stepX;\n\t\t\tstepB = stepY * w;\n\t\t\tdA = dx;\n\t\t\tdB = dy;\n\n\t\t} else {\n\t\t\t\n\t\t\tstepA = stepY * w;\n\t\t\tstepB = stepX;\n\t\t\tdA = dy;\n\t\t\tdB = dx;\n\n\t\t}\n\n\t\tdistance = 1;\n\t\ttrace[0] = from;\n\t\t\n\t\tint cell = from;\n\t\t\n\t\tint err = dA / 2;\n\t\twhile (cell != to || magic) {\n\t\t\t\n\t\t\tcell += stepA;\n\t\t\t\n\t\t\terr += dB;\n\t\t\tif (err >= dA) {\n\t\t\t\terr = err - dA;\n\t\t\t\tcell = cell + stepB;\n\t\t\t}\n\t\t\t\n\t\t\ttrace[distance++] = cell;\n\t\t\t\n\t\t\tif (!Level.passable[cell] && !Level.avoid[cell]) {\n\t\t\t\treturn trace[--distance - 1];\n\t\t\t}\n\t\t\t\n\t\t\tif (Level.losBlocking[cell] || (hitChars && Actor.findChar( cell ) != null)) {\n\t\t\t\treturn cell;\n\t\t\t}\n\t\t}\n\t\t\n\t\ttrace[distance++] = cell;\n\t\t\n\t\treturn to;\n\t}",
          "sourceCodeAfterRefactoring": "private void build( int from, int to, boolean stopTarget, boolean stopChars, boolean stopTerrain ) {\n\t\tint w = Level.WIDTH;\n\n\t\tint x0 = from % w;\n\t\tint x1 = to % w;\n\t\tint y0 = from / w;\n\t\tint y1 = to / w;\n\n\t\tint dx = x1 - x0;\n\t\tint dy = y1 - y0;\n\n\t\tint stepX = dx > 0 ? +1 : -1;\n\t\tint stepY = dy > 0 ? +1 : -1;\n\n\t\tdx = Math.abs( dx );\n\t\tdy = Math.abs( dy );\n\n\t\tint stepA;\n\t\tint stepB;\n\t\tint dA;\n\t\tint dB;\n\n\t\tif (dx > dy) {\n\n\t\t\tstepA = stepX;\n\t\t\tstepB = stepY * w;\n\t\t\tdA = dx;\n\t\t\tdB = dy;\n\n\t\t} else {\n\n\t\t\tstepA = stepY * w;\n\t\t\tstepB = stepX;\n\t\t\tdA = dy;\n\t\t\tdB = dx;\n\n\t\t}\n\n\t\tint cell = from;\n\n\t\tint err = dA / 2;\n\t\twhile (Level.insideMap(cell)) {\n\n\t\t\t//if we're in a wall, collide with the previous cell along the path.\n\t\t\tif (stopTerrain && !Level.passable[cell] && !Level.avoid[cell]) {\n\t\t\t\tcollide(path.get(path.size()-1));\n\t\t\t}\n\n\t\t\tpath.add(cell);\n\n\t\t\tif ((stopTerrain && Level.losBlocking[cell])\n\t\t\t\t\t|| (cell != sourcePos && stopChars && Actor.findChar( cell ) != null)\n\t\t\t\t\t|| (cell == to && stopTarget)){\n\t\t\t\tcollide(cell);\n\t\t\t}\n\n\t\t\tcell += stepA;\n\n\t\t\terr += dB;\n\t\t\tif (err >= dA) {\n\t\t\t\terr = err - dA;\n\t\t\t\tcell = cell + stepB;\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void collide(int cell){\n\t\tif (collisionPos == null)\n\t\t\tcollisionPos = cell;\n\t}",
          "uniqueId": "99f853c1901c98bbebf6bbf53dcdcf63c828c2bd_28_97_129_132_62_126"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "d94847af4c83ac69123700293f9f2f0c2e658510",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/d94847af4c83ac69123700293f9f2f0c2e658510",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void destroy() {\n\t\tsuper.destroy();\n\t\t\n\t\tinstance = new QuickSlotButton[4];\n\n\t\tlastTarget = null;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void destroy() {\n\t\tsuper.destroy();\n\t\t\n\t\treset();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void reset() {\n        instance = new QuickSlotButton[4];\n\n        lastTarget = null;\n    }",
          "uniqueId": "d94847af4c83ac69123700293f9f2f0c2e658510_56_63_63_67_56_61"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "e2ee042c386c030eecd0f68331942284aa2685ce",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/e2ee042c386c030eecd0f68331942284aa2685ce",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void chooseFont( float size ) {\n\t\t\n\t\tfloat pt = size * defaultZoom;\n\t\t\n\t\tif (pt >= 19) {\n\t\t\t\n\t\t\tscale = pt / 19;\n\t\t\tif (1.5 <= scale && scale < 2) {\n\t\t\t\tfont = font25x;\n\t\t\t\tscale = (int)(pt / 14);\n\t\t\t} else {\n\t\t\t\tfont = font3x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 14) {\n\t\t\t\n\t\t\tscale = pt / 14;\n\t\t\tif (1.8 <= scale && scale < 2) {\n\t\t\t\tfont = font2x;\n\t\t\t\tscale = (int)(pt / 12);\n\t\t\t} else {\n\t\t\t\tfont = font25x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 12) {\n\t\t\t\n\t\t\tscale = pt / 12;\n\t\t\tif (1.7 <= scale && scale < 2) {\n\t\t\t\tfont = font15x;\n\t\t\t\tscale = (int)(pt / 10);\n\t\t\t} else {\n\t\t\t\tfont = font2x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 10) {\n\t\t\t\n\t\t\tscale = pt / 10;\n\t\t\tif (1.4 <= scale && scale < 2) {\n\t\t\t\tfont = font1x;\n\t\t\t\tscale = (int)(pt / 7);\n\t\t\t} else {\n\t\t\t\tfont = font15x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tfont = font1x;\n\t\t\tscale = Math.max( 1, (int)(pt / 7) );\n\t\t\t\n\t\t}\n\t\t\n\t\tscale /= defaultZoom;\n\t}",
          "sourceCodeAfterRefactoring": "public static void chooseFont( float size ) {\n\t\tchooseFont( size, defaultZoom );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void chooseFont( float size, float zoom ) {\n\n\t\tfloat pt = size * zoom;\n\n\t\tif (pt >= 19) {\n\t\t\t\n\t\t\tscale = pt / 19;\n\t\t\tif (1.5 <= scale && scale < 2) {\n\t\t\t\tfont = font25x;\n\t\t\t\tscale = (int)(pt / 14);\n\t\t\t} else {\n\t\t\t\tfont = font3x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 14) {\n\t\t\t\n\t\t\tscale = pt / 14;\n\t\t\tif (1.8 <= scale && scale < 2) {\n\t\t\t\tfont = font2x;\n\t\t\t\tscale = (int)(pt / 12);\n\t\t\t} else {\n\t\t\t\tfont = font25x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 12) {\n\t\t\t\n\t\t\tscale = pt / 12;\n\t\t\tif (1.7 <= scale && scale < 2) {\n\t\t\t\tfont = font15x;\n\t\t\t\tscale = (int)(pt / 10);\n\t\t\t} else {\n\t\t\t\tfont = font2x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else if (pt >= 10) {\n\t\t\t\n\t\t\tscale = pt / 10;\n\t\t\tif (1.4 <= scale && scale < 2) {\n\t\t\t\tfont = font1x;\n\t\t\t\tscale = (int)(pt / 7);\n\t\t\t} else {\n\t\t\t\tfont = font15x;\n\t\t\t\tscale = (int)scale;\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tfont = font1x;\n\t\t\tscale = Math.max( 1, (int)(pt / 7) );\n\t\t\t\n\t\t}\n\t\t\n\t\tscale /= zoom;\n\t}",
          "uniqueId": "e2ee042c386c030eecd0f68331942284aa2685ce_142_198_150_206_146_148"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "37e1c8b8ff99866dc0c1ba4f355a47e38443a011",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/37e1c8b8ff99866dc0c1ba4f355a47e38443a011",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\t\n\t\tint level = Math.max( 0, weapon.level );\n\t\t\n\t\tint maxDamage = (int)(damage * Math.pow( 2, -1d / (level + 1) ));\n\t\tif (maxDamage >= 1) {\n\t\t\t\n\t\t\tint d = defender.pos - attacker.pos;\n\t\t\tint pos = defender.pos + d;\n\t\t\t\n\t\t\twhile (pos >= 0 && pos < Level.LENGTH) {\n\t\t\t\t\n\t\t\t\tChar ch = Actor.findChar( pos );\n\t\t\t\tif (ch == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint dr = Random.IntRange( 0, ch.dr() );\n\t\t\t\tint dmg = Random.Int( 1, maxDamage );\n\t\t\t\tint effectiveDamage = Math.max( dmg - dr, 0 );\n\t\t\t\t\n\t\t\t\tch.damage( effectiveDamage, this );\n\t\t\t\t\n\t\t\t\tch.sprite.bloodBurstA( attacker.sprite.center(), effectiveDamage );\n\t\t\t\tch.sprite.flash();\n\t\t\t\t\n\t\t\t\tpos += d;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\t// lvl 0 - 25%\n\t\t// lvl 1 - 40%\n\t\t// lvl 2 - 50%\n\t\tint level = Math.max( 0, weapon.level );\n\t\t\n\t\tif (Random.Int( level + 4 ) >= 3) {\n\t\t\t\n\t\t\tpoints[0] = attacker.pos;\n\t\t\tnPoints = 1;\n\t\t\t\n\t\t\taffected.clear();\n\t\t\taffected.add( attacker );\n\t\t\t\n\t\t\thit( defender, Random.Int( 1, damage / 2 ) );\n\t\t\t\n\t\t\tattacker.sprite.parent.add( new Lightning( points, nPoints, null ) );\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void hit( Char ch, int damage ) {\n\t\t\n\t\tif (damage < 1) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\taffected.add( ch );\n\t\tch.damage( Level.water[ch.pos] && !ch.flying ? (int)(damage * 2) : damage, LightningTrap.LIGHTNING  );\n\t\t\n\t\tch.sprite.centerEmitter().burst( SparkParticle.FACTORY, 3 );\n\t\tch.sprite.flash();\n\t\t\n\t\tpoints[nPoints++] = ch.pos;\n\t\t\n\t\tHashSet<Char> ns = new HashSet<Char>();\n\t\tfor (int i=0; i < Level.NEIGHBOURS8.length; i++) {\n\t\t\tChar n = Actor.findChar( ch.pos + Level.NEIGHBOURS8[i] );\n\t\t\tif (n != null && !affected.contains( n )) {\n\t\t\t\tns.add( n );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ns.size() > 0) {\n\t\t\thit( Random.element( ns ), Random.Int( damage / 2, damage ) );\n\t\t}\n\t}",
          "uniqueId": "37e1c8b8ff99866dc0c1ba4f355a47e38443a011_31_68_74_99_36_62"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\t\n\t\tint level = Math.max( 0, weapon.level );\n\t\t\n\t\tint maxDamage = (int)(damage * Math.pow( 2, -1d / (level + 1) ));\n\t\tif (maxDamage >= 1) {\n\t\t\t\n\t\t\tint p = attacker.pos;\n\t\t\tint[] neighbours = {\n\t\t\t\tp+1, p-1, p+Level.WIDTH, p-Level.WIDTH, \n\t\t\t\tp+1+Level.WIDTH, p+1-Level.WIDTH, p-1+Level.WIDTH, p-1-Level.WIDTH};\n\t\t\t\n\t\t\tfor (int n : neighbours) {\n\t\t\t\tChar ch = Actor.findChar( n );\n\t\t\t\tif (ch != null && ch != defender && ch.isAlive()) {\n\t\t\t\t\t\n\t\t\t\t\tint dr = Random.IntRange( 0, ch.dr() );\n\t\t\t\t\tint dmg = Random.Int( 1, maxDamage );\n\t\t\t\t\tint effectiveDamage = Math.max( dmg - dr, 0 );\n\t\t\t\t\t\n\t\t\t\t\tch.damage( effectiveDamage, this );\n\t\t\t\t\t\n\t\t\t\t\tch.sprite.bloodBurstA( attacker.sprite.center(), effectiveDamage );\n\t\t\t\t\tch.sprite.flash();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean proc( Weapon weapon, Char attacker, Char defender, int damage ) {\n\t\t// lvl 0 - 25%\n\t\t// lvl 1 - 40%\n\t\t// lvl 2 - 50%\n\t\tint level = Math.max( 0, weapon.level );\n\t\t\n\t\tif (Random.Int( level + 4 ) >= 3) {\n\t\t\t\n\t\t\tpoints[0] = attacker.pos;\n\t\t\tnPoints = 1;\n\t\t\t\n\t\t\taffected.clear();\n\t\t\taffected.add( attacker );\n\t\t\t\n\t\t\thit( defender, Random.Int( 1, damage / 2 ) );\n\t\t\t\n\t\t\tattacker.sprite.parent.add( new Lightning( points, nPoints, null ) );\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void hit( Char ch, int damage ) {\n\t\t\n\t\tif (damage < 1) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\taffected.add( ch );\n\t\tch.damage( Level.water[ch.pos] && !ch.flying ? (int)(damage * 2) : damage, LightningTrap.LIGHTNING  );\n\t\t\n\t\tch.sprite.centerEmitter().burst( SparkParticle.FACTORY, 3 );\n\t\tch.sprite.flash();\n\t\t\n\t\tpoints[nPoints++] = ch.pos;\n\t\t\n\t\tHashSet<Char> ns = new HashSet<Char>();\n\t\tfor (int i=0; i < Level.NEIGHBOURS8.length; i++) {\n\t\t\tChar n = Actor.findChar( ch.pos + Level.NEIGHBOURS8[i] );\n\t\t\tif (n != null && !affected.contains( n )) {\n\t\t\t\tns.add( n );\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (ns.size() > 0) {\n\t\t\thit( Random.element( ns ), Random.Int( damage / 2, damage ) );\n\t\t}\n\t}",
          "uniqueId": "37e1c8b8ff99866dc0c1ba4f355a47e38443a011_31_67_74_99_36_62"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "1acebb380cc84e361c256946354fb1fc370f130f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/1acebb380cc84e361c256946354fb1fc370f130f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Item random() {\n\t\tif (Random.Float() < 0.4) {\n\t\t\tint n = 1;\n\t\t\tif (Random.Int( 3 ) == 0) {\n\t\t\t\tn++;\n\t\t\t\tif (Random.Int( 3 ) == 0) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Random.Int( 2 ) == 0) {\n\t\t\t\tupgrade( n );\n\t\t\t} else {\n\t\t\t\tdegrade( n );\n\t\t\t\tcursed = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Random.Int( 10 ) == 0) {\n\t\t\tinscribe( Glyph.random() );\n\t\t}\n\t\t\n\t\treturn this;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Item random() {\n\t\tif (Random.Float() < 0.4) {\n\t\t\tint n = 1;\n\t\t\tif (Random.Int( 3 ) == 0) {\n\t\t\t\tn++;\n\t\t\t\tif (Random.Int( 3 ) == 0) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Random.Int( 2 ) == 0) {\n\t\t\t\tupgrade( n );\n\t\t\t} else {\n\t\t\t\tdegrade( n );\n\t\t\t\tcursed = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (Random.Int( 10 ) == 0) {\n\t\t\tinscribe();\n\t\t}\n\t\t\n\t\treturn this;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Armor inscribe() {\n\n\t\tClass<? extends Glyph> oldGlyphClass = glyph != null ? glyph.getClass() : null;\n\t\tGlyph gl = Glyph.random();\n\t\twhile (gl.getClass() == oldGlyphClass) {\n\t\t\tgl = Armor.Glyph.random();\n\t\t}\n\n\t\treturn inscribe( gl );\n\t}",
          "uniqueId": "1acebb380cc84e361c256946354fb1fc370f130f_255_278_330_339_262_285"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "private void inscribe( Armor armor ) {\n\t\t\n\t\tdetach( curUser.belongings.backpack );\n\t\t\n\t\tClass<? extends Armor.Glyph> oldGlyphClass = armor.glyph != null ? armor.glyph.getClass() : null;\n\t\tArmor.Glyph glyph = Armor.Glyph.random();\n\t\twhile (glyph.getClass() == oldGlyphClass) {\n\t\t\tglyph = Armor.Glyph.random();\n\t\t}\n\t\t\n\t\tGLog.w( TXT_INSCRIBED, glyph.name(), armor.name() );\n\t\t\n\t\tarmor.inscribe( glyph );\n\t\t\n\t\tcurUser.sprite.operate( curUser.pos );\n\t\tcurUser.sprite.centerEmitter().start( PurpleParticle.BURST, 0.05f, 10 );\n\t\tSample.INSTANCE.play( Assets.SND_BURNING );\n\t\t\n\t\tcurUser.spend( TIME_TO_INSCRIBE );\n\t\tcurUser.busy();\n\t}",
          "sourceCodeAfterRefactoring": "private void inscribe( Armor armor ) {\n\t\t\n\t\tdetach( curUser.belongings.backpack );\n\n\t\tGLog.w( TXT_INSCRIBED, armor.name() );\n\t\t\n\t\tarmor.inscribe();\n\t\t\n\t\tcurUser.sprite.operate( curUser.pos );\n\t\tcurUser.sprite.centerEmitter().start( PurpleParticle.BURST, 0.05f, 10 );\n\t\tSample.INSTANCE.play( Assets.SND_BURNING );\n\t\t\n\t\tcurUser.spend( TIME_TO_INSCRIBE );\n\t\tcurUser.busy();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "1acebb380cc84e361c256946354fb1fc370f130f_81_101_330_339_81_95"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "9e79aab869d76893d6e06cc5e280f90358ab95ef",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/9e79aab869d76893d6e06cc5e280f90358ab95ef",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static<T extends Buff> T affect( Char target, Class<T> buffClass ) {\n\t\tT buff = target.buff( buffClass );\n\t\tif (buff != null) {\n\t\t\treturn buff;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tbuff = buffClass.newInstance();\n\t\t\t\tbuff.attachTo( target );\n\t\t\t\treturn buff;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static<T extends Buff> T affect( Char target, Class<T> buffClass ) {\n\t\tT buff = target.buff( buffClass );\n\t\tif (buff != null) {\n\t\t\treturn buff;\n\t\t} else {\n\t\t\treturn append( target, buffClass );\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static<T extends Buff> T append( Char target, Class<T> buffClass ) {\n\t\ttry {\n\t\t\tT buff = buffClass.newInstance();\n\t\t\tbuff.attachTo( target );\n\t\t\treturn buff;\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}",
          "uniqueId": "9e79aab869d76893d6e06cc5e280f90358ab95ef_60_73_60_68_76_83"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void detach() {\n\t\ttarget.paralysed = false;\n\t\tsuper.detach();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void detach() {\n\t\tsuper.detach();\n\t\tunfreeze(target);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void unfreeze( Char ch ) {\n\t\tif (ch.buff( Paralysis.class ) == null &&\n\t\t\t\tch.buff( Frost.class ) == null) {\n\n\t\t\tch.paralysed = false;\n\t\t}\n\t}",
          "uniqueId": "9e79aab869d76893d6e06cc5e280f90358ab95ef_38_42_59_65_38_42"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void detach() {\n\t\ttarget.paralysed = false;\n\t\tsuper.detach();\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void detach() {\n\t\tsuper.detach();\n\t\tParalysis.unfreeze( target );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nsuper.detach();\n\t\tParalysis.unfreeze( target );\n\t}\n\t\n\t@Override\n\tpublic int icon() {\n\t\treturn BuffIndicator.FROST;",
          "uniqueId": "9e79aab869d76893d6e06cc5e280f90358ab95ef_57_61_59_65_57_61"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "67a7bf05150337010f6d26158eaaba73e79333f0",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/67a7bf05150337010f6d26158eaaba73e79333f0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n        public void detach(){\n            for (int cell : presses)\n                Dungeon.level.press(cell, null);\n            for (Mob mob : Dungeon.level.mobs.toArray(new Mob[0]))\n                mob.sprite.remove(CharSprite.State.PARALYSED);\n            GameScene.freezeEmitters = false;\n\n            charge = 0;\n            QuickSlot.refresh();\n            super.detach();\n        }",
          "sourceCodeAfterRefactoring": "@Override\n        public void detach(){\n            triggerPresses();\n            for (Mob mob : Dungeon.level.mobs.toArray(new Mob[0]))\n                mob.sprite.remove(CharSprite.State.PARALYSED);\n            GameScene.freezeEmitters = false;\n\n            charge = 0;\n            QuickSlot.refresh();\n            super.detach();\n        }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void triggerPresses(){\n            for (int cell : presses)\n                Dungeon.level.press(cell, null);\n\n            presses = new ArrayList<Integer>();\n        }",
          "uniqueId": "67a7bf05150337010f6d26158eaaba73e79333f0_269_280_261_266_277_287"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "f40f7f325cdc05e27b81155b5c309f61b4f686af",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/f40f7f325cdc05e27b81155b5c309f61b4f686af",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Item cook(Seed seed){\n        Class<? extends Item> potion = seed.alchemyClass;\n\n\n        try {\n            potionAttrib = (Potion)potion.newInstance();\n            potionAttrib.ownedByFruit = true;\n        } catch (Exception e) {\n            return null;\n        }\n\n        potionAttrib.image = ItemSpriteSheet.BLANDFRUIT;\n\n\n        info = \"The fruit has plumped up from its time soaking in the pot and has even absorbed the properties \"+\n               \"of the \" + seed.name() + \" it was cooked with.\\n\\n\";\n\n        if (potionAttrib instanceof PotionOfHealing){\n\n            name = \"Sunfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x2EE62E );\n            info += \"It looks delicious and hearty, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfStrength){\n\n            name = \"Rotfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xCC0022 );\n            info += \"It looks delicious and powerful, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfParalyticGas){\n\n            name = \"Earthfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x67583D );\n            info += \"It looks delicious and firm, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfInvisibility){\n\n            name = \"Blindfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xE5D273 );\n            info += \"It looks delicious and shiny, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfLiquidFlame){\n\n            name = \"Firefruit\";\n            potionGlow = new ItemSprite.Glowing( 0xFF7F00 );\n            info += \"It looks delicious and spicy, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfFrost){\n\n            name = \"Icefruit\";\n            potionGlow = new ItemSprite.Glowing( 0x66B3FF );\n            info += \"It looks delicious and refreshing, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfMindVision){\n\n            name = \"Fadefruit\";\n            potionGlow = new ItemSprite.Glowing( 0xB8E6CF );\n            info += \"It looks delicious and shadowy, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfToxicGas){\n\n            name = \"Sorrowfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xA15CE5 );\n            info += \"It looks delicious and crisp, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfLevitation) {\n\n            name = \"Stormfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x1C3A57 );\n            info += \"It looks delicious and lightweight, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfPurity) {\n\n            name = \"Dreamfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x8E2975 );\n            info += \"It looks delicious and clean, ready to be eaten!\";\n\n        }\n\n        return this;\n    }",
          "sourceCodeAfterRefactoring": "public Item cook(Seed seed){\n\n        try {\n            return imbuePotion((Potion)seed.alchemyClass.newInstance());\n        } catch (Exception e) {\n            return null;\n        }\n\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Item imbuePotion(Potion potion){\n\n        potionAttrib = potion;\n        potionAttrib.ownedByFruit = true;\n\n        potionAttrib.image = ItemSpriteSheet.BLANDFRUIT;\n\n\n        info = \"The fruit has plumped up from its time soaking in the pot and has even absorbed the properties \"+\n               \"of the seed it was cooked with.\\n\\n\";\n\n        if (potionAttrib instanceof PotionOfHealing){\n\n            name = \"Sunfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x2EE62E );\n            info += \"It looks delicious and hearty, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfStrength){\n\n            name = \"Rotfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xCC0022 );\n            info += \"It looks delicious and powerful, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfParalyticGas){\n\n            name = \"Earthfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x67583D );\n            info += \"It looks delicious and firm, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfInvisibility){\n\n            name = \"Blindfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xE5D273 );\n            info += \"It looks delicious and shiny, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfLiquidFlame){\n\n            name = \"Firefruit\";\n            potionGlow = new ItemSprite.Glowing( 0xFF7F00 );\n            info += \"It looks delicious and spicy, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfFrost){\n\n            name = \"Icefruit\";\n            potionGlow = new ItemSprite.Glowing( 0x66B3FF );\n            info += \"It looks delicious and refreshing, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfMindVision){\n\n            name = \"Fadefruit\";\n            potionGlow = new ItemSprite.Glowing( 0xB8E6CF );\n            info += \"It looks delicious and shadowy, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfToxicGas){\n\n            name = \"Sorrowfruit\";\n            potionGlow = new ItemSprite.Glowing( 0xA15CE5 );\n            info += \"It looks delicious and crisp, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfLevitation) {\n\n            name = \"Stormfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x1C3A57 );\n            info += \"It looks delicious and lightweight, ready to be eaten!\";\n\n        } else if (potionAttrib instanceof PotionOfPurity) {\n\n            name = \"Dreamfruit\";\n            potionGlow = new ItemSprite.Glowing( 0x8E2975 );\n            info += \"It looks delicious and clean, ready to be eaten!\";\n\n        }\n\n        return this;\n    }",
          "uniqueId": "f40f7f325cdc05e27b81155b5c309f61b4f686af_178_258_188_262_178_186"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "bd4405a8052635cfc9eb568cf905c29dbc07d38f",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/bd4405a8052635cfc9eb568cf905c29dbc07d38f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Potion() {\n\t\tsuper();\n\t\timage = handler.image( this );\n\t\tcolor = handler.label( this );\n\t}",
          "sourceCodeAfterRefactoring": "public Potion() {\n\t\tsuper();\n\t\tsyncVisuals();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n    public void syncVisuals(){\n        image = handler.image( this );\n        color = handler.label( this );\n    };",
          "uniqueId": "bd4405a8052635cfc9eb568cf905c29dbc07d38f_111_115_116_120_111_114"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Scroll() {\n\t\tsuper();\n\t\timage = handler.image( this );\n\t\trune = handler.label( this );\n\t}",
          "sourceCodeAfterRefactoring": "public Scroll() {\n\t\tsuper();\n\t\tsyncVisuals();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n    public void syncVisuals(){\n        image = handler.image( this );\n        rune = handler.label( this );\n    };",
          "uniqueId": "bd4405a8052635cfc9eb568cf905c29dbc07d38f_93_97_98_102_93_96"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Wand() {\n\t\tsuper();\n\t\t\n\t\tcalculateDamage();\n\t\t\n\t\ttry {\n\t\t\timage = handler.image( this );\n\t\t\twood = handler.label( this );\n\t\t} catch (Exception e) {\n\t\t\t// Wand of Magic Missile\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Wand() {\n\t\tsuper();\n\t\t\n\t\tcalculateDamage();\n\t\t\n\t\ttry {\n            syncVisuals();\n\t\t} catch (Exception e) {\n\t\t\t// Wand of Magic Missile\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n    public void syncVisuals(){\n        image = handler.image( this );\n        wood = handler.label( this );\n    }",
          "uniqueId": "bd4405a8052635cfc9eb568cf905c29dbc07d38f_122_133_134_138_122_132"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "fa53d788098701593fd72f72c8336be7f52f1e26",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/fa53d788098701593fd72f72c8336be7f52f1e26",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static void leave() {\n\t\t\n\t\titem = null;\n\t\tswitch (Random.Int( 4 )) {\n\t\tcase 0:\n\t\t\titem = Dungeon.hero.belongings.weapon;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\titem = Dungeon.hero.belongings.armor;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\titem = Dungeon.hero.belongings.misc1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\titem = Dungeon.hero.belongings.misc2;\n\t\t\tbreak;\n\t\t}\n\t\tif (item == null) {\n\t\t\tif (Dungeon.gold > 0) {\n\t\t\t\titem = new Gold( Random.IntRange( 1, Dungeon.gold ) );\n\t\t\t} else {\n\t\t\t\titem = new Gold( 1 );\n\t\t\t}\n\t\t}\n\t\t\n\t\tdepth = Dungeon.depth;\n\t\t\n\t\tBundle bundle = new Bundle();\n\t\tbundle.put( LEVEL, depth );\n\t\tbundle.put( ITEM, item );\n\t\t\n\t\ttry {\n\t\t\tOutputStream output = Game.instance.openFileOutput( BONES_FILE, Game.MODE_PRIVATE );\n\t\t\tBundle.write( bundle, output );\n\t\t\toutput.close();\n\t\t} catch (IOException e) {\n\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public static void leave() {\n\t\t\n\t\titem = pickItem(Dungeon.hero);\n\n\t\t\n\t\tdepth = Dungeon.depth;\n\t\t\n\t\tBundle bundle = new Bundle();\n\t\tbundle.put( LEVEL, depth );\n\t\tbundle.put( ITEM, item );\n\t\t\n\t\ttry {\n\t\t\tOutputStream output = Game.instance.openFileOutput( BONES_FILE, Game.MODE_PRIVATE );\n\t\t\tBundle.write( bundle, output );\n\t\t\toutput.close();\n\t\t} catch (IOException e) {\n\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static Item pickItem(Hero hero){\n        Item item = null;\n        if (Random.Int(2) == 0) {\n            switch (Random.Int(5)) {\n                case 0:\n                    item = hero.belongings.weapon;\n                    break;\n                case 1:\n                    item = hero.belongings.armor;\n                    break;\n                case 2:\n                    item = hero.belongings.misc1;\n                    break;\n                case 3:\n                    item = hero.belongings.misc2;\n                    break;\n                case 4:\n                    item = QuickSlot.getItem();\n                    break;\n            }\n            if (item != null && !item.bones)\n                return pickItem(hero);\n        } else {\n\n            Iterator<Item> iterator = hero.belongings.backpack.iterator();\n            Item curItem;\n            ArrayList<Item> items = new ArrayList<Item>();\n            while (iterator.hasNext()){\n                curItem = iterator.next();\n                if (curItem.bones && !(curItem instanceof EquipableItem))\n                    items.add(curItem);\n            }\n\n            if (!items.isEmpty()) {\n                item = Random.element(items);\n                if (item.stackable){\n                    item.quantity(Random.NormalIntRange(1, (int)Math.sqrt(item.quantity())));\n                }\n            }\n        }\n        if (item == null) {\n            if (Dungeon.gold > 0) {\n                item = new Gold( Random.NormalIntRange( 1, Dungeon.gold ) );\n            } else {\n                item = new Gold( 1 );\n            }\n        }\n        return item;\n    }",
          "uniqueId": "fa53d788098701593fd72f72c8336be7f52f1e26_41_79_66_114_46_64"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "13afc9df8deddc66d57059b48ebbb0b38bc49fec",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/13afc9df8deddc66d57059b48ebbb0b38bc49fec",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean doEquip( Hero hero ) {\n\t\t\n\t\tdetach( hero.belongings.backpack );\n\t\t\n\t\tif (hero.belongings.armor == null || hero.belongings.armor.doUnequip( hero, true )) {\n\t\t\t\n\t\t\thero.belongings.armor = this;\n\t\t\t\n\t\t\tcursedKnown = true;\n\t\t\tif (cursed) {\n\t\t\t\tequipCursed( hero );\n\t\t\t\tGLog.n( TXT_EQUIP_CURSED, toString() );\n\t\t\t}\n\t\t\t\n\t\t\t((HeroSprite)hero.sprite).updateArmor();\n\t\t\t\n\t\t\thero.spendAndNext( 2 * hero.speed() );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tcollect( hero.belongings.backpack );\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean doEquip( Hero hero ) {\n\t\t\n\t\tdetach( hero.belongings.backpack );\n\t\t\n\t\tif (hero.belongings.armor == null || hero.belongings.armor.doUnequip( hero, true, false )) {\n\t\t\t\n\t\t\thero.belongings.armor = this;\n\t\t\t\n\t\t\tcursedKnown = true;\n\t\t\tif (cursed) {\n\t\t\t\tequipCursed( hero );\n\t\t\t\tGLog.n( TXT_EQUIP_CURSED, toString() );\n\t\t\t}\n\t\t\t\n\t\t\t((HeroSprite)hero.sprite).updateArmor();\n\n            hero.spendAndNext( 2 * time2equip( hero ) );\n\t\t\treturn true;\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tcollect( hero.belongings.backpack );\n\t\t\treturn false;\n\t\t\t\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n    protected float time2equip( Hero hero ) {\n        return hero.speed();\n    }",
          "uniqueId": "13afc9df8deddc66d57059b48ebbb0b38bc49fec_87_113_114_117_86_112"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/4a497633093ad56095b50f7f1c2c1ec9a5c194aa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void initWarrior( Hero hero ) {\n\t\thero.STR = hero.STR + 1;\n\t\t\n\t\t(hero.belongings.weapon = new ShortSword()).identify();\n\t\t(hero.belongings.armor = new ClothArmor()).identify();\n\t\tnew Dart( 8 ).identify().collect();\n\t\tnew Food().identify().collect();\n\t\t\n\t\tif (Badges.isUnlocked( Badges.Badge.MASTERY_WARRIOR )) {\n\t\t\tnew TomeOfMastery().collect();\n\t\t}\n\t\t\n\t\tDungeon.quickslot = Dart.class;\n\t\t\n\t\tnew PotionOfStrength().setKnown();\n\t}",
          "sourceCodeAfterRefactoring": "private static void initWarrior( Hero hero ) {\n        hero.STR = hero.STR + 1;\n\n        (hero.belongings.weapon = new ShortSword()).identify();\n        new Dart( 8 ).identify().collect();\n\n        Dungeon.quickslot = Dart.class;\n\n        new PotionOfStrength().setKnown();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void initCommon( Hero hero ) {\n        (hero.belongings.armor = new ClothArmor()).identify();\n        new Food().identify().collect();\n    }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_106_121_112_115_131_140"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void initMage( Hero hero ) {\t\n\t\t(hero.belongings.weapon = new Knuckles()).identify();\n\t\t(hero.belongings.armor = new ClothArmor()).identify();\n\t\tnew Food().identify().collect();\n\t\t\n\t\tWandOfMagicMissile wand = new WandOfMagicMissile();\n\t\twand.identify().collect();\n\t\t\n\t\tif (Badges.isUnlocked( Badges.Badge.MASTERY_MAGE )) {\n\t\t\tnew TomeOfMastery().collect();\n\t\t}\n\t\t\n\t\tDungeon.quickslot = wand;\n\t\t\n\t\tnew ScrollOfIdentify().setKnown();\n\t}",
          "sourceCodeAfterRefactoring": "private static void initMage( Hero hero ) {\n        (hero.belongings.weapon = new Knuckles()).identify();\n\n        WandOfMagicMissile wand = new WandOfMagicMissile();\n        wand.identify().collect();\n\n        Dungeon.quickslot = wand;\n\n        new ScrollOfIdentify().setKnown();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void initCommon( Hero hero ) {\n        (hero.belongings.armor = new ClothArmor()).identify();\n        new Food().identify().collect();\n    }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_123_138_112_115_142_151"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void initRogue( Hero hero ) {\n\t\t(hero.belongings.weapon = new Dagger()).identify();\n\t\t(hero.belongings.armor = new ClothArmor()).identify();\n        CloakOfShadows cloak = new CloakOfShadows();\n\t\thero.belongings.misc1 = cloak;\n\t\tnew Dart( 8 ).identify().collect();\n\t\tnew Food().identify().collect();\n\n\t\thero.belongings.misc1.activate( hero );\n\t\t\n\t\tif (Badges.isUnlocked( Badges.Badge.MASTERY_ROGUE )) {\n\t\t\tnew TomeOfMastery().collect();\n\t\t}\n\t\t\n\t\tDungeon.quickslot = cloak;\n\t\t\n\t\tnew ScrollOfMagicMapping().setKnown();\n\t}",
          "sourceCodeAfterRefactoring": "private static void initRogue( Hero hero ) {\n        (hero.belongings.weapon = new Dagger()).identify();\n\n        CloakOfShadows cloak = new CloakOfShadows();\n        hero.belongings.misc1 = cloak;\n        hero.belongings.misc1.activate( hero );\n\n        new Dart( 8 ).identify().collect();\n\n\n        Dungeon.quickslot = cloak;\n\n        new ScrollOfMagicMapping().setKnown();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void initCommon( Hero hero ) {\n        (hero.belongings.armor = new ClothArmor()).identify();\n        new Food().identify().collect();\n    }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_140_157_112_115_153_166"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void initHuntress( Hero hero ) {\n\t\t\n\t\thero.HP = (hero.HT -= 5);\n\t\t\n\t\t(hero.belongings.weapon = new Dagger()).identify();\n\t\t(hero.belongings.armor = new ClothArmor()).identify();\n\t\tBoomerang boomerang = new Boomerang();\n\t\tboomerang.identify().collect();\n\t\tnew Food().identify().collect();\n\t\t\n\t\tif (Badges.isUnlocked( Badges.Badge.MASTERY_HUNTRESS )) {\n\t\t\tnew TomeOfMastery().collect();\n\t\t}\n\t\t\n\t\tDungeon.quickslot = boomerang;\n\t}",
          "sourceCodeAfterRefactoring": "private static void initHuntress( Hero hero ) {\n\n        hero.HP = (hero.HT -= 5);\n\n        (hero.belongings.weapon = new Dagger()).identify();\n        Boomerang boomerang = new Boomerang();\n        boomerang.identify().collect();\n\n        Dungeon.quickslot = boomerang;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void initCommon( Hero hero ) {\n        (hero.belongings.armor = new ClothArmor()).identify();\n        new Food().identify().collect();\n    }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_159_174_112_115_168_177"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean alertedNow = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t\n\t\tint oldPos = pos;\n\t\t\n\t\tswitch (state) {\n\t\t\n\t\tcase SLEEPING:\n\t\t\tif (enemyInFOV && \n\t\t\t\tRandom.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t\tspend( TIME_TO_WAKE_UP );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase WANDERING:\n\t\t\tif (enemyInFOV && (alertedNow || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\t\t\t\t\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase HUNTING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV && canAttack( enemy )) {\n\t\t\t\t\n\t\t\t\treturn doAttack( enemy );\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (enemyInFOV) {\n\t\t\t\t\ttarget = enemy.pos;\n\t\t\t\t}\n\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\t\n\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos,  pos );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspend( TICK );\n\t\t\t\t\tstate = State.WANDERING;\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\t// <--------\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcase FLEEING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV) {\n\t\t\t\ttarget = enemy.pos;\n\t\t\t}\n\t\t\tif (target != -1 && getFurther( target )) {\n\t\t\t\t\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\tnowhereToRun();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\tcase PASSIVE:\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean justAlerted = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\n        return state.act( enemyInFOV, justAlerted );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n        public boolean act( boolean enemyInFOV, boolean justAlerted ) {\n            if (enemyInFOV && Random.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\n                enemySeen = true;\n\n                notice();\n                state = HUNTING;\n                target = enemy.pos;\n\n                if (Dungeon.isChallenged( Challenges.SWARM_INTELLIGENCE )) {\n                    for (Mob mob : Dungeon.level.mobs) {\n                        if (mob != Mob.this) {\n                            mob.beckon( target );\n                        }\n                    }\n                }\n\n                spend( TIME_TO_WAKE_UP );\n\n            } else {\n\n                enemySeen = false;\n\n                spend( TICK );\n\n            }\n            return true;\n        }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_122_245_440_468_136_157"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean alertedNow = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t\n\t\tint oldPos = pos;\n\t\t\n\t\tswitch (state) {\n\t\t\n\t\tcase SLEEPING:\n\t\t\tif (enemyInFOV && \n\t\t\t\tRandom.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t\tspend( TIME_TO_WAKE_UP );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase WANDERING:\n\t\t\tif (enemyInFOV && (alertedNow || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\t\t\t\t\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase HUNTING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV && canAttack( enemy )) {\n\t\t\t\t\n\t\t\t\treturn doAttack( enemy );\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (enemyInFOV) {\n\t\t\t\t\ttarget = enemy.pos;\n\t\t\t\t}\n\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\t\n\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos,  pos );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspend( TICK );\n\t\t\t\t\tstate = State.WANDERING;\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\t// <--------\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcase FLEEING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV) {\n\t\t\t\ttarget = enemy.pos;\n\t\t\t}\n\t\t\tif (target != -1 && getFurther( target )) {\n\t\t\t\t\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\tnowhereToRun();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\tcase PASSIVE:\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean justAlerted = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\n        return state.act( enemyInFOV, justAlerted );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n        public boolean act( boolean enemyInFOV, boolean justAlerted ) {\n            if (enemyInFOV && (justAlerted || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\n                enemySeen = true;\n\n                notice();\n                state = HUNTING;\n                target = enemy.pos;\n\n            } else {\n\n                enemySeen = false;\n\n                int oldPos = pos;\n                if (target != -1 && getCloser( target )) {\n                    spend( 1 / speed() );\n                    return moveSprite( oldPos, pos );\n                } else {\n                    target = Dungeon.level.randomDestination();\n                    spend( TICK );\n                }\n\n            }\n            return true;\n        }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_122_245_480_505_136_157"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean alertedNow = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t\n\t\tint oldPos = pos;\n\t\t\n\t\tswitch (state) {\n\t\t\n\t\tcase SLEEPING:\n\t\t\tif (enemyInFOV && \n\t\t\t\tRandom.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t\tspend( TIME_TO_WAKE_UP );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase WANDERING:\n\t\t\tif (enemyInFOV && (alertedNow || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\t\t\t\t\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase HUNTING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV && canAttack( enemy )) {\n\t\t\t\t\n\t\t\t\treturn doAttack( enemy );\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (enemyInFOV) {\n\t\t\t\t\ttarget = enemy.pos;\n\t\t\t\t}\n\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\t\n\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos,  pos );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspend( TICK );\n\t\t\t\t\tstate = State.WANDERING;\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\t// <--------\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcase FLEEING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV) {\n\t\t\t\ttarget = enemy.pos;\n\t\t\t}\n\t\t\tif (target != -1 && getFurther( target )) {\n\t\t\t\t\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\tnowhereToRun();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\tcase PASSIVE:\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean justAlerted = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\n        return state.act( enemyInFOV, justAlerted );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n        public boolean act( boolean enemyInFOV, boolean justAlerted ) {\n            enemySeen = enemyInFOV;\n            if (enemyInFOV && canAttack( enemy )) {\n\n                return doAttack( enemy );\n\n            } else {\n\n                if (enemyInFOV) {\n                    target = enemy.pos;\n                }\n\n                int oldPos = pos;\n                if (target != -1 && getCloser( target )) {\n\n                    spend( 1 / speed() );\n                    return moveSprite( oldPos,  pos );\n\n                } else {\n\n                    spend( TICK );\n                    state = WANDERING;\n                    target = Dungeon.level.randomDestination();\n                    return true;\n                }\n            }\n        }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_122_245_517_544_136_157"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean alertedNow = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t\n\t\tint oldPos = pos;\n\t\t\n\t\tswitch (state) {\n\t\t\n\t\tcase SLEEPING:\n\t\t\tif (enemyInFOV && \n\t\t\t\tRandom.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t\tspend( TIME_TO_WAKE_UP );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase WANDERING:\n\t\t\tif (enemyInFOV && (alertedNow || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\t\t\t\t\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase HUNTING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV && canAttack( enemy )) {\n\t\t\t\t\n\t\t\t\treturn doAttack( enemy );\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (enemyInFOV) {\n\t\t\t\t\ttarget = enemy.pos;\n\t\t\t\t}\n\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\t\n\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos,  pos );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspend( TICK );\n\t\t\t\t\tstate = State.WANDERING;\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\t// <--------\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcase FLEEING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV) {\n\t\t\t\ttarget = enemy.pos;\n\t\t\t}\n\t\t\tif (target != -1 && getFurther( target )) {\n\t\t\t\t\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\tnowhereToRun();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\tcase PASSIVE:\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean justAlerted = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\n        return state.act( enemyInFOV, justAlerted );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n        public boolean act( boolean enemyInFOV, boolean justAlerted ) {\n            enemySeen = enemyInFOV;\n            if (enemyInFOV) {\n                target = enemy.pos;\n            }\n\n            int oldPos = pos;\n            if (target != -1 && getFurther( target )) {\n\n                spend( 1 / speed() );\n                return moveSprite( oldPos, pos );\n\n            } else {\n\n                spend( TICK );\n                nowhereToRun();\n\n                return true;\n            }\n        }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_122_245_556_576_136_157"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean alertedNow = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\t\t\n\t\tint oldPos = pos;\n\t\t\n\t\tswitch (state) {\n\t\t\n\t\tcase SLEEPING:\n\t\t\tif (enemyInFOV && \n\t\t\t\tRandom.Int( distance( enemy ) + enemy.stealth() + (enemy.flying ? 2 : 0) ) == 0) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t\tspend( TIME_TO_WAKE_UP );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\n\t\tcase WANDERING:\n\t\t\tif (enemyInFOV && (alertedNow || Random.Int( distance( enemy ) / 2 + enemy.stealth() ) == 0)) {\n\t\t\t\t\n\t\t\t\tenemySeen = true;\n\t\t\t\t\n\t\t\t\tnotice();\n\t\t\t\tstate = State.HUNTING;\n\t\t\t\ttarget = enemy.pos;\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tenemySeen = false;\n\t\t\t\t\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t} else {\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\n\t\t\t\t\tspend( TICK );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase HUNTING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV && canAttack( enemy )) {\n\t\t\t\t\n\t\t\t\treturn doAttack( enemy );\n\t\t\t\t\n\t\t\t} else {\n\n\t\t\t\tif (enemyInFOV) {\n\t\t\t\t\ttarget = enemy.pos;\n\t\t\t\t}\n\n\t\t\t\tif (target != -1 && getCloser( target )) {\n\t\t\t\t\t\n\n\t\t\t\t\tspend( 1 / speed() );\n\t\t\t\t\treturn moveSprite( oldPos,  pos );\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\tspend( TICK );\n\t\t\t\t\tstate = State.WANDERING;\n\t\t\t\t\ttarget = Dungeon.level.randomDestination();\t// <--------\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tcase FLEEING:\n\t\t\tenemySeen = enemyInFOV;\n\t\t\tif (enemyInFOV) {\n\t\t\t\ttarget = enemy.pos;\n\t\t\t}\n\t\t\tif (target != -1 && getFurther( target )) {\n\t\t\t\t\n\t\t\t\tspend( 1 / speed() );\n\t\t\t\treturn moveSprite( oldPos, pos );\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tspend( TICK );\n\t\t\t\tnowhereToRun();\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\tcase PASSIVE:\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t\treturn true;\n\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected boolean act() {\n\t\t\n\t\tsuper.act();\n\t\t\n\t\tboolean justAlerted = alerted;\n\t\talerted = false;\n\t\t\n\t\tsprite.hideAlert();\n\t\t\n\t\tif (paralysed) {\n\t\t\tenemySeen = false;\n\t\t\tspend( TICK );\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tenemy = chooseEnemy();\n\t\t\n\t\tboolean enemyInFOV = enemy.isAlive() && Level.fieldOfView[enemy.pos] && enemy.invisible <= 0;\n\n        return state.act( enemyInFOV, justAlerted );\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n        public boolean act( boolean enemyInFOV, boolean justAlerted ) {\n            enemySeen = false;\n            spend( TICK );\n            return true;\n        }",
          "uniqueId": "4a497633093ad56095b50f7f1c2c1ec9a5c194aa_122_245_591_596_136_157"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "724338b57f1088b163b3a41e526efa7bfb81ae60",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/724338b57f1088b163b3a41e526efa7bfb81ae60",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Emitter.Factory factory( final int type ) {\n\t\t\n\t\tEmitter.Factory factory = factories.get( type );\n\t\t\n\t\tif (factory == null) {\n\t\t\tfactory = new Emitter.Factory() {\n\t\t\t\t@Override\n\t\t\t\tpublic void emit ( Emitter emitter, int index, float x, float y ) {\n\t\t\t\t\tSpeck p = (Speck)emitter.recycle( Speck.class );\n\t\t\t\t\tp.reset( index, x, y, type );\n\t\t\t\t}\n\t\t\t};\n\t\t\tfactories.put( type, factory );\n\t\t}\n\t\t\n\t\treturn factory;\n\t}",
          "sourceCodeAfterRefactoring": "public static Emitter.Factory factory( final int type ) {\n        return factory( type, false );\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Emitter.Factory factory( final int type, final boolean lightMode ) {\n\n        Emitter.Factory factory = factories.get( type );\n\n        if (factory == null) {\n            factory = new Emitter.Factory() {\n                @Override\n                public void emit ( Emitter emitter, int index, float x, float y ) {\n                    Speck p = (Speck)emitter.recycle( Speck.class );\n                    p.reset( index, x, y, type );\n                }\n                @Override\n                public boolean lightMode() {\n                    return lightMode;\n                }\n            };\n            factories.put( type, factory );\n        }\n\n        return factory;\n    }",
          "uniqueId": "724338b57f1088b163b3a41e526efa7bfb81ae60_416_432_430_450_426_428"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "1c40c23a7279e2bfc4a1b3d0dcc75898c3bdc228",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/1c40c23a7279e2bfc4a1b3d0dcc75898c3bdc228",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Armor randomArmor() throws Exception {\n\t\t\n\t\tint curStr = Hero.STARTING_STR + Dungeon.potionOfStrength;\n\t\t\n\t\tCategory cat = Category.ARMOR;\n\t\t\n\t\tArmor a1 = (Armor)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\tArmor a2 = (Armor)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\t\n\t\ta1.random();\n\t\ta2.random();\n\t\t\n\t\treturn Math.abs( curStr - a1.STR ) < Math.abs( curStr - a2.STR ) ? a1 : a2;\n\t}",
          "sourceCodeAfterRefactoring": "public static Armor randomArmor() throws Exception {\n        int curStr = Hero.STARTING_STR + Dungeon.potionOfStrength;\n\n        return randomArmor(curStr);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Armor randomArmor(int targetStr) throws Exception {\n\t\t\n\t\tCategory cat = Category.ARMOR;\n\t\t\n\t\tArmor a1 = (Armor)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\tArmor a2 = (Armor)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\t\n\t\ta1.random();\n\t\ta2.random();\n\t\t\n\t\treturn Math.abs( targetStr - a1.STR ) < Math.abs( targetStr - a2.STR ) ? a1 : a2;\n\t}",
          "uniqueId": "1c40c23a7279e2bfc4a1b3d0dcc75898c3bdc228_246_259_252_263_246_250"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Weapon randomWeapon() throws Exception {\n\t\t\n\t\tint curStr = Hero.STARTING_STR + Dungeon.potionOfStrength;\n\t\t\n\t\tCategory cat = Category.WEAPON;\n\t\t\n\t\tWeapon w1 = (Weapon)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\tWeapon w2 = (Weapon)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\t\n\t\tw1.random();\n\t\tw2.random();\n\t\t\n\t\treturn Math.abs( curStr - w1.STR ) < Math.abs( curStr - w2.STR ) ? w1 : w2;\n\t}",
          "sourceCodeAfterRefactoring": "public static Weapon randomWeapon() throws Exception {\n        int curStr = Hero.STARTING_STR + Dungeon.potionOfStrength;\n\n        return randomWeapon(curStr);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Weapon randomWeapon(int targetStr) throws Exception {\n\n\t\tCategory cat = Category.WEAPON;\n\t\t\n\t\tWeapon w1 = (Weapon)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\tWeapon w2 = (Weapon)cat.classes[Random.chances( cat.probs )].newInstance();\n\t\t\n\t\tw1.random();\n\t\tw2.random();\n\t\t\n\t\treturn Math.abs( targetStr - w1.STR ) < Math.abs( targetStr - w2.STR ) ? w1 : w2;\n\t}",
          "uniqueId": "1c40c23a7279e2bfc4a1b3d0dcc75898c3bdc228_261_274_271_282_265_269"
        }
      ]
    },
    {
      "repository": "https://github.com/00-Evan/shattered-pixel-dungeon.git",
      "sha1": "93b5fe3eb6d54145a7caf89202d5f41679c46048",
      "url": "https://github.com/00-Evan/shattered-pixel-dungeon/commit/93b5fe3eb6d54145a7caf89202d5f41679c46048",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    public void execute( Hero hero, String action ) {\n        super.execute(hero, action);\n        if (action.equals(AC_PRICK)){\n            //TODO: add warning screen if chalice would take more than 75% current hp.\n\n            hero.spendAndNext(1f);\n            hero.damage((level*2)*(level*2), this);\n\n            if (!hero.isAlive()) {\n                Dungeon.fail(Utils.format(ResultDescriptions.ITEM, name, Dungeon.depth));\n                GLog.n(\"The Chalice sucks your life essence dry...\");\n            } else\n                level++;\n\n        }\n\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    public void execute(Hero hero, String action ) {\n        super.execute(hero, action);\n        if (action.equals(AC_PRICK)){\n\n            int damage = (level*2)*(level*2);\n\n            if (damage > hero.HT*(3/4)) {\n\n                GameScene.show(\n                    new WndOptions(TXT_CHALICE, TXT_PRICK, TXT_YES, TXT_NO) {\n                        @Override\n                        protected void onSelect(int index) {\n                            if (index == 0)\n                                prick(Dungeon.hero);\n                        };\n                    }\n                );\n\n            } else {\n                prick(hero);\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void prick(Hero hero){\n        int damage = (level*2)*(level*2);\n\n        hero.spendAndNext(3f);\n\n        Earthroot.Armor armor = hero.buff(Earthroot.Armor.class);\n        if (armor != null) {\n            damage = armor.absorb(damage);\n        }\n\n        damage -= Random.IntRange(0, hero.dr());\n\n        hero.damage(damage, this);\n\n        //TODO: make sure this look good\n        if (damage == 0){\n            GLog.i(\"You prick yourself, that hardly hurt at all!\");\n        } else if (damage < 25){\n            GLog.w(\"You prick yourself and the chalice feeds on you.\");\n            Sample.INSTANCE.play(Assets.SND_CURSED);\n            hero.sprite.emitter().burst( ShadowParticle.CURSE, 6 );\n        } else if (damage < 100){\n            GLog.w(\"Your life essence drains into the chalice.\");\n            Sample.INSTANCE.play(Assets.SND_CURSED);\n            hero.sprite.emitter().burst( ShadowParticle.CURSE, 6 );\n        } else {\n            GLog.w(\"The chalice devours your life energy.\");\n            Sample.INSTANCE.play(Assets.SND_CURSED);\n            hero.sprite.emitter().burst( ShadowParticle.CURSE, 6 );\n        }\n\n        if (!hero.isAlive()) {\n            Dungeon.fail(Utils.format(ResultDescriptions.ITEM, name, Dungeon.depth));\n            GLog.n(\"The Chalice sucks your life essence dry...\");\n        } else\n            level++;\n    }",
          "uniqueId": "93b5fe3eb6d54145a7caf89202d5f41679c46048_37_54_77_113_52_75"
        }
      ]
    }
  ]
}
{
  "commits": [
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "46ab704221608fb6318d110f1b0c2abca73a9ea2",
      "url": "https://github.com/google/gson/commit/46ab704221608fb6318d110f1b0c2abca73a9ea2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isTrue();\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertThat(excluder.excludeClass(clazz, true)).isFalse();\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/InnerClassExclusionStrategyTest.java",
          "sourceCodeAfterRefactoring": "@Test\n  public void testExcludeInnerClassObject() {\n    Class<?> clazz = innerClass.getClass();\n    assertExcludesClass(clazz);\n  }\n@Test\n  public void testExcludeInnerClassField() throws Exception {\n    Field f = getClass().getField(\"innerClass\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testIncludeStaticNestedClassObject() {\n    Class<?> clazz = staticNestedClass.getClass();\n    assertIncludesClass(clazz);\n  }\n@Test\n  public void testIncludeStaticNestedClassField() throws Exception {\n    Field f = getClass().getField(\"staticNestedClass\");\n    assertIncludesField(f);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertExcludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
          "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_39_40_43_55_59"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    // Until version is exclusive\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isFalse();\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertThat(excluder.excludeClass(MockClassSince.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassSince.class.getField(\"someField\"), true)).isTrue();\n\n    assertThat(excluder.excludeClass(MockClassUntil.class, true)).isFalse();\n    assertThat(excluder.excludeField(MockClassUntil.class.getField(\"someField\"), true)).isFalse();\n\n    assertThat(excluder.excludeClass(MockClassBoth.class, true)).isTrue();\n    assertThat(excluder.excludeField(MockClassBoth.class.getField(\"someField\"), true)).isTrue();\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/VersionExclusionStrategyTest.java",
          "sourceCodeAfterRefactoring": "@Test\n  public void testSameVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    // Until version is exclusive\n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassBoth.class);\n    assertIncludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testNewerVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION + 5);\n    assertIncludesClass(excluder, MockClassSince.class);\n    assertIncludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassUntil.class);\n    assertExcludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }\n@Test\n  public void testOlderVersion() throws Exception {\n    Excluder excluder = Excluder.DEFAULT.withVersion(VERSION - 5);\n    assertExcludesClass(excluder, MockClassSince.class);\n    assertExcludesField(excluder, MockClassSince.class.getField(\"someField\"));\n\n    assertIncludesClass(excluder, MockClassUntil.class);\n    assertIncludesField(excluder, MockClassUntil.class.getField(\"someField\"));\n\n    assertExcludesClass(excluder, MockClassBoth.class);\n    assertExcludesField(excluder, MockClassBoth.class.getField(\"someField\"));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertIncludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate static void assertExcludesClass(Excluder excluder, Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isTrue();\n    assertThat(excluder.excludeClass(c, false)).isTrue();\n  }",
          "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_35_47_36_39_56_68"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertThat(excluder.excludeClass(MockObject.class, true)).isFalse();\n    assertThat(excluder.excludeClass(MockObject.class, false)).isFalse();\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/ExposeAnnotationExclusionStrategyTest.java",
          "sourceCodeAfterRefactoring": "@Test\n  public void testNeverSkipClasses() {\n    assertIncludesClass(MockObject.class);\n  }\n@Test\n  public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"hiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertExcludesField(f);\n  }\n@Test\n  public void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"exposedField\");\n    assertIncludesField(f);\n  }\n@Test\n  public void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = createFieldAttributes(\"explicitlyExposedField\");\n    assertIncludesField(f);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertIncludesClass(Class<?> c) {\n    assertThat(excluder.excludeClass(c, true)).isFalse();\n    assertThat(excluder.excludeClass(c, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertExcludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isTrue();\n    assertThat(excluder.excludeField(f, false)).isTrue();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }\nExtractedCodeFragments:\nprivate void assertIncludesField(Field f) {\n    assertThat(excluder.excludeField(f, true)).isFalse();\n    assertThat(excluder.excludeField(f, false)).isFalse();\n  }",
          "uniqueId": "46ab704221608fb6318d110f1b0c2abca73a9ea2_34_38_34_37_49_52"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "08174e201980698a89f5f5996e10617d89ff09e1",
      "url": "https://github.com/google/gson/commit/08174e201980698a89f5f5996e10617d89ff09e1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/stream/JsonWriterTest.java",
          "sourceCodeAfterRefactoring": "@Test\n  public void testNonFiniteFloats() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteFloatsWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteFloatsExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoubles() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteDoublesWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteDoublesExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbers() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }\n@Test\n  public void testNonFiniteNumbersWhenStrict() throws IOException {\n    StringWriter stringWriter = new StringWriter();\n    JsonWriter jsonWriter = new JsonWriter(stringWriter);\n    jsonWriter.setStrictness(Strictness.STRICT);\n    assertNonFiniteNumbersExceptions(jsonWriter);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteFloatsExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Float.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Float.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteDoublesExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(IllegalArgumentException.class, () -> jsonWriter.value(Double.NaN));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.NEGATIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.POSITIVE_INFINITY));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }\nExtractedCodeFragments:\nprivate static void assertNonFiniteNumbersExceptions(JsonWriter jsonWriter) throws IOException {\n    jsonWriter.beginArray();\n\n    IllegalArgumentException expected =\n        assertThrows(\n            IllegalArgumentException.class, () -> jsonWriter.value(Double.valueOf(Double.NaN)));\n    assertThat(expected).hasMessageThat().isEqualTo(\"Numeric values must be finite, but was NaN\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.NEGATIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was -Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(Double.valueOf(Double.POSITIVE_INFINITY)));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n\n    expected =\n        assertThrows(\n            IllegalArgumentException.class,\n            () -> jsonWriter.value(new LazilyParsedNumber(\"Infinity\")));\n    assertThat(expected)\n        .hasMessageThat()\n        .isEqualTo(\"Numeric values must be finite, but was Infinity\");\n  }",
          "uniqueId": "08174e201980698a89f5f5996e10617d89ff09e1_289_312_289_309_311_316"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "66847264765180c849f945ca13704aa0eae79c58",
      "url": "https://github.com/google/gson/commit/66847264765180c849f945ca13704aa0eae79c58",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Configures Gson to serialize {@code Date} objects according to the style value provided. You\n   * can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n   * invocation will be used to decide the serialization format.\n   *\n   * <p>Note that this style value should be one of the predefined constants in the {@code\n   * DateFormat} class. See the documentation in {@link java.text.DateFormat} for more information\n   * on the valid style constants.\n   *\n   * @param style the predefined date style that date objects will be serialized/deserialized\n   *     to/from\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.2\n   */\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = style;\n    this.datePattern = null;\n    return this;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/GsonBuilder.java",
          "sourceCodeAfterRefactoring": "/**\n   * Configures Gson to serialize {@code Date} objects according to the style value provided. You\n   * can call this method or {@link #setDateFormat(String)} multiple times, but only the last\n   * invocation will be used to decide the serialization format.\n   *\n   * <p>Note that this style value should be one of the predefined constants in the {@code\n   * DateFormat} class. See the documentation in {@link java.text.DateFormat} for more information\n   * on the valid style constants.\n   *\n   * @param style the predefined date style that date objects will be serialized/deserialized\n   *     to/from\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @throws IllegalArgumentException if the style is invalid\n   * @since 1.2\n   */\n  @CanIgnoreReturnValue\n  public GsonBuilder setDateFormat(int style) {\n    this.dateStyle = checkDateFormatStyle(style);\n    this.datePattern = null;\n    return this;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static int checkDateFormatStyle(int style) {\n    // Valid DateFormat styles are: 0, 1, 2, 3 (FULL, LONG, MEDIUM, SHORT)\n    if (style < 0 || style > 3) {\n      throw new IllegalArgumentException(\"Invalid style: \" + style);\n    }\n    return style;\n  }",
          "uniqueId": "66847264765180c849f945ca13704aa0eae79c58_614_633_616_622_624_644"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
      "url": "https://github.com/google/gson/commit/6a9d240f786bfe6602ae5dafd6da23b4fb3043fc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a BigDecimal so that they won't need Gson on the other side to\n   * deserialize it.\n   */\n  private Object writeReplace() throws ObjectStreamException {\n    return new BigDecimal(value);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/LazilyParsedNumber.java",
          "sourceCodeAfterRefactoring": "/**\n   * If somebody is unlucky enough to have to serialize one of these, serialize\n   * it as a BigDecimal so that they won't need Gson on the other side to\n   * deserialize it.\n   */\n  private Object writeReplace() throws ObjectStreamException {\n    return asBigDecimal();\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate BigDecimal asBigDecimal() {\n    return NumberLimits.parseBigDecimal(value);\n  }",
          "uniqueId": "6a9d240f786bfe6602ae5dafd6da23b4fb3043fc_75_82_38_40_79_86"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "e7cf5c458374e5fc69dbdce6de5cb2c881521135",
      "url": "https://github.com/google/gson/commit/e7cf5c458374e5fc69dbdce6de5cb2c881521135",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw,\n                                                 boolean blockInaccessible, boolean isRecord) {\n    Map<String, BoundField> result = new LinkedHashMap<>();\n    if (raw.isInterface()) {\n      return result;\n    }\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      // For inherited fields, check if access to their declaring class is allowed\n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        // The accessor method is only used for records. If the type is a record, we will read out values\n        // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\n        Method accessor = null;\n        if (isRecord) {\n          // If there is a static field on a record, there will not be an accessor. Instead we will use the default\n          // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\n          // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            // If blockInaccessible, skip and perform access check later\n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            // @SerializedName can be placed on accessor method, but it is not supported there\n            // If field and method have annotation it is not easily possible to determine if accessor method\n            // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        // If blockInaccessible, skip and perform access check later\n        // For Records if the accessor method is used the field does not have to be made accessible\n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        BoundField previous = null;\n        for (int i = 0, size = fieldNames.size(); i < size; ++i) {\n          String name = fieldNames.get(i);\n          if (i != 0) serialize = false; // only serialize the default name\n          BoundField boundField = createBoundField(context, field, accessor, name,\n              TypeToken.get(fieldType), serialize, deserialize, blockInaccessible);\n          BoundField replaced = result.put(name, boundField);\n          if (previous == null) previous = replaced;\n        }\n        if (previous != null) {\n          throw new IllegalArgumentException(\"Class \" + originalRaw.getName()\n              + \" declares multiple JSON fields named '\" + previous.name + \"'; conflict is caused\"\n              + \" by fields \" + ReflectionHelper.fieldToString(previous.field) + \" and \" + ReflectionHelper.fieldToString(field)\n              + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return result;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "sourceCodeAfterRefactoring": "private FieldsData getBoundFields(Gson context, TypeToken<?> type, Class<?> raw, boolean blockInaccessible, boolean isRecord) {\n    if (raw.isInterface()) {\n      return FieldsData.EMPTY;\n    }\n\n    Map<String, BoundField> deserializedFields = new LinkedHashMap<>();\n    // For serialized fields use a Map to track duplicate field names; otherwise this could be a List<BoundField> instead\n    Map<String, BoundField> serializedFields = new LinkedHashMap<>();\n\n    Class<?> originalRaw = raw;\n    while (raw != Object.class) {\n      Field[] fields = raw.getDeclaredFields();\n\n      // For inherited fields, check if access to their declaring class is allowed\n      if (raw != originalRaw && fields.length > 0) {\n        FilterResult filterResult = ReflectionAccessFilterHelper.getFilterResult(reflectionFilters, raw);\n        if (filterResult == FilterResult.BLOCK_ALL) {\n          throw new JsonIOException(\"ReflectionAccessFilter does not permit using reflection for \" + raw\n              + \" (supertype of \" + originalRaw + \"). Register a TypeAdapter for this type\"\n              + \" or adjust the access filter.\");\n        }\n        blockInaccessible = filterResult == FilterResult.BLOCK_INACCESSIBLE;\n      }\n\n      for (Field field : fields) {\n        boolean serialize = includeField(field, true);\n        boolean deserialize = includeField(field, false);\n        if (!serialize && !deserialize) {\n          continue;\n        }\n        // The accessor method is only used for records. If the type is a record, we will read out values\n        // via its accessor method instead of via reflection. This way we will bypass the accessible restrictions\n        Method accessor = null;\n        if (isRecord) {\n          // If there is a static field on a record, there will not be an accessor. Instead we will use the default\n          // field serialization logic, but for deserialization the field is excluded for simplicity. Note that Gson\n          // ignores static fields by default, but GsonBuilder.excludeFieldsWithModifiers can overwrite this.\n          if (Modifier.isStatic(field.getModifiers())) {\n            deserialize = false;\n          } else {\n            accessor = ReflectionHelper.getAccessor(raw, field);\n            // If blockInaccessible, skip and perform access check later\n            if (!blockInaccessible) {\n              ReflectionHelper.makeAccessible(accessor);\n            }\n\n            // @SerializedName can be placed on accessor method, but it is not supported there\n            // If field and method have annotation it is not easily possible to determine if accessor method\n            // is implicit and has inherited annotation, or if it is explicitly declared with custom annotation\n            if (accessor.getAnnotation(SerializedName.class) != null\n                && field.getAnnotation(SerializedName.class) == null) {\n              String methodDescription = ReflectionHelper.getAccessibleObjectDescription(accessor, false);\n              throw new JsonIOException(\"@SerializedName on \" + methodDescription + \" is not supported\");\n            }\n          }\n        }\n\n        // If blockInaccessible, skip and perform access check later\n        // For Records if the accessor method is used the field does not have to be made accessible\n        if (!blockInaccessible && accessor == null) {\n          ReflectionHelper.makeAccessible(field);\n        }\n\n        Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n        List<String> fieldNames = getFieldNames(field);\n        String serializedName = fieldNames.get(0);\n        BoundField boundField = createBoundField(context, field, accessor, serializedName,\n            TypeToken.get(fieldType), serialize, blockInaccessible);\n\n        if (deserialize) {\n          for (String name : fieldNames) {\n            BoundField replaced = deserializedFields.put(name, boundField);\n\n            if (replaced != null) {\n              throw createDuplicateFieldException(originalRaw, name, replaced.field, field);\n            }\n          }\n        }\n\n        if (serialize) {\n          BoundField replaced = serializedFields.put(serializedName, boundField);\n          if (replaced != null) {\n            throw createDuplicateFieldException(originalRaw, serializedName, replaced.field, field);\n          }\n        }\n      }\n      type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n      raw = type.getRawType();\n    }\n    return new FieldsData(deserializedFields, new ArrayList<>(serializedFields.values()));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static IllegalArgumentException createDuplicateFieldException(Class<?> declaringType, String duplicateName, Field field1, Field field2) {\n    throw new IllegalArgumentException(\"Class \" + declaringType.getName()\n        + \" declares multiple JSON fields named '\" + duplicateName + \"'; conflict is caused\"\n        + \" by fields \" + ReflectionHelper.fieldToString(field1) + \" and \" + ReflectionHelper.fieldToString(field2)\n        + \"\\nSee \" + TroubleshootingGuide.createUrl(\"duplicate-fields\"));\n  }",
          "uniqueId": "e7cf5c458374e5fc69dbdce6de5cb2c881521135_236_318_247_252_254_344"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
      "url": "https://github.com/google/gson/commit/7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\") // this is not safe; requires that user has specified correct adapter class for @JsonAdapter\n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation) {\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of\n    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage\n    Object instance = constructorConstructor.get(TypeToken.get(annotation.value())).construct();\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      typeAdapter = ((TypeAdapterFactory) instance).create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, null, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\") // this is not safe; requires that user has specified correct adapter class for @JsonAdapter\n  @Override\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> rawType = targetType.getRawType();\n    JsonAdapter annotation = getAnnotation(rawType);\n    if (annotation == null) {\n      return null;\n    }\n    return (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation, true);\n  }\nTypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n      TypeToken<?> type, JsonAdapter annotation, boolean isClassAnnotation) {\n    Object instance = createAdapter(constructorConstructor, annotation.value());\n\n    TypeAdapter<?> typeAdapter;\n    boolean nullSafe = annotation.nullSafe();\n    if (instance instanceof TypeAdapter) {\n      typeAdapter = (TypeAdapter<?>) instance;\n    } else if (instance instanceof TypeAdapterFactory) {\n      TypeAdapterFactory factory = (TypeAdapterFactory) instance;\n\n      if (isClassAnnotation) {\n        factory = putFactoryAndGetCurrent(type.getRawType(), factory);\n      }\n\n      typeAdapter = factory.create(gson, type);\n    } else if (instance instanceof JsonSerializer || instance instanceof JsonDeserializer) {\n      JsonSerializer<?> serializer = instance instanceof JsonSerializer\n          ? (JsonSerializer<?>) instance\n          : null;\n      JsonDeserializer<?> deserializer = instance instanceof JsonDeserializer\n          ? (JsonDeserializer<?>) instance\n          : null;\n\n      // Uses dummy factory instances because TreeTypeAdapter needs a 'skipPast' factory for `Gson.getDelegateAdapter`\n      // call and has to differentiate there whether TreeTypeAdapter was created for @JsonAdapter on class or field\n      TypeAdapterFactory skipPast;\n      if (isClassAnnotation) {\n        skipPast = TREE_TYPE_CLASS_DUMMY_FACTORY;\n      } else {\n        skipPast = TREE_TYPE_FIELD_DUMMY_FACTORY;\n      }\n      @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n      TypeAdapter<?> tempAdapter = new TreeTypeAdapter(serializer, deserializer, gson, type, skipPast, nullSafe);\n      typeAdapter = tempAdapter;\n\n      nullSafe = false;\n    } else {\n      throw new IllegalArgumentException(\"Invalid attempt to bind an instance of \"\n          + instance.getClass().getName() + \" as a @JsonAdapter for \" + type.toString()\n          + \". @JsonAdapter value must be a TypeAdapter, TypeAdapterFactory,\"\n          + \" JsonSerializer or JsonDeserializer.\");\n    }\n\n    if (typeAdapter != null && nullSafe) {\n      typeAdapter = typeAdapter.nullSafe();\n    }\n\n    return typeAdapter;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate JsonAdapter getAnnotation(Class<?> rawType) {\n    return rawType.getAnnotation(JsonAdapter.class);\n  }\nExtractedCodeFragments:\nprivate static Object createAdapter(ConstructorConstructor constructorConstructor, Class<?> adapterClass) {\n    // TODO: The exception messages created by ConstructorConstructor are currently written in the context of\n    // deserialization and for example suggest usage of TypeAdapter, which would not work for @JsonAdapter usage\n    return constructorConstructor.get(TypeToken.get(adapterClass)).construct();\n  }",
          "uniqueId": "7ee5ad6cd1640d957f3a73d89a271ee2ef9c7956_41_50_73_75_77_86"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b3dce2dc17086c72bd1f8ccf508874849f9631bb",
      "url": "https://github.com/google/gson/commit/b3dce2dc17086c72bd1f8ccf508874849f9631bb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Configure this writer to relax its syntax rules. By default, this writer\n   * only emits well-formed JSON as specified by <a\n   * href=\"http://www.ietf.org/rfc/rfc7159.txt\">RFC 7159</a>. Setting the writer\n   * to lenient permits the following:\n   * <ul>\n   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n   *       Double#isInfinite() infinities}.\n   * </ul>\n   */\n  public final void setLenient(boolean lenient) {\n    this.lenient = lenient;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "sourceCodeAfterRefactoring": "/**\n   * Sets the strictness of this writer.\n   *\n   * @deprecated Please use {@link #setStrictness(Strictness)} instead.\n   * {@code JsonWriter.setLenient(true)} should be replaced by {@code JsonWriter.setStrictness(Strictness.LENIENT)}\n   * and {@code JsonWriter.setLenient(false)} should be replaced by {@code JsonWriter.setStrictness(Strictness.LEGACY_STRICT)}.<br>\n   * However, if you used {@code setLenient(false)} before, you might prefer {@link Strictness#STRICT} now instead.\n   *\n   * @param lenient whether this writer should be lenient. If true, the strictness is set to {@link Strictness#LENIENT}.\n   *                If false, the strictness is set to {@link Strictness#LEGACY_STRICT}.\n   * @see #setStrictness(Strictness)\n   */\n  @Deprecated\n  @SuppressWarnings(\"InlineMeSuggester\") // Don't specify @InlineMe, so caller with `setLenient(false)` becomes aware of new Strictness.STRICT\n  public final void setLenient(boolean lenient) {\n    setStrictness(lenient ? Strictness.LENIENT : Strictness.LEGACY_STRICT);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Configures how strict this writer is with regard to the syntax rules specified in <a\n   * href=\"https://www.ietf.org/rfc/rfc8259.txt\">RFC 8259</a>. By default, {@link Strictness#LEGACY_STRICT} is used.\n   *\n   * <dl>\n   *     <dt>{@link Strictness#STRICT} & {@link Strictness#LEGACY_STRICT}</dt>\n   *     <dd>\n   *         The behavior of these is currently identical. In these strictness modes, the writer only writes JSON\n   *         in accordance with RFC 8259.\n   *     </dd>\n   *     <dt>{@link Strictness#LENIENT}</dt>\n   *     <dd>\n   *         This mode relaxes the behavior of the writer to allow the writing of {@link Double#isNaN() NaNs}\n   *         and {@link Double#isInfinite() infinities}. It also allows writing multiple top level values.\n   *     </dd>\n   * </dl>\n   *\n   * @param strictness the new strictness of this writer. May not be {@code null}.\n   * @since $next-version$\n   */\n  public final void setStrictness(Strictness strictness) {\n    this.strictness = Objects.requireNonNull(strictness);\n  }",
          "uniqueId": "b3dce2dc17086c72bd1f8ccf508874849f9631bb_270_282_298_320_271_287"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "cbad1aa79f9a41f0e0887c2c0159fa9aee1cdf3b",
      "url": "https://github.com/google/gson/commit/cbad1aa79f9a41f0e0887c2c0159fa9aee1cdf3b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Test serializing an instance of a non-accessible internal class, but where\n   * Gson supports serializing one of its superinterfaces.\n   *\n   * <p>Here {@link Collections#emptyList()} is used which returns an instance\n   * of the internal class {@code java.util.Collections.EmptyList}. Gson should\n   * serialize the object as {@code List} despite the internal class not being\n   * accessible.\n   *\n   * <p>See https://github.com/google/gson/issues/1875\n   */\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    // But deserialization should fail\n    Class<?> internalClass = Collections.emptyList().getClass();\n    try {\n      gson.fromJson(\"[]\", internalClass);\n      fail(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().startsWith(\"Failed making constructor 'java.util.Collections$EmptyList()' accessible;\"\n          + \" either increase its visibility or write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n    }\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/ReflectionAccessTest.java",
          "sourceCodeAfterRefactoring": "/**\n   * Test serializing an instance of a non-accessible internal class, but where\n   * Gson supports serializing one of its superinterfaces.\n   *\n   * <p>Here {@link Collections#emptyList()} is used which returns an instance\n   * of the internal class {@code java.util.Collections.EmptyList}. Gson should\n   * serialize the object as {@code List} despite the internal class not being\n   * accessible.\n   *\n   * <p>See https://github.com/google/gson/issues/1875\n   */\n  @Test\n  public void testSerializeInternalImplementationObject() {\n    Gson gson = new Gson();\n    String json = gson.toJson(Collections.emptyList());\n    assertThat(json).isEqualTo(\"[]\");\n\n    // But deserialization should fail\n    Class<?> internalClass = Collections.emptyList().getClass();\n    JsonIOException exception = assertInaccessibleException(\"[]\", internalClass);\n    // Don't check exact class name because it is a JDK implementation detail\n    assertThat(exception).hasMessageThat().startsWith(\"Failed making constructor '\");\n    assertThat(exception).hasMessageThat().contains(\"' accessible; either increase its visibility or\"\n        + \" write a custom InstanceCreator or TypeAdapter for its declaring type: \");\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static JsonIOException assertInaccessibleException(String json, Class<?> toDeserialize) {\n    Gson gson = new Gson();\n    try {\n      gson.fromJson(json, toDeserialize);\n      throw new AssertionError(\"Missing exception; test has to be run with `--illegal-access=deny`\");\n    } catch (JsonSyntaxException e) {\n      throw new AssertionError(\"Unexpected exception; test has to be run with `--illegal-access=deny`\", e);\n    } catch (JsonIOException expected) {\n      assertThat(expected).hasMessageThat().endsWith(\"\\nSee https://github.com/google/gson/blob/master/Troubleshooting.md#reflection-inaccessible\");\n      // Return exception for further assertions\n      return expected;\n    }\n  }",
          "uniqueId": "cbad1aa79f9a41f0e0887c2c0159fa9aee1cdf3b_110_138_110_122_124_148"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "19f54ee6ed33b7517c729c801bc57c8c0478be7d",
      "url": "https://github.com/google/gson/commit/19f54ee6ed33b7517c729c801bc57c8c0478be7d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      this.indent = null;\n      this.separator = \":\";\n    } else {\n      this.indent = indent;\n      this.separator = \": \";\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/stream/JsonWriter.java",
          "sourceCodeAfterRefactoring": "/**\n   * Sets the indentation string to be repeated for each level of indentation\n   * in the encoded document. If {@code indent.isEmpty()} the encoded document\n   * will be compact. Otherwise the encoded document will be more\n   * human-readable.\n   *\n   * @param indent a string containing only whitespace.\n   */\n  public final void setIndent(String indent) {\n    if (indent.length() == 0) {\n      setFormattingStyle(null);\n    } else {\n      setFormattingStyle(FormattingStyle.DEFAULT.withIndent(indent));\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Sets the pretty printing style to be used in the encoded document.\n   * No pretty printing if null.\n   *\n   * <p>Sets the various attributes to be used in the encoded document. \n   * For example the indentation string to be repeated for each level of indentation.\n   * Or the newline style, to accommodate various OS styles.</p>\n   *\n   * <p>Has no effect if the serialized format is a single line.</p>\n   *\n   * @param formattingStyle the style used for pretty printing, no pretty printing if null.\n   * @since $next-version$\n   */\n  public final void setFormattingStyle(FormattingStyle formattingStyle) {\n    this.formattingStyle = formattingStyle;\n    if (formattingStyle == null) {\n      this.separator = \":\";\n    } else {\n      this.separator = \": \";\n    }\n  }",
          "uniqueId": "19f54ee6ed33b7517c729c801bc57c8c0478be7d_210_226_227_247_211_225"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "66d9621ce87c04a5167ee04097694093b13b514c",
      "url": "https://github.com/google/gson/commit/66d9621ce87c04a5167ee04097694093b13b514c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Creates a string representation for a constructor.\n   * E.g.: {@code java.lang.String#String(char[], int, int)}\n   */\n  private static String constructorToString(Constructor<?> constructor) {\n    StringBuilder stringBuilder = new StringBuilder(constructor.getDeclaringClass().getName())\n      .append('#')\n      .append(constructor.getDeclaringClass().getSimpleName())\n      .append('(');\n    Class<?>[] parameters = constructor.getParameterTypes();\n    for (int i = 0; i < parameters.length; i++) {\n      if (i > 0) {\n        stringBuilder.append(\", \");\n      }\n      stringBuilder.append(parameters[i].getSimpleName());\n    }\n\n    return stringBuilder.append(')').toString();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java",
          "sourceCodeAfterRefactoring": "/**\n   * Creates a string representation for a constructor.\n   * E.g.: {@code java.lang.String(char[], int, int)}\n   */\n  public static String constructorToString(Constructor<?> constructor) {\n    StringBuilder stringBuilder = new StringBuilder(constructor.getDeclaringClass().getName());\n    appendExecutableParameters(constructor, stringBuilder);\n\n    return stringBuilder.toString();\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static void appendExecutableParameters(AccessibleObject executable, StringBuilder stringBuilder) {\n    stringBuilder.append('(');\n\n    Class<?>[] parameters = (executable instanceof Method)\n        ? ((Method) executable).getParameterTypes()\n        : ((Constructor<?>) executable).getParameterTypes();\n    for (int i = 0; i < parameters.length; i++) {\n      if (i > 0) {\n        stringBuilder.append(\", \");\n      }\n      stringBuilder.append(parameters[i].getSimpleName());\n    }\n\n    stringBuilder.append(')');\n  }",
          "uniqueId": "66d9621ce87c04a5167ee04097694093b13b514c_68_86_90_104_78_87"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "a0dc7bfdddfe488510edde8d8abb0727743394c4",
      "url": "https://github.com/google/gson/commit/a0dc7bfdddfe488510edde8d8abb0727743394c4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Tries making the field accessible, wrapping any thrown exception in a\n   * {@link JsonIOException} with descriptive message.\n   *\n   * @param field field to make accessible\n   * @throws JsonIOException if making the field accessible fails\n   */\n  public static void makeAccessible(Field field) throws JsonIOException {\n    try {\n      field.setAccessible(true);\n    } catch (Exception exception) {\n      throw new JsonIOException(\"Failed making field '\" + field.getDeclaringClass().getName() + \"#\"\n          + field.getName() + \"' accessible; either change its visibility or write a custom \"\n          + \"TypeAdapter for its declaring type\", exception);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/reflect/ReflectionHelper.java",
          "sourceCodeAfterRefactoring": "/**\n   * Tries making the field accessible, wrapping any thrown exception in a {@link JsonIOException}\n   * with descriptive message.\n   *\n   * @param field field to make accessible\n   * @throws JsonIOException if making the field accessible fails\n   */\n  public static void makeAccessible(Field field) throws JsonIOException {\n    makeAccessible(\"field '\" + field.getDeclaringClass().getName() + \"#\" + field.getName() + \"'\", field);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Internal implementation of making an {@link AccessibleObject} accessible.\n   *\n   * @param description describe what we are attempting to make accessible\n   * @param object the object that {@link AccessibleObject#setAccessible(boolean)} should be called on.\n   * @throws JsonIOException if making the object accessible fails\n   */\n  private static void makeAccessible(String description, AccessibleObject object) throws JsonIOException {\n    try {\n      object.setAccessible(true);\n    } catch (Exception exception) {\n      throw new JsonIOException(\"Failed making \" + description + \"' accessible; either change its visibility \"\n              + \"or write a custom TypeAdapter for its declaring type\", exception);\n    }\n  }",
          "uniqueId": "a0dc7bfdddfe488510edde8d8abb0727743394c4_11_26_50_64_25_34"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "8451c1fa63f5198daf38498869836e85c85bdd08",
      "url": "https://github.com/google/gson/commit/8451c1fa63f5198daf38498869836e85c85bdd08",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public T read(JsonReader in) throws IOException {\n      if (delegate == null) {\n        throw new IllegalStateException();\n      }\n      return delegate.read(in);\n    }\n@Override public void write(JsonWriter out, T value) throws IOException {\n      if (delegate == null) {\n        throw new IllegalStateException();\n      }\n      delegate.write(out, value);\n    }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "@Override public T read(JsonReader in) throws IOException {\n      return delegate().read(in);\n    }\n@Override public void write(JsonWriter out, T value) throws IOException {\n      delegate().write(out, value);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate TypeAdapter<T> delegate() {\n      if (delegate == null) {\n        throw new IllegalStateException(\"Delegate has not been set yet\");\n      }\n      return delegate;\n    }\nExtractedCodeFragments:\nprivate TypeAdapter<T> delegate() {\n      if (delegate == null) {\n        throw new IllegalStateException(\"Delegate has not been set yet\");\n      }\n      return delegate;\n    }",
          "uniqueId": "8451c1fa63f5198daf38498869836e85c85bdd08_1328_1333_1329_1334_1340_1342"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "5269701679295d8143ec578e25f68fe25594f46a",
      "url": "https://github.com/google/gson/commit/5269701679295d8143ec578e25f68fe25594f46a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public String nextName() throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = result;\n    push(entry.getValue());\n    return result;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
          "sourceCodeAfterRefactoring": "@Override public String nextName() throws IOException {\n    return nextName(false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String nextName(boolean skipName) throws IOException {\n    expect(JsonToken.NAME);\n    Iterator<?> i = (Iterator<?>) peekStack();\n    Map.Entry<?, ?> entry = (Map.Entry<?, ?>) i.next();\n    String result = (String) entry.getKey();\n    pathNames[stackSize - 1] = skipName ? \"<skipped>\" : result;\n    push(entry.getValue());\n    return result;\n  }",
          "uniqueId": "5269701679295d8143ec578e25f68fe25594f46a_168_176_169_177_179_181"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6b9db2e44948d410b2dbede6a4a8667782d6c04b",
      "url": "https://github.com/google/gson/commit/6b9db2e44948d410b2dbede6a4a8667782d6c04b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method deserializes the specified Json into an object of the specified class. It is not\n   * suitable to use if the specified class is a generic type since it will not have the generic\n   * type information because of the Type Erasure feature of Java. Therefore, this method should not\n   * be used if the desired type is a generic type. Note that this method works fine if the any of\n   * the fields of the specified object are generics, just the object itself should not be a\n   * generic type. For the cases when the object is of generic type, invoke\n   * {@link #fromJson(String, Type)}. If you have the Json in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, Class)} instead.\n   *\n   * <p>An exception is thrown if the JSON string has multiple top-level JSON elements,\n   * or if there is trailing data.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * classOfT\n   */\n  public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the specified Json into an object of the specified type. This method\n   * is useful if the specified object is a generic type. For non-generic objects, use\n   * {@link #fromJson(String, Class)} instead. If you have the Json in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, Type)} instead.\n   *\n   * <p>An exception is thrown if the JSON string has multiple top-level JSON elements,\n   * or if there is trailing data.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   */\n  public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    @SuppressWarnings(\"unchecked\")\n    T target = (T) fromJson(reader, typeOfT);\n    return target;\n  }\n/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified class. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a\n   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements,\n   * or if there is trailing data.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing the Json from which the object is to be deserialized.\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = newJsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements,\n   * or if there is trailing data.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    @SuppressWarnings(\"unchecked\")\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n/**\n   * Reads the next JSON value from {@code reader} and convert it to an object\n   * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\n   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully.\n   *\n   * <p>Unlike the other {@code fromJson} methods, no exception is thrown if the JSON data has\n   * multiple top-level JSON elements, or if there is trailing data.\n   *\n   * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},\n   * regardless of the lenient mode setting of the provided reader. The lenient mode setting\n   * of the reader is restored once this method returns.\n   *\n   * @throws JsonIOException if there was a problem writing to the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   */\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      @SuppressWarnings(\"unchecked\")\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } catch (AssertionError e) {\n      AssertionError error = new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage());\n      error.initCause(e);\n      throw error;\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\n/**\n   * This method deserializes the Json read from the specified parse tree into an object of the\n   * specified type. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(JsonElement, Type)}.\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param classOfT The class of T\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   */\n  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n    Object object = fromJson(json, (Type) classOfT);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the Json read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return (T) fromJson(new JsonTreeReader(json), typeOfT);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method deserializes the specified JSON into an object of the specified type. This method\n   * is useful if the specified object is a generic type. For non-generic objects, use\n   * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON string has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(String, Class)\n   */\n  public <T> T fromJson(String json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    return fromJson(reader, typeOfT);\n  }\n/**\n   * This method deserializes the specified JSON into an object of the specified type. This method\n   * is useful if the specified object is a generic type. For non-generic objects, use\n   * {@link #fromJson(String, Class)} instead. If you have the JSON in a {@link Reader} instead of\n   * a String, use {@link #fromJson(Reader, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON string has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the string from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(String, Class)\n   */\n  public <T> T fromJson(String json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    StringReader reader = new StringReader(json);\n    return fromJson(reader, typeOfT);\n  }\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified class. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(Reader, TypeToken)}. If you have the JSON in a String form instead of a\n   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing the JSON from which the object is to be deserialized.\n   * @param classOfT the class of T\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.2\n   *\n   * @see #fromJson(String, Class)\n   * @see #fromJson(Reader, TypeToken)\n   */\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    T object = fromJson(json, TypeToken.get(classOfT));\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and\n   * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\n   * prefer using {@link #fromJson(Reader, TypeToken)} instead since its return type is based\n   * on the {@code TypeToken} and is therefore more type-safe.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, Type)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.2\n   *\n   * @see #fromJson(String, Type)\n   * @see #fromJson(Reader, Class)\n   * @see #fromJson(Reader, TypeToken)\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    return (T) fromJson(json, TypeToken.get(typeOfT));\n  }\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\n/**\n   * This method deserializes the JSON read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonElement, Class)\n   */\n  public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return fromJson(new JsonTreeReader(json), typeOfT);\n  }\n/**\n   * This method deserializes the JSON read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * <p>Since {@code Type} is not parameterized by T, this method is not type-safe and\n   * should be used carefully. If you are creating the {@code Type} from a {@link TypeToken},\n   * prefer using {@link #fromJson(JsonElement, TypeToken)} instead since its return type is based\n   * on the {@code TypeToken} and is therefore more type-safe.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src\n   * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   *\n   * @see #fromJson(Reader, Type)\n   * @see #fromJson(JsonElement, Class)\n   * @see #fromJson(JsonElement, TypeToken)\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n    return (T) fromJson(json, TypeToken.get(typeOfT));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * Reads the next JSON value from {@code reader} and converts it to an object\n   * of type {@code typeOfT}. Returns {@code null}, if the {@code reader} is at EOF.\n   * This method is useful if the specified object is a generic type. For non-generic objects,\n   * {@link #fromJson(JsonReader, Type)} can be called, or {@link TypeToken#get(Class)} can\n   * be used to create the type token.\n   *\n   * <p>Unlike the other {@code fromJson} methods, no exception is thrown if the JSON data has\n   * multiple top-level JSON elements, or if there is trailing data.\n   *\n   * <p>The JSON data is parsed in {@linkplain JsonReader#setLenient(boolean) lenient mode},\n   * regardless of the lenient mode setting of the provided reader. The lenient mode setting\n   * of the reader is restored once this method returns.\n   *\n   * @param <T> the type of the desired object\n   * @param reader the reader whose next JSON value should be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the JsonReader. Returns {@code null} if {@code reader} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the JsonReader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of the type typeOfT\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonReader, Type)\n   */\n  public <T> T fromJson(JsonReader reader, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeAdapter<T> typeAdapter = getAdapter(typeOfT);\n      T object = typeAdapter.read(reader);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } catch (AssertionError e) {\n      AssertionError error = new AssertionError(\"AssertionError (GSON \" + GsonBuildConfig.VERSION + \"): \" + e.getMessage());\n      error.initCause(e);\n      throw error;\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the JSON in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, TypeToken)} instead.\n   *\n   * <p>An exception is thrown if the JSON data has multiple top-level JSON elements, or if there\n   * is trailing data. Use {@link #fromJson(JsonReader, TypeToken)} if this behavior is not desired.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing JSON from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the Reader. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type of typeOfT\n   *\n   * @see #fromJson(String, TypeToken)\n   * @see #fromJson(Reader, Class)\n   */\n  public <T> T fromJson(Reader json, TypeToken<T> typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }\nExtractedCodeFragments:\n/**\n   * This method deserializes the JSON read from the specified parse tree into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(JsonElement, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the root of the parse tree of {@link JsonElement}s from which the object is to\n   * be deserialized\n   * @param typeOfT The specific genericized type of src. You should create an anonymous subclass of\n   * {@code TypeToken} with the specific generic type arguments. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * new TypeToken<Collection<Foo>>(){}\n   * </pre>\n   * @return an object of type T from the JSON. Returns {@code null} if {@code json} is {@code null}\n   * or if {@code json} is empty.\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n   * @since 1.3\n   *\n   * @see #fromJson(Reader, TypeToken)\n   * @see #fromJson(JsonElement, Class)\n   */\n  public <T> T fromJson(JsonElement json, TypeToken<T> typeOfT) throws JsonSyntaxException {\n    if (json == null) {\n      return null;\n    }\n    return fromJson(new JsonTreeReader(json), typeOfT);\n  }",
          "uniqueId": "6b9db2e44948d410b2dbede6a4a8667782d6c04b_915_939_1091_1120_999_1029"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "51a72b463bc447d32fe8e594afa1980fd34e52d6",
      "url": "https://github.com/google/gson/commit/51a72b463bc447d32fe8e594afa1980fd34e52d6",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * convenience method to get this array as a {@link Number} if it contains a single element.\n   *\n   * @return get this element as a number if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid Number.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public Number getAsNumber() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsNumber();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a {@link String} if it contains a single element.\n   *\n   * @return get this element as a String if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid String.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public String getAsString() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsString();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a double if it contains a single element.\n   *\n   * @return get this element as a double if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid double.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public double getAsDouble() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsDouble();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a {@link BigDecimal} if it contains a single element.\n   *\n   * @return get this element as a {@link BigDecimal} if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigDecimal}.\n   * @throws IllegalStateException if the array has more than one element.\n   * @since 1.2\n   */\n  @Override\n  public BigDecimal getAsBigDecimal() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigDecimal();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a {@link BigInteger} if it contains a single element.\n   *\n   * @return get this element as a {@link BigInteger} if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive}.\n   * @throws NumberFormatException if the element at index 0 is not a valid {@link BigInteger}.\n   * @throws IllegalStateException if the array has more than one element.\n   * @since 1.2\n   */\n  @Override\n  public BigInteger getAsBigInteger() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBigInteger();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a float if it contains a single element.\n   *\n   * @return get this element as a float if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid float.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public float getAsFloat() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsFloat();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a long if it contains a single element.\n   *\n   * @return get this element as a long if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid long.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public long getAsLong() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsLong();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as an integer if it contains a single element.\n   *\n   * @return get this element as an integer if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid integer.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public int getAsInt() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsInt();\n    }\n    throw new IllegalStateException();\n  }\n@Override\n  public byte getAsByte() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsByte();\n    }\n    throw new IllegalStateException();\n  }\n@Deprecated\n  @Override\n  public char getAsCharacter() {\n    if (elements.size() == 1) {\n      JsonElement element = elements.get(0);\n      return element.getAsCharacter();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a primitive short if it contains a single element.\n   *\n   * @return get this element as a primitive short if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid short.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public short getAsShort() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsShort();\n    }\n    throw new IllegalStateException();\n  }\n/**\n   * convenience method to get this array as a boolean if it contains a single element.\n   *\n   * @return get this element as a boolean if it is single element array.\n   * @throws ClassCastException if the element in the array is of not a {@link JsonPrimitive} and\n   * is not a valid boolean.\n   * @throws IllegalStateException if the array has more than one element.\n   */\n  @Override\n  public boolean getAsBoolean() {\n    if (elements.size() == 1) {\n      return elements.get(0).getAsBoolean();\n    }\n    throw new IllegalStateException();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonArray.java",
          "sourceCodeAfterRefactoring": "/**\n   * Convenience method to get this array as a {@link Number} if it contains a single element.\n   * This method calls {@link JsonElement#getAsNumber()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a number if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public Number getAsNumber() {\n    return getAsSingleElement().getAsNumber();\n  }\n/**\n   * Convenience method to get this array as a {@link String} if it contains a single element.\n   * This method calls {@link JsonElement#getAsString()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a String if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public String getAsString() {\n    return getAsSingleElement().getAsString();\n  }\n/**\n   * Convenience method to get this array as a double if it contains a single element.\n   * This method calls {@link JsonElement#getAsDouble()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a double if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public double getAsDouble() {\n    return getAsSingleElement().getAsDouble();\n  }\n/**\n   * Convenience method to get this array as a {@link BigDecimal} if it contains a single element.\n   * This method calls {@link JsonElement#getAsBigDecimal()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a {@link BigDecimal} if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @since 1.2\n   */\n  @Override\n  public BigDecimal getAsBigDecimal() {\n    return getAsSingleElement().getAsBigDecimal();\n  }\n/**\n   * Convenience method to get this array as a {@link BigInteger} if it contains a single element.\n   * This method calls {@link JsonElement#getAsBigInteger()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a {@link BigInteger} if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @since 1.2\n   */\n  @Override\n  public BigInteger getAsBigInteger() {\n    return getAsSingleElement().getAsBigInteger();\n  }\n/**\n   * Convenience method to get this array as a float if it contains a single element.\n   * This method calls {@link JsonElement#getAsFloat()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a float if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public float getAsFloat() {\n    return getAsSingleElement().getAsFloat();\n  }\n/**\n   * Convenience method to get this array as a long if it contains a single element.\n   * This method calls {@link JsonElement#getAsLong()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a long if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public long getAsLong() {\n    return getAsSingleElement().getAsLong();\n  }\n/**\n   * Convenience method to get this array as an integer if it contains a single element.\n   * This method calls {@link JsonElement#getAsInt()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as an integer if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public int getAsInt() {\n    return getAsSingleElement().getAsInt();\n  }\n/**\n   * Convenience method to get this array as a primitive byte if it contains a single element.\n   * This method calls {@link JsonElement#getAsByte()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive byte if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public byte getAsByte() {\n    return getAsSingleElement().getAsByte();\n  }\n/**\n   * Convenience method to get this array as a character if it contains a single element.\n   * This method calls {@link JsonElement#getAsCharacter()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive short if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   * @deprecated This method is misleading, as it does not get this element as a char but rather as\n   * a string's first character.\n   */\n  @Deprecated\n  @Override\n  public char getAsCharacter() {\n    return getAsSingleElement().getAsCharacter();\n  }\n/**\n   * Convenience method to get this array as a primitive short if it contains a single element.\n   * This method calls {@link JsonElement#getAsShort()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a primitive short if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public short getAsShort() {\n    return getAsSingleElement().getAsShort();\n  }\n/**\n   * Convenience method to get this array as a boolean if it contains a single element.\n   * This method calls {@link JsonElement#getAsBoolean()} on the element, therefore any\n   * of the exceptions declared by that method can occur.\n   *\n   * @return this element as a boolean if it is single element array.\n   * @throws IllegalStateException if the array is empty or has more than one element.\n   */\n  @Override\n  public boolean getAsBoolean() {\n    return getAsSingleElement().getAsBoolean();\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }\nExtractedCodeFragments:\nprivate JsonElement getAsSingleElement() {\n    int size = elements.size();\n    if (size == 1) {\n      return elements.get(0);\n    }\n    throw new IllegalStateException(\"Array must have size 1, but has size \" + size);\n  }",
          "uniqueId": "51a72b463bc447d32fe8e594afa1980fd34e52d6_216_230_221_227_229_240"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "46b97bf15633929e7db6c43007a6b03e852e2aee",
      "url": "https://github.com/google/gson/commit/46b97bf15633929e7db6c43007a6b03e852e2aee",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.gson = gson;\n    this.typeToken = typeToken;\n    this.skipPast = skipPast;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java",
          "sourceCodeAfterRefactoring": "public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n                         Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n    this(serializer, deserializer, gson, typeToken, skipPast, true);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast, boolean nullSafe) {\n    this.serializer = serializer;\n    this.deserializer = deserializer;\n    this.gson = gson;\n    this.typeToken = typeToken;\n    this.skipPast = skipPast;\n    this.nullSafe = nullSafe;\n  }",
          "uniqueId": "46b97bf15633929e7db6c43007a6b03e852e2aee_52_59_53_61_63_66"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "2d01d6a20f39881c692977564c1ea591d9f39027",
      "url": "https://github.com/google/gson/commit/2d01d6a20f39881c692977564c1ea591d9f39027",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public JsonElement read(JsonReader in) throws IOException {\n      if (in instanceof JsonTreeReader) {\n        return ((JsonTreeReader) in).nextJsonElement();\n      }\n\n      switch (in.peek()) {\n      case STRING:\n        return new JsonPrimitive(in.nextString());\n      case NUMBER:\n        String number = in.nextString();\n        return new JsonPrimitive(new LazilyParsedNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(in.nextBoolean());\n      case NULL:\n        in.nextNull();\n        return JsonNull.INSTANCE;\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        in.beginArray();\n        while (in.hasNext()) {\n          array.add(read(in));\n        }\n        in.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        in.beginObject();\n        while (in.hasNext()) {\n          object.add(in.nextName(), read(in));\n        }\n        in.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java",
          "sourceCodeAfterRefactoring": "@Override public JsonElement read(JsonReader in) throws IOException {\n      if (in instanceof JsonTreeReader) {\n        return ((JsonTreeReader) in).nextJsonElement();\n      }\n\n      // Either JsonArray or JsonObject\n      JsonElement current;\n      JsonToken peeked = in.peek();\n\n      current = tryBeginNesting(in, peeked);\n      if (current == null) {\n        return readTerminal(in, peeked);\n      }\n\n      Deque<JsonElement> stack = new ArrayDeque<>();\n\n      while (true) {\n        while (in.hasNext()) {\n          String name = null;\n          // Name is only used for JSON object members\n          if (current instanceof JsonObject) {\n            name = in.nextName();\n          }\n\n          peeked = in.peek();\n          JsonElement value = tryBeginNesting(in, peeked);\n          boolean isNesting = value != null;\n\n          if (value == null) {\n            value = readTerminal(in, peeked);\n          }\n\n          if (current instanceof JsonArray) {\n            ((JsonArray) current).add(value);\n          } else {\n            ((JsonObject) current).add(name, value);\n          }\n\n          if (isNesting) {\n            stack.addLast(current);\n            current = value;\n          }\n        }\n\n        // End current element\n        if (current instanceof JsonArray) {\n          in.endArray();\n        } else {\n          in.endObject();\n        }\n\n        if (stack.isEmpty()) {\n          return current;\n        } else {\n          // Continue with enclosing element\n          current = stack.removeLast();\n        }\n      }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Tries to begin reading a JSON array or JSON object, returning {@code null} if\n     * the next element is neither of those.\n     */\n    private JsonElement tryBeginNesting(JsonReader in, JsonToken peeked) throws IOException {\n      switch (peeked) {\n        case BEGIN_ARRAY:\n          in.beginArray();\n          return new JsonArray();\n        case BEGIN_OBJECT:\n          in.beginObject();\n          return new JsonObject();\n        default:\n          return null;\n      }\n    }",
          "uniqueId": "2d01d6a20f39881c692977564c1ea591d9f39027_698_737_699_714_735_793"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public Object read(JsonReader in) throws IOException {\n    JsonToken token = in.peek();\n    switch (token) {\n    case BEGIN_ARRAY:\n      List<Object> list = new ArrayList<>();\n      in.beginArray();\n      while (in.hasNext()) {\n        list.add(read(in));\n      }\n      in.endArray();\n      return list;\n\n    case BEGIN_OBJECT:\n      Map<String, Object> map = new LinkedTreeMap<>();\n      in.beginObject();\n      while (in.hasNext()) {\n        map.put(in.nextName(), read(in));\n      }\n      in.endObject();\n      return map;\n\n    case STRING:\n      return in.nextString();\n\n    case NUMBER:\n      return toNumberStrategy.readNumber(in);\n\n    case BOOLEAN:\n      return in.nextBoolean();\n\n    case NULL:\n      in.nextNull();\n      return null;\n\n    default:\n      throw new IllegalStateException();\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java",
          "sourceCodeAfterRefactoring": "@Override public Object read(JsonReader in) throws IOException {\n    // Either List or Map\n    Object current;\n    JsonToken peeked = in.peek();\n\n    current = tryBeginNesting(in, peeked);\n    if (current == null) {\n      return readTerminal(in, peeked);\n    }\n\n    Deque<Object> stack = new ArrayDeque<>();\n\n    while (true) {\n      while (in.hasNext()) {\n        String name = null;\n        // Name is only used for JSON object members\n        if (current instanceof Map) {\n          name = in.nextName();\n        }\n\n        peeked = in.peek();\n        Object value = tryBeginNesting(in, peeked);\n        boolean isNesting = value != null;\n\n        if (value == null) {\n          value = readTerminal(in, peeked);\n        }\n\n        if (current instanceof List) {\n          @SuppressWarnings(\"unchecked\")\n          List<Object> list = (List<Object>) current;\n          list.add(value);\n        } else {\n          @SuppressWarnings(\"unchecked\")\n          Map<String, Object> map = (Map<String, Object>) current;\n          map.put(name, value);\n        }\n\n        if (isNesting) {\n          stack.addLast(current);\n          current = value;\n        }\n      }\n\n      // End current element\n      if (current instanceof List) {\n        in.endArray();\n      } else {\n        in.endObject();\n      }\n\n      if (stack.isEmpty()) {\n        return current;\n      } else {\n        // Continue with enclosing element\n        current = stack.removeLast();\n      }\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Tries to begin reading a JSON array or JSON object, returning {@code null} if\n   * the next element is neither of those.\n   */\n  private Object tryBeginNesting(JsonReader in, JsonToken peeked) throws IOException {\n    switch (peeked) {\n      case BEGIN_ARRAY:\n        in.beginArray();\n        return new ArrayList<>();\n      case BEGIN_OBJECT:\n        in.beginObject();\n        return new LinkedTreeMap<>();\n      default:\n        return null;\n    }\n  }",
          "uniqueId": "2d01d6a20f39881c692977564c1ea591d9f39027_73_110_74_89_109_167"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "e82637c4856b026f1ff2575c5e3d60c516391b79",
      "url": "https://github.com/google/gson/commit/e82637c4856b026f1ff2575c5e3d60c516391b79",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Constructors for common interface types like Map and List and their\n   * subtypes.\n   */\n  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n      final Type type, Class<? super T> rawType) {\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }\n        };\n      } else if (EnumSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @SuppressWarnings(\"rawtypes\")\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                return (T) EnumSet.noneOf((Class)elementType);\n              } else {\n                throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayDeque<Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\n      // and constructor parameter might have completely different meaning\n      if (rawType == EnumMap.class) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            if (type instanceof ParameterizedType) {\n              Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n              if (elementType instanceof Class) {\n                @SuppressWarnings(\"rawtypes\")\n                T map = (T) new EnumMap((Class) elementType);\n                return map;\n              } else {\n                throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\n              }\n            } else {\n              throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\n            }\n          }\n        };\n      } else if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap<Object, Object>();\n          }\n        };\n      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentHashMap<Object, Object>();\n          }\n        };\n      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }\n        };\n      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }\n        };\n      }\n    }\n\n    return null;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java",
          "sourceCodeAfterRefactoring": "/**\n   * Constructors for common interface types like Map and List and their\n   * subtypes.\n   */\n  @SuppressWarnings(\"unchecked\") // use runtime checks to guarantee that 'T' is what it is\n  private static <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n      final Type type, Class<? super T> rawType) {\n\n    /*\n     * IMPORTANT: Must only create instances for classes with public no-args constructor.\n     * For classes with special constructors / factory methods (e.g. EnumSet)\n     * `newSpecialCollectionConstructor` defined above must be used, to avoid no-args\n     * constructor check (which is called before this method) detecting internal no-args\n     * constructors which might be added in a future JDK version\n     */\n\n    if (Collection.class.isAssignableFrom(rawType)) {\n      if (SortedSet.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeSet<Object>();\n          }\n        };\n      } else if (Set.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashSet<Object>();\n          }\n        };\n      } else if (Queue.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayDeque<Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ArrayList<Object>();\n          }\n        };\n      }\n    }\n\n    if (Map.class.isAssignableFrom(rawType)) {\n      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentSkipListMap<Object, Object>();\n          }\n        };\n      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new ConcurrentHashMap<Object, Object>();\n          }\n        };\n      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new TreeMap<Object, Object>();\n          }\n        };\n      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedHashMap<Object, Object>();\n          }\n        };\n      } else {\n        return new ObjectConstructor<T>() {\n          @Override public T construct() {\n            return (T) new LinkedTreeMap<String, Object>();\n          }\n        };\n      }\n    }\n\n    return null;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Creates constructors for special JDK collection types which do not have a public no-args constructor.\n   */\n  private static <T> ObjectConstructor<T> newSpecialCollectionConstructor(final Type type, Class<? super T> rawType) {\n    if (EnumSet.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          if (type instanceof ParameterizedType) {\n            Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n            if (elementType instanceof Class) {\n              @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n              T set = (T) EnumSet.noneOf((Class)elementType);\n              return set;\n            } else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          } else {\n            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n          }\n        }\n      };\n    }\n    // Only support creation of EnumMap, but not of custom subtypes; for them type parameters\n    // and constructor parameter might have completely different meaning\n    else if (rawType == EnumMap.class) {\n      return new ObjectConstructor<T>() {\n        @Override public T construct() {\n          if (type instanceof ParameterizedType) {\n            Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n            if (elementType instanceof Class) {\n              @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n              T map = (T) new EnumMap((Class) elementType);\n              return map;\n            } else {\n              throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\n            }\n          } else {\n            throw new JsonIOException(\"Invalid EnumMap type: \" + type.toString());\n          }\n        }\n      };\n    }\n\n    return null;\n  }",
          "uniqueId": "e82637c4856b026f1ff2575c5e3d60c516391b79_157_263_139_183_260_340"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Check if the class can be instantiated by unsafe allocator. If the instance has interface or abstract modifiers\n   * throw an {@link java.lang.UnsupportedOperationException}\n   * @param c instance of the class to be checked\n   */\n  static void assertInstantiable(Class<?> c) {\n    int modifiers = c.getModifiers();\n    if (Modifier.isInterface(modifiers)) {\n      throw new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n    }\n    if (Modifier.isAbstract(modifiers)) {\n      throw new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java",
          "sourceCodeAfterRefactoring": "/**\n   * Asserts that the class is instantiable. This check should have already occurred\n   * in {@link ConstructorConstructor}; this check here acts as safeguard since trying\n   * to use Unsafe for non-instantiable classes might crash the JVM on some devices.\n   */\n  private static void assertInstantiable(Class<?> c) {\n    String exceptionMessage = checkInstantiable(c);\n    if (exceptionMessage != null) {\n      throw new AssertionError(\"UnsafeAllocator is used for non-instantiable type: \" + exceptionMessage);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Check if the class can be instantiated by Unsafe allocator. If the instance has interface or abstract modifiers\n   * return an exception message.\n   * @param c instance of the class to be checked\n   * @return if instantiable {@code null}, else a non-{@code null} exception message\n   */\n  static String checkInstantiable(Class<?> c) {\n    int modifiers = c.getModifiers();\n    if (Modifier.isInterface(modifiers)) {\n      return \"Interfaces can't be instantiated! Register an InstanceCreator \"\n          + \"or a TypeAdapter for this type. Interface name: \" + c.getName();\n    }\n    if (Modifier.isAbstract(modifiers)) {\n      return \"Abstract classes can't be instantiated! Register an InstanceCreator \"\n          + \"or a TypeAdapter for this type. Class name: \" + c.getName();\n    }\n    return null;\n  }",
          "uniqueId": "e82637c4856b026f1ff2575c5e3d60c516391b79_110_123_34_51_53_63"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b4dab86b105c85e6b7d7106c9ff11e3e923e3485",
      "url": "https://github.com/google/gson/commit/b4dab86b105c85e6b7d7106c9ff11e3e923e3485",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (++i < stackSize && stack[i] instanceof Iterator) {\n          result.append('[').append(pathIndices[i]).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (++i < stackSize && stack[i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java",
          "sourceCodeAfterRefactoring": "@Override public String getPath() {\n    return getPath(false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String getPath(boolean usePreviousPath) {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      if (stack[i] instanceof JsonArray) {\n        if (++i < stackSize && stack[i] instanceof Iterator) {\n          int pathIndex = pathIndices[i];\n          // If index is last path element it points to next array element; have to decrement\n          // `- 1` covers case where iterator for next element is on stack\n          // `- 2` covers case where peek() already pushed next element onto stack\n          if (usePreviousPath && pathIndex > 0 && (i == stackSize - 1 || i == stackSize - 2)) {\n            pathIndex--;\n          }\n          result.append('[').append(pathIndex).append(']');\n        }\n      } else if (stack[i] instanceof JsonObject) {\n        if (++i < stackSize && stack[i] instanceof Iterator) {\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n        }\n      }\n    }\n    return result.toString();\n  }",
          "uniqueId": "b4dab86b105c85e6b7d7106c9ff11e3e923e3485_307_324_307_331_337_339"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n   * the current location in the JSON value.\n   */\n  public String getPath() {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0, size = stackSize; i < size; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          result.append('[').append(pathIndices[i]).append(']');\n          break;\n\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/stream/JsonReader.java",
          "sourceCodeAfterRefactoring": "/**\n   * Returns a <a href=\"https://goessner.net/articles/JsonPath/\">JsonPath</a>\n   * in <i>dot-notation</i> to the next (or current) location in the JSON document:\n   * <ul>\n   *   <li>For JSON arrays the path points to the index of the next element (even\n   *   if there are no further elements).</li>\n   *   <li>For JSON objects the path points to the last property, or to the current\n   *   property if its value has not been consumed yet.</li>\n   * </ul>\n   *\n   * <p>This method can be useful to add additional context to exception messages\n   * <i>before</i> a value is consumed, for example when the {@linkplain #peek() peeked}\n   * token is unexpected.\n   */\n  public String getPath() {\n    return getPath(false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String getPath(boolean usePreviousPath) {\n    StringBuilder result = new StringBuilder().append('$');\n    for (int i = 0; i < stackSize; i++) {\n      switch (stack[i]) {\n        case JsonScope.EMPTY_ARRAY:\n        case JsonScope.NONEMPTY_ARRAY:\n          int pathIndex = pathIndices[i];\n          // If index is last path element it points to next array element; have to decrement\n          if (usePreviousPath && pathIndex > 0 && i == stackSize - 1) {\n            pathIndex--;\n          }\n          result.append('[').append(pathIndex).append(']');\n          break;\n        case JsonScope.EMPTY_OBJECT:\n        case JsonScope.DANGLING_NAME:\n        case JsonScope.NONEMPTY_OBJECT:\n          result.append('.');\n          if (pathNames[i] != null) {\n            result.append(pathNames[i]);\n          }\n          break;\n        case JsonScope.NONEMPTY_DOCUMENT:\n        case JsonScope.EMPTY_DOCUMENT:\n        case JsonScope.CLOSED:\n          break;\n      }\n    }\n    return result.toString();\n  }",
          "uniqueId": "b4dab86b105c85e6b7d7106c9ff11e3e923e3485_1457_1486_1457_1485_1504_1520"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "4fb215c9df408ef48bad1288ef23c68b7910a7a3",
      "url": "https://github.com/google/gson/commit/4fb215c9df408ef48bad1288ef23c68b7910a7a3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void testNullSerializationAndDeserialization(Class<?> c) {\n    assertEquals(\"null\", gson.toJson(null, c));\n    assertEquals(null, gson.fromJson(\"null\", c));\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java",
          "sourceCodeAfterRefactoring": "private void testNullSerializationAndDeserialization(Class<?> c) {\n    testNullSerializationAndDeserialization(gson, c);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static void testNullSerializationAndDeserialization(Gson gson, Class<?> c) {\n    assertEquals(\"null\", gson.toJson(null, c));\n    assertEquals(null, gson.fromJson(\"null\", c));\n  }",
          "uniqueId": "4fb215c9df408ef48bad1288ef23c68b7910a7a3_185_188_189_192_185_187"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "c5a3f21fbad3828deba1deb88168e1f76829f807",
      "url": "https://github.com/google/gson/commit/c5a3f21fbad3828deba1deb88168e1f76829f807",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   */\r\n  public JsonElement parse(String json) throws JsonSyntaxException {\r\n    return parse(new StringReader(json));\r\n  }\n/**\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   */\r\n  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\r\n    try {\r\n      JsonReader jsonReader = new JsonReader(json);\r\n      JsonElement element = parse(jsonReader);\r\n      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\r\n        throw new JsonSyntaxException(\"Did not consume the entire document.\");\r\n      }\r\n      return element;\r\n    } catch (MalformedJsonException e) {\r\n      throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n      throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n      throw new JsonSyntaxException(e);\r\n    }\r\n  }\n/**\r\n   * Returns the next value from the JSON stream as a parse tree.\r\n   *\r\n   * @throws JsonParseException if there is an IOException or if the specified\r\n   *     text is not valid JSON\r\n   * @since 1.6\r\n   */\r\n  public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {\r\n    boolean lenient = json.isLenient();\r\n    json.setLenient(true);\r\n    try {\r\n      return Streams.parse(json);\r\n    } catch (StackOverflowError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } finally {\r\n      json.setLenient(lenient);\r\n    }\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParser.java",
          "sourceCodeAfterRefactoring": "/** @deprecated Use {@link JsonParser#parseString} */\r\n  @Deprecated\r\n  public JsonElement parse(String json) throws JsonSyntaxException {\r\n    return parseString(json);\r\n  }\n/** @deprecated Use {@link JsonParser#parseReader(Reader)} */\r\n  @Deprecated\r\n  public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\r\n    return parseReader(json);\r\n  }\n/**\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param reader JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   */\r\n  public static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {\r\n    try {\r\n      JsonReader jsonReader = new JsonReader(reader);\r\n      JsonElement element = parseReader(jsonReader);\r\n      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\r\n        throw new JsonSyntaxException(\"Did not consume the entire document.\");\r\n      }\r\n      return element;\r\n    } catch (MalformedJsonException e) {\r\n      throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n      throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n      throw new JsonSyntaxException(e);\r\n    }\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   */\r\n  public static JsonElement parseString(String json) throws JsonSyntaxException {\r\n    return parseReader(new StringReader(json));\r\n  }\nExtractedCodeFragments:\n/**\r\n   * Parses the specified JSON string into a parse tree\r\n   *\r\n   * @param reader JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON\r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   */\r\n  public static JsonElement parseReader(Reader reader) throws JsonIOException, JsonSyntaxException {\r\n    try {\r\n      JsonReader jsonReader = new JsonReader(reader);\r\n      JsonElement element = parseReader(jsonReader);\r\n      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\r\n        throw new JsonSyntaxException(\"Did not consume the entire document.\");\r\n      }\r\n      return element;\r\n    } catch (MalformedJsonException e) {\r\n      throw new JsonSyntaxException(e);\r\n    } catch (IOException e) {\r\n      throw new JsonIOException(e);\r\n    } catch (NumberFormatException e) {\r\n      throw new JsonSyntaxException(e);\r\n    }\r\n  }\nExtractedCodeFragments:\n/**\r\n   * Returns the next value from the JSON stream as a parse tree.\r\n   *\r\n   * @throws JsonParseException if there is an IOException or if the specified\r\n   *     text is not valid JSON\r\n   */\r\n  public static JsonElement parseReader(JsonReader reader)\r\n      throws JsonIOException, JsonSyntaxException {\r\n    boolean lenient = reader.isLenient();\r\n    reader.setLenient(true);\r\n    try {\r\n      return Streams.parse(reader);\r\n    } catch (StackOverflowError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + reader + \" to Json\", e);\r\n    } finally {\r\n      reader.setLenient(lenient);\r\n    }\r\n  }",
          "uniqueId": "c5a3f21fbad3828deba1deb88168e1f76829f807_36_46_39_48_95_99"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "a6890bbaba29fb1074388c06bf0c231f8e06b4f2",
      "url": "https://github.com/google/gson/commit/a6890bbaba29fb1074388c06bf0c231f8e06b4f2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static int determineMajorJavaVersion() {\n    String[] parts = System.getProperty(\"java.version\").split(\"[._]\");\n    int firstVer = Integer.parseInt(parts[0]);\n    if (firstVer == 1 && parts.length > 1) {\n      return Integer.parseInt(parts[1]);\n    } else {\n      return firstVer;\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/util/VersionUtils.java",
          "sourceCodeAfterRefactoring": "static int getMajorJavaVersion(String javaVersion) {\n    int version = parseDotted(javaVersion);\n    if (version == -1) {\n      version = extractBeginningInt(javaVersion);\n    }\n    if (version == -1) {\n      return 6;  // Choose minimum supported JDK version as default\n    }\n    return version;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static int parseDotted(String javaVersion) {\n    try {\n      String[] parts = javaVersion.split(\"[._]\");\n      int firstVer = Integer.parseInt(parts[0]);\n      if (firstVer == 1 && parts.length > 1) {\n        return Integer.parseInt(parts[1]);\n      } else {\n        return firstVer;\n      }\n    } catch (NumberFormatException e) {\n      return -1;\n    }\n  }",
          "uniqueId": "a6890bbaba29fb1074388c06bf0c231f8e06b4f2_26_34_46_58_34_43"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "049bf84e6803444282d0ad1c4c43f5359cc1dfe5",
      "url": "https://github.com/google/gson/commit/049bf84e6803444282d0ad1c4c43f5359cc1dfe5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * {@inheritDoc}\n   */\n  @Override\n  public void makeAccessible(AccessibleObject ao) {\n    if (theUnsafe != null && overrideField != null) {\n      long overrideOffset = theUnsafe.objectFieldOffset(overrideField);\n      theUnsafe.putBoolean(ao, overrideOffset, true);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/reflect/UnsafeReflectionAccessor.java",
          "sourceCodeAfterRefactoring": "/** {@inheritDoc} */\n  @Override\n  public void makeAccessible(AccessibleObject ao) {\n    boolean success = makeAccessibleWithUnsafe(ao);\n    if (!success) {\n      try {\n        // unsafe couldn't be found, so try using accessible anyway\n        ao.setAccessible(true);\n      } catch (SecurityException e) {\n        throw new JsonIOException(\"Gson couldn't modify fields for \" + ao\n          + \"\\nand sun.misc.Unsafe not found.\\nEither write a custom type adapter,\"\n          + \" or make fields accessible, or include sun.misc.Unsafe.\", e);\n      }\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nboolean makeAccessibleWithUnsafe(AccessibleObject ao) {\n    if (theUnsafe != null && overrideField != null) {\n      try {\n        Method method = unsafeClass.getMethod(\"objectFieldOffset\", Field.class);\n        long overrideOffset = (Long) method.invoke(theUnsafe, overrideField);  // long overrideOffset = theUnsafe.objectFieldOffset(overrideField);\n        Method putBooleanMethod = unsafeClass.getMethod(\"putBoolean\",  Object.class, long.class, boolean.class);\n        putBooleanMethod.invoke(theUnsafe, ao, overrideOffset, true); // theUnsafe.putBoolean(ao, overrideOffset, true);\n        return true;\n      } catch (Exception ignored) { // do nothing\n      }\n    }\n    return false;\n  }",
          "uniqueId": "049bf84e6803444282d0ad1c4c43f5359cc1dfe5_34_43_54_66_37_51"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "3bf1967c0a315d8a74a1975a9bbc6edbf1009549",
      "url": "https://github.com/google/gson/commit/3bf1967c0a315d8a74a1975a9bbc6edbf1009549",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\n    if (version != Excluder.IGNORE_VERSIONS\n        && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n      return true;\n    }\n\n    if (!serializeInnerClasses && isInnerClass(clazz)) {\n      return true;\n    }\n\n    if (isAnonymousOrLocal(clazz)) {\n      return true;\n    }\n\n    List<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\n    for (ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipClass(clazz)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/Excluder.java",
          "sourceCodeAfterRefactoring": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\n      return excludeClassChecks(clazz) ||\n              excludeClassInStrategy(clazz, serialize);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean excludeClassChecks(Class<?> clazz) {\n      if (version != Excluder.IGNORE_VERSIONS && !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\n          return true;\n      }\n\n      if (!serializeInnerClasses && isInnerClass(clazz)) {\n          return true;\n      }\n\n      if (isAnonymousOrLocal(clazz)) {\n          return true;\n      }\n\n      return false;\n  }",
          "uniqueId": "3bf1967c0a315d8a74a1975a9bbc6edbf1009549_191_213_193_207_209_212"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "03a72e752ef68269990f984c9fd613cfd59224bc",
      "url": "https://github.com/google/gson/commit/03a72e752ef68269990f984c9fd613cfd59224bc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/$Gson$Types.java",
          "sourceCodeAfterRefactoring": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n    return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          // cannot reduce due to infinite recursion\n          return toResolve;\n        } else {\n          visitedTypeVariables.add(typeVariable);\n        }\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }",
          "uniqueId": "03a72e752ef68269990f984c9fd613cfd59224bc_336_406_336_413_332_334"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b8f616c939c652b8540c95fa2b377b8c628ef3ff",
      "url": "https://github.com/google/gson/commit/b8f616c939c652b8540c95fa2b377b8c628ef3ff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java",
          "sourceCodeAfterRefactoring": "public DefaultDateTypeAdapter(int dateStyle, int timeStyle) {\n    this(Date.class,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic DefaultDateTypeAdapter(Class<? extends Date> dateType, int dateStyle, int timeStyle) {\n    this(dateType,\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle, Locale.US),\n        DateFormat.getDateTimeInstance(dateStyle, timeStyle));\n  }",
          "uniqueId": "b8f616c939c652b8540c95fa2b377b8c628ef3ff_59_62_68_72_62_66"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "3360c93a76a74d1182b912052973e08ffa868b43",
      "url": "https://github.com/google/gson/commit/3360c93a76a74d1182b912052973e08ffa868b43",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified class. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a\n   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing the Json from which the object is to be deserialized.\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = new JsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = new JsonReader(json);\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified class. It is not suitable to use if the specified class is a generic type since it\n   * will not have the generic type information because of the Type Erasure feature of Java.\n   * Therefore, this method should not be used if the desired type is a generic type. Note that\n   * this method works fine if the any of the fields of the specified object are generics, just the\n   * object itself should not be a generic type. For the cases when the object is of generic type,\n   * invoke {@link #fromJson(Reader, Type)}. If you have the Json in a String form instead of a\n   * {@link Reader}, use {@link #fromJson(String, Class)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing the Json from which the object is to be deserialized.\n   * @param classOfT the class of T\n   * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n    JsonReader jsonReader = newJsonReader(json);\n    Object object = fromJson(jsonReader, classOfT);\n    assertFullConsumption(object, jsonReader);\n    return Primitives.wrap(classOfT).cast(object);\n  }\n/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n   * @throws JsonIOException if there was a problem reading from the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   * @since 1.2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    JsonReader jsonReader = newJsonReader(json);\n    T object = (T) fromJson(jsonReader, typeOfT);\n    assertFullConsumption(object, jsonReader);\n    return object;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   */\n  public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader = new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }\nExtractedCodeFragments:\n/**\n   * Returns a new JSON writer configured for the settings on this Gson instance.\n   */\n  public JsonReader newJsonReader(Reader reader) {\n    JsonReader jsonReader = new JsonReader(reader);\n    jsonReader.setLenient(lenient);\n    return jsonReader;\n  }",
          "uniqueId": "3360c93a76a74d1182b912052973e08ffa868b43_779_802_716_723_797_820"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "299ee89852f8e3ac510a939a2583515a6f1c3e87",
      "url": "https://github.com/google/gson/commit/299ee89852f8e3ac510a939a2583515a6f1c3e87",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void testIdentity() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(IDENTITY).create();\n    assertEquals(\"{'lowerCamel':1,'UpperCamel':2,'_lowerCamelLeadingUnderscore':3,\" +\n        \"'_UpperCamelLeadingUnderscore':4,'lower_words':5,'UPPER_WORDS':6,\" +\n        \"'annotatedName':7}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testUpperCamelCase() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(UPPER_CAMEL_CASE).create();\n    assertEquals(\"{'LowerCamel':1,'UpperCamel':2,'_LowerCamelLeadingUnderscore':3,\" +\n        \"'_UpperCamelLeadingUnderscore':4,'Lower_words':5,'UPPER_WORDS':6,\" +\n        \"'annotatedName':7}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testUpperCamelCaseWithSpaces() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES).create();\n    assertEquals(\"{'Lower Camel':1,'Upper Camel':2,'_Lower Camel Leading Underscore':3,\" +\n        \"'_ Upper Camel Leading Underscore':4,'Lower_words':5,'U P P E R_ W O R D S':6,\" +\n        \"'annotatedName':7}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testLowerCaseWithUnderscores() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(LOWER_CASE_WITH_UNDERSCORES).create();\n    assertEquals(\"{'lower_camel':1,'upper_camel':2,'_lower_camel_leading_underscore':3,\" +\n        \"'__upper_camel_leading_underscore':4,'lower_words':5,'u_p_p_e_r__w_o_r_d_s':6,\" +\n        \"'annotatedName':7}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testLowerCaseWithDashes() {\n    Gson gson = new GsonBuilder().setFieldNamingPolicy(LOWER_CASE_WITH_DASHES).create();\n    assertEquals(\"{'lower-camel':1,'upper-camel':2,'_lower-camel-leading-underscore':3,\" +\n        \"'_-upper-camel-leading-underscore':4,'lower_words':5,'u-p-p-e-r_-w-o-r-d-s':6,\" +\n        \"'annotatedName':7}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/FieldNamingTest.java",
          "sourceCodeAfterRefactoring": "public void testIdentity() {\n    Gson gson = getGsonWithNamingPolicy(IDENTITY);\n    assertEquals(\"{'lowerCamel':1,'UpperCamel':2,'_lowerCamelLeadingUnderscore':3,\" +\n        \"'_UpperCamelLeadingUnderscore':4,'lower_words':5,'UPPER_WORDS':6,\" +\n        \"'annotatedName':7,'lowerId':8}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testUpperCamelCase() {\n    Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE);\n    assertEquals(\"{'LowerCamel':1,'UpperCamel':2,'_LowerCamelLeadingUnderscore':3,\" +\n        \"'_UpperCamelLeadingUnderscore':4,'Lower_words':5,'UPPER_WORDS':6,\" +\n        \"'annotatedName':7,'LowerId':8}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testUpperCamelCaseWithSpaces() {\n    Gson gson = getGsonWithNamingPolicy(UPPER_CAMEL_CASE_WITH_SPACES);\n    assertEquals(\"{'Lower Camel':1,'Upper Camel':2,'_Lower Camel Leading Underscore':3,\" +\n        \"'_ Upper Camel Leading Underscore':4,'Lower_words':5,'U P P E R_ W O R D S':6,\" +\n        \"'annotatedName':7,'Lower Id':8}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testLowerCaseWithUnderscores() {\n    Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_UNDERSCORES);\n    assertEquals(\"{'lower_camel':1,'upper_camel':2,'_lower_camel_leading_underscore':3,\" +\n        \"'__upper_camel_leading_underscore':4,'lower_words':5,'u_p_p_e_r__w_o_r_d_s':6,\" +\n        \"'annotatedName':7,'lower_id':8}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }\npublic void testLowerCaseWithDashes() {\n    Gson gson = getGsonWithNamingPolicy(LOWER_CASE_WITH_DASHES);\n    assertEquals(\"{'lower-camel':1,'upper-camel':2,'_lower-camel-leading-underscore':3,\" +\n        \"'_-upper-camel-leading-underscore':4,'lower_words':5,'u-p-p-e-r_-w-o-r-d-s':6,\" +\n        \"'annotatedName':7,'lower-id':8}\",\n        gson.toJson(new TestNames()).replace('\\\"', '\\''));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){\n    return new GsonBuilder()\n      .setFieldNamingPolicy(fieldNamingPolicy)\n        .create();\n  }\nExtractedCodeFragments:\nprivate Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){\n    return new GsonBuilder()\n      .setFieldNamingPolicy(fieldNamingPolicy)\n        .create();\n  }\nExtractedCodeFragments:\nprivate Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){\n    return new GsonBuilder()\n      .setFieldNamingPolicy(fieldNamingPolicy)\n        .create();\n  }\nExtractedCodeFragments:\nprivate Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){\n    return new GsonBuilder()\n      .setFieldNamingPolicy(fieldNamingPolicy)\n        .create();\n  }\nExtractedCodeFragments:\nprivate Gson getGsonWithNamingPolicy(FieldNamingPolicy fieldNamingPolicy){\n    return new GsonBuilder()\n      .setFieldNamingPolicy(fieldNamingPolicy)\n        .create();\n  }",
          "uniqueId": "299ee89852f8e3ac510a939a2583515a6f1c3e87_30_36_72_76_32_38"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "0e3708be82830ab1862cc8c752e9efa841e0fae7",
      "url": "https://github.com/google/gson/commit/0e3708be82830ab1862cc8c752e9efa841e0fae7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public UtcDateTypeAdapter() {\n    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n  }",
          "filePathBefore": "extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java",
          "sourceCodeAfterRefactoring": "public UtcDateTypeAdapter() {\n    this(false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic UtcDateTypeAdapter(boolean jdk6Compatible) {\n    if (jdk6Compatible) {\n      this.iso8601Format = null;\n    } else {\n      // XXX is only supported by JDK 1.7+\n      this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n      this.iso8601Format.setTimeZone(UTC_TIME_ZONE);\n    }\n  }",
          "uniqueId": "0e3708be82830ab1862cc8c752e9efa841e0fae7_35_38_43_51_39_41"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b6a625fb6cb7e46a01938fef79ac6ea26c93a8dc",
      "url": "https://github.com/google/gson/commit/b6a625fb6cb7e46a01938fef79ac6ea26c93a8dc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean excludeField(Field f, boolean serialize) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nprivate String getFieldName(Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
          "sourceCodeAfterRefactoring": "public boolean excludeField(Field f, boolean serialize) {\n    return excludeField(f, serialize, excluder);\n  }\nprivate String getFieldName(Field f) {\n    return getFieldName(fieldNamingPolicy, f);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic boolean excludeField(Field f, boolean serialize, Excluder excluder) {\n    return !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n  }\nExtractedCodeFragments:\nstatic String getFieldName(FieldNamingStrategy fieldNamingPolicy, Field f) {\n    SerializedName serializedName = f.getAnnotation(SerializedName.class);\n    return serializedName == null ? fieldNamingPolicy.translateName(f) : serializedName.value();\n  }",
          "uniqueId": "b6a625fb6cb7e46a01938fef79ac6ea26c93a8dc_58_60_62_64_58_60"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "bf549f0589105a42f159c78a621fc28087561d16",
      "url": "https://github.com/google/gson/commit/bf549f0589105a42f159c78a621fc28087561d16",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> clazz = targetType.getRawType();\n    JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n    if (annotation == null) return null;\n    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n    ObjectConstructor<? extends TypeAdapter<?>> constructor = constructorConstructor.get(TypeToken.get(adapterClass));\n    TypeAdapter adapter = constructor.construct();\n    return adapter;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
          "sourceCodeAfterRefactoring": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n    Class<? super T> clazz = targetType.getRawType();\n    JsonAdapter annotation = clazz.getAnnotation(JsonAdapter.class);\n    if (annotation == null) return null;\n    TypeAdapter adapter = getAnnotationTypeAdapter(constructorConstructor, annotation);\n    return adapter;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic TypeAdapter<?> getAnnotationTypeAdapter(\n      ConstructorConstructor constructorConstructor, JsonAdapter annotation) {\n    Class<? extends TypeAdapter<?>> adapterClass = annotation.value();\n    ObjectConstructor<? extends TypeAdapter<?>> constructor =\n        constructorConstructor.get(TypeToken.get(adapterClass));\n    return constructor.construct();\n  }",
          "uniqueId": "bf549f0589105a42f159c78a621fc28087561d16_41_50_50_56_41_48"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "url": "https://github.com/google/gson/commit/fd4fbe41322c39329245b6a1311ae42bd10827ad",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Reads the next JSON value from {@code reader} and convert it to an object\n   * of type {@code typeOfT}.\n   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n   *\n   * @throws JsonIOException if there was a problem writing to the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken);\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * Reads the next JSON value from {@code reader} and convert it to an object\n   * of type {@code typeOfT}.\n   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n   *\n   * @throws JsonIOException if there was a problem writing to the Reader\n   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n    boolean isEmpty = true;\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      reader.peek();\n      isEmpty = false;\n      TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n      TypeAdapter<T> typeAdapter = (TypeAdapter<T>) getAdapter(typeToken);\n      T object = typeAdapter.read(reader);\n      invokeInterceptorIfNeeded(object, typeToken.getRawType());\n      return object;\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return null for empty\n       * documents instead of throwing.\n       */\n      if (isEmpty) {\n        return null;\n      }\n      throw new JsonSyntaxException(e);\n    } catch (IllegalStateException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      // TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\n      throw new JsonSyntaxException(e);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate <T> void invokeInterceptorIfNeeded(T object, Type type) {\n    @SuppressWarnings(\"unchecked\")\n    TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(type);\n    Class<? super T> clazz = typeToken.getRawType();\n    invokeInterceptorIfNeeded(object, clazz);\n  }",
          "uniqueId": "fd4fbe41322c39329245b6a1311ae42bd10827ad_781_819_893_898_781_819"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "2fef83799de82f67f2124908e982c773c49a6153",
      "url": "https://github.com/google/gson/commit/2fef83799de82f67f2124908e982c773c49a6153",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void assertAvlBuilder(int size, String expected) {\n    char[] values = \"abcdefghijklmnopqrstuvwxyzABCDE\".toCharArray();\n    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();\n    avlBuilder.reset(size);\n    for (int i = 0; i < size; i++) {\n      avlBuilder.add(node(Character.toString(values[i])));\n    }\n    assertEquals(expected, toString(avlBuilder.root()));\n  }\npublic void testDoubleCapacity() {\n    @SuppressWarnings(\"unchecked\") // Arrays and generics don't get along.\n    Node<String, String>[] oldTable = new Node[1];\n    oldTable[0] = node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\")));\n\n    Node<String, String>[] newTable = LinkedTreeMap.doubleCapacity(oldTable);\n    assertEquals(\"(b d f)\", toString(newTable[0])); // Even hash codes!\n    assertEquals(\"(a c (. e g))\", toString(newTable[1])); // Odd hash codes!\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java",
          "sourceCodeAfterRefactoring": "private void assertAvlBuilder(int size, String expected) {\n    char[] values = \"abcdefghijklmnopqrstuvwxyzABCDE\".toCharArray();\n    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();\n    avlBuilder.reset(size);\n    for (int i = 0; i < size; i++) {\n      avlBuilder.add(node(Character.toString(values[i])));\n    }\n    assertTree(expected, avlBuilder.root());\n  }\npublic void testDoubleCapacity() {\n    @SuppressWarnings(\"unchecked\") // Arrays and generics don't get along.\n    Node<String, String>[] oldTable = new Node[1];\n    oldTable[0] = node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\")));\n\n    Node<String, String>[] newTable = LinkedHashTreeMap.doubleCapacity(oldTable);\n    assertTree(\"(b d f)\", newTable[0]); // Even hash codes!\n    assertTree(\"(a c (. e g))\", newTable[1]); // Odd hash codes!\n\n    for (Node<?, ?> node : newTable) {\n      if (node != null) {\n        assertConsistent(node);\n      }\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertTree(String expected, Node<?, ?> root) {\n    assertEquals(expected, toString(root));\n    assertConsistent(root);\n  }\nExtractedCodeFragments:\nprivate void assertTree(String expected, Node<?, ?> root) {\n    assertEquals(expected, toString(root));\n    assertConsistent(root);\n  }",
          "uniqueId": "2fef83799de82f67f2124908e982c773c49a6153_132_140_167_170_121_129"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "751c69c655c9317a7169e24e452d3931ec956761",
      "url": "https://github.com/google/gson/commit/751c69c655c9317a7169e24e452d3931ec956761",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override public V get(Object key) {\n    if (key == null) {\n      return null;\n    }\n\n    // Doug Lea's supplemental secondaryHash function (inlined)\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    hash ^= (hash >>> 7) ^ (hash >>> 4);\n\n    LinkedEntry<K, V>[] tab = table;\n    for (LinkedEntry<K, V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n      K eKey = e.key;\n      if (eKey == key || (e.hash == hash && key.equals(eKey))) {\n        return e.value;\n      }\n    }\n    return null;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/StringMap.java",
          "sourceCodeAfterRefactoring": "@Override public V get(Object key) {\n    LinkedEntry<K, V> entry = getEntry(key);\n    return entry != null ? entry.value : null;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate LinkedEntry<K, V> getEntry(Object key) {\n    if (key == null) {\n      return null;\n    }\n\n    int hash = secondaryHash(key.hashCode());\n    LinkedEntry<K, V>[] tab = table;\n    for (LinkedEntry<K, V> e = tab[hash & (tab.length - 1)]; e != null; e = e.next) {\n      K eKey = e.key;\n      if (eKey == key || (e.hash == hash && key.equals(eKey))) {\n        return e;\n      }\n    }\n    return null;\n  }",
          "uniqueId": "751c69c655c9317a7169e24e452d3931ec956761_104_122_110_124_105_108"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea",
      "url": "https://github.com/google/gson/commit/194c18d20c6a05c9454ca9e0bc5503f2581ee3ea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n    Type type = typeToken.getType();\n\n    Class<? super T> rawType = typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter<?> keyAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[0]));\n    TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n\n    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n    TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,\n        keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java",
          "sourceCodeAfterRefactoring": "public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n    Type type = typeToken.getType();\n\n    Class<? super T> rawType = typeToken.getRawType();\n    if (!Map.class.isAssignableFrom(rawType)) {\n      return null;\n    }\n\n    Class<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\n    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\n    TypeAdapter<?> keyAdapter = getKeyAdapter(context, keyAndValueTypes[0]);\n    TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n    ObjectConstructor<T> constructor = constructorConstructor.getConstructor(typeToken);\n\n    @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n    TypeAdapter<T> result = new Adapter(context, keyAndValueTypes[0], keyAdapter,\n        keyAndValueTypes[1], valueAdapter, constructor);\n    return result;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Returns a type adapter that writes the value as a string.\n   */\n  private TypeAdapter<?> getKeyAdapter(MiniGson context, Type keyType) {\n    return (keyType == boolean.class || keyType == Boolean.class)\n        ? TypeAdapters.BOOLEAN_AS_STRING\n        : context.getAdapter(TypeToken.get(keyType));\n  }",
          "uniqueId": "194c18d20c6a05c9454ca9e0bc5503f2581ee3ea_112_130_131_138_111_129"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "bb7f0b6bb01b0e98e32229cb528772a66a9d6075",
      "url": "https://github.com/google/gson/commit/bb7f0b6bb01b0e98e32229cb528772a66a9d6075",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\n   *\n   * @param jsonElement root of a tree of {@link JsonElement}s\n   * @param writer Writer to which the Json representation needs to be written\n   * @throws JsonIOException if there was a problem writing to the writer\n   * @since 1.4\n   */\n  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n    try {\n      if (generateNonExecutableJson) {\n        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n      }\n      JsonWriter jsonWriter = new JsonWriter(Streams.writerForAppendable(writer));\n      if (prettyPrinting) {\n        jsonWriter.setIndent(\"  \");\n      }\n      toJson(jsonElement, jsonWriter);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * Writes out the equivalent JSON for a tree of {@link JsonElement}s.\n   *\n   * @param jsonElement root of a tree of {@link JsonElement}s\n   * @param writer Writer to which the Json representation needs to be written\n   * @throws JsonIOException if there was a problem writing to the writer\n   * @since 1.4\n   */\n  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n    try {\n      JsonWriter jsonWriter = newJsonWriter(Streams.writerForAppendable(writer));\n      toJson(jsonElement, jsonWriter);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Returns a new JSON writer configured for this GSON and with the non-execute\n   * prefix if that is configured.\n   */\n  private JsonWriter newJsonWriter(Writer writer) throws IOException {\n    if (generateNonExecutableJson) {\n      writer.write(JSON_NON_EXECUTABLE_PREFIX);\n    }\n    JsonWriter jsonWriter = new JsonWriter(writer);\n    if (prettyPrinting) {\n      jsonWriter.setIndent(\"  \");\n    }\n    jsonWriter.setSerializeNulls(serializeNulls);\n    return jsonWriter;\n  }",
          "uniqueId": "bb7f0b6bb01b0e98e32229cb528772a66a9d6075_515_536_551_565_534_549"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "befcfd908b55f1ee80eb046fe6c1196e49491ab2",
      "url": "https://github.com/google/gson/commit/befcfd908b55f1ee80eb046fe6c1196e49491ab2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void testFailWithPosition() throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    JsonReader reader = new JsonReader(new StringReader(\"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\"));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(\"Expected literal value @6:3\", expected.getMessage());\n    }\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/stream/JsonReaderTest.java",
          "sourceCodeAfterRefactoring": "public void testFailWithPosition() throws IOException {\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\\n\\n\\n0,}]\");\n  }\npublic void testFailWithPositionGreaterThanBufferSize() throws IOException {\n    String spaces = repeat(' ', 8192);\n    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n        \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }\nExtractedCodeFragments:\nprivate void testFailWithPosition(String message, String json) throws IOException {\n    JsonReader reader = new JsonReader(new StringReader(json));\n    reader.beginArray();\n    reader.nextInt();\n    try {\n      reader.peek();\n      fail();\n    } catch (IOException expected) {\n      assertEquals(message, expected.getMessage());\n    }\n  }",
          "uniqueId": "befcfd908b55f1ee80eb046fe6c1196e49491ab2_768_778_800_810_784_787"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "9196b2325126988f72248a7d35ffcb44744e0134",
      "url": "https://github.com/google/gson/commit/9196b2325126988f72248a7d35ffcb44744e0134",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Configures Gson for custom serialization or deserialization. This method combines the\n   * registration of an {@link InstanceCreator}, {@link JsonSerializer}, and a\n   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\n   * all the required interfaces for custom serialization with Gson. If an instance creator,\n   * serializer or deserializer was previously registered for the specified {@code type}, it is\n   * overwritten.\n   *\n   * @param type the type definition for the type adapter being registered\n   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n    if (typeAdapter instanceof InstanceCreator<?>) {\n      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n    }\n    if (typeAdapter instanceof JsonSerializer<?>) {\n      registerSerializer(type, (JsonSerializer<?>) typeAdapter);\n    }\n    if (typeAdapter instanceof JsonDeserializer<?>) {\n      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter);\n    }\n    return this;\n  }\n/**\n   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n   * This method combines the registration of an {@link InstanceCreator}, {@link JsonSerializer},\n   * and a {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter}\n   * implements all the required interfaces for custom serialization with Gson.\n   * If an instance creator, serializer or deserializer was previously registered for the specified\n   * type hierarchy, it is overwritten. If an instance creator, serializer or deserializer is\n   * registered for a specific type in the type hierarchy, it will be invoked instead of the one\n   * registered for the type hierarchy.\n   *\n   * @param baseType the class definition for the type adapter being registered for the base class\n   *        or interface\n   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   */\n  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n    if (typeAdapter instanceof InstanceCreator<?>) {\n      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n    }\n    if (typeAdapter instanceof JsonSerializer<?>) {\n      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter);\n    }\n    if (typeAdapter instanceof JsonDeserializer<?>) {\n      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n    }\n    return this;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/GsonBuilder.java",
          "sourceCodeAfterRefactoring": "/**\n   * Configures Gson for custom serialization or deserialization. This method combines the\n   * registration of an {@link InstanceCreator}, {@link JsonSerializer}, and a\n   * {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter} implements\n   * all the required interfaces for custom serialization with Gson. If an instance creator,\n   * serializer or deserializer was previously registered for the specified {@code type}, it is\n   * overwritten.\n   *\n   * @param type the type definition for the type adapter being registered\n   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   */\n  public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n    return registerTypeAdapter(type, typeAdapter, false);\n  }\n/**\n   * Configures Gson for custom serialization or deserialization for an inheritance type hierarchy.\n   * This method combines the registration of an {@link InstanceCreator}, {@link JsonSerializer},\n   * and a {@link JsonDeserializer}. It is best used when a single object {@code typeAdapter}\n   * implements all the required interfaces for custom serialization with Gson.\n   * If an instance creator, serializer or deserializer was previously registered for the specified\n   * type hierarchy, it is overwritten. If an instance creator, serializer or deserializer is\n   * registered for a specific type in the type hierarchy, it will be invoked instead of the one\n   * registered for the type hierarchy.\n   *\n   * @param baseType the class definition for the type adapter being registered for the base class\n   *        or interface\n   * @param typeAdapter This object must implement at least one of the {@link InstanceCreator},\n   * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.7\n   */\n  public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n    return registerTypeHierarchyAdapter(baseType, typeAdapter, false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate GsonBuilder registerTypeAdapter(Type type, Object typeAdapter, boolean isSystem) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n    if (typeAdapter instanceof InstanceCreator<?>) {\n      registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter, isSystem);\n    }\n    if (typeAdapter instanceof JsonSerializer<?>) {\n      registerSerializer(type, (JsonSerializer<?>) typeAdapter, isSystem);\n    }\n    if (typeAdapter instanceof JsonDeserializer<?>) {\n      registerDeserializer(type, (JsonDeserializer<?>) typeAdapter, isSystem);\n    }\n    return this;\n  }\nExtractedCodeFragments:\nprivate GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter,\n      boolean isSystem) {\n    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n    if (typeAdapter instanceof InstanceCreator<?>) {\n      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter, isSystem);\n    }\n    if (typeAdapter instanceof JsonSerializer<?>) {\n      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter, isSystem);\n    }\n    if (typeAdapter instanceof JsonDeserializer<?>) {\n      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter, isSystem);\n    }\n    return this;\n  }",
          "uniqueId": "9196b2325126988f72248a7d35ffcb44744e0134_477_503_495_508_478_493"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"{mapForTypeHierarchy:{\");\n    boolean first = true;\n    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append(typeToString(entry.first)).append(':');\n      sb.append(entry.second);\n    }\n    sb.append(\"},map:{\");\n    first = true;\n    for (Map.Entry<Type, T> entry : map.entrySet()) {\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append(typeToString(entry.getKey())).append(':');\n      sb.append(entry.getValue());\n    }\n    sb.append(\"}\");\n    return sb.toString();\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java",
          "sourceCodeAfterRefactoring": "@Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder(\"{userTypeHierarchyList:{\");\n    appendList(sb, userTypeHierarchyList);\n    sb.append(\"},systemTypeHierarchyList:{\");\n    appendList(sb, systemTypeHierarchyList);\n    sb.append(\"},userMap:{\");\n    appendMap(sb, userMap);\n    sb.append(\"},systemMap:{\");\n    appendMap(sb, systemMap);\n    sb.append(\"}\");\n    return sb.toString();\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void appendList(StringBuilder sb, List<Pair<Class<?>,T>> list) {\n    boolean first = true;\n    for (Pair<Class<?>, T> entry : list) {\n      if (first) {\n        first = false;\n      } else {\n        sb.append(',');\n      }\n      sb.append(typeToString(entry.first)).append(':');\n      sb.append(entry.second);\n    }\n  }",
          "uniqueId": "9196b2325126988f72248a7d35ffcb44744e0134_184_210_244_255_230_242"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "2fb8c92812fc385a79bc54f6214c7ac801d2c06a",
      "url": "https://github.com/google/gson/commit/2fb8c92812fc385a79bc54f6214c7ac801d2c06a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public JsonElement serialize(Object src, Type typeOfSrc) {\r\n    if (src == null) {\r\n      return JsonNull.createJsonNull();\r\n    }\r\n    JsonSerializationVisitor visitor = new JsonSerializationVisitor(\r\n        objectNavigator, fieldNamingPolicy, serializeNulls, serializers, this, ancestors);\r\n    objectNavigator.accept(new ObjectTypePair(src, typeOfSrc, true), visitor);\r\n    return visitor.getJsonElement();\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java",
          "sourceCodeAfterRefactoring": "public JsonElement serialize(Object src, Type typeOfSrc) {\r\n    return serialize(src, typeOfSrc, true);\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nJsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\r\n    if (src == null) {\r\n      return JsonNull.createJsonNull();\r\n    }\r\n    JsonSerializationVisitor visitor = new JsonSerializationVisitor(\r\n        objectNavigator, fieldNamingPolicy, serializeNulls, serializers, this, ancestors);\r\n    objectNavigator.accept(new ObjectTypePair(src, typeOfSrc, preserveType), visitor);\r\n    return visitor.getJsonElement();\r\n  }",
          "uniqueId": "2fb8c92812fc385a79bc54f6214c7ac801d2c06a_52_60_56_64_52_54"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "f718784f33c6f52416325039381833645651d2a2",
      "url": "https://github.com/google/gson/commit/f718784f33c6f52416325039381833645651d2a2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n        throws JsonParseException {\n      if (!(json instanceof JsonPrimitive)) {\n        throw new JsonParseException(\"The date should be a string value\");\n      }\n      synchronized (localFormat) {\n        try {\n          return localFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return enUsFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return iso8601Format.parse(json.getAsString());\n        } catch (ParseException e) {\n          throw new JsonSyntaxException(json.getAsString(), e);\n        }\n      }\n    }",
          "filePathBefore": "gson/src/main/java/com/google/gson/DefaultTypeAdapters.java",
          "sourceCodeAfterRefactoring": "public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n        throws JsonParseException {\n      if (!(json instanceof JsonPrimitive)) {\n        throw new JsonParseException(\"The date should be a string value\");\n      }\n      Date date = deserializeToDate(json);\n      if (typeOfT == Date.class) {\n        return date;\n      } else if (typeOfT == Timestamp.class) {\n        return new Timestamp(date.getTime());\n      } else if (typeOfT == java.sql.Date.class) {\n        return new java.sql.Date(date.getTime());\n      } else {\n        throw new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n      }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Date deserializeToDate(JsonElement json) {\n      synchronized (localFormat) {\n        try {\n          return localFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return enUsFormat.parse(json.getAsString());\n        } catch (ParseException ignored) {\n        }\n        try {\n          return iso8601Format.parse(json.getAsString());\n        } catch (ParseException e) {\n          throw new JsonSyntaxException(json.getAsString(), e);\n        }\n      }\n    }",
          "uniqueId": "f718784f33c6f52416325039381833645651d2a2_343_363_363_379_346_361"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "4d9bec220682ff8e0a854eb422e8b498692f6394",
      "url": "https://github.com/google/gson/commit/4d9bec220682ff8e0a854eb422e8b498692f6394",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * @param objTypePair The object,type (fully genericized) being navigated\n   * @param visitor the visitor to visit each field with\n   */\n  void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {\n    ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n    Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n    for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n      curr.getSuperclass()) {\n      if (!curr.isSynthetic()) {\n        navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);\n      }\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java",
          "sourceCodeAfterRefactoring": "/**\n   * @param objTypePair The object,type (fully genericized) being navigated\n   * @param visitor the visitor to visit each field with\n   */\n  void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {\n    ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\n    Class<?> topLevelClass = Types.getRawType(currObjTypePair.type);\n    for (Class<?> curr : getInheritanceHierarchy(currObjTypePair.type)) {\n      navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Returns a list of classes corresponding to the inheritance of specified type \n   */\n  private List<Class<?>> getInheritanceHierarchy(Type type) {\n    List<Class<?>> classes = classCache.get(type);\n    if (classes == null) {\n      classes = new ArrayList<Class<?>>();\n      Class<?> topLevelClass = Types.getRawType(type);\n      for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n        curr.getSuperclass()) {\n        if (!curr.isSynthetic()) {\n          classes.add(curr);\n        }\n      }\n      classCache.put(type, classes);\n    }\n    return classes;\n  }",
          "uniqueId": "4d9bec220682ff8e0a854eb422e8b498692f6394_48_61_64_81_52_62"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "0adf7f5e1797baf3ac44a369fa13ad4126096d4a",
      "url": "https://github.com/google/gson/commit/0adf7f5e1797baf3ac44a369fa13ad4126096d4a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void navigateClassFields(Object obj, Type objType,\n      Class<?> classInInheritanceHierarchyForObj, Visitor visitor) {\n    Field[] fields = classInInheritanceHierarchyForObj.getDeclaredFields();\n    AccessibleObject.setAccessible(fields, true);\n    for (Field f : fields) {\n      FieldAttributes fieldAttributes = new FieldAttributes(classInInheritanceHierarchyForObj, f);\n      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n        continue; // skip\n      }\n      Type declaredTypeOfField = getTypeInfoForField(f, objType);\n      boolean visitedWithCustomHandler =\n          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n      if (!visitedWithCustomHandler) {\n        if (Types.isArray(declaredTypeOfField)) {\n          visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n        } else {\n          visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n        }\n      }\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java",
          "sourceCodeAfterRefactoring": "private void navigateClassFields(Object obj, Type objType,\n      Class<?> classInInheritanceHierarchyForObj, Visitor visitor) {\n    Field[] fields = getFields(classInInheritanceHierarchyForObj);\n    AccessibleObject.setAccessible(fields, true);\n    for (Field f : fields) {\n      FieldAttributes fieldAttributes = new FieldAttributes(classInInheritanceHierarchyForObj, f);\n      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n        continue; // skip\n      }\n      Type declaredTypeOfField = getTypeInfoForField(f, objType);\n      boolean visitedWithCustomHandler =\n          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n      if (!visitedWithCustomHandler) {\n        if (Types.isArray(declaredTypeOfField)) {\n          visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n        } else {\n          visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n        }\n      }\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Field[] getFields(Class<?> clazz) {\n    Field[] fields = fieldsCache.get(clazz);\n    if (fields == null) {\n      fields = clazz.getDeclaredFields();\n      fieldsCache.put(clazz, fields);\n    }\n    return fields;\n  }",
          "uniqueId": "0adf7f5e1797baf3ac44a369fa13ad4126096d4a_60_81_86_93_63_84"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6d3e0e92a5695f47628d2f7d3fcff207c22c1825",
      "url": "https://github.com/google/gson/commit/6d3e0e92a5695f47628d2f7d3fcff207c22c1825",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private <T> Constructor<T> getNoArgsConstructor(Class<T> clazz) {\n    try {\n      Constructor<T> declaredConstructor = clazz.getDeclaredConstructor();\n      declaredConstructor.setAccessible(true);\n      return declaredConstructor;\n    } catch (Exception e) {\n      return null;\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/MappedObjectConstructor.java",
          "sourceCodeAfterRefactoring": "private <T> Constructor<T> getNoArgsConstructor(Class<T> clazz) {\n    @SuppressWarnings(\"unchecked\")\n    Constructor<T> constructor = (Constructor<T>)noArgsConstructorsCache.getElement(clazz);\n    if (constructor == NULL_VALUE) {\n      return null;\n    }\n    if (constructor == null) {\n      constructor = getNoArgsConstructorUsingReflection(clazz);\n      noArgsConstructorsCache.addElement(clazz, constructor);\n    }\n    return constructor == NULL_VALUE ? null : constructor;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"unchecked\")\n  private static <T> Constructor<T> getNoArgsConstructorUsingReflection(Class<T> clazz) {\n    try {\n      Constructor<T> constructor = clazz.getDeclaredConstructor();\n      constructor.setAccessible(true);\n      return constructor;\n    } catch (Exception e) {\n      return (Constructor<T>) NULL_VALUE;\n    }\n  }",
          "uniqueId": "6d3e0e92a5695f47628d2f7d3fcff207c22c1825_73_81_102_111_89_100"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "114633fbf933c3085a189d20c62fadae0398fb39",
      "url": "https://github.com/google/gson/commit/114633fbf933c3085a189d20c62fadae0398fb39",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public SampleObjectForTest() {\n      annotatedField = 5;\n      stringField = \"someDefaultValue\";\n      longField = 1234;\n      clazzField = String.class;\n    }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/ExclusionStrategyFunctionalTest.java",
          "sourceCodeAfterRefactoring": "public SampleObjectForTest() {\n      this(5, \"someDefaultValue\", 12345L);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic SampleObjectForTest(int annotatedField, String stringField, long longField) {\n      this.annotatedField = annotatedField;\n      this.stringField = stringField;\n      this.longField = longField;\n    }",
          "uniqueId": "114633fbf933c3085a189d20c62fadae0398fb39_122_127_121_125_117_119"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b883f8f4aaa7ae906b4298cc43223060495fc6ff",
      "url": "https://github.com/google/gson/commit/b883f8f4aaa7ae906b4298cc43223060495fc6ff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/ExposeAnnotationSerializationExclusionStrategyTest.java",
          "sourceCodeAfterRefactoring": "public void testSkipNonAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }",
          "uniqueId": "b883f8f4aaa7ae906b4298cc43223060495fc6ff_43_46_74_77_44_48"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void testSkipNonAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    Field f = MockObject.class.getField(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(new FieldAttributes(MockObject.class, f)));\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/ExposeAnnotationDeserializationExclusionStrategyTest.java",
          "sourceCodeAfterRefactoring": "public void testSkipNonAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"hiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testSkipExplicitlySkippedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyHiddenField\");\n    assertTrue(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertTrue(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"exposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }\npublic void testNeverSkipExplicitlyExposedAnnotatedFields() throws Exception {\n    FieldAttributes f = createFieldAttributes(\"explicitlyExposedField\");\n    assertFalse(strategy.shouldSkipField(f, Mode.DESERIALIZE));\n    assertFalse(strategy.shouldSkipField(f, Mode.SERIALIZE));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }\nExtractedCodeFragments:\nprivate static FieldAttributes createFieldAttributes(String fieldName) throws Exception {\n    Field f = MockObject.class.getField(fieldName);\n    return new FieldAttributes(MockObject.class, f);\n  }",
          "uniqueId": "b883f8f4aaa7ae906b4298cc43223060495fc6ff_43_46_74_77_44_48"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "be05420c6b6fe150faaba4152a2846fbab95408e",
      "url": "https://github.com/google/gson/commit/be05420c6b6fe150faaba4152a2846fbab95408e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public CallPath(String path) {\r\n    if (path == null) {\r\n      this.path = null;\r\n      version = -1D;\r\n    } else {\r\n      int index1 = path.indexOf('/');\r\n      int index2 = path.substring(index1+1).indexOf('/');\r\n      String versionStr = path.substring(index1+1, index2+1);\r\n      String callPathStr = path;\r\n      double givenVersion = -1D;\r\n      try {\r\n        // Skip over the version number from the URL\r\n        givenVersion = Double.parseDouble(versionStr);\r\n        callPathStr = path.substring(index2+1);\r\n      } catch (NumberFormatException e) {\r\n        // Assume that version number wasn't specified\r\n      }\r\n      this.path = callPathStr;\r\n      this.version = givenVersion;\r\n    }\r\n  }",
          "filePathBefore": "wsdef/src/main/java/com/google/gson/webservice/definition/CallPath.java",
          "sourceCodeAfterRefactoring": "public CallPath(String path) {\r\n    if (path == null) {\r\n      this.path = null;\r\n      version = IGNORE_VERSION;\r\n      resourceId = ID.INVALID_ID;\r\n    } else {\r\n      Pair<Double, String> path2 = extractVersion(path);\r\n      this.version = path2.first;\r\n      Pair<Long, String> path3 = extractId(path2.second);\r\n      this.resourceId = path3.first;\r\n      this.path = path3.second;\r\n    }\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\r\n   * Returns path after consuming version number from the begining\r\n   */\r\n  private static Pair<Double, String> extractVersion(String path) {\r\n    int index1 = path.indexOf('/');\r\n    int index2 = path.substring(index1+1).indexOf('/');\r\n    String versionStr = path.substring(index1+1, index2+1);\r\n    double extractedVersion = -1.0D;\r\n    String revisedPath = path;\r\n    try {\r\n      // Skip over the version number from the URL\r\n      extractedVersion = Double.parseDouble(versionStr);\r\n      revisedPath = path.substring(index2+1);\r\n    } catch (NumberFormatException e) {\r\n      // Assume that version number wasn't specified\r\n    }\r\n    return Pair.create(extractedVersion, revisedPath);\r\n  }",
          "uniqueId": "be05420c6b6fe150faaba4152a2846fbab95408e_28_48_47_64_33_45"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "103edb9c36988c42170a75046eee37407c0c6475",
      "url": "https://github.com/google/gson/commit/103edb9c36988c42170a75046eee37407c0c6475",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Takes a reader in any state and returns the next value as a JsonElement.\n   */\n  static JsonElement parse(JsonReader reader) throws JsonParseException {\n    try {\n      switch (reader.peek()) {\n      case STRING:\n        return new JsonPrimitive(reader.nextString());\n      case NUMBER:\n        String number = reader.nextString();\n        return new JsonPrimitive(JsonPrimitive.stringToNumber(number));\n      case BOOLEAN:\n        return new JsonPrimitive(reader.nextBoolean());\n      case NULL:\n        reader.nextNull();\n        return JsonNull.createJsonNull();\n      case BEGIN_ARRAY:\n        JsonArray array = new JsonArray();\n        reader.beginArray();\n        while (reader.hasNext()) {\n          array.add(parse(reader));\n        }\n        reader.endArray();\n        return array;\n      case BEGIN_OBJECT:\n        JsonObject object = new JsonObject();\n        reader.beginObject();\n        while (reader.hasNext()) {\n          object.add(reader.nextName(), parse(reader));\n        }\n        reader.endObject();\n        return object;\n      case END_DOCUMENT:\n      case NAME:\n      case END_OBJECT:\n      case END_ARRAY:\n      default:\n        throw new IllegalArgumentException();\n      }\n    } catch (EOFException e) {\n      return JsonNull.createJsonNull();\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Streams.java",
          "sourceCodeAfterRefactoring": "/**\n   * Takes a reader in any state and returns the next value as a JsonElement.\n   */\n  static JsonElement parse(JsonReader reader) throws JsonParseException {\n    boolean isEmpty = true;\n    try {\n      reader.peek();\n      isEmpty = false;\n      return parseRecursive(reader);\n    } catch (EOFException e) {\n      /*\n       * For compatibility with JSON 1.5 and earlier, we return a JsonNull for\n       * empty documents instead of throwing.\n       */\n      if (isEmpty) {\n        return JsonNull.createJsonNull();\n      } else {\n        throw new JsonIOException(e);\n      }\n    } catch (MalformedJsonException e) {\n      throw new JsonSyntaxException(e);\n    } catch (IOException e) {\n      throw new JsonIOException(e);\n    } catch (NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static JsonElement parseRecursive(JsonReader reader) throws IOException {\n    switch (reader.peek()) {\n    case STRING:\n      return new JsonPrimitive(reader.nextString());\n    case NUMBER:\n      String number = reader.nextString();\n      return new JsonPrimitive(JsonPrimitive.stringToNumber(number));\n    case BOOLEAN:\n      return new JsonPrimitive(reader.nextBoolean());\n    case NULL:\n      reader.nextNull();\n      return JsonNull.createJsonNull();\n    case BEGIN_ARRAY:\n      JsonArray array = new JsonArray();\n      reader.beginArray();\n      while (reader.hasNext()) {\n        array.add(parseRecursive(reader));\n      }\n      reader.endArray();\n      return array;\n    case BEGIN_OBJECT:\n      JsonObject object = new JsonObject();\n      reader.beginObject();\n      while (reader.hasNext()) {\n        object.add(reader.nextName(), parseRecursive(reader));\n      }\n      reader.endObject();\n      return object;\n    case END_DOCUMENT:\n    case NAME:\n    case END_OBJECT:\n    case END_ARRAY:\n    default:\n      throw new IllegalArgumentException();\n    }\n  }",
          "uniqueId": "103edb9c36988c42170a75046eee37407c0c6475_33_81_60_95_32_58"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6a951b427e2f0b37597da343401029312ff8288c",
      "url": "https://github.com/google/gson/commit/6a951b427e2f0b37597da343401029312ff8288c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Test for issue 226.\n   */\n  public void testEnumSubclass() {\n    assertFalse(Roshambo.class == Roshambo.ROCK.getClass());\n    assertEquals(\"\\\"ROCK\\\"\", gson.toJson(Roshambo.ROCK));\n    assertEquals(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", gson.toJson(EnumSet.allOf(Roshambo.class)));\n    assertEquals(Roshambo.ROCK, gson.fromJson(\"\\\"ROCK\\\"\", Roshambo.class));\n    assertEquals(EnumSet.allOf(Roshambo.class),\n        gson.fromJson(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", new TypeToken<Set<Roshambo>>() {}.getType()));\n  }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/EnumTest.java",
          "sourceCodeAfterRefactoring": "/**\n   * Test for issue 226.\n   */\n  public void testEnumSubclass() {\n    assertRoshambo();\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertRoshambo() {\n    assertFalse(Roshambo.class == Roshambo.ROCK.getClass());\n    assertEquals(\"\\\"ROCK\\\"\", gson.toJson(Roshambo.ROCK));\n    assertEquals(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", gson.toJson(EnumSet.allOf(Roshambo.class)));\n    assertEquals(Roshambo.ROCK, gson.fromJson(\"\\\"ROCK\\\"\", Roshambo.class));\n    assertEquals(EnumSet.allOf(Roshambo.class),\n        gson.fromJson(\"[\\\"ROCK\\\",\\\"PAPER\\\",\\\"SCISSORS\\\"]\", new TypeToken<Set<Roshambo>>() {}.getType()));\n  }",
          "uniqueId": "6a951b427e2f0b37597da343401029312ff8288c_111_121_133_140_119_124"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6825477d75b45e724c6f91bb9f11d2cc5df1ff20",
      "url": "https://github.com/google/gson/commit/6825477d75b45e724c6f91bb9f11d2cc5df1ff20",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public <R> RestResponse<R> getResponse(\n      RestCallSpec<R> callSpec, RestRequest<R> request, Gson gson) {\n    HttpURLConnection conn = null;\n    try {\n      URL webServiceUrl = getWebServiceUrl(callSpec);\n      if (logger != null) {\n        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n      }\n      conn = (HttpURLConnection) webServiceUrl.openConnection();\n      RestRequestSender requestSender = new RestRequestSender(gson, logLevel);\n      requestSender.send(conn, request);\n      RestResponseReceiver<R> responseReceiver =\n        new RestResponseReceiver<R>(gson, callSpec.getResponseSpec(), logLevel);\n      return responseReceiver.receive(conn);\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    } catch (IllegalArgumentException e) {\n      throw new WebServiceSystemException(e);\n    } finally {\n      closeIgnoringErrors(conn);\n    }\n  }",
          "filePathBefore": "wsclient/src/main/java/com/google/gson/webservice/client/RestClient.java",
          "sourceCodeAfterRefactoring": "public <R> RestResponse<R> getResponse(\n      RestCallSpec<R> callSpec, RestRequest<R> request, Gson gson) {\n    HttpURLConnection conn = null;\n    try {\n      URL webServiceUrl = getWebServiceUrl(callSpec);\n      if (logger != null) {\n        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n      }\n      conn = (HttpURLConnection) webServiceUrl.openConnection();\n      return getResponse(callSpec, request, gson, conn);\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    } finally {\n      closeIgnoringErrors(conn);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Use this method if you want to mange the HTTP Connection yourself. This is useful when you\n   * want to use HTTP pipelining.\n   */\n  public <R> RestResponse<R> getResponse(\n      RestCallSpec<R> callSpec, RestRequest<R> request, Gson gson, HttpURLConnection conn) {\n    try {\n      if (logger != null) {\n        URL webServiceUrl = getWebServiceUrl(callSpec);\n        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n      }\n      RestRequestSender requestSender = new RestRequestSender(gson, logLevel);\n      requestSender.send(conn, request);\n      RestResponseReceiver<R> responseReceiver =\n        new RestResponseReceiver<R>(gson, callSpec.getResponseSpec(), logLevel);\n      return responseReceiver.receive(conn);\n    } catch (IllegalArgumentException e) {\n      throw new WebServiceSystemException(e);\n    }\n  }",
          "uniqueId": "6825477d75b45e724c6f91bb9f11d2cc5df1ff20_66_87_83_102_66_81"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "747e3c3051153779954e49b7dbc475daa678e1f4",
      "url": "https://github.com/google/gson/commit/747e3c3051153779954e49b7dbc475daa678e1f4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\r\n   * Parses the specified JSON string into a parse tree\r\n   * \r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON \r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   */\r\n  public JsonElement parse(Reader json) throws JsonParseException {\r\n    try {\r\n      JsonReader jsonReader = new JsonReader(json);\r\n      jsonReader.setLenient(true);\r\n      return Streams.parse(jsonReader);\r\n    } catch (StackOverflowError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } catch (JsonParseException e) {\r\n      if (e.getCause() instanceof EOFException) {\r\n        return JsonNull.createJsonNull();\r\n      } else {\r\n        throw e;\r\n      }\r\n    }\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParser.java",
          "sourceCodeAfterRefactoring": "/**\r\n   * Parses the specified JSON string into a parse tree\r\n   * \r\n   * @param json JSON text\r\n   * @return a parse tree of {@link JsonElement}s corresponding to the specified JSON \r\n   * @throws JsonParseException if the specified text is not valid JSON\r\n   * @since 1.3\r\n   */\r\n  public JsonElement parse(Reader json) throws JsonParseException {\r\n    return parse(new JsonReader(json));\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\r\n   * Returns the next value from the JSON stream as a parse tree.\r\n   *\r\n   * @throws JsonParseException if there is an IOException or if the specified\r\n   *     text is not valid JSON\r\n   */\r\n  public JsonElement parse(JsonReader json) throws JsonParseException {\r\n    boolean lenient = json.isLenient();\r\n    json.setLenient(true);\r\n    try {\r\n      return Streams.parse(json);\r\n    } catch (StackOverflowError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } catch (OutOfMemoryError e) {\r\n      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r\n    } catch (JsonParseException e) {\r\n      if (e.getCause() instanceof EOFException) {\r\n        return JsonNull.createJsonNull();\r\n      } else {\r\n        throw e;\r\n      }\r\n    } finally {\r\n      json.setLenient(lenient);\r\n    }\r\n  }",
          "uniqueId": "747e3c3051153779954e49b7dbc475daa678e1f4_44_68_56_80_44_54"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json\n   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n   * @since 1.2\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    JsonReader jsonReader = new JsonReader(json);\n    jsonReader.setLenient(true);\n    JsonElement root = Streams.parse(jsonReader);\n    return (T) fromJson(root, typeOfT);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method deserializes the Json read from the specified reader into an object of the\n   * specified type. This method is useful if the specified object is a generic type. For\n   * non-generic objects, use {@link #fromJson(Reader, Class)} instead. If you have the Json in a\n   * String form instead of a {@link Reader}, use {@link #fromJson(String, Type)} instead.\n   *\n   * @param <T> the type of the desired object\n   * @param json the reader producing Json from which the object is to be deserialized\n   * @param typeOfT The specific genericized type of src. You can obtain this type by using the\n   * {@link com.google.gson.reflect.TypeToken} class. For example, to get the type for\n   * {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfT = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return an object of type T from the json\n   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n   * @since 1.2\n   */\n  public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n    return this.<T>fromJson(new JsonReader(json), typeOfT);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Reads the next JSON value from {@code reader} and convert it to an object\n   * of type {@code typeOfT}.\n   */\n  @SuppressWarnings(\"unchecked\") // this method is unsafe and should be used very carefully\n  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n    boolean oldLenient = reader.isLenient();\n    reader.setLenient(true);\n    try {\n      JsonElement root = Streams.parse(reader);\n      return (T) fromJson(root, typeOfT);\n    } finally {\n      reader.setLenient(oldLenient);\n    }\n  }",
          "uniqueId": "747e3c3051153779954e49b7dbc475daa678e1f4_424_448_472_486_450_470"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "2610a2920dcff87cb58b67902fd21bfaaf659e64",
      "url": "https://github.com/google/gson/commit/2610a2920dcff87cb58b67902fd21bfaaf659e64",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean jj_3R_5() {\n    if (jj_scan_token(33)) return true;\n    return false;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParserJavacc.java",
          "sourceCodeAfterRefactoring": "private boolean jj_3R_5() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_6()) jj_scanpos = xsp;\n    if (jj_scan_token(INFINITY)) return true;\n    return false;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean jj_3R_6() {\n    if (jj_scan_token(33)) return true;\n    return false;\n  }",
          "uniqueId": "2610a2920dcff87cb58b67902fd21bfaaf659e64_448_451_433_436_438_444"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "9c8e8bd77e391dbf7d1cc81ab2d4c6b8d09da0ac",
      "url": "https://github.com/google/gson/commit/9c8e8bd77e391dbf7d1cc81ab2d4c6b8d09da0ac",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public WebServiceResponse getResponse(WebServiceCallSpec callSpec, WebServiceRequest request) {\n    try {\n      URL webServiceUrl = getWebServiceUrl(callSpec);\n      if (logger != null) {\n        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n      }\n      HttpURLConnection conn = (HttpURLConnection) webServiceUrl.openConnection();\n      Gson gson = new GsonBuilder()\n        .registerTypeAdapter(ResponseBody.class,\n            new ResponseBodyGsonConverter(callSpec.getResponseSpec().getBodySpec()))\n        .create();\n      RequestSender requestSender = new RequestSender(gson, logLevel);\n      requestSender.send(conn, request);\n      ResponseReceiver responseReceiver =\n        new ResponseReceiver(gson, callSpec.getResponseSpec(), logLevel);\n      return responseReceiver.receive(conn);\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    } catch (IllegalArgumentException e) {\n      throw new WebServiceSystemException(e);\n    }\n  }",
          "filePathBefore": "wsclient/src/main/java/com/google/gson/webservice/client/WebServiceClient.java",
          "sourceCodeAfterRefactoring": "public WebServiceResponse getResponse(WebServiceCallSpec callSpec, WebServiceRequest request) {\n    Gson gson = new GsonBuilder().registerTypeAdapter(ResponseBody.class,\n        new ResponseBodyGsonConverter(callSpec.getResponseSpec().getBodySpec()))\n        .create();\n    return getResponse(callSpec, request, gson);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic WebServiceResponse getResponse(\n      WebServiceCallSpec callSpec, WebServiceRequest request, Gson gson) {\n    try {\n      URL webServiceUrl = getWebServiceUrl(callSpec);\n      if (logger != null) {\n        logger.log(logLevel, \"Opening connection to \" + webServiceUrl);\n      }\n      HttpURLConnection conn = (HttpURLConnection) webServiceUrl.openConnection();\n      RequestSender requestSender = new RequestSender(gson, logLevel);\n      requestSender.send(conn, request);\n      ResponseReceiver responseReceiver =\n        new ResponseReceiver(gson, callSpec.getResponseSpec(), logLevel);\n      return responseReceiver.receive(conn);\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    } catch (IllegalArgumentException e) {\n      throw new WebServiceSystemException(e);\n    }\n  }",
          "uniqueId": "9c8e8bd77e391dbf7d1cc81ab2d4c6b8d09da0ac_63_84_70_88_63_68"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "dbca5571e0e97293664a89346b38758e85bdfd27",
      "url": "https://github.com/google/gson/commit/dbca5571e0e97293664a89346b38758e85bdfd27",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void send(HttpURLConnection conn, WebServiceRequest request) {    \n    try {\n      conn.setRequestMethod(request.getHttpMethod().toString());\n      conn.setRequestProperty(\"Content-Type\", request.getContentType());\n      \n      // Assume conservatively that the response will need to be read.\n      // This is done here instead of in the response receiver because this property must be set\n      // before sending any data on the connection.\n      conn.setDoInput(true);\n      \n      addRequestParams(conn, request.getHeaders());\n      RequestBody requestBody = request.getBody();\n      if (requestBody.getSpec().size() > 0) {\n        conn.setDoOutput(true);    \n        addRequestBody(conn, requestBody);\n      }      \n      \n      // Initiate the sending of the request.\n      conn.connect();\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    }\n  }\nprivate void addRequestParams(HttpURLConnection conn, HeaderMap requestParams) {\n    HeaderMapSpec spec = requestParams.getSpec();\n    for (Map.Entry<String, Object> entry : requestParams.entrySet()) {\n      String paramName = entry.getKey();\n      Type type = spec.getTypeFor(paramName);\n      Object value = entry.getValue();\n      String json = gson.toJson(value, type);\n      conn.addRequestProperty(paramName, json);\n      if (logger != null) {\n        logger.log(logLevel, String.format(\"Request param: %s:%s\", paramName, json));\n      }\n    }\n  }",
          "filePathBefore": "wsclient/src/main/java/com/google/gson/webservice/client/RequestSender.java",
          "sourceCodeAfterRefactoring": "public void send(HttpURLConnection conn, WebServiceRequest request) {    \n    try {\n      conn.setRequestMethod(request.getHttpMethod().toString());\n      setHeader(conn, \"Content-Type\", request.getContentType(), true);\n      \n      // Assume conservatively that the response will need to be read.\n      // This is done here instead of in the response receiver because this property must be set\n      // before sending any data on the connection.\n      conn.setDoInput(true);\n      \n      addRequestParams(conn, request.getHeaders());\n      RequestBody requestBody = request.getBody();\n      String contentLength = \"0\";\n      String requestBodyContents = null;\n      if (requestBody.getSpec().size() > 0) {\n        conn.setDoOutput(true);    \n        requestBodyContents = gson.toJson(requestBody);\n        contentLength = String.valueOf(requestBodyContents.length());\n      }\n      setHeader(conn, \"Content-Length\", contentLength, true);\n      if (requestBody.getSpec().size() > 0) {\n        Streams.copy(requestBodyContents, conn.getOutputStream());\n      }\n      \n      // Initiate the sending of the request.\n      conn.connect();\n    } catch (IOException e) {\n      throw new WebServiceSystemException(e);\n    }\n  }\nprivate void addRequestParams(HttpURLConnection conn, HeaderMap requestParams) {\n    HeaderMapSpec spec = requestParams.getSpec();\n    for (Map.Entry<String, Object> entry : requestParams.entrySet()) {\n      String paramName = entry.getKey();\n      Type type = spec.getTypeFor(paramName);\n      Object value = entry.getValue();\n      String json = gson.toJson(value, type);\n      setHeader(conn, paramName, json, false);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void setHeader(HttpURLConnection conn, String name, String value, boolean overwrite) {\n    if (logger != null) {\n      logger.log(logLevel, String.format(\"Request param: %s:%s\", name, value));\n    }\n    if (overwrite) {\n      conn.setRequestProperty(name, value);\n    } else {\n      conn.addRequestProperty(name, value);\n    }\n  }\nExtractedCodeFragments:\nprivate void setHeader(HttpURLConnection conn, String name, String value, boolean overwrite) {\n    if (logger != null) {\n      logger.log(logLevel, String.format(\"Request param: %s:%s\", name, value));\n    }\n    if (overwrite) {\n      conn.setRequestProperty(name, value);\n    } else {\n      conn.addRequestProperty(name, value);\n    }\n  }",
          "uniqueId": "dbca5571e0e97293664a89346b38758e85bdfd27_53_75_93_102_51_80"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "e4e925403413601f092f1c8830d722e17f41d178",
      "url": "https://github.com/google/gson/commit/e4e925403413601f092f1c8830d722e17f41d178",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ResponseReceiver(Gson gson, ResponseSpec spec) {\n    this.gson = gson;\n    this.spec = spec;\n  }",
          "filePathBefore": "wsclient/src/main/java/com/google/gson/webservice/client/ResponseReceiver.java",
          "sourceCodeAfterRefactoring": "public ResponseReceiver(Gson gson, ResponseSpec spec) {\n    this(gson, spec, null);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ResponseReceiver(Gson gson, ResponseSpec spec, Level logLevel) {\n    this.gson = gson;\n    this.spec = spec;\n    this.logger = logLevel == null ? null : Logger.getLogger(ResponseReceiver.class.getName());\n    this.logLevel = logLevel;\n  }",
          "uniqueId": "e4e925403413601f092f1c8830d722e17f41d178_43_46_50_55_47_49"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public RequestSender(Gson gson) {\n    this.gson = gson;\n  }",
          "filePathBefore": "wsclient/src/main/java/com/google/gson/webservice/client/RequestSender.java",
          "sourceCodeAfterRefactoring": "public RequestSender(Gson gson) {\n    this(gson, null);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic RequestSender(Gson gson, Level logLevel) {\n    this.gson = gson;\n    logger = logLevel == null ? null : Logger.getLogger(RequestSender.class.getName());\n    this.logLevel = logLevel;\n  }",
          "uniqueId": "e4e925403413601f092f1c8830d722e17f41d178_39_41_47_51_44_46"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "e3af076ff271968a1a639c5bbdc1ba967b11ea94",
      "url": "https://github.com/google/gson/commit/e3af076ff271968a1a639c5bbdc1ba967b11ea94",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Configures Gson to apply a specific naming policy strategy to an object's field during\n   * serialization and deserialization.\n   *\n   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   */\n  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n    this.fieldNamingPolicy =\n        new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy);\n    return this;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/GsonBuilder.java",
          "sourceCodeAfterRefactoring": "/**\n   * Configures Gson to apply a specific naming policy strategy to an object's field during\n   * serialization and deserialization.\n   *\n   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.3\n   * @deprecated use {@link #setFieldNamingStrategy(FieldNamingStrategy2)} instead.\n   */\n  @Deprecated\n  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) {\n    return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy));\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Configures Gson to apply a specific naming policy strategy to an object's field during\n   * serialization and deserialization.\n   *\n   * @param fieldNamingStrategy the actual naming strategy to apply to the fields\n   * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n   * @since 1.4\n   */\n  public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) {\n    this.fieldNamingPolicy =\n        new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy);\n    return this;\n  }",
          "uniqueId": "e3af076ff271968a1a639c5bbdc1ba967b11ea94_216_228_230_242_216_228"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Return the {@code T} annotation object from this field if it exist; otherwise returns\n   * {@code null}.\n   *\n   * @param annotation the class of the annotation that will be retrieved\n   * @return the annotation instance if it is bound to the field; otherwise {@code null}\n   */\n  public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n    if (annotations == null) {\n      annotations = field.getAnnotations();\n    }\n    return getAnnotationFromArray(annotations, annotation);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/FieldAttributes.java",
          "sourceCodeAfterRefactoring": "/**\n   * Return the {@code T} annotation object from this field if it exist; otherwise returns\n   * {@code null}.\n   *\n   * @param annotation the class of the annotation that will be retrieved\n   * @return the annotation instance if it is bound to the field; otherwise {@code null}\n   */\n  public <T extends Annotation> T getAnnotation(Class<T> annotation) {\n    return getAnnotationFromArray(getAnnotations(), annotation);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Return the annotations that are present on this field.\n   *\n   * @return an array of all the annotations set on the field\n   * @since 1.4 \n   */\n  public Collection<Annotation> getAnnotations() {\n    if (annotations == null) {\n      annotations = Collections.unmodifiableCollection(\n          Arrays.asList(field.getAnnotations()));\n    }\n    return annotations;\n  }",
          "uniqueId": "e3af076ff271968a1a639c5bbdc1ba967b11ea94_110_122_122_134_111_120"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "bc1e5c5c991fe6d06a5a0f6b775684ac91d289d3",
      "url": "https://github.com/google/gson/commit/bc1e5c5c991fe6d06a5a0f6b775684ac91d289d3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n  public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n    if (pair == null) {\n      return false;\n    }    \n    if (!json.isJsonNull()) {\n      JsonDeserializer deserializer = pair.getFirst();\n      Type objType = pair.getSecond().getType();\n      target = (T) deserializer.deserialize(json, objType, context);\n    }\n    return true;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\")\n  public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n    if (pair == null) {\n      return false;\n    }    \n    Object value = invokeCustomDeserializer(json, pair);\n    target = (T) value;\n    constructed = true;\n    return true;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Object invokeCustomDeserializer(JsonElement element, \n      Pair<JsonDeserializer<?>, ObjectTypePair> pair) {\n    if (element == null || element.isJsonNull()) {\n      return null;\n    }\n    Type objType = pair.getSecond().getType();\n    return (pair.getFirst()).deserialize(element, objType, context);\n  }",
          "uniqueId": "bc1e5c5c991fe6d06a5a0f6b775684ac91d289d3_67_79_82_89_70_80"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b634804533ab68697b6f5414e8c93c3613850bf2",
      "url": "https://github.com/google/gson/commit/b634804533ab68697b6f5414e8c93c3613850bf2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\n   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\n   * instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   */\n  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    if (src == null) {\n      return JsonNull.createJsonNull();\n    }\n    JsonSerializationContext context = new JsonSerializationContextDefault(\n        createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\n    return context.serialize(src, typeOfSrc);\n  }\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out\n   * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   */\n  public String toJson(Object src, Type typeOfSrc) {\n    StringWriter writer = new StringWriter();\n    toJson(src, typeOfSrc, writer);\n    return writer.toString();\n  }\n/**\n   * This method serializes the specified object into its equivalent Json representation.\n   * This method should be used when the specified object is not a generic type. This method uses\n   * {@link Class#getClass()} to get the type for the specified object, but the\n   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n   * just the object itself should not be of a generic type. If the object is of generic type, use\n   * {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which Json representation is to be created setting for Gson\n   * @param writer Writer to which the Json representation needs to be written\n   * @since 1.2\n   */\n  public void toJson(Object src, Appendable writer) {\n    try {\n      if (src != null) {\n        toJson(src, src.getClass(), writer);\n      } else if (serializeNulls) {\n        writeOutNullString(writer);\n      }\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n    toJson(jsonElement, writer);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the\n   * specified object is a generic type. For non-generic objects, use {@link #toJsonTree(Object)}\n   * instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   */\n  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    return toJsonTree(src, typeOfSrc, true);\n  }\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object)} instead. If you want to write out\n   * the object to a {@link Appendable}, use {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   */\n  public String toJson(Object src, Type typeOfSrc) {\n    return toJson(src, typeOfSrc, true);\n  }\n/**\n   * This method serializes the specified object into its equivalent Json representation.\n   * This method should be used when the specified object is not a generic type. This method uses\n   * {@link Class#getClass()} to get the type for the specified object, but the\n   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n   * just the object itself should not be of a generic type. If the object is of generic type, use\n   * {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which Json representation is to be created setting for Gson\n   * @param writer Writer to which the Json representation needs to be written\n   * @since 1.2\n   */\n  public void toJson(Object src, Appendable writer) {\n    try {\n      if (src != null) {\n        toJson(src, src.getClass(), writer, false);\n      } else if (serializeNulls) {\n        writeOutNullString(writer);\n      }\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    toJson(src, typeOfSrc, writer, true);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate JsonElement toJsonTree(Object src, Type typeOfSrc, boolean preserveType) {\n    if (src == null) {\n      return JsonNull.createJsonNull();\n    }\n    JsonSerializationContextDefault context = new JsonSerializationContextDefault(\n        createDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\n    return context.serialize(src, typeOfSrc, preserveType);\n  }\nExtractedCodeFragments:\nprivate String toJson(Object src, Type typeOfSrc, boolean preserveType) {\n    StringWriter writer = new StringWriter();\n    toJson(src, typeOfSrc, writer, preserveType);\n    return writer.toString();\n  }\nExtractedCodeFragments:\nprivate void toJson(Object src, Type typeOfSrc, Appendable writer, boolean preserveType) {\n    JsonElement jsonElement = toJsonTree(src, typeOfSrc, preserveType);\n    toJson(jsonElement, writer);\n  }\nExtractedCodeFragments:\nprivate void toJson(Object src, Type typeOfSrc, Appendable writer, boolean preserveType) {\n    JsonElement jsonElement = toJsonTree(src, typeOfSrc, preserveType);\n    toJson(jsonElement, writer);\n  }",
          "uniqueId": "b634804533ab68697b6f5414e8c93c3613850bf2_208_231_228_235_208_226"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public JsonElement serialize(Object src, Type typeOfSrc) {\r\n    ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc));\r\n    JsonSerializationVisitor visitor =\r\n        new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);\r\n    on.accept(visitor);\r\n    return visitor.getJsonElement();\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonSerializationContextDefault.java",
          "sourceCodeAfterRefactoring": "public JsonElement serialize(Object src, Type typeOfSrc) {\r\n    return serialize(src, typeOfSrc, true);\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\r\n    ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType));\r\n    JsonSerializationVisitor visitor =\r\n        new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);\r\n    on.accept(visitor);\r\n    return visitor.getJsonElement();\r\n  }",
          "uniqueId": "b634804533ab68697b6f5414e8c93c3613850bf2_48_54_52_58_48_50"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "907082102dad9f93d20ccf4a53ea626d5dc559eb",
      "url": "https://github.com/google/gson/commit/907082102dad9f93d20ccf4a53ea626d5dc559eb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"unchecked\")\n  public boolean visitUsingCustomHandler(Object obj, Type objType) {\n    JsonSerializer serializer = serializers.getHandlerFor(objType);\n    if (serializer == null && obj != null) {\n      serializer = serializers.getHandlerFor(obj.getClass());\n    }\n\n    if (serializer != null) {\n      if (obj == null) {\n        assignToRoot(JsonNull.createJsonNull());\n      } else {\n        assignToRoot(serializer.serialize(obj, objType, context));\n      }\n      return true;\n    }\n    return false;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonSerializationVisitor.java",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"unchecked\")\n  public boolean visitUsingCustomHandler(Object obj, Type objType) {\n    try {\n      JsonSerializer serializer = serializers.getHandlerFor(objType);\n      if (serializer == null && obj != null) {\n        serializer = serializers.getHandlerFor(obj.getClass());\n      }\n\n      if (serializer != null) {\n        if (obj == null) {\n          assignToRoot(JsonNull.createJsonNull());\n        } else {\n          assignToRoot(invokeCustomHandler(obj, objType, serializer));\n        }\n        return true;\n      }\n      return false;\n    } catch (CircularReferenceException e) {\n      throw e.createDetailedException(null);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"unchecked\")\n  private JsonElement invokeCustomHandler(Object obj, Type objType, JsonSerializer serializer) {\n    start(obj);\n    try {\n      return serializer.serialize(obj, objType, context);\n    } finally {\n      end(obj);\n    }\n  }",
          "uniqueId": "907082102dad9f93d20ccf4a53ea626d5dc559eb_161_177_191_199_169_189"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "3e7ebf85568e7c9ef5b1373907c89a215e27e2b9",
      "url": "https://github.com/google/gson/commit/3e7ebf85568e7c9ef5b1373907c89a215e27e2b9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void visitObjectField(Field f, Type typeOfF, Object obj) {\n    if (isFieldNull(f, obj)) {\n      if (serializeNulls) {\n        addChildAsElement(f, JsonNull.createJsonNull());\n      }\n    } else {\n      Object fieldValue = getFieldValue(f, obj);\n      // This takes care of situations where the field was declared as an Object, but the\n      // actual value contains something more specific. See Issue 54.\n      if (fieldValue != null && typeOfF == Object.class) {\n        typeOfF = fieldValue.getClass();\n      }\n      addAsChildOfObject(f, typeOfF, fieldValue);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonSerializationVisitor.java",
          "sourceCodeAfterRefactoring": "public void visitObjectField(Field f, Type typeOfF, Object obj) {\n    if (isFieldNull(f, obj)) {\n      if (serializeNulls) {\n        addChildAsElement(f, JsonNull.createJsonNull());\n      }\n    } else {\n      Object fieldValue = getFieldValue(f, obj);\n      if (fieldValue != null) {\n        typeOfF = getActualTypeIfMoreSpecific(typeOfF, fieldValue.getClass());\n      }\n      addAsChildOfObject(f, typeOfF, fieldValue);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) {\n    if (type instanceof Class<?>) {\n      Class<?> typeAsClass = (Class<?>) type;\n      if (typeAsClass.isAssignableFrom(actualClass)) {\n        type = actualClass;\n      }\n      if (type == Object.class) {\n        type = actualClass;\n      } \n    }\n    return type;\n  }",
          "uniqueId": "3e7ebf85568e7c9ef5b1373907c89a215e27e2b9_94_108_114_125_98_110"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "18b301dfeb91ca4468e0955d4cafcb32186efe1e",
      "url": "https://github.com/google/gson/commit/18b301dfeb91ca4468e0955d4cafcb32186efe1e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * Navigate all the fields of the specified object.\n   * If a field is null, it does not get visited.\n   */\n  public void accept(Visitor visitor) {\n    boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(obj, objType);\n    if (!visitedWithCustomHandler) {\n      Object objectToVisit = (obj == null) ? visitor.getTarget() : obj;\n      if (objectToVisit == null) {\n        return;\n      }\n      TypeInfo objTypeInfo = new TypeInfo(objType);\n      if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\n        return;\n      }\n      visitor.start(obj);  \n      try {\n        if (objTypeInfo.isArray()) {\n          visitor.visitArray(objectToVisit, objType);\n        } else if (objTypeInfo.getActualType() == Object.class) {\n          visitor.visitPrimitive(objectToVisit);\n          objectToVisit = visitor.getTarget();\n        } else {\n          visitor.startVisitingObject(objectToVisit);\n          // For all classes in the inheritance hierarchy (including the current class),\n          // visit all fields\n          for (Class<?> curr = objTypeInfo.getRawClass();\n          curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) {\n            if (!curr.isSynthetic()) {\n              navigateClassFields(objectToVisit, curr, visitor);\n            }\n          }\n        }\n      } finally {\n        visitor.end(obj);\n      }\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/ObjectNavigator.java",
          "sourceCodeAfterRefactoring": "/**\n   * Navigate all the fields of the specified object.\n   * If a field is null, it does not get visited.\n   */\n  public void accept(Visitor visitor) {\n    boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(obj, objType);\n    if (!visitedWithCustomHandler) {\n      Object objectToVisit = (obj == null) ? visitor.getTarget() : obj;\n      if (objectToVisit == null) {\n        return;\n      }\n      TypeInfo objTypeInfo = new TypeInfo(objType);\n      if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\n        return;\n      }\n      visitor.start(obj);  \n      try {\n        if (objTypeInfo.isArray()) {\n          visitor.visitArray(objectToVisit, objType);\n        } else if (objTypeInfo.getActualType() == Object.class\n            && isPrimitiveOrString(objectToVisit)) {\n          // TODO(Joel): this is only used for deserialization of \"primitves\"\n          //             we should rethink this!!!\n          visitor.visitPrimitive(objectToVisit);\n          objectToVisit = visitor.getTarget();\n        } else {\n          visitor.startVisitingObject(objectToVisit);\n          // For all classes in the inheritance hierarchy (including the current class),\n          // visit all fields\n          Class<?> topLevelClass = (objTypeInfo.getRawClass() == Object.class)\n              ? objectToVisit.getClass() : objTypeInfo.getRawClass();\n          for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class);\n              curr = curr.getSuperclass()) {\n            if (!curr.isSynthetic()) {\n              navigateClassFields(objectToVisit, curr, visitor);\n            }\n          }\n        }\n      } finally {\n        visitor.end(obj);\n      }\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isPrimitiveOrString(Object objectToVisit) {\n    Class<?> realClazz = objectToVisit.getClass();\n    return realClazz == Object.class || realClazz == String.class\n        || Primitives.unwrap(realClazz).isPrimitive();\n  }",
          "uniqueId": "18b301dfeb91ca4468e0955d4cafcb32186efe1e_92_129_136_140_92_134"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "cbcf7defa344ad1dee63baa0767613a5f9848e86",
      "url": "https://github.com/google/gson/commit/cbcf7defa344ad1dee63baa0767613a5f9848e86",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\r\n   * Returns a new Token object, by default. However, if you want, you\r\n   * can create and return subclass objects based on the value of ofKind.\r\n   * Simply add the cases to the switch for all those special cases.\r\n   * For example, if you have a subclass of Token called IDToken that\r\n   * you want to create if ofKind is ID, simlpy add something like :\r\n   *\r\n   *    case MyParserConstants.ID : return new IDToken();\r\n   *\r\n   * to the following switch statement. Then you can cast matchedToken\r\n   * variable to the appropriate type and use it in your lexical actions.\r\n   */\r\n  public static final Token newToken(int ofKind)\r\n  {\r\n     switch(ofKind)\r\n     {\r\n       default : return new Token();\r\n     }\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Token.java",
          "sourceCodeAfterRefactoring": "public static Token newToken(int ofKind)\n  {\n    return newToken(ofKind, null);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Returns a new Token object, by default. However, if you want, you\n   * can create and return subclass objects based on the value of ofKind.\n   * Simply add the cases to the switch for all those special cases.\n   * For example, if you have a subclass of Token called IDToken that\n   * you want to create if ofKind is ID, simply add something like :\n   *\n   *    case MyParserConstants.ID : return new IDToken(ofKind, image);\n   *\n   * to the following switch statement. Then you can cast matchedToken\n   * variable to the appropriate type and use sit in your lexical actions.\n   */\n  public static Token newToken(int ofKind, String image)\n  {\n    switch(ofKind)\n    {\n      default : return new Token(ofKind, image);\n    }\n  }",
          "uniqueId": "cbcf7defa344ad1dee63baa0767613a5f9848e86_62_80_105_123_125_128"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "final private JsonArray JsonArray() throws ParseException {\n  JsonArray array = new JsonArray();\n    jj_consume_token(31);\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case DIGITS:\n    case NULL:\n    case NAN:\n    case INFINITY:\n    case BOOLEAN:\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n    case 27:\n    case 31:\n    case 33:\n      Elements(array);\n      break;\n    default:\n      jj_la1[6] = jj_gen;\n      ;\n    }\n    jj_consume_token(32);\n    array.reverse();\n    {if (true) return array;}\n    throw new Error(\"Missing return statement in function\");\n  }\nprivate boolean jj_3R_4() {\n    if (jj_scan_token(33)) return true;\n    return false;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParserJavacc.java",
          "sourceCodeAfterRefactoring": "final private JsonArray JsonArray() throws ParseException {\n  JsonArray array = new JsonArray();\n    jj_consume_token(31);\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case 32:\n      array = JsonArrayEmpty(array);\n                               {if (true) return array;}\n      break;\n    case DIGITS:\n    case NULL:\n    case NAN:\n    case INFINITY:\n    case BOOLEAN:\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n    case 27:\n    case 31:\n    case 33:\n      JsonArrayElement(array);\n      label_1:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case 29:\n          ;\n          break;\n        default:\n          jj_la1[6] = jj_gen;\n          break label_1;\n        }\n        JsonArrayNextElement(array);\n      }\n      jj_consume_token(32);\n                                                              {if (true) return array;}\n      break;\n    default:\n      jj_la1[7] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n  }\nprivate boolean jj_3R_4() {\n    Token xsp;\n    xsp = jj_scanpos;\n    if (jj_3R_5()) jj_scanpos = xsp;\n    if (jj_scan_token(INFINITY)) return true;\n    return false;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nfinal private JsonArray JsonArrayEmpty(JsonArray array) throws ParseException {\n    jj_consume_token(32);\n        {if (true) return array;}\n    throw new Error(\"Missing return statement in function\");\n  }\nExtractedCodeFragments:\nprivate boolean jj_3R_5() {\n    if (jj_scan_token(33)) return true;\n    return false;\n  }",
          "uniqueId": "cbcf7defa344ad1dee63baa0767613a5f9848e86_137_161_179_183_137_177"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b7cbfc5c347869a271270ab98b8238428813517f",
      "url": "https://github.com/google/gson/commit/b7cbfc5c347869a271270ab98b8238428813517f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    try {\n      if (generateNonExecutableJson) {\n        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n      }\n      JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n      formatter.format(jsonElement, writer, serializeNulls);\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n    toJson(jsonElement, writer);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * Writes out the equivalent JSON for the tree of {@link JsonElement}s.\n   * \n   * @param jsonElement root of the tree of {@link JsonElement}s\n   * @param writer Writer to which the Json representation needs to be written\n   * @since 1.4\n   */\n  public void toJson(JsonElement jsonElement, Appendable writer) {\n    try {\n      if (generateNonExecutableJson) {\n        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n      }\n      if (jsonElement == null && serializeNulls) {\n        writeOutNullString(writer);\n      }\n      formatter.format(jsonElement, writer, serializeNulls);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }    \n  }",
          "uniqueId": "b7cbfc5c347869a271270ab98b8238428813517f_302_327_335_354_302_320"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6d50bcea8711642c90caa6db6b1f13ccd38290c1",
      "url": "https://github.com/google/gson/commit/6d50bcea8711642c90caa6db6b1f13ccd38290c1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ClassWithExposedFields(Integer a, Integer b) {\n      this.a = a;\n      this.b = b;\n    }",
          "filePathBefore": "gson/src/test/java/com/google/gson/functional/ExposeFieldsTest.java",
          "sourceCodeAfterRefactoring": "public ClassWithExposedFields(Integer a, Integer b) {\n      this(a, b, 1L, 2.0, 'a');\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ClassWithExposedFields(Integer a, Integer b, long c, double d, char e) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n      this.d = d;\n      this.e = e;\n    }",
          "uniqueId": "6d50bcea8711642c90caa6db6b1f13ccd38290c1_120_123_127_133_124_126"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "b44bbbf5e70d2589e3293be1c91c63dba6b5bbfb",
      "url": "https://github.com/google/gson/commit/b44bbbf5e70d2589e3293be1c91c63dba6b5bbfb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    try {\n      if (src != null) {\n        JsonSerializationContext context = new JsonSerializationContextDefault(\n            createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n        JsonElement jsonElement = context.serialize(src, typeOfSrc);\n\n        if (generateNonExecutableJson) {\n          writer.append(JSON_NON_EXECUTABLE_PREFIX);\n        }\n        //TODO(Joel): instead of navigating the \"JsonElement\" inside the formatter, do it here.\n        formatter.format(jsonElement, writer, serializeNulls);\n      } else {\n        if (serializeNulls) {\n          writeOutNullString(writer);\n        }\n      }\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/Gson.java",
          "sourceCodeAfterRefactoring": "/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent Json representation. This method must be used if the specified object is a generic\n   * type. For non-generic objects, use {@link #toJson(Object, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @param writer Writer to which the Json representation of src needs to be written.\n   * @since 1.2\n   */\n  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n    try {\n      if (generateNonExecutableJson) {\n        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n      }\n      JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n      formatter.format(jsonElement, writer, serializeNulls);\n    } catch (IOException ioe) {\n      throw new RuntimeException(ioe);\n    }\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n   * This method serializes the specified object, including those of generic types, into its\n   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the \n   * specified object is a generic type. For non-generic objects, use {@link #toJson(Object)} \n   * instead. If you want to write out the object to a {@link Appendable}, \n   * use {@link #toJson(Object, Type, Appendable)} instead.\n   *\n   * @param src the object for which JSON representation is to be created\n   * @param typeOfSrc The specific genericized type of src. You can obtain\n   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n   * to get the type for {@code Collection<Foo>}, you should use:\n   * <pre>\n   * Type typeOfSrc = new TypeToken<Collection<Foo>>(){}.getType();\n   * </pre>\n   * @return Json representation of {@code src}\n   * @since 1.4\n   */\n  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n    if (src == null) {\n      return JsonNull.createJsonNull();\n    }\n    JsonSerializationContext context = new JsonSerializationContextDefault(\n        createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n    return context.serialize(src, typeOfSrc);\n  }",
          "uniqueId": "b44bbbf5e70d2589e3293be1c91c63dba6b5bbfb_249_284_204_228_296_321"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "16be7167ec8470cc6ba24e188b6fd6d70afe109d",
      "url": "https://github.com/google/gson/commit/16be7167ec8470cc6ba24e188b6fd6d70afe109d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "final private JsonPrimitive JsonMemberName() throws ParseException {\n  Token t; JsonPrimitive value;\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case IDENTIFIER:\n      t = jj_consume_token(IDENTIFIER);\n                   {if (true) return new JsonPrimitive(t.image);}\n      break;\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n      value = JsonString();\n                       {if (true) return value;}\n      break;\n    default:\n      jj_la1[3] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParserImpl.java",
          "sourceCodeAfterRefactoring": "final private JsonPrimitive JsonMemberName() throws ParseException {\n  Token t; JsonPrimitive value;\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case IDENTIFIER_SANS_EXPONENT:\n    case IDENTIFIER_STARTS_WITH_EXPONENT:\n      t = Identifier();\n                    {if (true) return new JsonPrimitive(t.image);}\n      break;\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n      value = JsonString();\n                       {if (true) return value;}\n      break;\n    default:\n      jj_la1[3] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nfinal private Token Identifier() throws ParseException {\n  Token t;\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case IDENTIFIER_STARTS_WITH_EXPONENT:\n      t = jj_consume_token(IDENTIFIER_STARTS_WITH_EXPONENT);\n      break;\n    case IDENTIFIER_SANS_EXPONENT:\n      t = jj_consume_token(IDENTIFIER_SANS_EXPONENT);\n      break;\n    default:\n      jj_la1[14] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n                                                                            {if (true) return t;}\n    throw new Error(\"Missing return statement in function\");\n  }",
          "uniqueId": "16be7167ec8470cc6ba24e188b6fd6d70afe109d_84_102_327_343_85_104"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "90a461903438c1810588c94863cc5b50e3c75877",
      "url": "https://github.com/google/gson/commit/90a461903438c1810588c94863cc5b50e3c75877",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void breakLineIfNeeded() throws IOException {\n      if (getLine().length() > printMargin - rightMargin) {\n        finishLine();\n      }\n    }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonPrintFormatter.java",
          "sourceCodeAfterRefactoring": "private void breakLineIfNeeded() throws IOException {\n      breakLineIfThisToNextExceedsLimit(0);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void breakLineIfThisToNextExceedsLimit(int nextLength) throws IOException {\n        if (getLine().length() + nextLength > printMargin - rightMargin) {\n          finishLine();\n        }\n      }",
          "uniqueId": "90a461903438c1810588c94863cc5b50e3c75877_109_113_115_119_111_113"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "73d93e332251ccf3619b3b6d2e7b1529e902e78d",
      "url": "https://github.com/google/gson/commit/73d93e332251ccf3619b3b6d2e7b1529e902e78d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public JsonPrintFormatter() {\n    this(DEFAULT_PRINT_MARGIN, DEFAULT_INDENTATION_SIZE, DEFAULT_RIGHT_MARGIN);\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonPrintFormatter.java",
          "sourceCodeAfterRefactoring": "JsonPrintFormatter() {\n    this(true);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nJsonPrintFormatter(boolean escapeHtmlChars) {\n    this(DEFAULT_PRINT_MARGIN, DEFAULT_INDENTATION_SIZE, DEFAULT_RIGHT_MARGIN, escapeHtmlChars);\n  }",
          "uniqueId": "73d93e332251ccf3619b3b6d2e7b1529e902e78d_40_42_45_47_41_43"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "458f2baa2f79bbfe78d3db3dfa1dd7866d7cf7a9",
      "url": "https://github.com/google/gson/commit/458f2baa2f79bbfe78d3db3dfa1dd7866d7cf7a9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n    ParameterizedTypeHandlerMap<JsonSerializer<?>> map =\n      new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n\n    map.register(Enum.class, ENUM_TYPE_ADAPTER);\n    map.register(URL.class, URL_TYPE_ADAPTER);\n    map.register(URI.class, URI_TYPE_ADAPTER);\n    map.register(UUID.class, UUUID_TYPE_ADAPTER);\n    map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n    map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n    map.register(Map.class, MAP_TYPE_ADAPTER);\n    map.register(Date.class, DATE_TYPE_ADAPTER);\n    map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n    map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n    \n    // Add primitive serializers\n    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n    map.register(Byte.class, BYTE_TYPE_ADAPTER);\n    map.register(byte.class, BYTE_TYPE_ADAPTER);\n    map.register(Character.class, CHARACTER_TYPE_ADAPTER);\n    map.register(char.class, CHARACTER_TYPE_ADAPTER);\n    map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n    map.register(int.class, INTEGER_TYPE_ADAPTER);\n    map.register(Long.class, LONG_TYPE_ADAPTER);\n    map.register(long.class, LONG_TYPE_ADAPTER);\n    map.register(Number.class, NUMBER_TYPE_ADAPTER);\n    map.register(Short.class, SHORT_TYPE_ADAPTER);\n    map.register(short.class, SHORT_TYPE_ADAPTER);\n    map.register(String.class, STRING_TYPE_ADAPTER);\n\n    map.makeUnmodifiable();\n    return map;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/DefaultTypeAdapters.java",
          "sourceCodeAfterRefactoring": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\n    return getDefaultSerializers(false, false);\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\n      boolean serializeSpecialFloatingPointValues, boolean serializeLongsAsString) {\n    ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\n        new ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n    \n    // Double primitive\n    DefaultTypeAdapters.DoubleSerializer doubleSerializer = \n        new DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues);\n    serializers.registerIfAbsent(Double.class, doubleSerializer);\n    serializers.registerIfAbsent(double.class, doubleSerializer);\n\n    // Float primitive\n    DefaultTypeAdapters.FloatSerializer floatSerializer = \n        new DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues);\n    serializers.registerIfAbsent(Float.class, floatSerializer);\n    serializers.registerIfAbsent(float.class, floatSerializer);\n\n    // Long primitive\n    DefaultTypeAdapters.LongSerializer longSerializer = \n        new DefaultTypeAdapters.LongSerializer(serializeLongsAsString);\n    serializers.registerIfAbsent(Long.class, longSerializer);\n    serializers.registerIfAbsent(long.class, longSerializer);\n\n    serializers.registerIfAbsent(DEFAULT_SERIALIZERS);\n    return serializers;\n  }",
          "uniqueId": "458f2baa2f79bbfe78d3db3dfa1dd7866d7cf7a9_91_124_189_214_185_187"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "362a94ec74f81a8c9f2a3f42d1a53d9400be2e69",
      "url": "https://github.com/google/gson/commit/362a94ec74f81a8c9f2a3f42d1a53d9400be2e69",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "final private JsonPrimitive JsonNumber() throws ParseException {\n  String intpart = null,\n         fracpart = null,\n         exppart = null;\n    intpart = JsonInt();\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case 30:\n      fracpart = JsonFrac();\n      break;\n    default:\n      jj_la1[8] = jj_gen;\n      ;\n    }\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case E:\n      exppart = JsonExp();\n      break;\n    default:\n      jj_la1[9] = jj_gen;\n      ;\n    }\n    Number n;\n    if (exppart != null || fracpart != null) {\n      fracpart = (fracpart == null) ? \"\" : fracpart;\n      exppart = (exppart == null) ? \"\" : exppart;\n      n = new java.math.BigDecimal(intpart + fracpart + exppart);\n    } else {\n      n = new java.math.BigInteger(intpart);\n    }\n    {if (true) return new JsonPrimitive(n);}\n    throw new Error(\"Missing return statement in function\");\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParser.java",
          "sourceCodeAfterRefactoring": "final private JsonPrimitive JsonNumber() throws ParseException {\r\n  String intpart = null,\r\n         fracpart = null,\r\n         exppart = null;\r\n  JsonPrimitive value;\r\n    if (jj_2_1(2)) {\r\n      value = JsonSpecialNumbers();\r\n                                {if (true) return value;}\r\n    } else {\r\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n      case DIGITS:\r\n      case 31:\r\n        intpart = JsonInt();\r\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n        case 32:\r\n          fracpart = JsonFrac();\r\n          break;\r\n        default:\r\n          jj_la1[8] = jj_gen;\r\n          ;\r\n        }\r\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n        case E:\r\n          exppart = JsonExp();\r\n          break;\r\n        default:\r\n          jj_la1[9] = jj_gen;\r\n          ;\r\n        }\r\n    Number n;\r\n    if (exppart != null || fracpart != null) {\r\n      fracpart = (fracpart == null) ? \"\" : fracpart;\r\n      exppart = (exppart == null) ? \"\" : exppart;\r\n      n = new java.math.BigDecimal(intpart + fracpart + exppart);\r\n    } else {\r\n      n = new java.math.BigInteger(intpart);\r\n    }\r\n    {if (true) return new JsonPrimitive(n);}\r\n        break;\r\n      default:\r\n        jj_la1[10] = jj_gen;\r\n        jj_consume_token(-1);\r\n        throw new ParseException();\r\n      }\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nfinal private JsonPrimitive JsonSpecialNumbers() throws ParseException {\r\n  boolean negative = false;\r\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n    case NAN:\r\n      jj_consume_token(NAN);\r\n           {if (true) return new JsonPrimitive(Double.NaN);}\r\n      break;\r\n    case INFINITY:\r\n    case 31:\r\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n      case 31:\r\n        jj_consume_token(31);\r\n         negative = true;\r\n        break;\r\n      default:\r\n        jj_la1[11] = jj_gen;\r\n        ;\r\n      }\r\n      jj_consume_token(INFINITY);\r\n                                        {if (true) return new JsonPrimitive(negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);}\r\n      break;\r\n    default:\r\n      jj_la1[12] = jj_gen;\r\n      jj_consume_token(-1);\r\n      throw new ParseException();\r\n    }\r\n    throw new Error(\"Missing return statement in function\");\r\n  }",
          "uniqueId": "362a94ec74f81a8c9f2a3f42d1a53d9400be2e69_207_238_262_289_214_260"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "6f59bc3bfea8ccdff1bfd0640351241ccf4100ff",
      "url": "https://github.com/google/gson/commit/6f59bc3bfea8ccdff1bfd0640351241ccf4100ff",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean isValidVersion(Annotation[] annotations) {\n    for (Annotation annotation : annotations) {\n      if (annotation instanceof Since) {\n        double annotationVersion = ((Since) annotation).value();\n        if (annotationVersion > version) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/VersionExclusionStrategy.java",
          "sourceCodeAfterRefactoring": "private boolean isValidVersion(Annotation[] annotations) {\n    for (Annotation annotation : annotations) {\n      if (!isValidSince(annotation) || !isValidUntil(annotation)) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isValidSince(Annotation annotation) {\n    if (annotation instanceof Since) {\n      double annotationVersion = ((Since) annotation).value();\n      if (annotationVersion > version) {\n        return false;\n      }\n    }\n    return true;\n  }",
          "uniqueId": "6f59bc3bfea8ccdff1bfd0640351241ccf4100ff_46_56_56_64_47_54"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "59be02d4de5f854b13b3cce194d2cab8ea1ad8ab",
      "url": "https://github.com/google/gson/commit/59be02d4de5f854b13b3cce194d2cab8ea1ad8ab",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "final private JsonArray JsonArray() throws ParseException {\r\n  JsonArray array = new JsonArray();\r\n    jj_consume_token(25);\r\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\r\n    case DIGITS:\r\n    case SINGLE_QUOTE_LITERAL:\r\n    case DOUBLE_QUOTE_LITERAL:\r\n    case 20:\r\n    case 22:\r\n    case 25:\r\n    case 27:\r\n    case 28:\r\n    case 29:\r\n      Elements(array);\r\n      break;\r\n    default:\r\n      jj_la1[3] = jj_gen;\r\n      ;\r\n    }\r\n    jj_consume_token(26);\r\n    array.reverse();\r\n    {if (true) return array;}\r\n    throw new Error(\"Missing return statement in function\");\r\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/JsonParser.java",
          "sourceCodeAfterRefactoring": "final private JsonArray JsonArray() throws ParseException {\n  JsonArray array = new JsonArray();\n    jj_consume_token(27);\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case DIGITS:\n    case NULL:\n    case BOOLEAN:\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n    case 23:\n    case 27:\n    case 29:\n      Elements(array);\n      break;\n    default:\n      jj_la1[4] = jj_gen;\n      ;\n    }\n    jj_consume_token(28);\n    array.reverse();\n    {if (true) return array;}\n    throw new Error(\"Missing return statement in function\");\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nfinal private JsonPrimitive JsonMemberName() throws ParseException {\n  Token t; JsonPrimitive value;\n    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n    case IDENTIFIER:\n      t = jj_consume_token(IDENTIFIER);\n                   {if (true) return new JsonPrimitive(t.image);}\n      break;\n    case SINGLE_QUOTE_LITERAL:\n    case DOUBLE_QUOTE_LITERAL:\n      value = JsonString();\n                       {if (true) return value;}\n      break;\n    default:\n      jj_la1[3] = jj_gen;\n      jj_consume_token(-1);\n      throw new ParseException();\n    }\n    throw new Error(\"Missing return statement in function\");\n  }",
          "uniqueId": "59be02d4de5f854b13b3cce194d2cab8ea1ad8ab_82_105_82_100_102_124"
        }
      ]
    },
    {
      "repository": "https://github.com/google/gson.git",
      "sha1": "9245bebdba9a3227674f3c0b08d86165891f02cc",
      "url": "https://github.com/google/gson/commit/9245bebdba9a3227674f3c0b08d86165891f02cc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public synchronized T getHandlerFor(Type type) {\n    T handler = map.get(type);\n    if (handler == null && type instanceof ParameterizedType) {\n      // a handler for a non-generic version is registered, so use that\n      Type rawType = ((ParameterizedType)type).getRawType();\n      handler = map.get(rawType);\n    }\n    return handler;\n  }",
          "filePathBefore": "gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java",
          "sourceCodeAfterRefactoring": "public synchronized T getHandlerFor(Type type) {\n    T handler = getRawHandlerFor(type);\n    Type rawType = type;\n    if (handler == null && type instanceof ParameterizedType) {\n      // a handler for a non-generic version may be registered, so use that\n      rawType = ((ParameterizedType)type).getRawType();\n      handler = map.get(rawType);\n    }\n    // Check for map or collection \n    if (handler == null) {\n      if (rawType instanceof Class) {\n        Class<?> rawClass = (Class<?>) rawType;\n        if (Map.class.isAssignableFrom(rawClass)) {\n          handler = map.get(Map.class);\n        } else if (Collection.class.isAssignableFrom(rawClass)) {\n          handler = map.get(Collection.class);\n        }\n      }\n    }\n    return handler;\n  }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate synchronized T getRawHandlerFor(Type type) {\n    T handler = map.get(type);\n    if (type instanceof Map) {\n      handler = map.get(Map.class);\n    } else if (type instanceof Collection) {\n      handler = map.get(Collection.class);\n    }\n    return handler;\n  }",
          "uniqueId": "9245bebdba9a3227674f3c0b08d86165891f02cc_64_72_87_95_65_85"
        }
      ]
    }
  ]
}
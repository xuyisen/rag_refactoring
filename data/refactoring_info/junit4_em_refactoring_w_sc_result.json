{
  "commits": [
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6ba9c4dc1e71e9ceb2e35991e8fc0e4aee69ad6e",
      "url": "https://github.com/junit-team/junit4/commit/6ba9c4dc1e71e9ceb2e35991e8fc0e4aee69ad6e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Run the tests contained in the classes named in the <code>args</code>.\n     * If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1.\n     * Write feedback while tests are running and write\n     * stack traces for all failed tests after the tests all complete.\n     *\n     * @param args names of classes in which to find tests to run\n     */\n    public static void main(String... args) {\n        Result result = new JUnitCore().runMain(new RealSystem(), args);\n        System.exit(result.wasSuccessful() ? 0 : 1);\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Run the tests contained in the classes named in the <code>args</code>.\n     * If all tests run successfully, exit with a status of 0. Otherwise exit with a status of 1.\n     * Write feedback while tests are running and write\n     * stack traces for all failed tests after the tests all complete.\n     *\n     * @param args names of classes in which to find tests to run\n     */\n    public static void main(String... args) {\n        System.exit(runMain(args));\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic int runMain(String[] args) {\n        Result result = new JUnitCore().runMain(new RealSystem(), args);\n        return result.wasSuccessful() ? 0 : 1;\n    }",
          "uniqueId": "6ba9c4dc1e71e9ceb2e35991e8fc0e4aee69ad6e_27_38_39_42_27_37"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2db63942882d91020b46d7333285e5c94f1d1e52",
      "url": "https://github.com/junit-team/junit4/commit/2db63942882d91020b46d7333285e5c94f1d1e52",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime()\n            throws Throwable {\n        evaluateWithWaitDuration(0).run();\n        assertThrows(\n                TestTimedOutException.class,\n                evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT));\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void throwExceptionIfTheSecondCallToEvaluateNeedsTooMuchTime()\n            throws Throwable {\n        DelegateStatement statement = new DelegateStatement();\n        FailOnTimeout failOnTimeout = failAfter50Ms(statement);\n\n        statement.delegate = new FastStatement();\n        failOnTimeout.evaluate();\n\n        statement.delegate = new InfiniteLoop();\n        assertThrows(\n                TestTimedOutException.class,\n                run(failOnTimeout));\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate ThrowingRunnable run(final FailOnTimeout failOnTimeout) {\n        return new ThrowingRunnable() {\n            public void run() throws Throwable {\n                failOnTimeout.evaluate();\n            }\n        };\n    }",
          "uniqueId": "2db63942882d91020b46d7333285e5c94f1d1e52_83_90_242_248_81_94"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() {\n        try {\n            evaluateWithException(new RuntimeException()).run();\n        } catch (Throwable expected) {\n        }\n\n        TestTimedOutException e = assertThrows(\n                TestTimedOutException.class,\n                evaluateWithWaitDuration(DURATION_THAT_EXCEEDS_TIMEOUT));\n        assertEquals(\"test timed out after 100 milliseconds\", e.getMessage());\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void throwTimeoutExceptionOnSecondCallAlthoughFirstCallThrowsException() {\n        DelegateStatement statement = new DelegateStatement();\n        FailOnTimeout failOnTimeout = failAfter50Ms(statement);\n\n        statement.delegate = new Fail(new AssertionError(\"first execution failed\"));\n        assertThrows(\n                AssertionError.class,\n                run(failOnTimeout)\n        );\n\n        statement.delegate = new InfiniteLoop();\n        assertThrows(\n                TestTimedOutException.class,\n                run(failOnTimeout));\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate ThrowingRunnable run(final FailOnTimeout failOnTimeout) {\n        return new ThrowingRunnable() {\n            public void run() throws Throwable {\n                failOnTimeout.evaluate();\n            }\n        };\n    }",
          "uniqueId": "2db63942882d91020b46d7333285e5c94f1d1e52_92_103_242_248_96_111"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "de77f666b6bcc640425dbbca559c9d62ea64a815",
      "url": "https://github.com/junit-team/junit4/commit/de77f666b6bcc640425dbbca559c9d62ea64a815",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        CallableStatement callable = new CallableStatement();\n        FutureTask<Throwable> task = new FutureTask<Throwable>(callable);\n        ThreadGroup threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        if (!threadGroup.isDaemon()) {\n            try {\n                threadGroup.setDaemon(true);\n            } catch (SecurityException e) {\n                // Swallow the exception to keep the same behavior as in JUnit 4.12.\n            }\n        }\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        callable.awaitStarted();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        CallableStatement callable = new CallableStatement();\n        FutureTask<Throwable> task = new FutureTask<Throwable>(callable);\n        ThreadGroup threadGroup = threadGroupForNewThread();\n        Thread thread = new Thread(threadGroup, task, \"Time-limited test\");\n        thread.setDaemon(true);\n        thread.start();\n        callable.awaitStarted();\n        Throwable throwable = getResult(task, thread);\n        if (throwable != null) {\n            throw throwable;\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate ThreadGroup threadGroupForNewThread() {\n        if (!lookForStuckThread) {\n            // Use the default ThreadGroup (usually the one from the current\n            // thread).\n            return null;\n        }\n\n        // Create the thread in a new ThreadGroup, so if the time-limited thread\n        // becomes stuck, getStuckThread() can find the thread likely to be the\n        // culprit.\n        ThreadGroup threadGroup = new ThreadGroup(\"FailOnTimeoutGroup\");\n        if (!threadGroup.isDaemon()) {\n            // Mark the new ThreadGroup as a daemon thread group, so it will be\n            // destroyed after the time-limited thread completes. By ensuring the\n            // ThreadGroup is destroyed, any data associated with the ThreadGroup\n            // (ex: via java.beans.ThreadGroupContext) is destroyed.\n            try {\n                threadGroup.setDaemon(true);\n            } catch (SecurityException e) {\n                // Swallow the exception to keep the same behavior as in JUnit 4.12.\n            }\n        }\n        return threadGroup;\n    }",
          "uniqueId": "de77f666b6bcc640425dbbca559c9d62ea64a815_119_139_134_157_119_132"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "610155b8c22138329f0723eec22521627dbc52ae",
      "url": "https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private File createTemporaryFolderIn(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }",
          "sourceCodeAfterRefactoring": "private static File createTemporaryFolderIn(File parentFolder) throws IOException {\n        try {\n            return createTemporaryFolderWithNioApi(parentFolder);\n        } catch (ClassNotFoundException ignore) {\n            // Fallback for Java 5 and 6\n            return createTemporaryFolderWithFileApi(parentFolder);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof IOException) {\n                throw (IOException) cause;\n            }\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException) cause;\n            }\n            IOException exception = new IOException(\"Failed to create temporary folder in \" + parentFolder);\n            exception.initCause(cause);\n            throw exception;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create temporary folder in \" + parentFolder, e);\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static File createTemporaryFolderWithFileApi(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }",
          "uniqueId": "610155b8c22138329f0723eec22521627dbc52ae_232_251_273_292_235_255"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "aad22b88bf3332cf304da6f558152b59cdbeea2b",
      "url": "https://github.com/junit-team/junit4/commit/aad22b88bf3332cf304da6f558152b59cdbeea2b",
      "refactorings": [
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "/**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        List<TestRule> result = testClass.getAnnotatedMethodValues(null, ClassRule.class, TestRule.class);\n        result.addAll(testClass.getAnnotatedFieldValues(null, ClassRule.class, TestRule.class));\n        return result;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * @return the {@code ClassRule}s that can transform the block that runs\n     *         each method in the tested class.\n     */\n    protected List<TestRule> classRules() {\n        ClassRuleCollector collector = new ClassRuleCollector();\n        testClass.collectAnnotatedMethodValues(null, ClassRule.class, TestRule.class, collector);\n        testClass.collectAnnotatedFieldValues(null, ClassRule.class, TestRule.class, collector);\n        return collector.getOrderedRules();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic List<TestRule> getOrderedRules() {\n            if (entries.isEmpty()) {\n                return Collections.emptyList();\n            }\n            Collections.sort(entries, RuleContainer.ENTRY_COMPARATOR);\n            List<TestRule> result = new ArrayList<TestRule>(entries.size());\n            for (RuleContainer.RuleEntry entry : entries) {\n                result.add((TestRule) entry.rule);\n            }\n            return result;\n        }",
          "uniqueId": "aad22b88bf3332cf304da6f558152b59cdbeea2b_267_275_503_513_269_278"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n        return results;\n    }",
          "sourceCodeAfterRefactoring": "public <T> List<T> getAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        final List<T> results = new ArrayList<T>();\n        collectAnnotatedFieldValues(test, annotationClass, valueClass,\n                new MemberValueConsumer<T>() {\n                    public void accept(FrameworkMember member, T value) {\n                        results.add(value);\n                    }\n                });\n        return results;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Finds the fields annotated with the specified annotation and having the specified type,\n     * retrieves the values and passes those to the specified consumer.\n     *\n     * @since 4.13\n     */\n    public <T> void collectAnnotatedFieldValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass,\n            MemberValueConsumer<T> consumer) {\n        for (FrameworkField each : getAnnotatedFields(annotationClass)) {\n            try {\n                Object fieldValue = each.get(test);\n                if (valueClass.isInstance(fieldValue)) {\n                    consumer.accept(each, valueClass.cast(fieldValue));\n                }\n            } catch (IllegalAccessException e) {\n                throw new RuntimeException(\n                        \"How did getFields return a field we couldn't access?\", e);\n            }\n        }\n    }",
          "uniqueId": "aad22b88bf3332cf304da6f558152b59cdbeea2b_226_241_238_258_226_236"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        List<T> results = new ArrayList<T>();\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                /*\n                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,\n                 * we cannot call the method to check whether the return type matches our\n                 * expectation i.e. subclass of valueClass. If we do that then the method \n                 * will be invoked twice and we do not want to do that. So we first check\n                 * whether return type matches our expectation and only then call the method\n                 * to fetch the MethodRule\n                 */\n                if (valueClass.isAssignableFrom(each.getReturnType())) {\n                    Object fieldValue = each.invokeExplosively(test);\n                    results.add(valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n        return results;\n    }",
          "sourceCodeAfterRefactoring": "public <T> List<T> getAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass) {\n        final List<T> results = new ArrayList<T>();\n        collectAnnotatedMethodValues(test, annotationClass, valueClass,\n                new MemberValueConsumer<T>() {\n                    public void accept(FrameworkMember member, T value) {\n                        results.add(value);\n                    }\n                });\n        return results;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Finds the methods annotated with the specified annotation and returning the specified type,\n     * invokes it and pass the return value to the specified consumer.\n     *\n     * @since 4.13\n     */\n    public <T> void collectAnnotatedMethodValues(Object test,\n            Class<? extends Annotation> annotationClass, Class<T> valueClass,\n            MemberValueConsumer<T> consumer) {\n        for (FrameworkMethod each : getAnnotatedMethods(annotationClass)) {\n            try {\n                /*\n                 * A method annotated with @Rule may return a @TestRule or a @MethodRule,\n                 * we cannot call the method to check whether the return type matches our\n                 * expectation i.e. subclass of valueClass. If we do that then the method \n                 * will be invoked twice and we do not want to do that. So we first check\n                 * whether return type matches our expectation and only then call the method\n                 * to fetch the MethodRule\n                 */\n                if (valueClass.isAssignableFrom(each.getReturnType())) {\n                    Object fieldValue = each.invokeExplosively(test);\n                    consumer.accept(each, valueClass.cast(fieldValue));\n                }\n            } catch (Throwable e) {\n                throw new RuntimeException(\n                        \"Exception in \" + each.getName(), e);\n            }\n        }\n    }",
          "uniqueId": "aad22b88bf3332cf304da6f558152b59cdbeea2b_243_266_272_300_260_270"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1bf8438b65858565dbb64736bfe13aae9cfc1b5a",
      "url": "https://github.com/junit-team/junit4/commit/1bf8438b65858565dbb64736bfe13aae9cfc1b5a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        try {\n            next.evaluate();\n        } catch (Throwable e) {\n            errors.add(e);\n        } finally {\n            for (FrameworkMethod each : afters) {\n                try {\n                    each.invokeExplosively(target);\n                } catch (Throwable e) {\n                    errors.add(e);\n                }\n            }\n        }\n        MultipleFailureException.assertEmpty(errors);\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        List<Throwable> errors = new ArrayList<Throwable>();\n        try {\n            next.evaluate();\n        } catch (Throwable e) {\n            errors.add(e);\n        } finally {\n            for (FrameworkMethod each : afters) {\n                try {\n                    invokeMethod(each);\n                } catch (Throwable e) {\n                    errors.add(e);\n                }\n            }\n        }\n        MultipleFailureException.assertEmpty(errors);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * @since 4.13\n     */\n    protected void invokeMethod(FrameworkMethod method) throws Throwable {\n        method.invokeExplosively(target);\n    }",
          "uniqueId": "1bf8438b65858565dbb64736bfe13aae9cfc1b5a_23_40_42_47_23_40"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        for (FrameworkMethod before : befores) {\n            before.invokeExplosively(target);\n        }\n        next.evaluate();\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    public void evaluate() throws Throwable {\n        for (FrameworkMethod before : befores) {\n            invokeMethod(before);\n        }\n        next.evaluate();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * @since 4.13\n     */\n    protected void invokeMethod(FrameworkMethod method) throws Throwable {\n        method.invokeExplosively(target);\n    }",
          "uniqueId": "1bf8438b65858565dbb64736bfe13aae9cfc1b5a_21_27_29_34_21_27"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private TestWithParameters createTestWithNotNormalizedParameters(\n                String pattern, int index, Object parametersOrSingleParameter) {\n            Object[] parameters = (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n                    : new Object[] { parametersOrSingleParameter };\n            return createTestWithParameters(testClass, pattern, index,\n                    parameters);\n        }",
          "sourceCodeAfterRefactoring": "private TestWithParameters createTestWithNotNormalizedParameters(\n                String pattern, int index, Object parametersOrSingleParameter) {\n            Object[] parameters = normalizeParameters(parametersOrSingleParameter);\n            return createTestWithParameters(testClass, pattern, index, parameters);\n        }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static Object[] normalizeParameters(Object parametersOrSingleParameter) {\n            return (parametersOrSingleParameter instanceof Object[]) ? (Object[]) parametersOrSingleParameter\n                    : new Object[] { parametersOrSingleParameter };\n        }",
          "uniqueId": "1bf8438b65858565dbb64736bfe13aae9cfc1b5a_279_285_360_363_354_358"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ae28d978b41ed5a5785fde708490b19d76b0c1a5",
      "url": "https://github.com/junit-team/junit4/commit/ae28d978b41ed5a5785fde708490b19d76b0c1a5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\r\n     * Returns Class.forName for {@code className} using the current thread's class loader.\r\n     *\r\n     * @param className Name of the class.\r\n     * @throws ClassNotFoundException\r\n     */\r\n    public static Class<?> getClass(String className) throws ClassNotFoundException {\r\n        return Class.forName(className, true, currentThread().getContextClassLoader());\r\n    }",
          "sourceCodeAfterRefactoring": "/**\r\n     * Returns Class.forName for {@code className} using the current thread's class loader.\r\n     * If the current thread does not have a class loader, falls back to the class loader for\r\n     * {@link Classes}.\r\n     *\r\n     * @param className Name of the class.\r\n     * @throws ClassNotFoundException\r\n     */\r\n    public static Class<?> getClass(String className) throws ClassNotFoundException {\r\n        return getClass(className, Classes.class);\r\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\r\n     * Returns Class.forName for {@code className} using the current thread's class loader.\r\n     * If the current thread does not have a class loader, falls back to the class loader for the\r\n     * passed-in class.\r\n     *\r\n     * @param className Name of the class.\r\n     * @param callingClass Class that is requesting a the class\r\n     * @throws ClassNotFoundException\r\n     * @since 4.13\r\n     */\r\n    public static Class<?> getClass(String className, Class<?> callingClass) throws ClassNotFoundException {\r\n        ClassLoader classLoader = currentThread().getContextClassLoader();\r\n        return Class.forName(className, true, classLoader == null ? callingClass.getClassLoader() : classLoader);\r\n    }",
          "uniqueId": "ae28d978b41ed5a5785fde708490b19d76b0c1a5_18_26_30_43_18_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "892f798b459e3ffa1666b6514f1682ba5dde2525",
      "url": "https://github.com/junit-team/junit4/commit/892f798b459e3ffa1666b6514f1682ba5dde2525",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtStartMessage() {\n        try {\n            assertArrayEquals(\"not equal\", (new Object[]{true}), (new Object[]{false, true}));\n        } catch (AssertionError exception) {\n            assertEquals(\"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [0]; expected:<true> but was:<false>\", exception.getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtStartMessage() {\n        assertArrayEqualsFailure(\n                \"not equal\",\n                new Object[]{true},\n                new Object[]{false, true},\n                \"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [0]; expected:<true> but was:<false>\");\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_103_110_303_311_99_106"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtEndMessage() {\n        try {\n            assertArrayEquals(\"not equal\", (new Object[]{true}), (new Object[]{true, false}));\n        } catch (AssertionError exception) {\n            assertEquals(\"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [1]; expected:<end of array> but was:<false>\", exception.getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtEndMessage() {\n        assertArrayEqualsFailure(\n                \"not equal\",\n                new Object[]{true},\n                new Object[]{true, false},\n                \"not equal: array lengths differed, expected.length=1 actual.length=2; arrays first differed at element [1]; expected:<end of array> but was:<false>\");\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_112_119_303_311_108_115"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtEndAndExpectedArrayLongerMessage() {\n        try {\n            assertArrayEquals(\"not equal\", (new Object[]{true, false}), (new Object[]{true}));\n        } catch (AssertionError exception) {\n            assertEquals(\"not equal: array lengths differed, expected.length=2 actual.length=1; arrays first differed at element [1]; expected:<false> but was:<end of array>\", exception.getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferentLengthDifferingAtEndAndExpectedArrayLongerMessage() {\n        assertArrayEqualsFailure(\n                \"not equal\",\n                new Object[]{true, false},\n                new Object[]{true},\n                \"not equal: array lengths differed, expected.length=2 actual.length=1; arrays first differed at element [1]; expected:<false> but was:<end of array>\");\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_121_128_303_311_117_124"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferAtElement0nullMessage() {\n        try {\n            assertArrayEquals((new Object[]{true}), (new Object[]{false}));\n        } catch (AssertionError exception) {\n            assertEquals(\"arrays first differed at element [0]; expected:<true> but was:<false>\", exception\n                    .getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferAtElement0nullMessage() {\n        assertArrayEqualsFailure(\n                new Object[]{true},\n                new Object[]{false},\n                \"arrays first differed at element [0]; expected:<true> but was:<false>\"\n        );\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_135_143_293_301_135_142"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferAtElement1nullMessage() {\n        try {\n            assertArrayEquals((new Object[]{true, true}), (new Object[]{true,\n                    false}));\n        } catch (AssertionError exception) {\n            assertEquals(\"arrays first differed at element [1]; expected:<true> but was:<false>\", exception\n                    .getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferAtElement1nullMessage() {\n        assertArrayEqualsFailure(\n                new Object[]{true, true},\n                new Object[]{true, false},\n                \"arrays first differed at element [1]; expected:<true> but was:<false>\"\n        );\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_145_154_293_301_144_151"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferAtElement0withMessage() {\n        try {\n            assertArrayEquals(\"message\", (new Object[]{true}), (new Object[]{false}));\n        } catch (AssertionError exception) {\n            assertEquals(\"message: arrays first differed at element [0]; expected:<true> but was:<false>\", exception\n                    .getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferAtElement0withMessage() {\n        assertArrayEqualsFailure(\n                \"message\",\n                new Object[]{true},\n                new Object[]{false},\n                \"message: arrays first differed at element [0]; expected:<true> but was:<false>\"\n        );\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_156_164_303_311_153_161"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void arraysDifferAtElement1withMessage() {\n        try {\n            assertArrayEquals(\"message\", (new Object[]{true, true}), (new Object[]{true, false}));\n            fail();\n        } catch (AssertionError exception) {\n            assertEquals(\"message: arrays first differed at element [1]; expected:<true> but was:<false>\", exception.getMessage());\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void arraysDifferAtElement1withMessage() {\n        assertArrayEqualsFailure(\n                \"message\",\n                new Object[]{true, true},\n                new Object[]{true, false},\n                \"message: arrays first differed at element [1]; expected:<true> but was:<false>\"\n        );\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertArrayEqualsFailure(String message, Object[] expecteds, Object[] actuals, String expectedMessage) {\n        try {\n            assertArrayEquals(message, expecteds, actuals);\n        } catch (ArrayComparisonFailure e) {\n            assertEquals(expectedMessage, e.getMessage());\n            return;\n        }\n        fail(\"should have thrown an exception\");\n    }",
          "uniqueId": "892f798b459e3ffa1666b6514f1682ba5dde2525_166_174_303_311_163_171"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2adef6f30c64c5e5e14e9261637d113f7adda884",
      "url": "https://github.com/junit-team/junit4/commit/2adef6f30c64c5e5e14e9261637d113f7adda884",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    public Object createTest() throws Exception {\n        if (fieldsAreAnnotated()) {\n            return createTestUsingFieldInjection();\n        } else {\n            return createTestUsingConstructorInjection();\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    public Object createTest() throws Exception {\n        InjectionType injectionType = getInjectionType();\n        switch (injectionType) {\n            case CONSTRUCTOR:\n                return createTestUsingConstructorInjection();\n            case FIELD:\n                return createTestUsingFieldInjection();\n            default:\n                throw new IllegalStateException(\"The injection type \"\n                        + injectionType + \" is not supported.\");\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate InjectionType getInjectionType() {\n        if (fieldsAreAnnotated()) {\n            return InjectionType.FIELD;\n        } else {\n            return InjectionType.CONSTRUCTOR;\n        }\n    }",
          "uniqueId": "2adef6f30c64c5e5e14e9261637d113f7adda884_33_40_149_155_37_49"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        if (fieldsAreAnnotated()) {\n            validateZeroArgConstructor(errors);\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    protected void validateConstructor(List<Throwable> errors) {\n        validateOnlyOneConstructor(errors);\n        if (getInjectionType() != InjectionType.CONSTRUCTOR) {\n            validateZeroArgConstructor(errors);\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate InjectionType getInjectionType() {\n        if (fieldsAreAnnotated()) {\n            return InjectionType.FIELD;\n        } else {\n            return InjectionType.CONSTRUCTOR;\n        }\n    }",
          "uniqueId": "2adef6f30c64c5e5e14e9261637d113f7adda884_86_92_149_155_95_101"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n    protected void validateFields(List<Throwable> errors) {\n        super.validateFields(errors);\n        if (fieldsAreAnnotated()) {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                int index = each.getField().getAnnotation(Parameter.class)\n                        .value();\n                if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                    errors.add(new Exception(\"Invalid @Parameter value: \"\n                            + index + \". @Parameter fields counted: \"\n                            + annotatedFieldsByParameter.size()\n                            + \". Please use an index between 0 and \"\n                            + (annotatedFieldsByParameter.size() - 1) + \".\"));\n                } else {\n                    usedIndices[index]++;\n                }\n            }\n            for (int index = 0; index < usedIndices.length; index++) {\n                int numberOfUse = usedIndices[index];\n                if (numberOfUse == 0) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is never used.\"));\n                } else if (numberOfUse > 1) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is used more than once (\" + numberOfUse + \").\"));\n                }\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Override\n    protected void validateFields(List<Throwable> errors) {\n        super.validateFields(errors);\n        if (getInjectionType() == InjectionType.FIELD) {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n            int[] usedIndices = new int[annotatedFieldsByParameter.size()];\n            for (FrameworkField each : annotatedFieldsByParameter) {\n                int index = each.getField().getAnnotation(Parameter.class)\n                        .value();\n                if (index < 0 || index > annotatedFieldsByParameter.size() - 1) {\n                    errors.add(new Exception(\"Invalid @Parameter value: \"\n                            + index + \". @Parameter fields counted: \"\n                            + annotatedFieldsByParameter.size()\n                            + \". Please use an index between 0 and \"\n                            + (annotatedFieldsByParameter.size() - 1) + \".\"));\n                } else {\n                    usedIndices[index]++;\n                }\n            }\n            for (int index = 0; index < usedIndices.length; index++) {\n                int numberOfUse = usedIndices[index];\n                if (numberOfUse == 0) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is never used.\"));\n                } else if (numberOfUse > 1) {\n                    errors.add(new Exception(\"@Parameter(\" + index\n                            + \") is used more than once (\" + numberOfUse + \").\"));\n                }\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate InjectionType getInjectionType() {\n        if (fieldsAreAnnotated()) {\n            return InjectionType.FIELD;\n        } else {\n            return InjectionType.CONSTRUCTOR;\n        }\n    }",
          "uniqueId": "2adef6f30c64c5e5e14e9261637d113f7adda884_94_124_149_155_103_133"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "0804ef4cd09b0e94783a9882c60914e22fca5108",
      "url": "https://github.com/junit-team/junit4/commit/0804ef4cd09b0e94783a9882c60914e22fca5108",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n        if (testClass == null) {\n            throw new NullPointerException(\"Test class cannot be null\");\n        }\n        this.testClass = testClass;\n        causes = getCauses(cause);\n    }",
          "sourceCodeAfterRefactoring": "public ErrorReportingRunner(Class<?> testClass, Throwable cause) {\n        this(cause, new Class<?>[] { testClass });\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ErrorReportingRunner(Throwable cause, Class<?>... testClasses) {\n        if (testClasses == null || testClasses.length == 0) {\n            throw new NullPointerException(\"Test classes cannot be null or empty\");\n        }\n        for (Class<?> testClass : testClasses) {\n            if (testClass == null) {\n                throw new NullPointerException(\"Test class cannot be null\");\n            }\n        }\n        classNames = getClassNames(testClasses);\n        causes = getCauses(cause);\n    }",
          "uniqueId": "0804ef4cd09b0e94783a9882c60914e22fca5108_18_24_22_33_18_20"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "de9269563b6af4ccf9e3d3750864158a27eee6d3",
      "url": "https://github.com/junit-team/junit4/commit/de9269563b6af4ccf9e3d3750864158a27eee6d3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Delete all files and folders under the temporary folder. Usually not\n     * called directly, since it is automatically applied by the {@link Rule}\n     */\n    public void delete() {\n        if (folder != null) {\n            recursiveDelete(folder);\n        }\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Delete all files and folders under the temporary folder. Usually not\n     * called directly, since it is automatically applied by the {@link Rule}.\n     *\n     * @throws {@code IllegalStateException} if unable to clean up resources\n     * and deletion of resources is assured.\n     */\n    public void delete() {\n        if (!tryDelete()) {\n            if (assureDeletion) {\n                fail(\"Unable to clean up temporary folder \" + folder);\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Tries to delete all files and folders under the temporary folder and\n     * returns whether deletion was successful or not.\n     *\n     * @return {@code true} if all resources are deleted successfully,\n     *         {@code false} otherwise.\n     */\n    protected boolean tryDelete() {\n        if (folder == null) {\n            return true;\n        }\n        \n        return recursiveDelete(folder);\n    }",
          "uniqueId": "de9269563b6af4ccf9e3d3750864158a27eee6d3_151_159_251_264_236_249"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3f0adeaf0a812cf88e76527b95c499e3ba99404e",
      "url": "https://github.com/junit-team/junit4/commit/3f0adeaf0a812cf88e76527b95c499e3ba99404e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds</code> and\n     * <code>actuals</code> are <code>null</code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null</code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        int expectedsLength = assertArraysAreSameLength(expecteds,\n                actuals, header);\n\n        for (int i = 0; i < expectedsLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Asserts that two arrays are equal, according to the criteria defined by\n     * the concrete subclass. If they are not, an {@link AssertionError} is\n     * thrown with the given message. If <code>expecteds</code> and\n     * <code>actuals</code> are <code>null</code>, they are considered equal.\n     *\n     * @param message the identifying message for the {@link AssertionError} (\n     * <code>null</code> okay)\n     * @param expecteds Object array or array of arrays (multi-dimensional array) with\n     * expected values.\n     * @param actuals Object array or array of arrays (multi-dimensional array) with\n     * actual values\n     */\n    public void arrayEquals(String message, Object expecteds, Object actuals)\n            throws ArrayComparisonFailure {\n        arrayEquals(message, expecteds, actuals, true);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void arrayEquals(String message, Object expecteds, Object actuals, boolean outer)\n            throws ArrayComparisonFailure {\n        if (expecteds == actuals\n            || Arrays.deepEquals(new Object[] {expecteds}, new Object[] {actuals})) {\n            // The reflection-based loop below is potentially very slow, especially for primitive\n            // arrays. The deepEquals check allows us to circumvent it in the usual case where\n            // the arrays are exactly equal.\n            return;\n        }\n        String header = message == null ? \"\" : message + \": \";\n\n        // Only include the user-provided message in the outer exception.\n        String exceptionMessage = outer ? header : \"\";\n        int expectedsLength = assertArraysAreSameLength(expecteds, actuals, exceptionMessage);\n\n        for (int i = 0; i < expectedsLength; i++) {\n            Object expected = Array.get(expecteds, i);\n            Object actual = Array.get(actuals, i);\n\n            if (isArray(expected) && isArray(actual)) {\n                try {\n                    arrayEquals(message, expected, actual, false);\n                } catch (ArrayComparisonFailure e) {\n                    e.addDimension(i);\n                    throw e;\n                } catch (AssertionError e) {\n                    // Array lengths differed.\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            } else {\n                try {\n                    assertElementsEqual(expected, actual);\n                } catch (AssertionError e) {\n                    throw new ArrayComparisonFailure(header, e, i);\n                }\n            }\n        }\n    }",
          "uniqueId": "3f0adeaf0a812cf88e76527b95c499e3ba99404e_13_59_31_68_13_29"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "bd5b90f75908b7a3ed074a7be29823170f008fb4",
      "url": "https://github.com/junit-team/junit4/commit/bd5b90f75908b7a3ed074a7be29823170f008fb4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@code createTest()}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * </ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest();\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Returns a Statement that, when executed, either returns normally if\n     * {@code method} passes, or throws an exception if {@code method} fails.\n     *\n     * Here is an outline of the default implementation:\n     *\n     * <ul>\n     * <li>Invoke {@code method} on the result of {@link #createTest(org.junit.runners.model.FrameworkMethod)}, and\n     * throw any exceptions thrown by either operation.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * expecting} attribute, return normally only if the previous step threw an\n     * exception of the correct type, and throw an exception otherwise.\n     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code\n     * timeout} attribute, throw an exception if the previous step takes more\n     * than the specified number of milliseconds.\n     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class\n     * and superclasses before any of the previous steps; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @After} methods on this class\n     * and superclasses after any of the previous steps; all After methods are\n     * always executed: exceptions thrown by previous steps are combined, if\n     * necessary, with exceptions from After methods into a\n     * {@link MultipleFailureException}.\n     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the\n     * above steps. A {@code Rule} may prevent all execution of the above steps,\n     * or add additional behavior before and after, or modify thrown exceptions.\n     * For more information, see {@link TestRule}\n     * </ul>\n     *\n     * This can be overridden in subclasses, either by overriding this method,\n     * or the implementations creating each sub-statement.\n     */\n    protected Statement methodBlock(final FrameworkMethod method) {\n        Object test;\n        try {\n            test = new ReflectiveCallable() {\n                @Override\n                protected Object runReflectiveCall() throws Throwable {\n                    return createTest(method);\n                }\n            }.run();\n        } catch (Throwable e) {\n            return new Fail(e);\n        }\n\n        Statement statement = methodInvoker(method, test);\n        statement = possiblyExpectingExceptions(method, test, statement);\n        statement = withPotentialTimeout(method, test, statement);\n        statement = withBefores(method, test, statement);\n        statement = withAfters(method, test, statement);\n        statement = withRules(method, test, statement);\n        return statement;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Returns a new fixture to run a particular test {@code method} against.\n     * Default implementation executes the no-argument {@link #createTest()} method.\n     */\n    protected Object createTest(FrameworkMethod method) throws Exception {\n        return createTest();\n    }",
          "uniqueId": "bd5b90f75908b7a3ed074a7be29823170f008fb4_228_280_220_226_236_288"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "f6149a9236d9a2778bf2fd6db927fd9f498a79c8",
      "url": "https://github.com/junit-team/junit4/commit/f6149a9236d9a2778bf2fd6db927fd9f498a79c8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        new ObjectOutputStream(byteArrayOutputStream).writeObject(result);\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertNotNull(fromStream);\n    }",
          "sourceCodeAfterRefactoring": "private void assertResultSerializable(Result result) throws IOException, ClassNotFoundException {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        new ObjectOutputStream(byteArrayOutputStream).writeObject(result);\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Result fromStream = (Result) objectInputStream.readObject();\n        assertSerializedCorrectly(result, fromStream);\n\n        InputStream resource = getClass().getResourceAsStream(getName());\n        assertNotNull(\"Could not read resource \" + getName(), resource);\n        objectInputStream = new ObjectInputStream(resource);\n        fromStream = (Result) objectInputStream.readObject();\n        \n        assertSerializedCorrectly(new ResultWithFixedRunTime(result), fromStream);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertSerializedCorrectly(Result result, Result fromStream) {\n        assertNotNull(fromStream);\n\n        // Exceptions don't implement equals() so we need to compare field by field\n        assertEquals(\"failureCount\", result.getFailureCount(), fromStream.getFailureCount());\n        assertEquals(\"ignoreCount\", result.getIgnoreCount(), fromStream.getIgnoreCount());\n        assertEquals(\"runTime\", result.getRunTime(), fromStream.getRunTime());\n        assertEquals(\"failures\", result.getFailures().size(), fromStream.getFailures().size());\n        int index = 0;\n        for (Failure failure : result.getFailures()) {\n            Failure failureFromStream = fromStream.getFailures().get(index);\n            String messagePrefix = String.format(\"failures[%d]\", index++);\n            assertEquals(messagePrefix + \".description\",\n                    failure.getDescription(), failureFromStream.getDescription());\n            Throwable exception = failure.getException();\n            Throwable exceptionFromStream = failureFromStream.getException();\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getClass(), exceptionFromStream.getClass());\n            assertEquals(messagePrefix + \".exception\",\n                    exception.getMessage(), exceptionFromStream.getMessage());\n        }\n    }",
          "uniqueId": "f6149a9236d9a2778bf2fd6db927fd9f498a79c8_29_36_85_106_32_46"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "755a82f05ea6cfb884d72041b404fc1c8129f92c",
      "url": "https://github.com/junit-team/junit4/commit/755a82f05ea6cfb884d72041b404fc1c8129f92c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(Statement base, Description description) {\n        try {\n            return FailOnTimeout.builder()\n                .withTimeout(timeout, timeUnit)\n                .withLookingForStuckThread(lookForStuckThread)\n                .build(base);\n        } catch (final Exception e) {\n            return new Statement() {\n                @Override public void evaluate() throws Throwable {\n                    throw new RuntimeException(\"Invalid parameters for Timeout\", e);\n                }\n            };\n        }\n    }",
          "sourceCodeAfterRefactoring": "public Statement apply(Statement base, Description description) {\n        try {\n            return createFailOnTimeoutStatement(base);\n        } catch (final Exception e) {\n            return new Statement() {\n                @Override public void evaluate() throws Throwable {\n                    throw new RuntimeException(\"Invalid parameters for Timeout\", e);\n                }\n            };\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Creates a {@link Statement} that will run the given\n     * {@code statement}, and timeout the operation based\n     * on the values configured in this rule. Subclasses\n     * can override this method for different behavior.\n     *\n     * @since 4.12\n     */\n    protected Statement createFailOnTimeoutStatement(\n            Statement statement) throws Exception {\n        return FailOnTimeout.builder()\n            .withTimeout(timeout, timeUnit)\n            .withLookingForStuckThread(lookForStuckThread)\n            .build(statement);\n    }",
          "uniqueId": "755a82f05ea6cfb884d72041b404fc1c8129f92c_120_133_137_151_153_163"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Create a {@code Timeout} instance with the same fields as {@code t}\n     * except for {@code lookForStuckThread}.\n     *\n     * @param t the {@code Timeout} instance to copy\n     * @param lookForStuckThread whether to look for a stuck thread\n     * @since 4.12\n     */\n    protected Timeout(Timeout t, boolean lookForStuckThread) {\n        timeout = t.timeout;\n        timeUnit = t.timeUnit;\n        this.lookForStuckThread = lookForStuckThread;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Create a {@code Timeout} instance initialized with values form\n     * a builder.\n     *\n     * @since 4.12\n     */\n    protected Timeout(Builder builder) {\n        timeout = builder.getTimeout();\n        timeUnit = builder.getTimeUnit();\n        lookForStuckThread = builder.getLookingForStuckThread();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Gets whether this {@code Timeout} will look for a stuck thread\n     * when the test times out.\n     *\n     * @since 4.12\n     */\n    protected final boolean getLookingForStuckThread() {\n        return lookForStuckThread;\n    }",
          "uniqueId": "755a82f05ea6cfb884d72041b404fc1c8129f92c_77_89_127_135_86_96"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1d97da73fdafce8f5cf9d722f23c5cba41b26b70",
      "url": "https://github.com/junit-team/junit4/commit/1d97da73fdafce8f5cf9d722f23c5cba41b26b70",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        errors.addAll(fAnnotationsValidator.validateTestClass(getTestClass()));\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).\n     * Default implementation adds an error for each method annotated with\n     * {@code @BeforeClass} or {@code @AfterClass} that is not\n     * {@code public static void} with no arguments.\n     */\n    protected void collectInitializationErrors(List<Throwable> errors) {\n        validatePublicVoidNoArgMethods(BeforeClass.class, true, errors);\n        validatePublicVoidNoArgMethods(AfterClass.class, true, errors);\n        validateClassRules(errors);\n        applyValidators(errors);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void applyValidators(List<Throwable> errors) {\n        if (getTestClass().getJavaClass() != null) {\n            for (TestClassValidator each : VALIDATORS) {\n                errors.addAll(each.validateTestClass(getTestClass()));\n            }\n        }\n    }",
          "uniqueId": "1d97da73fdafce8f5cf9d722f23c5cba41b26b70_114_125_131_137_118_129"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "cb6abf6fc729f07c5d60b0756e91af444400b4b5",
      "url": "https://github.com/junit-team/junit4/commit/cb6abf6fc729f07c5d60b0756e91af444400b4b5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<Runner> createRunnersForParameters(Iterable<Object> allParameters, String namePattern) throws Exception {\n        try {\n            int i = 0;\n            List<Runner> children = new ArrayList<Runner>();\n            for (Object parametersOfSingleTest : allParameters) {\n                children.add(createRunnerWithNotNormalizedParameters(\n                    namePattern, i++, parametersOfSingleTest));\n            }\n            return children;\n        } catch (ClassCastException e) {\n            throw parametersMethodReturnedWrongType();\n        }\n    }",
          "sourceCodeAfterRefactoring": "private List<Runner> createRunnersForParameters(\n            Iterable<Object> allParameters, String namePattern,\n            ParametersRunnerFactory runnerFactory)\n            throws InitializationError,\n            Exception {\n        try {\n            List<TestWithParameters> tests = createTestsForParameters(\n                    allParameters, namePattern);\n            List<Runner> runners = new ArrayList<Runner>();\n            for (TestWithParameters test : tests) {\n                runners.add(runnerFactory\n                        .createRunnerForTestWithParameters(test));\n            }\n            return runners;\n        } catch (ClassCastException e) {\n            throw parametersMethodReturnedWrongType();\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<TestWithParameters> createTestsForParameters(\n            Iterable<Object> allParameters, String namePattern)\n            throws Exception {\n        int i = 0;\n        List<TestWithParameters> children = new ArrayList<TestWithParameters>();\n        for (Object parametersOfSingleTest : allParameters) {\n            children.add(createTestWithNotNormalizedParameters(namePattern,\n                    i++, parametersOfSingleTest));\n        }\n        return children;\n    }",
          "uniqueId": "cb6abf6fc729f07c5d60b0756e91af444400b4b5_243_255_320_330_301_318"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void meaningfulFailureWhenParametersNotPublic() throws Exception {\n        Result result = JUnitCore.runClasses(ProtectedParametersTest.class);\n        String expected = String.format(\n                \"No public static parameters method on class %s\",\n                ProtectedParametersTest.class.getName());\n        assertEquals(expected, result.getFailures().get(0).getMessage());\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void meaningfulFailureWhenParametersNotPublic() {\n        assertTestCreatesSingleFailureWithMessage(ProtectedParametersTest.class,\n                \"No public static parameters method on class \"\n                        + ProtectedParametersTest.class.getName());\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertTestCreatesSingleFailureWithMessage(Class<?> test, String message) {\n        Result result = JUnitCore.runClasses(test);\n        assertEquals(1, result.getFailures().size());\n        assertEquals(message, result.getFailures().get(0).getMessage());\n    }",
          "uniqueId": "cb6abf6fc729f07c5d60b0756e91af444400b4b5_309_316_467_471_312_317"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3e08f69912d69189e895c279b1bece0c7c0840f4",
      "url": "https://github.com/junit-team/junit4/commit/3e08f69912d69189e895c279b1bece0c7c0840f4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {\n            super(type);\n\n            fParameters = parameters;\n            fName = nameFor(pattern, index, parameters);\n        }",
          "sourceCodeAfterRefactoring": "/**\n         * @deprecated please use\n         *             {@code TestClassRunnerForParameters(TestWithParameters)}\n         */\n        @Deprecated\n        protected TestClassRunnerForParameters(Class<?> type, String pattern, int index, Object[] parameters) throws InitializationError {\n            this(createTestWithParameters(new TestClass(type), pattern, index,\n                    parameters));\n        }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected TestClassRunnerForParameters(TestWithParameters test)\n                throws InitializationError {\n            super(test.getTestClass().getJavaClass());\n            fParameters = test.getParameters().toArray();\n            fName = test.getName();\n        }",
          "uniqueId": "3e08f69912d69189e895c279b1bece0c7c0840f4_191_196_203_208_193_201"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "dc5f4661240f98469f498e6ab69a1512c8b39d0c",
      "url": "https://github.com/junit-team/junit4/commit/dc5f4661240f98469f498e6ab69a1512c8b39d0c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = new TestClass(testClass);\n        validate();\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Constructs a new {@code ParentRunner} that will run {@code @TestClass}\n     */\n    protected ParentRunner(Class<?> testClass) throws InitializationError {\n        fTestClass = createTestClass(testClass);\n        validate();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected TestClass createTestClass(Class<?> testClass) {\n        return new TestClass(testClass);\n    }",
          "uniqueId": "dc5f4661240f98469f498e6ab69a1512c8b39d0c_80_86_88_90_80_86"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n\n        fMethodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        fFieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Creates a {@code TestClass} wrapping {@code klass}. Each time this\n     * constructor executes, the class is scanned for annotations, which can be\n     * an expensive process (we hope in future JDK's it will not be.) Therefore,\n     * try to share instances of {@code TestClass} where possible.\n     */\n    public TestClass(Class<?> klass) {\n        fClass = klass;\n        if (klass != null && klass.getConstructors().length > 1) {\n            throw new IllegalArgumentException(\n                    \"Test class can only have one constructor\");\n        }\n\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkMethod>>();\n        Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations =\n                new LinkedHashMap<Class<? extends Annotation>, List<FrameworkField>>();\n\n        scanAnnotatedMembers(methodsForAnnotations, fieldsForAnnotations);\n\n        fMethodsForAnnotations = makeDeeplyUnmodifiable(methodsForAnnotations);\n        fFieldsForAnnotations = makeDeeplyUnmodifiable(fieldsForAnnotations);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void scanAnnotatedMembers(Map<Class<? extends Annotation>, List<FrameworkMethod>> methodsForAnnotations, Map<Class<? extends Annotation>, List<FrameworkField>> fieldsForAnnotations) {\n        for (Class<?> eachClass : getSuperClasses(fClass)) {\n            for (Method eachMethod : MethodSorter.getDeclaredMethods(eachClass)) {\n                addToAnnotationLists(new FrameworkMethod(eachMethod), methodsForAnnotations);\n            }\n            // ensuring fields are sorted to make sure that entries are inserted\n            // and read from fieldForAnnotations in a deterministic order\n            for (Field eachField : getSortedDeclaredFields(eachClass)) {\n                addToAnnotationLists(new FrameworkField(eachField), fieldsForAnnotations);\n            }\n        }\n    }",
          "uniqueId": "dc5f4661240f98469f498e6ab69a1512c8b39d0c_32_63_56_67_32_54"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "fd1ef3ca8069bd149ca63c9660587918aa28c7cd",
      "url": "https://github.com/junit-team/junit4/commit/fd1ef3ca8069bd149ca63c9660587918aa28c7cd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Constructs a {@code Statement} to run all of the tests in the test class.\n     * Override to add pre-/post-processing. Here is an outline of the\n     * implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned\n     * by {@link #getChildren()} (subject to any imposed filter and sort).</li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this\n     * class and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this\n     * class and superclasses before any of the previous steps; all AfterClass\n     * methods are always executed: exceptions thrown by previous steps are\n     * combined, if necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * </ul>\n     * \n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement= childrenInvoker(notifier);\n        if (statement instanceof ParentRunner.EmptyStatement == false) {\n            statement= withBeforeClasses(statement);\n            statement= withAfterClasses(statement);\n            statement= withClassRules(statement);\n        }\n        return statement;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Constructs a {@code Statement} to run all of the tests in the test class.\n     * Override to add pre-/post-processing. Here is an outline of the\n     * implementation:\n     * <ul>\n     * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned\n     * by {@link #getChildren()} (subject to any imposed filter and sort).</li>\n     * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this\n     * class and superclasses before the previous step; if any throws an\n     * Exception, stop execution and pass the exception on.\n     * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this\n     * class and superclasses before any of the previous steps; all AfterClass\n     * methods are always executed: exceptions thrown by previous steps are\n     * combined, if necessary, with exceptions from AfterClass methods into a\n     * {@link MultipleFailureException}.\n     * </ul>\n     * \n     * @return {@code Statement}\n     */\n    protected Statement classBlock(final RunNotifier notifier) {\n        Statement statement= childrenInvoker(notifier);\n        if (statementHasTestsToRun(statement)) {\n            statement= withBeforeClasses(statement);\n            statement= withAfterClasses(statement);\n            statement= withClassRules(statement);\n        }\n        return statement;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean statementHasTestsToRun(Statement statement) {\n        return statement instanceof ParentRunner.EmptyStatement == false;\n    }",
          "uniqueId": "fd1ef3ca8069bd149ca63c9660587918aa28c7cd_147_174_176_178_147_174"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "224098471a55701c40ab5a49888d93d8ff304164",
      "url": "https://github.com/junit-team/junit4/commit/224098471a55701c40ab5a49888d93d8ff304164",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        final Collection<T> filteredChildren= getFilteredChildren();\n        Collection<T> filteredChildrenCopy= new ArrayList<T>(filteredChildren);\n\n        for (T child : filteredChildren) {\n            if (isIgnoredMethod(child)) {\n                Description childDescription= describeChild(child);\n                notifier.fireTestIgnored(childDescription);\n                filteredChildrenCopy.remove(child);\n            }\n\n        }\n\n        final Collection<T> filteredChildrenWithoutIgnores= Collections\n                .unmodifiableCollection(filteredChildrenCopy);\n\n        if (filteredChildrenWithoutIgnores.isEmpty()) {\n            return new EmptyStatement();\n        }\n\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier, filteredChildrenWithoutIgnores);\n            }\n        };\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Returns a {@link Statement}: Call {@link #runChild(Object, RunNotifier)}\n     * on each object returned by {@link #getChildren()} (subject to any imposed\n     * filter and sort)\n     */\n    protected Statement childrenInvoker(final RunNotifier notifier) {\n        final Collection<T> filteredChildrenWithoutIgnores= getFilteredChildrenWithoutIgnores(notifier);\n\n        if (filteredChildrenWithoutIgnores.isEmpty()) {\n            return new EmptyStatement();\n        }\n\n        return new Statement() {\n            @Override\n            public void evaluate() {\n                runChildren(notifier, filteredChildrenWithoutIgnores);\n            }\n        };\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Collection<T> getFilteredChildrenWithoutIgnores(\n            final RunNotifier notifier) {\n        final Collection<T> filteredChildren= getFilteredChildren();\n        Collection<T> filteredChildrenCopy= new ArrayList<T>(filteredChildren);\n\n        for (T child : filteredChildren) {\n            if (isIgnoredMethod(child)) {\n                Description childDescription= describeChild(child);\n                notifier.fireTestIgnored(childDescription);\n                filteredChildrenCopy.remove(child);\n            }\n\n        }\n\n        return Collections\n                .unmodifiableCollection(filteredChildrenCopy);\n    }",
          "uniqueId": "224098471a55701c40ab5a49888d93d8ff304164_230_261_249_265_229_247"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8b35f0c0a07b80f068d78bf03025bcebef760a1e",
      "url": "https://github.com/junit-team/junit4/commit/8b35f0c0a07b80f068d78bf03025bcebef760a1e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void handleException(Throwable e) throws Throwable {\n        if (fMatcherBuilder.expectsThrowable()) {\n            assertThat(e, fMatcherBuilder.build());\n        } else {\n            throw e;\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void handleException(Throwable e) throws Throwable {\n        if (isAnyExceptionExpected()) {\n            assertThat(e, fMatcherBuilder.build());\n        } else {\n            throw e;\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isAnyExceptionExpected() {\n        return fMatcherBuilder.expectsThrowable();\n    }",
          "uniqueId": "8b35f0c0a07b80f068d78bf03025bcebef760a1e_241_247_249_251_241_247"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3e8e865039fe6531666afb860961d787065b589e",
      "url": "https://github.com/junit-team/junit4/commit/3e8e865039fe6531666afb860961d787065b589e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n    }",
          "sourceCodeAfterRefactoring": "public FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        this(originalStatement, timeout, unit, false);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit, boolean lookForStuckThread) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n        fLookForStuckThread = lookForStuckThread;\n    }",
          "uniqueId": "3e8e865039fe6531666afb860961d787065b589e_25_29_30_35_26_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "d3ee5d06c0b797ce812cbfe35addc6146d5f07cb",
      "url": "https://github.com/junit-team/junit4/commit/d3ee5d06c0b797ce812cbfe35addc6146d5f07cb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator =\n                    fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void invokeValidatorsOnClass(List<Throwable> errors) {\n        Annotation[] annotations = getTestClass().getAnnotations();\n        for (Annotation annotation : annotations) {\n            Class<? extends Annotation> annotationType = annotation.annotationType();\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n            errors.addAll(annotationValidator.validateAnnotatedClass(getTestClass().getJavaClass()));\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }",
          "uniqueId": "d3ee5d06c0b797ce812cbfe35addc6146d5f07cb_133_142_165_171_133_141"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void invokeValidatorsOnMethods(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationMap = getTestClass().getAnnotationToMethods();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkMethod frameworkMethod : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedMethod(frameworkMethod.getMethod()));\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }",
          "uniqueId": "d3ee5d06c0b797ce812cbfe35addc6146d5f07cb_144_153_165_171_143_152"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void invokeValidatorsOnFields(List<Throwable> errors) {\n        Map<Class<? extends Annotation>, List<FrameworkField>> annotationMap = getTestClass().getAnnotationToFields();\n        for (Class<? extends Annotation> annotationType : annotationMap.keySet()) {\n            ValidateWith validateWithAnnotation = annotationType.getAnnotation(ValidateWith.class);\n            for (FrameworkField frameworkField : annotationMap.get(annotationType)) {\n                AnnotationValidator annotationValidator = createAnnotationValidator(validateWithAnnotation);\n                errors.addAll(annotationValidator.validateAnnotatedField(frameworkField.getField()));\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate AnnotationValidator createAnnotationValidator(ValidateWith validateWithAnnotation) {\n        if (validateWithAnnotation == null) {\n            return new AnnotationValidator() {\n            };\n        }\n        return fAnnotationValidatorFactory.createAnnotationValidator(validateWithAnnotation);\n    }",
          "uniqueId": "d3ee5d06c0b797ce812cbfe35addc6146d5f07cb_155_164_165_171_154_163"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "85f9d8397bfd96261c3214284672180c522e2d38",
      "url": "https://github.com/junit-team/junit4/commit/85f9d8397bfd96261c3214284672180c522e2d38",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private boolean hasValidatorAnnotation(Annotation annotation) {\n        Annotation[] annotations = annotation.annotationType().getAnnotations();\n        for (Annotation current : annotations) {\n            if (Validator.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "sourceCodeAfterRefactoring": "private boolean hasValidatorAnnotation(Annotation annotation) {\n        Class<? extends Annotation> annotationType = annotation.annotationType();\n        boolean hasValidatorAnnotation;\n        if (fAnnotationTypeToValidatorMap.containsKey(annotationType)) {\n            hasValidatorAnnotation = fAnnotationTypeToValidatorMap.get(annotationType) != null;\n        } else {\n            hasValidatorAnnotation = hasValidatorAnnotation(annotationType);\n            if (!hasValidatorAnnotation) {\n                fAnnotationTypeToValidatorMap.put(annotationType, null);\n            }\n        }\n\n        return hasValidatorAnnotation;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean hasValidatorAnnotation(Class<? extends Annotation> annotationType) {\n        Annotation[] annotations = annotationType.getAnnotations();\n        for (Annotation current : annotations) {\n            if (ValidateWith.class.isAssignableFrom(current.getClass())) {\n                return true;\n            }\n        }\n        return false;\n    }",
          "uniqueId": "85f9d8397bfd96261c3214284672180c522e2d38_178_186_186_194_171_184"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "fba19ba73a93dcc2d18942b3cf4992ce010afdb2",
      "url": "https://github.com/junit-team/junit4/commit/fba19ba73a93dcc2d18942b3cf4992ce010afdb2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Exception createTimeoutException(Thread thread) {\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        final Thread stuckThread = getStuckThread (thread);\n        Exception exception = new Exception(String.format(\n                \"test timed out after %d %s\", fTimeout, fTimeUnit.name().toLowerCase()));\n        if (stuckThread != null) {\n            Exception stuckThreadException = \n                new Exception (\"Appears to be stuck in thread \" +\n                               stuckThread.getName());\n            StackTraceElement[] threadStack;\n            try {\n                threadStack = stuckThread.getStackTrace();\n            } catch (SecurityException e) {\n                threadStack = new StackTraceElement[0];\n            }\n            stuckThreadException.setStackTrace (threadStack);\n            exception = new MultipleFailureException    \n                (Arrays.<Throwable>asList (exception, stuckThreadException));\n        }\n        if (stackTrace != null) {\n            exception.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        return exception;\n    }",
          "sourceCodeAfterRefactoring": "private Exception createTimeoutException(Thread thread) {\n        Exception resultException;\n        StackTraceElement[] stackTrace = thread.getStackTrace();\n        final Thread stuckThread = getStuckThread(thread);\n        Exception currThreadException = new Exception(String.format(\n                \"test timed out after %d %s\", fTimeout, fTimeUnit.name().toLowerCase()));\n        if (stuckThread != null) {\n            Exception stuckThreadException = \n                new Exception (\"Appears to be stuck in thread \" +\n                               stuckThread.getName());\n            stuckThreadException.setStackTrace(getStackTrace(stuckThread));\n            resultException = new MultipleFailureException    \n                (Arrays.<Throwable>asList(currThreadException, stuckThreadException));\n        } else {\n            resultException = currThreadException;\n        }\n        if (stackTrace != null) {\n            currThreadException.setStackTrace(stackTrace);\n            thread.interrupt();\n        }\n        return resultException;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Retrieves the stack trace for a given thread.\n     * @param thread The thread whose stack is to be retrieved.\n     * @return The stack trace; returns a zero-length array if the thread has \n     * terminated or the stack cannot be retrieved for some other reason.\n     */\n    private StackTraceElement[] getStackTrace(Thread thread) {\n        StackTraceElement[] threadStack;\n        try {\n            threadStack = thread.getStackTrace();\n        } catch (SecurityException e) {\n            threadStack = new StackTraceElement[0];\n        }\n        return threadStack;\n    }",
          "uniqueId": "fba19ba73a93dcc2d18942b3cf4992ce010afdb2_62_86_85_99_62_83"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); // this is just an estimate\n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t// threads are proliferating too fast for us.  Bail before we get into \n    \t\t// trouble.\n    \t} \n    \t\n    \t// Now that we have all the threads in the test's thread group: Assume that\n    \t// any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n    \t// If just one, we return that (unless it equals threadMain).  If there's more\n    \t// than one, pick the one that's using the most CPU time, if this feature is\n    \t// supported.\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n        if (fThreadGroup == null) return null;\n        Thread[] threadsInGroup = getThreadArray(fThreadGroup);\n        if (threadsInGroup == null) return null;\n        \n        // Now that we have all the threads in the test's thread group: Assume that\n        // any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n        // If just one, we return that (unless it equals threadMain).  If there's more\n        // than one, pick the one that's using the most CPU time, if this feature is\n        // supported.\n        Thread stuckThread = null;\n        long maxCpuTime = 0;\n        for (Thread thread : threadsInGroup) {\n            if (thread.getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime(thread);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = thread;\n                    maxCpuTime = threadCpuTime;\n                }\n            }               \n        }\n        return (stuckThread == mainThread) ? null : stuckThread;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Returns all active threads belonging to a thread group.  \n     * @param group The thread group.\n     * @return The active threads in the thread group.  The result should be a\n     * complete list of the active threads at some point in time.  Returns {@code null}\n     * if this cannot be determined, e.g. because new threads are being created at an\n     * extremely fast rate.\n     */\n    private Thread[] getThreadArray(ThreadGroup group) {\n        final int count = group.activeCount(); // this is just an estimate\n        int enumSize = Math.max(count * 2, 100);\n        int enumCount;\n        Thread[] threads;\n        int loopCount = 0;\n        while (true) {\n            threads = new Thread[enumSize];\n            enumCount = group.enumerate(threads);\n            if (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n            enumSize += 100;\n            if (++loopCount >= 5) return null;\n            // threads are proliferating too fast for us.  Bail before we get into \n            // trouble.\n        }\n        return Arrays.copyOf(threads, enumCount);\n    }",
          "uniqueId": "fba19ba73a93dcc2d18942b3cf4992ce010afdb2_88_134_134_161_101_132"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void stalledThreadAppearsInStackTrace() throws Exception {\n        JUnitCore core = new JUnitCore();\n        Result result = core.run(InfiniteLoopTest.class);\n        assertEquals(1, result.getRunCount());\n        assertEquals(1, result.getFailureCount());\n        Throwable exception = result.getFailures().get(0).getException();\n        Writer buffer = new StringWriter();\n        PrintWriter writer = new PrintWriter(buffer);\n        exception.printStackTrace(writer);\n        assertThat(buffer.toString(), containsString(\"infiniteLoop\")); // Make sure we have the stalled frame on the stack somewhere\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void stalledThreadAppearsInStackTrace() throws Exception {\n        JUnitCore core = new JUnitCore();\n        Result result = core.run(InfiniteLoopTest.class);\n        assertEquals(1, result.getRunCount());\n        assertEquals(1, result.getFailureCount());\n        Throwable exception = result.getFailures().get(0).getException();\n        assertThat(stackForException(exception), containsString(\"infiniteLoop\")); // Make sure we have the stalled frame on the stack somewhere\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String stackForException (Throwable exception) {\n        Writer buffer = new StringWriter();\n        PrintWriter writer = new PrintWriter(buffer);\n        exception.printStackTrace(writer);\n        return buffer.toString();\n    }",
          "uniqueId": "fba19ba73a93dcc2d18942b3cf4992ce010afdb2_144_155_145_150_152_160"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5ca9da987a7d4dc00e082aaf552cbd8ee8c7bd33",
      "url": "https://github.com/junit-team/junit4/commit/5ca9da987a7d4dc00e082aaf552cbd8ee8c7bd33",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); // this is just an estimate\n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\t// if there are too many threads to fit into the array, enumerate's result\n    \t\t// is >= the array's length; therefore we can't trust that it returned all\n    \t\t// the threads.  Try again.\n    \t\tif (enumCount < enumSize) break;\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t// threads are proliferating too fast for us.  Bail before we get into \n    \t\t// trouble.\n    \t} \n    \t\n    \t// Now that we have all the threads in the test's thread group: Assume that\n    \t// any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n    \t// If just one, we return that (unless it equals threadMain).  If there's more\n    \t// than one, pick the one that's using the most CPU time, if this feature is\n    \t// supported.\n    \tThread firstRunnable = null;\n    \tThread mostCpu = null;\n    \tlong maxCpuTime = 0;\n    \tint runnableCount = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n    \t\t\trunnableCount++;\n    \t\t\tif (firstRunnable == null) firstRunnable = threads[i];\n    \t\t\tif (mxBean.isThreadCpuTimeSupported()) {\n    \t\t\t\ttry {\n    \t\t\t\t\tlong cpuTime = mxBean.getThreadCpuTime(threads[i].getId());\n    \t\t\t\t\tif (mostCpu == null || cpuTime > maxCpuTime) {\n    \t\t\t\t\t\tmostCpu = threads[i];\n    \t\t\t\t\t\tmaxCpuTime = cpuTime;\n    \t\t\t\t\t}\n    \t\t\t\t} catch (UnsupportedOperationException e) {\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}   \t\t\t\n    \t}\n    \tThread stuckThread =\n    \t\t\t(runnableCount == 1) ? firstRunnable :\n    \t\t\t\t((mostCpu != null) ? mostCpu : firstRunnable);\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Determines whether the test appears to be stuck in some thread other than\n     * the \"main thread\" (the one created to run the test).\n     * @param mainThread The main thread created by {@code evaluate()}\n     * @return The thread which appears to be causing the problem, if different from\n     * {@code mainThread}, or {@code null} if the main thread appears to be the\n     * problem or if the thread cannot be determined.  The return value is never equal \n     * to {@code mainThread}.\n     */\n    private Thread getStuckThread (Thread mainThread) {\n    \tif (fThreadGroup == null) return null;\n    \tfinal int count = fThreadGroup.activeCount(); // this is just an estimate\n    \tint enumSize = Math.max (count * 2, 100);\n    \tint enumCount;\n    \tThread[] threads;\n\t\tint loopCount = 0;\n    \twhile (true) {\n    \t\tthreads = new Thread[enumSize];\n    \t\tenumCount = fThreadGroup.enumerate (threads);\n    \t\tif (enumCount < enumSize) break;\n            // if there are too many threads to fit into the array, enumerate's result\n            // is >= the array's length; therefore we can't trust that it returned all\n            // the threads.  Try again.\n    \t\tenumSize += 100;\n    \t\tif (++loopCount >= 5) return null;\n    \t\t// threads are proliferating too fast for us.  Bail before we get into \n    \t\t// trouble.\n    \t} \n    \t\n    \t// Now that we have all the threads in the test's thread group: Assume that\n    \t// any thread we're \"stuck\" in is RUNNABLE.  Look for all RUNNABLE threads. \n    \t// If just one, we return that (unless it equals threadMain).  If there's more\n    \t// than one, pick the one that's using the most CPU time, if this feature is\n    \t// supported.\n    \tThread stuckThread = null;\n    \tlong maxCpuTime = 0;\n    \tfor (int i = 0; i < enumCount; i++) {\n    \t\tif (threads[i].getState() == Thread.State.RUNNABLE) {\n                long threadCpuTime = cpuTime (threads [i]);\n                if (stuckThread == null || threadCpuTime > maxCpuTime) {\n                    stuckThread = threads[i];\n                    maxCpuTime = threadCpuTime;\n                }\n    \t\t}   \t\t\t\n    \t}\n    \treturn (stuckThread == mainThread) ? null : stuckThread;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n     * Returns the CPU time used by a thread, if possible.\n     * @param thr The thread to query.\n     * @return The CPU time used by {@code thr}, or 0 if it cannot be determined.\n     */\n    private long cpuTime (Thread thr) {\n\t\tThreadMXBean mxBean = ManagementFactory.getThreadMXBean();\n        if (mxBean.isThreadCpuTimeSupported()) {\n            try {\n                return mxBean.getThreadCpuTime(thr.getId());\n            } catch (UnsupportedOperationException e) {\n            }\n        }\n        return 0;\n    }",
          "uniqueId": "5ca9da987a7d4dc00e082aaf552cbd8ee8c7bd33_77_136_136_150_88_134"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "810536929044271a608e019255e87c756235bb97",
      "url": "https://github.com/junit-team/junit4/commit/810536929044271a608e019255e87c756235bb97",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test\n    public void getDescriptionWithAnnotation() {\n        JUnit38ClassRunner runner = new JUnit38ClassRunner(JUnit3ClassWithAnnotatedMethod.class);\n        Description d = runner.getDescription();\n        assertEquals(2, d.testCount());\n        for (Description methodDesc : d.getChildren()) {\n            if (methodDesc.getMethodName().equals(\"testAnnotated\")) {\n                assertNotNull(methodDesc.getAnnotation(MyAnnotation.class));\n            } else {\n                assertNull(methodDesc.getAnnotation(MyAnnotation.class));\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "@Test\n    public void getDescriptionWithAnnotation() {\n        JUnit38ClassRunner runner = new JUnit38ClassRunner(JUnit3ClassWithAnnotatedMethod.class);\n        assertAnnotationFiltering(runner);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void assertAnnotationFiltering(JUnit38ClassRunner runner) {\n        Description d = runner.getDescription();\n        assertEquals(2, d.testCount());\n        for (Description methodDesc : d.getChildren()) {\n            if (methodDesc.getMethodName().equals(\"testAnnotated\")) {\n                assertNotNull(methodDesc.getAnnotation(MyAnnotation.class));\n            } else {\n                assertNull(methodDesc.getAnnotation(MyAnnotation.class));\n            }\n        }\n    }",
          "uniqueId": "810536929044271a608e019255e87c756235bb97_106_118_121_131_109_113"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "b421d0ebd66701187c10c2b0c7f519dc435531ae",
      "url": "https://github.com/junit-team/junit4/commit/b421d0ebd66701187c10c2b0c7f519dc435531ae",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if (returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) {\n                try {\n                    addArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) throws Throwable {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            Class<?> returnType = dataPointsMethod.getReturnType();\n            \n            if ((returnType.isArray() && sig.canPotentiallyAcceptType(returnType.getComponentType())) ||\n                    Iterable.class.isAssignableFrom(returnType)) {\n                try {\n                    addDataPointsValues(returnType, sig, dataPointsMethod.getName(), list, \n                            dataPointsMethod.invokeExplosively(null));\n                } catch (Throwable throwable) {\n                    DataPoints annotation = dataPointsMethod.getAnnotation(DataPoints.class);\n                    if (annotation != null && isAssignableToAnyOf(annotation.ignoredExceptions(), throwable)) {\n                        return;\n                    } else {\n                        throw throwable;\n                    }\n                }\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addDataPointsValues(Class<?> type, ParameterSignature sig, String name, \n            List<PotentialAssignment> list, Object value) {\n        if (type.isArray()) {\n            addArrayValues(sig, name, list, value);\n        }\n        else if (Iterable.class.isAssignableFrom(type)) {\n            addIterableValues(sig, name, list, (Iterable<?>) value);\n        }\n    }",
          "uniqueId": "b421d0ebd66701187c10c2b0c7f519dc435531ae_75_92_122_130_76_95"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addMultiPointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            addArrayValues(sig, field.getName(), list, getStaticFieldValue(field));\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addMultiPointFields(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            Class<?> type = field.getType();\n            addDataPointsValues(type, sig, field.getName(), list, getStaticFieldValue(field));\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addDataPointsValues(Class<?> type, ParameterSignature sig, String name, \n            List<PotentialAssignment> list, Object value) {\n        if (type.isArray()) {\n            addArrayValues(sig, name, list, value);\n        }\n        else if (Iterable.class.isAssignableFrom(type)) {\n            addIterableValues(sig, name, list, (Iterable<?>) value);\n        }\n    }",
          "uniqueId": "b421d0ebd66701187c10c2b0c7f519dc435531ae_102_106_122_130_105_110"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "cc8497f28e1d5a46d7940a0b36556154c83d6f7a",
      "url": "https://github.com/junit-team/junit4/commit/cc8497f28e1d5a46d7940a0b36556154c83d6f7a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean canAcceptType(Class<?> candidate) {\n        return type.isAssignableFrom(candidate);\n    }",
          "sourceCodeAfterRefactoring": "public boolean canAcceptType(Class<?> candidate) {\n        return type.isAssignableFrom(candidate) ||\n                canAcceptBoxed(candidate) ||\n                canAcceptUnboxed(candidate);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean canAcceptBoxed(Class<?> candidate) {\n        if (primitivesBoxingMap.containsKey(candidate)) {\n            Class<?> wrapperClass = primitivesBoxingMap.get(candidate);\n            return type.isAssignableFrom(wrapperClass);\n        } else {\n            return false;\n        }\n    }",
          "uniqueId": "cc8497f28e1d5a46d7940a0b36556154c83d6f7a_44_46_67_74_61_65"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1963b424c176742b711fb4226ce8f314d431813c",
      "url": "https://github.com/junit-team/junit4/commit/1963b424c176742b711fb4226ce8f314d431813c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private ParameterSupplier getSupplierFromAnnotation(ParameterSignature unassigned)\n            throws InstantiationException, IllegalAccessException {\n        ParametersSuppliedBy parameterSupplierAnnotation = unassigned\n                .findDeepAnnotation(ParametersSuppliedBy.class);\n        if (parameterSupplierAnnotation != null) {\n            return parameterSupplierAnnotation.value().newInstance();\n        }\n        \n        FromDataPoints fromDataPointsAnnotation = unassigned.getAnnotation(FromDataPoints.class);\n        if (fromDataPointsAnnotation != null) {\n            return new SpecificDataPointsSupplier(fClass);\n        }\n        \n        return null;\n    }",
          "sourceCodeAfterRefactoring": "private ParameterSupplier getAnnotatedSupplier(ParameterSignature unassigned)\n            throws ReflectiveOperationException {\n        ParametersSuppliedBy annotation = unassigned\n                .findDeepAnnotation(ParametersSuppliedBy.class);\n        if (annotation != null) {\n            return buildParameterSupplierFromClass(annotation.value());\n        } else {\n            return null;\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate ParameterSupplier buildParameterSupplierFromClass(Class<? extends ParameterSupplier> cls)\n            throws ReflectiveOperationException {\n        Constructor<?>[] supplierConstructors = cls.getConstructors();\n\n        for (Constructor<?> constructor : supplierConstructors) {\n            Class<?>[] parameterTypes = constructor.getParameterTypes();\n            if (parameterTypes.length == 1\n                    && parameterTypes[0].equals(TestClass.class)) {\n                return (ParameterSupplier) constructor.newInstance(fClass);\n            }\n        }\n\n        return cls.newInstance();\n    }",
          "uniqueId": "1963b424c176742b711fb4226ce8f314d431813c_93_107_104_117_93_102"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "043e82844ef2c3c0961d98a34771c84f7a950d1a",
      "url": "https://github.com/junit-team/junit4/commit/043e82844ef2c3c0961d98a34771c84f7a950d1a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : fClass\n                .getAnnotatedMethods(DataPoints.class)) {\n            try {\n                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addMultiPointMethods(ParameterSignature sig, List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointsMethod : getDataPointsMethods(sig)) {\n            try {\n                addMultiPointArrayValues(sig, dataPointsMethod.getName(), list, dataPointsMethod.invokeExplosively(null));\n            } catch (Throwable e) {\n                // ignore and move on\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Collection<FrameworkMethod> getDataPointsMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoints.class);        \n    }",
          "uniqueId": "043e82844ef2c3c0961d98a34771c84f7a950d1a_70_79_139_141_72_80"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addSinglePointMethods(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : fClass\n                .getAnnotatedMethods(DataPoint.class)) {\n            if (sig.canAcceptType(dataPointMethod.getType())) {\n                list.add(new MethodParameterValue(dataPointMethod));\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addSinglePointMethods(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (FrameworkMethod dataPointMethod : getSingleDataPointMethods(sig)) {\n            if (sig.canAcceptType(dataPointMethod.getType())) {\n                list.add(new MethodParameterValue(dataPointMethod));\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Collection<FrameworkMethod> getSingleDataPointMethods(ParameterSignature sig) {\n        return fClass.getAnnotatedMethods(DataPoint.class);\n    }",
          "uniqueId": "043e82844ef2c3c0961d98a34771c84f7a950d1a_81_89_171_173_82_89"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : fClass.getJavaClass().getFields()) {\n            if (Modifier.isStatic(field.getModifiers())) {\n                Class<?> type = field.getType();\n                if (sig.canAcceptArrayType(type)\n                        && field.getAnnotation(DataPoints.class) != null) {\n                    try {\n                        addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                    } catch (Throwable e) {\n                        // ignore and move on\n                    }\n                } else if (sig.canAcceptType(type)\n                        && field.getAnnotation(DataPoint.class) != null) {\n                    list.add(PotentialAssignment\n                            .forValue(field.getName(), getStaticFieldValue(field)));\n                }\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptArrayType(type)) {\n                try {\n                    addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptType(type)) {\n                list.add(PotentialAssignment.forValue(field.getName(), getStaticFieldValue(field)));\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Collection<Field> getSingleDataPointFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoint.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            Field field = frameworkField.getField();\n            if (Modifier.isStatic(field.getModifiers())) {\n                validFields.add(field);\n            }\n        }\n\n        return validFields;\n    }",
          "uniqueId": "043e82844ef2c3c0961d98a34771c84f7a950d1a_91_110_143_155_91_109"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : fClass.getJavaClass().getFields()) {\n            if (Modifier.isStatic(field.getModifiers())) {\n                Class<?> type = field.getType();\n                if (sig.canAcceptArrayType(type)\n                        && field.getAnnotation(DataPoints.class) != null) {\n                    try {\n                        addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                    } catch (Throwable e) {\n                        // ignore and move on\n                    }\n                } else if (sig.canAcceptType(type)\n                        && field.getAnnotation(DataPoint.class) != null) {\n                    list.add(PotentialAssignment\n                            .forValue(field.getName(), getStaticFieldValue(field)));\n                }\n            }\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void addFields(ParameterSignature sig,\n            List<PotentialAssignment> list) {\n        for (final Field field : getDataPointsFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptArrayType(type)) {\n                try {\n                    addArrayValues(field.getName(), list, getStaticFieldValue(field));\n                } catch (Throwable e) {\n                    // ignore and move on\n                }\n            }\n        }\n        for (final Field field : getSingleDataPointFields(sig)) {\n            Class<?> type = field.getType();\n            if (sig.canAcceptType(type)) {\n                list.add(PotentialAssignment.forValue(field.getName(), getStaticFieldValue(field)));\n            }\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Collection<Field> getDataPointsFields(ParameterSignature sig) {\n        List<FrameworkField> fields = fClass.getAnnotatedFields(DataPoints.class);\n        Collection<Field> validFields = new ArrayList<Field>();\n\n        for (FrameworkField frameworkField : fields) {\n            Field field = frameworkField.getField();\n            if (Modifier.isStatic(field.getModifiers())) {\n                validFields.add(field);\n            }\n        }\n\n        return validFields;\n    }",
          "uniqueId": "043e82844ef2c3c0961d98a34771c84f7a950d1a_91_110_157_169_91_109"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "78b4a8975523d0288a6f20f0ae7862b45cb55038",
      "url": "https://github.com/junit-team/junit4/commit/78b4a8975523d0288a6f20f0ae7862b45cb55038",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null</code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected</code>\n     * @param delta the maximum delta between <code>expected</code> and\n     * <code>actual</code> for which both numbers are still\n     * considered equal.\n     */\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (Float.compare(expected, actual) == 0) {\n            return;\n        }\n        if (!(Math.abs(expected - actual) <= delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }",
          "sourceCodeAfterRefactoring": "/**\n     * Asserts that two floats are equal to within a positive delta.\n     * If they are not, an {@link AssertionError} is thrown with the given\n     * message. If the expected value is infinity then the delta value is\n     * ignored. NaNs are considered equal:\n     * <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes\n     *\n     * @param message the identifying message for the {@link AssertionError} (<code>null</code>\n     * okay)\n     * @param expected expected value\n     * @param actual the value to check against <code>expected</code>\n     * @param delta the maximum delta between <code>expected</code> and\n     * <code>actual</code> for which both numbers are still\n     * considered equal.\n     */\n    static public void assertEquals(String message, float expected,\n            float actual, float delta) {\n        if (floatIsDifferent(expected, actual, delta)) {\n            failNotEquals(message, new Float(expected), new Float(actual));\n        }\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic private boolean floatIsDifferent(float f1, float f2, float delta) {\n        if (Float.compare(f1, f2) == 0) {\n            return false;\n        }\n        if ((Math.abs(f1 - f2) <= delta)) {\n            return false;\n        }\n\n        return true;\n    }",
          "uniqueId": "78b4a8975523d0288a6f20f0ae7862b45cb55038_498_521_569_578_514_534"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ebc674b2536e5bda7083dfd7841cf5c3c846b274",
      "url": "https://github.com/junit-team/junit4/commit/ebc674b2536e5bda7083dfd7841cf5c3c846b274",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void starting() {\n        fStartNanos= System.nanoTime();\n    }",
          "sourceCodeAfterRefactoring": "private void starting() {\n        fStartNanos= currentNanoTime();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate long currentNanoTime() {\n        return System.nanoTime();\n    }",
          "uniqueId": "ebc674b2536e5bda7083dfd7841cf5c3c846b274_120_122_148_150_140_142"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void stopping() {\n        fEndNanos= System.nanoTime();\n    }",
          "sourceCodeAfterRefactoring": "private void stopping() {\n        fEndNanos= currentNanoTime();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate long currentNanoTime() {\n        return System.nanoTime();\n    }",
          "uniqueId": "ebc674b2536e5bda7083dfd7841cf5c3c846b274_124_126_148_150_144_146"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "61badf2f7f147d6e782e1700b24da4ac06ce070c",
      "url": "https://github.com/junit-team/junit4/commit/61badf2f7f147d6e782e1700b24da4ac06ce070c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void createRunnersForParameters(Iterable<Object[]> allParameters,\n            String namePattern) throws InitializationError, Exception {\n        try {\n            int i = 0;\n            for (Object[] parametersOfSingleTest : allParameters) {\n                String name = nameFor(namePattern, i, parametersOfSingleTest);\n                TestClassRunnerForParameters runner = new TestClassRunnerForParameters(\n                        getTestClass().getJavaClass(), parametersOfSingleTest,\n                        name);\n                runners.add(runner);\n                ++i;\n            }\n        } catch (ClassCastException e) {\n            throw parametersMethodReturnedWrongType();\n        }\n    }",
          "sourceCodeAfterRefactoring": "private void createRunnersForParameters(Iterable<Object[]> allParameters, String namePattern) throws Exception {\r\n        try {\r\n            int i = 0;\r\n            for (Object[] parametersOfSingleTest : allParameters) {\r\n                runners.add(createRunner(namePattern, i++, parametersOfSingleTest));\r\n            }\r\n        } catch (ClassCastException e) {\r\n            throw parametersMethodReturnedWrongType();\r\n        }\r\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Runner createRunner(String pattern, int index, Object[] parameters) throws InitializationError {\r\n        return new TestClassRunnerForParameters(getTestClass().getJavaClass(), pattern, index, parameters);\r\n    }",
          "uniqueId": "61badf2f7f147d6e782e1700b24da4ac06ce070c_314_329_295_297_322_331"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "cbcb29a2d80b04803566a3aaaffd9dceb53053bf",
      "url": "https://github.com/junit-team/junit4/commit/cbcb29a2d80b04803566a3aaaffd9dceb53053bf",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override final protected void succeeded(Description description) {\n        endNanos = System.nanoTime();\n        succeeded(getNanos(), description);\n    }",
          "sourceCodeAfterRefactoring": "@Override final protected void succeeded(Description description) {\n        stopping();\n        succeeded(getNanos(), description);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void stopping() {\n        endNanos = System.nanoTime();\n    }",
          "uniqueId": "cbcb29a2d80b04803566a3aaaffd9dceb53053bf_118_121_124_126_128_131"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override final protected void failed(Throwable e, Description description) {\n        endNanos = System.nanoTime();\n        failed(getNanos(), e, description);\n    }",
          "sourceCodeAfterRefactoring": "@Override final protected void failed(Throwable e, Description description) {\n        stopping();\n        failed(getNanos(), e, description);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void stopping() {\n        endNanos = System.nanoTime();\n    }",
          "uniqueId": "cbcb29a2d80b04803566a3aaaffd9dceb53053bf_123_126_124_126_133_136"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override final protected void skipped(AssumptionViolatedException e, Description description) {\n        endNanos = System.nanoTime();\n        skipped(getNanos(), e, description);\n    }",
          "sourceCodeAfterRefactoring": "@Override final protected void skipped(AssumptionViolatedException e, Description description) {\n        stopping();\n        skipped(getNanos(), e, description);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void stopping() {\n        endNanos = System.nanoTime();\n    }",
          "uniqueId": "cbcb29a2d80b04803566a3aaaffd9dceb53053bf_128_131_124_126_138_141"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override final protected void starting(Description description) {\n        startNanos = System.nanoTime();\n    }",
          "sourceCodeAfterRefactoring": "@Override final protected void starting(Description description) {\n        starting();\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void starting() {\n        startNanos = System.nanoTime();\n    }",
          "uniqueId": "cbcb29a2d80b04803566a3aaaffd9dceb53053bf_133_135_120_122_143_145"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5976b1d40ef41cecafd9769dd8776a6e6610d0c5",
      "url": "https://github.com/junit-team/junit4/commit/5976b1d40ef41cecafd9769dd8776a6e6610d0c5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<String> getDeclaredFilteredMethods(Class<?> clazz, List<String> ofInterest) {\n    \t// the method under test.\n    \tMethod[] actualMethods = MethodSorter.getDeclaredMethods(clazz);\n    \t\n    \t// obtain just the names instead of the full methods.\n    \tList<String> names = new ArrayList<String>();\n    \tfor (Method m : actualMethods) {\n    \t\tnames.add(m.toString().replace(clazz.getName() + '.', \"\"));\n    \t}\n\n    \t// reduce to the methods of interest.\n    \tnames.retainAll(ofInterest);\n    \t\n    \treturn names;\n    }",
          "sourceCodeAfterRefactoring": "private List<String> getDeclaredFilteredMethods(Class<?> clazz, List<String> ofInterest) {\n    \tList<String> names= getDeclaredMethodNames(clazz);\n    \tnames.retainAll(ofInterest);   \t\n    \treturn names;\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<String> getDeclaredMethodNames(Class<?> clazz) {\n\t\t// the method under test.\n    \tMethod[] actualMethods = MethodSorter.getDeclaredMethods(clazz);\n    \t\n    \t// obtain just the names instead of the full methods.\n    \tList<String> names = new ArrayList<String>();\n    \tfor (Method m : actualMethods) {\n    \t\tnames.add(m.toString().replace(clazz.getName() + '.', \"\"));\n    \t}\n\t\treturn names;\n\t}",
          "uniqueId": "5976b1d40ef41cecafd9769dd8776a6e6610d0c5_64_78_70_80_64_68"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "467dd0725eb20d018339ae843e895f9cabcfb988",
      "url": "https://github.com/junit-team/junit4/commit/467dd0725eb20d018339ae843e895f9cabcfb988",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void failDueToMissingException() throws AssertionError {\n        String failureMessage;\n        \n        if ( isMissingExceptionMessageEmpty() ) {\n            String expectation = StringDescription.toString(fMatcherBuilder.build());\n            failureMessage = \"Expected test to throw \" + expectation;\n        } else {\n            failureMessage = missingExceptionMessage;\n        }\n\n        fail(failureMessage);\n    }",
          "sourceCodeAfterRefactoring": "private void failDueToMissingException() throws AssertionError {\n        fail(missingExceptionMessage());\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String missingExceptionMessage() {\n        if (isMissingExceptionMessageEmpty()) {\n        \tString expectation = StringDescription.toString(fMatcherBuilder.build());\n            return \"Expected test to throw \" + expectation;\n        } else {\n            return missingExceptionMessage;\n        }        \n    }",
          "uniqueId": "467dd0725eb20d018339ae843e895f9cabcfb988_195_206_216_223_195_197"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "544e5ba3a3034932879604b72fb6f8526d27eb50",
      "url": "https://github.com/junit-team/junit4/commit/544e5ba3a3034932879604b72fb6f8526d27eb50",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public FailOnTimeout(Statement originalStatement, long timeout) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n    }",
          "sourceCodeAfterRefactoring": "public FailOnTimeout(Statement originalStatement, long timeout) {\n        this(originalStatement, timeout, TimeUnit.MILLISECONDS);\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\npublic FailOnTimeout(Statement originalStatement, long timeout, TimeUnit unit) {\n        fOriginalStatement = originalStatement;\n        fTimeout = timeout;\n        fTimeUnit = unit;\n    }",
          "uniqueId": "544e5ba3a3034932879604b72fb6f8526d27eb50_10_13_16_20_12_14"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "c63e0913154a8f01e9f78fef9de23fffd7a1a717",
      "url": "https://github.com/junit-team/junit4/commit/c63e0913154a8f01e9f78fef9de23fffd7a1a717",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tskipped(e, description);\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\terrors.add(e);\n\t\t\t\t\tskippedQuietly(e, description, errors);\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void skippedQuietly(AssumptionViolatedException t, Description description,\n\t\t\tList<Throwable> errors) {\n\t\ttry {\n\t\t\tskipped(t, description);\n\t\t} catch (Throwable t1) {\n\t\t\terrors.add(t1);\n\t\t}\n\t}",
          "uniqueId": "c63e0913154a8f01e9f78fef9de23fffd7a1a717_46_69_89_96_46_69"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "785c7859cd87dc5cb3872fef476ce2f86c9259dd",
      "url": "https://github.com/junit-team/junit4/commit/785c7859cd87dc5cb3872fef476ce2f86c9259dd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, clazz.getName()), clazz, annotations);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn new Description(clazz, formatDisplayName(name, clazz.getName()), annotations);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static String formatDisplayName(String name, String className) {\n\t\treturn String.format(\"%s(%s)\", name, className);\n\t}",
          "uniqueId": "785c7859cd87dc5cb3872fef476ce2f86c9259dd_72_82_107_109_72_82"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * (This remains for binary compatibility with clients of JUnit 4.3)\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, clazz.getName()), clazz);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * (This remains for binary compatibility with clients of JUnit 4.3)\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name) {\n\t\treturn new Description(clazz, formatDisplayName(name, clazz.getName()));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static String formatDisplayName(String name, String className) {\n\t\treturn String.format(\"%s(%s)\", name, className);\n\t}",
          "uniqueId": "785c7859cd87dc5cb3872fef476ce2f86c9259dd_84_94_107_109_84_94"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3bb48f0a58eb44f36b6e03538a7db05b6c6da335",
      "url": "https://github.com/junit-team/junit4/commit/3bb48f0a58eb44f36b6e03538a7db05b6c6da335",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public AssumptionViolatedException(Object value, Matcher<?> matcher) {\n\t\tsuper(value instanceof Throwable ? (Throwable) value : null);\n\t\tfValue= value;\n\t\tfMatcher= matcher;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * An assumption exception with the given <i>value</i> (String or \n\t * Throwable) and an additional failing {@link Matcher}.\n\t */\n\tpublic AssumptionViolatedException(Object value, Matcher<?> matcher) {\n\t\tthis(null, true, value, matcher);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic AssumptionViolatedException(String assumption, boolean valueMatcher, Object value, Matcher<?> matcher) {\n\t\tsuper(value instanceof Throwable ? (Throwable) value : null);\n\t\tfAssumption= assumption;\n\t\tfValue= value;\n\t\tfMatcher= matcher;\n\t\tfValueMatcher= valueMatcher;\n\t}",
          "uniqueId": "3bb48f0a58eb44f36b6e03538a7db05b6c6da335_15_19_25_31_33_39"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "0215c66179ed2c04da2e53f67aefc97b6db5782a",
      "url": "https://github.com/junit-team/junit4/commit/0215c66179ed2c04da2e53f67aefc97b6db5782a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tObject testClassInstance = null;\n\t\t\tList<FrameworkField> fields = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (!fields.isEmpty()) {\n\t\t\t\tif (fields.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+fields.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\t\ttestClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\t\tfor (FrameworkField f : fields) {\n\t\t\t\t\tField field = f.getField();\n\t\t\t\t\tParameter annot = field.getAnnotation(Parameter.class);\n\t\t\t\t\tint index = annot.value();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttestClassInstance = getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tif (fieldsAreAnnotated()) {\n\t\t\t\treturn createTestUsingFieldInjection();\n\t\t\t} else {\n\t\t\t\treturn createTestUsingConstructorInjection();\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Object createTestUsingFieldInjection() throws Exception {\n            List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n\t\t\tif (annotatedFieldsByParameter.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @Parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+annotatedFieldsByParameter.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\tObject testClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\tfor (FrameworkField each : annotatedFieldsByParameter) {\n\t\t\t\tField field = each.getField();\n\t\t\t\tParameter annotation = field.getAnnotation(Parameter.class);\n\t\t\t\tint index = annotation.value();\n\t\t\t\ttry {\n\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}",
          "uniqueId": "0215c66179ed2c04da2e53f67aefc97b6db5782a_174_200_187_207_174_181"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tprotected void validateFields(List<Throwable> errors) {\n\t\t\tsuper.validateFields(errors);\n\t\t\tList<FrameworkField> annotatedFieldsByParameter = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (annotatedFieldsByParameter.size() > 0) {\n\t\t\t\tint[] usedIndices = new int[annotatedFieldsByParameter.size()];\n\t\t\t\tfor (FrameworkField f : annotatedFieldsByParameter) {\n\t\t\t\t\tint index = f.getField().getAnnotation(Parameter.class).value();\n\t\t\t\t\tif (index < 0 || index > annotatedFieldsByParameter.size()-1) {\n\t\t\t\t\t\terrors.add(\n\t\t\t\t\t\t\tnew Exception(\"Invalid @Parameter value: \"+index+\". @Parameter fields counted: \"+\n\t\t\t\t\t\t\t\tannotatedFieldsByParameter.size()+\". Please use an index between 0 and \"+\n\t\t\t\t\t\t\t\t(annotatedFieldsByParameter.size()-1)+\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusedIndices[index]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int index = 0 ; index < usedIndices.length ; index++) {\n\t\t\t\t\tint numberOfUse = usedIndices[index];\n\t\t\t\t\tif (numberOfUse == 0) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is never used.\"));\n\t\t\t\t\t} else if (numberOfUse > 1) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is used more than once (\"+numberOfUse+\").\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected void validateFields(List<Throwable> errors) {\n\t\t\tsuper.validateFields(errors);\n\t\t\tif (fieldsAreAnnotated()) {\n                List<FrameworkField> annotatedFieldsByParameter = getAnnotatedFieldsByParameter();\n\t\t\t\tint[] usedIndices = new int[annotatedFieldsByParameter.size()];\n\t\t\t\tfor (FrameworkField f : annotatedFieldsByParameter) {\n\t\t\t\t\tint index = f.getField().getAnnotation(Parameter.class).value();\n\t\t\t\t\tif (index < 0 || index > annotatedFieldsByParameter.size()-1) {\n\t\t\t\t\t\terrors.add(\n\t\t\t\t\t\t\tnew Exception(\"Invalid @Parameter value: \"+index+\". @Parameter fields counted: \"+\n\t\t\t\t\t\t\t\tannotatedFieldsByParameter.size()+\". Please use an index between 0 and \"+\n\t\t\t\t\t\t\t\t(annotatedFieldsByParameter.size()-1)+\".\")\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tusedIndices[index]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int index = 0 ; index < usedIndices.length ; index++) {\n\t\t\t\t\tint numberOfUse = usedIndices[index];\n\t\t\t\t\tif (numberOfUse == 0) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is never used.\"));\n\t\t\t\t\t} else if (numberOfUse > 1) {\n\t\t\t\t\t\terrors.add(new Exception(\"@Parameter(\"+index+\") is used more than once (\"+numberOfUse+\").\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<FrameworkField> getAnnotatedFieldsByParameter() {\n        return getTestClass().getAnnotatedFields(Parameter.class);\n    }",
          "uniqueId": "0215c66179ed2c04da2e53f67aefc97b6db5782a_221_248_341_343_227_254"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tObject testClassInstance = null;\n\t\t\tList<FrameworkField> fields = getTestClass().getAnnotatedFields(Parameter.class);\n\t\t\tif (!fields.isEmpty()) {\n\t\t\t\tif (fields.size() != fParameters.length)\n\t\t\t\t\tthrow new Exception(\"Wrong number of parameters and @parameter fields.\"+\n\t\t\t\t\t\" @Parameter fields counted: \"+fields.size()+\", available parameters: \"+fParameters.length+\".\");\n\t\t\t\ttestClassInstance = getTestClass().getJavaClass().newInstance();\n\t\t\t\tfor (FrameworkField f : fields) {\n\t\t\t\t\tField field = f.getField();\n\t\t\t\t\tParameter annot = field.getAnnotation(Parameter.class);\n\t\t\t\t\tint index = annot.value();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfield.set(testClassInstance,  fParameters[index]);\n\t\t\t\t\t} catch(IllegalArgumentException iare) {\n\t\t\t\t\t\tthrow new Exception(getTestClass().getName() + \": Trying to set \"+field.getName()+\n\t\t\t\t\t\t\" with the value \"+fParameters[index]+\n\t\t\t\t\t\t\" that is not the right type (\"+fParameters[index].getClass().getSimpleName()+\" instead of \"+\n\t\t\t\t\t\tfield.getType().getSimpleName()+\").\", iare);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttestClassInstance = getTestClass().getOnlyConstructor().newInstance(fParameters);\n\t\t\t}\n\t\t\treturn testClassInstance;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\tif (fieldsAreAnnotated()) {\n\t\t\t\treturn createTestUsingFieldInjection();\n\t\t\t} else {\n\t\t\t\treturn createTestUsingConstructorInjection();\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean fieldsAreAnnotated() {\n\t\treturn !getAnnotatedFieldsByParameter().isEmpty();\n\t}",
          "uniqueId": "0215c66179ed2c04da2e53f67aefc97b6db5782a_174_200_345_347_174_181"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6bea82df32f687d636f1b843a1918a3a1ff22a6e",
      "url": "https://github.com/junit-team/junit4/commit/6bea82df32f687d636f1b843a1918a3a1ff22a6e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Matcher<Throwable> createCompositeMatcher() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}",
          "sourceCodeAfterRefactoring": "private Matcher<Throwable> createCompositeMatcher() {\n\t\treturn withStacktrace(allOfTheMatchers());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Matcher<Throwable> allOfTheMatchers() {\n\t\tif (fMatchers.size() == 1) {\n\t\t\treturn cast(fMatchers.get(0));\n\t\t}\n\t\treturn allOf(castedMatchers());\n\t}",
          "uniqueId": "6bea82df32f687d636f1b843a1918a3a1ff22a6e_54_59_65_70_61_63"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2162def2d4eefae0c5668586b837af4ecd4aed91",
      "url": "https://github.com/junit-team/junit4/commit/2162def2d4eefae0c5668586b837af4ecd4aed91",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\t\t\t\ttry {\n\t\t\t\t\tstarting(description);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbase.evaluate();\n\t\t\t\t\t\tsucceeded(description);\n\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\terrors.add(t);\n\t\t\t\t\t\tfailed(t, description);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tfinished(description);\n\t\t\t\t\t}\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t}\n\t\t\t\tif (!errors.isEmpty())\n\t\t\t\t\tthrow new MultipleFailureException(errors);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void succeededQuietly(Description description,\n\t\t\tList<Throwable> errors) {\n\t\ttry {\n\t\t\tsucceeded(description);\n\t\t} catch (Throwable t) {\n\t\t\terrors.add(t);\n\t\t}\n\t}",
          "uniqueId": "2162def2d4eefae0c5668586b837af4ecd4aed91_46_73_70_77_46_68"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\t\t\t\ttry {\n\t\t\t\t\tstarting(description);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbase.evaluate();\n\t\t\t\t\t\tsucceeded(description);\n\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\terrors.add(t);\n\t\t\t\t\t\tfailed(t, description);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tfinished(description);\n\t\t\t\t\t}\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t}\n\t\t\t\tif (!errors.isEmpty())\n\t\t\t\t\tthrow new MultipleFailureException(errors);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void failedQuietly(Throwable t, Description description,\n\t\t\tList<Throwable> errors) {\n\t\ttry {\n\t\t\tfailed(t, description);\n\t\t} catch (Throwable t1) {\n\t\t\terrors.add(t1);\n\t\t}\n\t}",
          "uniqueId": "2162def2d4eefae0c5668586b837af4ecd4aed91_46_73_79_86_46_68"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\t\t\t\ttry {\n\t\t\t\t\tstarting(description);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbase.evaluate();\n\t\t\t\t\t\tsucceeded(description);\n\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\terrors.add(t);\n\t\t\t\t\t\tfailed(t, description);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tfinished(description);\n\t\t\t\t\t}\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t}\n\t\t\t\tif (!errors.isEmpty())\n\t\t\t\t\tthrow new MultipleFailureException(errors);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void startingQuietly(Description description, \n\t\t\tList<Throwable> errors) {\n\t\ttry {\n\t\t\tstarting(description);\n\t\t} catch (Throwable t) {\n\t\t\terrors.add(t);\n\t\t}\n\t}",
          "uniqueId": "2162def2d4eefae0c5668586b837af4ecd4aed91_46_73_88_95_46_68"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\t\t\t\ttry {\n\t\t\t\t\tstarting(description);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tbase.evaluate();\n\t\t\t\t\t\tsucceeded(description);\n\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\terrors.add(t);\n\t\t\t\t\t\tfailed(t, description);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tfinished(description);\n\t\t\t\t\t}\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t}\n\t\t\t\tif (!errors.isEmpty())\n\t\t\t\t\tthrow new MultipleFailureException(errors);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public Statement apply(final Statement base, final Description description) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tList<Throwable> errors = new ArrayList<Throwable>();\n\n\t\t\t\tstartingQuietly(description, errors);\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t\tsucceededQuietly(description, errors);\n\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\tthrow e;\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\terrors.add(t);\n\t\t\t\t\tfailedQuietly(t, description, errors);\n\t\t\t\t} finally {\n\t\t\t\t\tfinishedQuietly(description, errors);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tMultipleFailureException.assertEmpty(errors);\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void finishedQuietly(Description description,\n\t\t\tList<Throwable> errors) {\n\t\ttry {\n\t\t\tfinished(description);\n\t\t} catch (Throwable t) {\n\t\t\terrors.add(t);\n\t\t}\n\t}",
          "uniqueId": "2162def2d4eefae0c5668586b837af4ecd4aed91_46_73_97_104_46_68"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "14f9868962aee5bcba8a7595287be1d5fed54b7d",
      "url": "https://github.com/junit-team/junit4/commit/14f9868962aee5bcba8a7595287be1d5fed54b7d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, clazz.getName()), annotations);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the class <code>clazz</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param clazz the class of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(Class<?> clazz, String name, Annotation... annotations) {\n\t\treturn createTestDescription(clazz.getName(), name, annotations);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Create a <code>Description</code> of a single test named <code>name</code> in the 'class' named <code>className</code>.\n\t * Generally, this will be a leaf <code>Description</code>.\n\t * @param className the class name of the test\n\t * @param name the name of the test (a method name for test annotated with {@link org.junit.Test})\n\t * @param annotations meta-data about the test, for downstream interpreters\n\t * @return a <code>Description</code> named <code>name</code>\n\t */\n\tpublic static Description createTestDescription(String className, String name, Annotation... annotations) {\n\t\treturn new Description(String.format(\"%s(%s)\", name, className), annotations);\n\t}",
          "uniqueId": "14f9868962aee5bcba8a7595287be1d5fed54b7d_57_67_57_67_69_79"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "24f9b5223c2801a5cba0611e447e66677069b837",
      "url": "https://github.com/junit-team/junit4/commit/24f9b5223c2801a5cba0611e447e66677069b837",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Description(String displayName, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tfDisplayName= displayName;\n\t\tfAnnotations= annotations;\n\t}",
          "sourceCodeAfterRefactoring": "private Description(String displayName, Annotation... annotations) {\n\t\tthis(displayName, displayName, annotations);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Description(String displayName, Object uniqueId, Annotation... annotations) {\n\t\tif ((displayName == null) || (displayName.length() == 0))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The display name must not be empty.\");\n\t\tif ((uniqueId == null))\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"The unique id must not be null.\");\n\t\tfDisplayName= displayName;\n\t\tfUniqueId= uniqueId;\n\t\tfAnnotations= annotations;\n\t}",
          "uniqueId": "24f9b5223c2801a5cba0611e447e66677069b837_94_100_111_121_107_109"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "c610a49727858597d9a10289bed0a0174053a69f",
      "url": "https://github.com/junit-team/junit4/commit/c610a49727858597d9a10289bed0a0174053a69f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static String declaredMethods(Class<?> c) {\n        return Arrays.toString(MethodSorter.getDeclaredMethods(c)).replace(c.getName() + '.', \"\");\n    }",
          "sourceCodeAfterRefactoring": "private String declaredMethods(Class<?> clazz) {\n        return toString(clazz, MethodSorter.getDeclaredMethods(clazz));\n    }",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String toString(Class<?> clazz, Method[] methods) {\n    \treturn Arrays.toString(methods).replace(clazz.getName() + '.', \"\");\n    }",
          "uniqueId": "c610a49727858597d9a10289bed0a0174053a69f_15_17_27_29_31_33"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5475e12b57f5af0140deffa7f45c75dc47803167",
      "url": "https://github.com/junit-team/junit4/commit/5475e12b57f5af0140deffa7f45c75dc47803167",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Only called reflectively. Do not use programmatically.\n\t */\n\tpublic Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, Collections.<Runner>emptyList());\n\t\tList<Object[]> parametersList= getParametersList(getTestClass());\n\t\tfor (int i= 0; i < parametersList.size(); i++)\n\t\t\trunners.add(new TestClassRunnerForParameters(getTestClass().getJavaClass(),\n\t\t\t\t\tparametersList, i));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Only called reflectively. Do not use programmatically.\n\t */\n\tpublic Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, Collections.<Runner> emptyList());\n\t\tIterable<Object[]> allParameters= getAllParameters();\n\t\tcreateRunnersForParameters(allParameters);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void createRunnersForParameters(Iterable<Object[]> allParameters)\n\t\t\tthrows InitializationError, Exception {\n\t\ttry {\n\t\t\tint i= 0;\n\t\t\tfor (Object[] parametersOfSingleTest : allParameters) {\n\t\t\t\tTestClassRunnerForParameters runner= new TestClassRunnerForParameters(\n\t\t\t\t\t\tgetTestClass().getJavaClass(), parametersOfSingleTest,\n\t\t\t\t\t\ti);\n\t\t\t\trunners.add(runner);\n\t\t\t\t++i;\n\t\t\t}\n\t\t} catch (ClassCastException e) {\n\t\t\tthrow parametersMethodReturnedWrongType();\n\t\t}\n\t}",
          "uniqueId": "5475e12b57f5af0140deffa7f45c75dc47803167_130_139_154_168_117_124"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6f8a359dde5b1e317f0bab2da3ac2b5bce117884",
      "url": "https://github.com/junit-team/junit4/commit/6f8a359dde5b1e317f0bab2da3ac2b5bce117884",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void assertFileDoesNotExists(String msg, File file) {\n\t\tassertThat(msg + \": is null\", file, is(notNullValue()));\n\t\tassertThat(msg + \": still exists\", file.exists(), is(false));\n\t}",
          "sourceCodeAfterRefactoring": "private void assertFileDoesNotExist(File file) {\n\t\tcheckFileExists(\"exists\", file, false);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void checkFileExists(String msg, File file, boolean exists) {\n\t\tassertThat(\"File is null\", file, is(notNullValue()));\n\t\tassertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n\t\t\t\tfile.exists(), is(exists));\n\t}",
          "uniqueId": "6f8a359dde5b1e317f0bab2da3ac2b5bce117884_78_81_126_130_122_124"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void assertFileExists(String msg, File file) {\n\t\tassertThat(msg + \": is null\", file, is(notNullValue()));\n\t\tassertThat(msg + \": does not exist\", file.exists(), is(true));\n\t}",
          "sourceCodeAfterRefactoring": "private void assertFileExists(File file) {\n\t\tcheckFileExists(\"does not exist\", file, true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void checkFileExists(String msg, File file, boolean exists) {\n\t\tassertThat(\"File is null\", file, is(notNullValue()));\n\t\tassertThat(\"File '\" + file.getAbsolutePath() + \"' \" + msg,\n\t\t\t\tfile.exists(), is(exists));\n\t}",
          "uniqueId": "6f8a359dde5b1e317f0bab2da3ac2b5bce117884_83_86_126_130_132_134"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2d3090bf96357c0d9387a4e8f87525f776e52799",
      "url": "https://github.com/junit-team/junit4/commit/2d3090bf96357c0d9387a4e8f87525f776e52799",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Returns a new fresh folder with a random name under the temporary\n\t * folder.\n\t */\n\tpublic File newFolder() throws IOException {\n\t\tFile createdFolder= File.createTempFile(\"junit\", \"\", folder);\n\t\tcreatedFolder.delete();\n\t\tcreatedFolder.mkdir();\n\t\treturn createdFolder;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Returns a new fresh folder with a random name under the temporary folder.\n\t */\n\tpublic File newFolder() throws IOException {\n\t\treturn createTemporaryFolderIn(getRoot());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate File createTemporaryFolderIn(File parentFolder) throws IOException {\n\t\tFile createdFolder= File.createTempFile(\"junit\", \"\", parentFolder);\n\t\tcreatedFolder.delete();\n\t\tcreatedFolder.mkdir();\n\t\treturn createdFolder;\n\t}",
          "uniqueId": "2d3090bf96357c0d9387a4e8f87525f776e52799_76_85_84_89_77_82"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ce867738993339a28fd7b3a25ff1e74dbc0013aa",
      "url": "https://github.com/junit-team/junit4/commit/ce867738993339a28fd7b3a25ff1e74dbc0013aa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= File.createTempFile(\"junit\", \"\");\n\t\tfolder.delete();\n\t\tfolder.mkdir();\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * for testing purposes only.  Do not use.\n\t */\n\tpublic void create() throws IOException {\n\t\tfolder= newFolder();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Returns a new fresh folder with a random name under the temporary\n\t * folder.\n\t */\n\tpublic File newFolder() throws IOException {\n\t\tFile createdFolder= File.createTempFile(\"junit\", \"\", folder);\n\t\tcreatedFolder.delete();\n\t\tcreatedFolder.mkdir();\n\t\treturn createdFolder;\n\t}",
          "uniqueId": "ce867738993339a28fd7b3a25ff1e74dbc0013aa_41_48_76_85_41_46"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1ad3a59952f3528914d1225d51bbb04adb62c22f",
      "url": "https://github.com/junit-team/junit4/commit/1ad3a59952f3528914d1225d51bbb04adb62c22f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tThread thread= new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tfNext.evaluate();\n\t\t\t\t\tfFinished= true;\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tfThrown= e;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t\tthread.join(fTimeout);\n\t\tif (fFinished)\n\t\t\treturn;\n\t\tif (fThrown != null)\n\t\t\tthrow fThrown;\n\t\tException exception= new Exception(String.format(\n\t\t\t\t\"test timed out after %d milliseconds\", fTimeout));\n\t\texception.setStackTrace(thread.getStackTrace());\n\t\tthrow exception;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tStatementThread thread= evaluateStatement();\n\t\tif (!thread.fFinished)\n\t\t\tthrowExceptionForUnfinishedThread(thread);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate StatementThread evaluateStatement() throws InterruptedException {\n\t\tStatementThread thread= new StatementThread(fOriginalStatement);\n\t\tthread.start();\n\t\tthread.join(fTimeout);\n\t\tthread.interrupt();\n\t\treturn thread;\n\t}",
          "uniqueId": "1ad3a59952f3528914d1225d51bbb04adb62c22f_22_45_25_31_18_23"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tThread thread= new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tfNext.evaluate();\n\t\t\t\t\tfFinished= true;\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tfThrown= e;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t\tthread.join(fTimeout);\n\t\tif (fFinished)\n\t\t\treturn;\n\t\tif (fThrown != null)\n\t\t\tthrow fThrown;\n\t\tException exception= new Exception(String.format(\n\t\t\t\t\"test timed out after %d milliseconds\", fTimeout));\n\t\texception.setStackTrace(thread.getStackTrace());\n\t\tthrow exception;\n\t}",
          "sourceCodeAfterRefactoring": "private void throwExceptionForUnfinishedThread(StatementThread thread)\n\t\t\tthrows Throwable {\n\t\tif (thread.fExceptionThrownByOriginalStatement != null)\n\t\t\tthrow thread.fExceptionThrownByOriginalStatement;\n\t\telse\n\t\t\tthrowTimeoutException(thread);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void throwTimeoutException(StatementThread thread) throws Exception {\n\t\tException exception= new Exception(String.format(\n\t\t\t\t\"test timed out after %d milliseconds\", fTimeout));\n\t\texception.setStackTrace(thread.getStackTrace());\n\t\tthrow exception;\n\t}",
          "uniqueId": "1ad3a59952f3528914d1225d51bbb04adb62c22f_22_45_41_46_33_39"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tThread thread= new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tfNext.evaluate();\n\t\t\t\t\tfFinished= true;\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tfThrown= e;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t\tthread.join(fTimeout);\n\t\tif (fFinished)\n\t\t\treturn;\n\t\tif (fThrown != null)\n\t\t\tthrow fThrown;\n\t\tException exception= new Exception(String.format(\n\t\t\t\t\"test timed out after %d milliseconds\", fTimeout));\n\t\texception.setStackTrace(thread.getStackTrace());\n\t\tthrow exception;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tStatementThread thread= evaluateStatement();\n\t\tif (!thread.fFinished)\n\t\t\tthrowExceptionForUnfinishedThread(thread);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void throwExceptionForUnfinishedThread(StatementThread thread)\n\t\t\tthrows Throwable {\n\t\tif (thread.fExceptionThrownByOriginalStatement != null)\n\t\t\tthrow thread.fExceptionThrownByOriginalStatement;\n\t\telse\n\t\t\tthrowTimeoutException(thread);\n\t}",
          "uniqueId": "1ad3a59952f3528914d1225d51bbb04adb62c22f_22_45_33_39_18_23"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tThread thread= new Thread() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tfNext.evaluate();\n\t\t\t\t\tfFinished= true;\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\tfThrown= e;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tthread.start();\n\t\tthread.join(fTimeout);\n\t\tif (fFinished)\n\t\t\treturn;\n\t\tif (fThrown != null)\n\t\t\tthrow fThrown;\n\t\tException exception= new Exception(String.format(\n\t\t\t\t\"test timed out after %d milliseconds\", fTimeout));\n\t\texception.setStackTrace(thread.getStackTrace());\n\t\tthrow exception;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void evaluate() throws Throwable {\n\t\tStatementThread thread= evaluateStatement();\n\t\tif (!thread.fFinished)\n\t\t\tthrowExceptionForUnfinishedThread(thread);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tfStatement.evaluate();\n\t\t\t\tfFinished= true;\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t//don't log the InterruptedException\n\t\t\t} catch (Throwable e) {\n\t\t\t\tfExceptionThrownByOriginalStatement= e;\n\t\t\t}\n\t\t}",
          "uniqueId": "1ad3a59952f3528914d1225d51bbb04adb62c22f_22_45_59_69_18_23"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "7a65992af084650c52dc69380ae1ac24b107715c",
      "url": "https://github.com/junit-team/junit4/commit/7a65992af084650c52dc69380ae1ac24b107715c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If\n\t * <code>expected</code> and <code>actual</code> are <code>null</code>,\n\t * they are considered equal.\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expected\n\t *            expected value\n\t * @param actual\n\t *            actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected,\n\t\t\tObject actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && isEquals(expected, actual))\n\t\t\treturn;\n\t\telse if (expected instanceof String && actual instanceof String) {\n\t\t\tString cleanMessage= message == null ? \"\" : message;\n\t\t\tthrow new ComparisonFailure(cleanMessage, (String) expected,\n\t\t\t\t\t(String) actual);\n\t\t} else\n\t\t\tfailNotEquals(message, expected, actual);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two objects are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If\n\t * <code>expected</code> and <code>actual</code> are <code>null</code>,\n\t * they are considered equal.\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expected\n\t *            expected value\n\t * @param actual\n\t *            actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected,\n\t\t\tObject actual) {\n\t\tif (equalsRegardingNull(expected, actual))\n\t\t\treturn;\n\t\telse if (expected instanceof String && actual instanceof String) {\n\t\t\tString cleanMessage= message == null ? \"\" : message;\n\t\t\tthrow new ComparisonFailure(cleanMessage, (String) expected,\n\t\t\t\t\t(String) actual);\n\t\t} else\n\t\t\tfailNotEquals(message, expected, actual);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static boolean equalsRegardingNull(Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn true;\n\t\tif (expected != null && isEquals(expected, actual))\n\t\t\treturn true;\n\t\t\n\t\treturn false;\n\n\t}",
          "uniqueId": "7a65992af084650c52dc69380ae1ac24b107715c_103_129_129_137_103_127"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two doubles or floats are equal to within a positive delta.\n\t * If they are not, an {@link AssertionError} is thrown with the given\n\t * message. If the expected value is infinity then the delta value is\n\t * ignored. NaNs are considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)</code> passes\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expected\n\t *            expected value\n\t * @param actual\n\t *            the value to check against <code>expected</code>\n\t * @param delta\n\t *            the maximum delta between <code>expected</code> and\n\t *            <code>actual</code> for which both numbers are still\n\t *            considered equal.\n\t */\n\tstatic public void assertEquals(String message, double expected,\n\t\t\tdouble actual, double delta) {\n\t\tif (Double.compare(expected, actual) == 0)\n\t\t\treturn;\n\t\tif (!(Math.abs(expected - actual) <= delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two doubles or floats are equal to within a positive delta.\n\t * If they are not, an {@link AssertionError} is thrown with the given\n\t * message. If the expected value is infinity then the delta value is\n\t * ignored. NaNs are considered equal:\n\t * <code>assertEquals(Double.NaN, Double.NaN, *)</code> passes\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expected\n\t *            expected value\n\t * @param actual\n\t *            the value to check against <code>expected</code>\n\t * @param delta\n\t *            the maximum delta between <code>expected</code> and\n\t *            <code>actual</code> for which both numbers are still\n\t *            considered equal.\n\t */\n\tstatic public void assertEquals(String message, double expected,\n\t\t\tdouble actual, double delta) {\n\t\tif (doubleIsDifferent(expected, actual, delta))\n\t\t\tfailNotEquals(message, new Double(expected), new Double(actual));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic private boolean doubleIsDifferent(double d1, double d2, double delta) {\n\t\tif (Double.compare(d1, d2) == 0)\n\t\t\treturn false;\n\t\tif ((Math.abs(d1 - d2) <= delta))\n\t\t\treturn false;\n\t\t\n\t\treturn true;\n\t}",
          "uniqueId": "7a65992af084650c52dc69380ae1ac24b107715c_419_444_566_573_541_564"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "b23ffd790b06f561290239ef3b7a5239ba755f10",
      "url": "https://github.com/junit-team/junit4/commit/b23ffd790b06f561290239ef3b7a5239ba755f10",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic boolean isShadowedBy(FrameworkField otherMember) {\n\t\treturn otherMember.getField().getName().equals(getField().getName());\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic boolean isShadowedBy(FrameworkField otherMember) {\n\t\treturn otherMember.getField().getName().equals(getName());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String getName() {\n\t\treturn getField().getName();\n\t}",
          "uniqueId": "b23ffd790b06f561290239ef3b7a5239ba755f10_24_27_20_22_34_37"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8782efa08abf5d47afdc16740678661443706740",
      "url": "https://github.com/junit-team/junit4/commit/8782efa08abf5d47afdc16740678661443706740",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn rules(target);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * @param target\n\t *            the test case instance\n\t * @return a list of MethodRules that should be applied when executing this\n\t *         test\n\t * @deprecated {@link MethodRule} is a deprecated interface. Port to\n\t *             {@link TestRule} and\n\t *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}\n\t */\n\t@Deprecated\n\tprotected List<org.junit.rules.MethodRule> rules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target, Rule.class,\n\t\t\t\torg.junit.rules.MethodRule.class);\n\t}",
          "uniqueId": "8782efa08abf5d47afdc16740678661443706740_358_362_363_376_358_361"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "01b427b3b89ce04d01f0ddbd746d13a175feec5b",
      "url": "https://github.com/junit-team/junit4/commit/01b427b3b89ce04d01f0ddbd746d13a175feec5b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * The result of running JUnit on {@code type}\n\t */\n\tpublic static PrintableResult testResult(Class<?> type) {\n\t\treturn new PrintableResult(type);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * The result of running JUnit on {@code type}\n\t */\n\tpublic static PrintableResult testResult(Class<?> type) {\n\t\treturn testResult(Request.aClass(type));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * The result of running JUnit on Request {@code request}\n\t */\n\tpublic static PrintableResult testResult(Request request) {\n\t\treturn new PrintableResult(new JUnitCore().run(request));\n\t}",
          "uniqueId": "01b427b3b89ce04d01f0ddbd746d13a175feec5b_22_27_30_35_23_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "81b50e9f3bdb66543d07e7349026bd3b447f433e",
      "url": "https://github.com/junit-team/junit4/commit/81b50e9f3bdb66543d07e7349026bd3b447f433e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (org.junit.rules.MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tList<TestRule> testRules= getTestRules(target);\n\t\tfor (org.junit.rules.MethodRule each : getMethodRules(target))\n\t\t\tif (! testRules.contains(each))\n\t\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"deprecation\")\n\tprivate List<org.junit.rules.MethodRule> getMethodRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class);\n\t}",
          "uniqueId": "81b50e9f3bdb66543d07e7349026bd3b447f433e_367_374_377_381_367_375"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement withTestRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (TestRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class))\n\t\t\tresult= each.apply(result, describeChild(method));\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement withTestRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (TestRule each : getTestRules(target))\n\t\t\tresult= each.apply(result, describeChild(method));\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<TestRule> getTestRules(Object target) {\n\t\treturn getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class);\n\t}",
          "uniqueId": "81b50e9f3bdb66543d07e7349026bd3b447f433e_376_382_390_393_383_388"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "d21d4edb6a5c55a3d8930dd26762a26cad67d827",
      "url": "https://github.com/junit-team/junit4/commit/d21d4edb6a5c55a3d8930dd26762a26cad67d827",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!(MethodRule.class.isAssignableFrom(type) || \n\t\t\t\tTestRule.class.isAssignableFrom(type)))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}",
          "sourceCodeAfterRefactoring": "private void validateRuleField(Field field, List<Throwable> errors) {\n\t\tClass<?> type= field.getType();\n\t\tif (!isMethodRule(type) && !isTestRule(type))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must implement MethodRule\"));\n\t\tif (!Modifier.isPublic(field.getModifiers()))\n\t\t\terrors.add(new Exception(\"Field \" + field.getName()\n\t\t\t\t\t+ \" must be public\"));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isTestRule(Class<?> type) {\n\t\treturn TestRule.class.isAssignableFrom(type);\n\t}",
          "uniqueId": "d21d4edb6a5c55a3d8930dd26762a26cad67d827_187_196_196_198_186_194"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tfor (MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\tfor (TestRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class))\n\t\t\tresult= each.apply(result, describeChild(method));\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tresult= withMethodRules(method, target, result);\n\t\tresult= withTestRules(method, target, result);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n@SuppressWarnings(\"deprecation\")\n\tprivate Statement withMethodRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (org.junit.rules.MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, org.junit.rules.MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\treturn result;\n\t}",
          "uniqueId": "d21d4edb6a5c55a3d8930dd26762a26cad67d827_352_362_367_374_359_365"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tfor (MethodRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, MethodRule.class))\n\t\t\tresult= each.apply(result, method, target);\n\t\tfor (TestRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class))\n\t\t\tresult= each.apply(result, describeChild(method));\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement withRules(FrameworkMethod method, Object target,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tresult= withMethodRules(method, target, result);\n\t\tresult= withTestRules(method, target, result);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Statement withTestRules(FrameworkMethod method, Object target,\n\t\t\tStatement result) {\n\t\tfor (TestRule each : getTestClass().getAnnotatedFieldValues(target,\n\t\t\t\tRule.class, TestRule.class))\n\t\t\tresult= each.apply(result, describeChild(method));\n\t\treturn result;\n\t}",
          "uniqueId": "d21d4edb6a5c55a3d8930dd26762a26cad67d827_352_362_376_382_359_365"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "568e29c871ea144e12f273dc7e12c949a5a507da",
      "url": "https://github.com/junit-team/junit4/commit/568e29c871ea144e12f273dc7e12c949a5a507da",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public final Statement apply(final Statement base,\n\t\t\tFrameworkMethod method, Object target) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tbefore();\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t} finally {\n\t\t\t\t\tafter();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public final Statement apply(final Statement base,\n\t\t\tFrameworkMethod method, Object target) {\n\t\treturn statement(base);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Statement statement(final Statement base) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\tbefore();\n\t\t\t\ttry {\n\t\t\t\t\tbase.evaluate();\n\t\t\t\t} finally {\n\t\t\t\t\tafter();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "uniqueId": "568e29c871ea144e12f273dc7e12c949a5a507da_36_49_47_59_38_41"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "f09cff79b941a525271f3f2838a9742b4c5c8d36",
      "url": "https://github.com/junit-team/junit4/commit/f09cff79b941a525271f3f2838a9742b4c5c8d36",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public SuiteBuilder(Class<?> testClass) throws InitializationError {\n\t\t\tfTestClass= new TestClass(testClass);\n\t\t\t// TODO: extract complexity\n\t\t\ttry {\n\t\t\t\tfInstance= fTestClass.getOnlyConstructor().newInstance();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new InitializationError(e);\n\t\t\t}\n\t\t\tfRunners= computeRunners();\n\t\t}",
          "sourceCodeAfterRefactoring": "public SuiteBuilder(Class<?> testClass) throws InitializationError {\n\t\tfTestClass= new TestClass(testClass);\n\t\tfInstance = createInstance();\n\t\tfRunners= computeRunners();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Object createInstance() throws InitializationError {\n\t\ttry {\n\t\t\treturn fTestClass.getOnlyConstructor().newInstance();\n\t\t} catch (Exception e) {\n\t\t\tthrow new InitializationError(e);\n\t\t}\n\t}",
          "uniqueId": "f09cff79b941a525271f3f2838a9742b4c5c8d36_65_74_45_51_39_43"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "d0534dae86dd511eb0575dbdf7e706a40f51e590",
      "url": "https://github.com/junit-team/junit4/commit/d0534dae86dd511eb0575dbdf7e706a40f51e590",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\t public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\tpublic TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "uniqueId": "d0534dae86dd511eb0575dbdf7e706a40f51e590_122_151_132_155_122_130"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(new TestSuite(each.asSubclass(TestCase.class)));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(testCaseForClass(each));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Test testCaseForClass(Class<?> each) {\n\t\tif (TestCase.class.isAssignableFrom(each))\n\t\t\treturn new TestSuite(each.asSubclass(TestCase.class));\n\t\telse\n\t\t\treturn warning(each.getCanonicalName() + \" does not extend TestCase\");\n\t}",
          "uniqueId": "d0534dae86dd511eb0575dbdf7e706a40f51e590_169_176_182_187_173_180"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5f7fddf537e551109ffd6241a00c87a2b3521523",
      "url": "https://github.com/junit-team/junit4/commit/5f7fddf537e551109ffd6241a00c87a2b3521523",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {\n\t\t\tT each= iter.next();\n\t\t\tif (!filter.shouldRun(describeChild(each)))\n\t\t\t\titer.remove();\n\t\t\telse\n\t\t\t\ttry {\n\t\t\t\t\tfilter.apply(each);\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\titer.remove();\n\t\t\t\t}\n\t\t}\n\n\t\tfDescription = null;\n\t\t\n\t\tif (getCachedChildren().isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}",
          "sourceCodeAfterRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tfFilter= filter;\n\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each))\n\t\t\t\treturn;\n\t\tthrow new NoTestsRemainException();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean shouldRun(T each) {\n\t\treturn fFilter == null || fFilter.shouldRun(describeChild(each));\n\t}",
          "uniqueId": "5f7fddf537e551109ffd6241a00c87a2b3521523_261_278_298_300_250_257"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2de4d6f2bcf699b94614f9208f620f4c56bc9876",
      "url": "https://github.com/junit-team/junit4/commit/2de4d6f2bcf699b94614f9208f620f4c56bc9876",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\t public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\tpublic TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "uniqueId": "2de4d6f2bcf699b94614f9208f620f4c56bc9876_122_151_132_155_122_130"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(new TestSuite(each.asSubclass(TestCase.class)));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(testCaseForClass(each));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Test testCaseForClass(Class<?> each) {\n\t\tif (TestCase.class.isAssignableFrom(each))\n\t\t\treturn new TestSuite(each.asSubclass(TestCase.class));\n\t\telse\n\t\t\treturn warning(each.getCanonicalName() + \" does not extend TestCase\");\n\t}",
          "uniqueId": "2de4d6f2bcf699b94614f9208f620f4c56bc9876_169_176_182_187_173_180"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "70adacdc1a7f963c081a9752ba62200f8b798d56",
      "url": "https://github.com/junit-team/junit4/commit/70adacdc1a7f963c081a9752ba62200f8b798d56",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\t public TestSuite(final Class<? extends TestCase> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given class. Adds all the methods\n\t * starting with \"test\" as test cases to the suite.\n\t * Parts of this method were written at 2337 meters in the Hueffihuette,\n\t * Kanton Uri\n\t */\n\tpublic TestSuite(final Class<?> theClass) {\n\t\taddTestsFromTestCase(theClass);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addTestsFromTestCase(final Class<?> theClass) {\n\t\tfName= theClass.getName();\n\t\ttry {\n\t\t\tgetTestConstructor(theClass); // Avoid generating multiple error messages\n\t\t} catch (NoSuchMethodException e) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" has no public constructor TestCase(String name) or TestCase()\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!Modifier.isPublic(theClass.getModifiers())) {\n\t\t\taddTest(warning(\"Class \"+theClass.getName()+\" is not public\"));\n\t\t\treturn;\n\t\t}\n\n\t\tClass<?> superClass= theClass;\n\t\tList<String> names= new ArrayList<String>();\n\t\twhile (Test.class.isAssignableFrom(superClass)) {\n\t\t\tfor (Method each : superClass.getDeclaredMethods())\n\t\t\t\taddTestMethod(each, names, theClass);\n\t\t\tsuperClass= superClass.getSuperclass();\n\t\t}\n\t\tif (fTests.size() == 0)\n\t\t\taddTest(warning(\"No tests found in \"+theClass.getName()));\n\t}",
          "uniqueId": "70adacdc1a7f963c081a9752ba62200f8b798d56_122_151_132_155_122_130"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(new TestSuite(each.asSubclass(TestCase.class)));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestSuite from the given array of classes.  \n\t * @param classes {@link TestCase}s\n\t */\n\tpublic TestSuite (Class<?>... classes) {\n\t\tfor (Class<?> each : classes)\n\t\t\taddTest(testCaseForClass(each));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Test testCaseForClass(Class<?> each) {\n\t\tif (TestCase.class.isAssignableFrom(each))\n\t\t\treturn new TestSuite(each.asSubclass(TestCase.class));\n\t\telse\n\t\t\treturn warning(each.getCanonicalName() + \" does not extend TestCase\");\n\t}",
          "uniqueId": "70adacdc1a7f963c081a9752ba62200f8b798d56_169_176_182_187_173_180"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "97402a3401c6cc2d45d395c0d9d636f483b5571c",
      "url": "https://github.com/junit-team/junit4/commit/97402a3401c6cc2d45d395c0d9d636f483b5571c",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tfor (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {\n\t\t\tT each= iter.next();\n\t\t\tif (!filter.shouldRun(describeChild(each)))\n\t\t\t\titer.remove();\n\t\t\telse\n\t\t\t\ttry {\n\t\t\t\t\tfilter.apply(each);\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\titer.remove();\n\t\t\t\t}\n\t\t}\n\n\t\tfDescription = null;\n\t\t\n\t\tif (getCachedChildren().isEmpty())\n\t\t\tthrow new NoTestsRemainException();\n\t}",
          "sourceCodeAfterRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tfFilter= filter;\n\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each))\n\t\t\t\treturn;\n\t\tthrow new NoTestsRemainException();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean shouldRun(T each) {\n\t\treturn fFilter == null || fFilter.shouldRun(describeChild(each));\n\t}",
          "uniqueId": "97402a3401c6cc2d45d395c0d9d636f483b5571c_261_278_298_300_250_257"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "f1f4fe290a3a35a9083d2e76e922b57350e05f34",
      "url": "https://github.com/junit-team/junit4/commit/f1f4fe290a3a35a9083d2e76e922b57350e05f34",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Test asTest(Plan plan) {\n\t\tDescription description= plan.getDescription();\n\t\tif (description.isSuite())\n\t\t\treturn createTestSuite(plan);\n\t\telse\n\t\t\treturn asTestCase(description);\n\t}",
          "sourceCodeAfterRefactoring": "public Test asTest(Plan plan) {\n\t\tDescription description= plan.getDescription();\n\t\tif (description.isSuite())\n\t\t\treturn asTestSuite(plan);\n\t\telse\n\t\t\treturn asTestCase(description);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Test asTestSuite(Plan plan) {\n\t\treturn createTestSuite(plan);\n\t}",
          "uniqueId": "f1f4fe290a3a35a9083d2e76e922b57350e05f34_25_31_47_49_39_45"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2f9b53dbecad010dbb7e7cfff3a11476b7d2208a",
      "url": "https://github.com/junit-team/junit4/commit/2f9b53dbecad010dbb7e7cfff3a11476b7d2208a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (isExcluded(description))\n\t\t\t\treturn false;\n\t\t\tif (description.isSuite())\n\t\t\t\treturn true;\n\t\t\treturn isIncludedMethod(description);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isExcluded(Description description) {\n\t\t\tif (fExcluded == null)\n\t\t\t\treturn false;\t\t\t\n\t\t\tfor (Class<?> each: categories(description))\n\t\t\t\tif (fExcluded.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "uniqueId": "2f9b53dbecad010dbb7e7cfff3a11476b7d2208a_95_103_104_111_95_102"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f",
      "url": "https://github.com/junit-team/junit4/commit/7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "Test createTest(Description description) {\n\t\tif (description.isTest())\n\t\t\treturn new JUnit4TestCaseFacade(description);\n\t\telse {\n\t\t\tTestSuite suite = new TestSuite(description.getDisplayName());\n\t\t\tfor (Description child : description.getChildren())\n\t\t\t\tsuite.addTest(asTest(child));\n\t\t\treturn suite;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "Test createTest(Plan plan) {\n\t\tDescription description= plan.getDescription();\n\t\tif (plan.isTest())\n\t\t\treturn createSingleTest(description);\n\t\telse {\n\t\t\tTestSuite suite = new TestSuite(description.getDisplayName());\n\t\t\tfor (Plan child : plan.getChildren())\n\t\t\t\tsuite.addTest(asTest(child));\n\t\t\treturn suite;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate JUnit4TestCaseFacade createSingleTest(Description description) {\n\t\treturn new JUnit4TestCaseFacade(description);\n\t}",
          "uniqueId": "7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f_34_43_51_53_39_49"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\tMultipleFailureException mfe= (MultipleFailureException) targetException;\n\t\t\tfor (Throwable each : mfe.getFailures())\n\t\t\t\taddFailure(each);\n\t\t\treturn;\n\t\t}\n\t\tfNotifier.fireTestFailure(new Failure(fDescription, targetException));\n\t}",
          "sourceCodeAfterRefactoring": "public void addFailure(Throwable targetException) {\n\t\tif (targetException instanceof MultipleFailureException) {\n\t\t\taddMultipleFailureException((MultipleFailureException) targetException);\n\t\t} else {\n\t\t\tfNotifier\n\t\t\t\t\t.fireTestFailure(new Failure(fDescription, targetException));\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addMultipleFailureException(MultipleFailureException mfe) {\n\t\tfor (Throwable each : mfe.getFailures())\n\t\t\taddFailure(each);\n\t}",
          "uniqueId": "7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f_22_30_30_33_21_28"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void runNotIgnored(FrameworkMethod method,\n\t\t\tEachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
          "uniqueId": "7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f_66_84_77_89_67_75"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tmethodBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.addFailedAssumption(e);\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.getAnnotation(Ignore.class) != null) {\n\t\t\trunIgnored(eachNotifier);\n\t\t} else {\n\t\t\trunNotIgnored(method, eachNotifier);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void runIgnored(EachTestNotifier eachNotifier) {\n\t\teachNotifier.fireTestIgnored();\n\t}",
          "uniqueId": "7a2b0460c7abd7573faa9d7845a5b1169dcdcb7f_66_84_91_93_67_75"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "9eab1418bf073556414f8654a8b66d65d784ed71",
      "url": "https://github.com/junit-team/junit4/commit/9eab1418bf073556414f8654a8b66d65d784ed71",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Construct a new {@code InitializationError} with one cause\n\t * with message {@code string}\n\t */\n\tpublic InitializationError(String string) {\n\t\tthis(Arrays.<Throwable>asList(new Exception(string)));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Construct a new {@code InitializationError} with one cause\n\t * with message {@code string}\n\t */\n\tpublic InitializationError(String string) {\n\t\tthis(new Exception(string));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic InitializationError(Throwable error) {\n\t\tthis(Arrays.asList(error));\n\t}",
          "uniqueId": "9eab1418bf073556414f8654a8b66d65d784ed71_21_27_21_23_25_31"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\t// TODO: ack! why is value single-valued?\n\t\t\t// TODO: not just any category should work\n\t\t\t// TODO: should inheritance come into play?\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\treturn annotation != null && annotation.value() == fCategoryClass;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\n\t\t\t// TODO: feels as if we've done this child crawl several times.\n\t\t\t// Change design?\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\tfor (Class<? extends CategoryClass> each : annotation.value())\n\t\t\t\tif (fCategoryClass.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "uniqueId": "9eab1418bf073556414f8654a8b66d65d784ed71_91_98_52_60_39_50"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ce810b763e5021629248702993f226e3bf969db8",
      "url": "https://github.com/junit-team/junit4/commit/ce810b763e5021629248702993f226e3bf969db8",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Construct a new {@code InitializationError} with one cause\n\t * with message {@code string}\n\t */\n\tpublic InitializationError(String string) {\n\t\tthis(Arrays.<Throwable>asList(new Exception(string)));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Construct a new {@code InitializationError} with one cause\n\t * with message {@code string}\n\t */\n\tpublic InitializationError(String string) {\n\t\tthis(new Exception(string));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic InitializationError(Throwable error) {\n\t\tthis(Arrays.asList(error));\n\t}",
          "uniqueId": "ce810b763e5021629248702993f226e3bf969db8_21_27_21_23_25_31"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\t// TODO: ack! why is value single-valued?\n\t\t\t// TODO: not just any category should work\n\t\t\t// TODO: should inheritance come into play?\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\treturn annotation != null && annotation.value() == fCategoryClass;\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic boolean shouldRun(Description description) {\n\t\t\tif (hasCorrectCategoryAnnotation(description))\n\t\t\t\treturn true;\n\n\t\t\t// TODO: feels as if we've done this child crawl several times.\n\t\t\t// Change design?\n\t\t\tfor (Description each : description.getChildren())\n\t\t\t\tif (shouldRun(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean hasCorrectCategoryAnnotation(Description description) {\n\t\t\tCategory annotation= description.getAnnotation(Category.class);\n\t\t\tif (annotation == null)\n\t\t\t\treturn false;\n\t\t\tfor (Class<? extends CategoryClass> each : annotation.value())\n\t\t\t\tif (fCategoryClass.isAssignableFrom(each))\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}",
          "uniqueId": "ce810b763e5021629248702993f226e3bf969db8_91_98_52_60_39_50"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "54917b88aab026dabb4541276ed875117c1e1faa",
      "url": "https://github.com/junit-team/junit4/commit/54917b88aab026dabb4541276ed875117c1e1faa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static PrintableResult testResult(Class<?> type) {\n\t\treturn new PrintableResult(type);\n\t}",
          "sourceCodeAfterRefactoring": "public static PrintableResult testResult(Class<?> type) {\n\t\treturn testResult(type, new Computer());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static PrintableResult testResult(Class<?> type, Computer computer) {\n\t\treturn new PrintableResult(type, computer);\n\t}",
          "uniqueId": "54917b88aab026dabb4541276ed875117c1e1faa_16_18_21_23_17_19"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "dee8a47af11dd88139f4d46a1ebee7fc613e367e",
      "url": "https://github.com/junit-team/junit4/commit/dee8a47af11dd88139f4d46a1ebee7fc613e367e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\t// TODO (May 26, 2009 11:16:13 PM): outsource to a class?\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t.get(test);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * @return the StatementInterceptors that can transform the block\n\t * that runs each method in the tested class.\n\t */\n\tprotected List<StatementInterceptor> interceptors(Object test) {\n\t\tList<StatementInterceptor> results= new ArrayList<StatementInterceptor>();\n\t\tfor (FrameworkField each : interceptorFields()) {\n\t\t\tresults.add(createInterceptor(test, each));\n\t\t}\n\t\treturn results;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate StatementInterceptor createInterceptor(Object test,\n\t\t\tFrameworkField each) {\n\t\ttry {\n\t\t\treturn (StatementInterceptor) each.get(test);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t}\n\t}",
          "uniqueId": "dee8a47af11dd88139f4d46a1ebee7fc613e367e_298_312_345_353_329_339"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\t// TODO (May 26, 2009 11:16:13 PM): outsource to a class?\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t.get(test);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tfor (StatementInterceptor each : interceptors(test))\n\t\t\tresult= each.intercept(result, method);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * @return the StatementInterceptors that can transform the block\n\t * that runs each method in the tested class.\n\t */\n\tprotected List<StatementInterceptor> interceptors(Object test) {\n\t\tList<StatementInterceptor> results= new ArrayList<StatementInterceptor>();\n\t\tfor (FrameworkField each : interceptorFields()) {\n\t\t\tresults.add(createInterceptor(test, each));\n\t\t}\n\t\treturn results;\n\t}",
          "uniqueId": "dee8a47af11dd88139f4d46a1ebee7fc613e367e_298_312_329_339_321_327"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "9218455d51cd94b21b4536af793dd4c4c6820bf7",
      "url": "https://github.com/junit-team/junit4/commit/9218455d51cd94b21b4536af793dd4c4c6820bf7",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public String getClassName() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\treturn matcher.matches()\n\t\t\t? matcher.group(2)\n\t\t\t: toString();\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * @return If this describes a method invocation, \n\t * the name of the class of the test instance\n\t */\n\tpublic String getClassName() {\n\t\tMatcher matcher= methodStringMatcher();\n\t\treturn matcher.matches()\n\t\t\t? matcher.group(2)\n\t\t\t: toString();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Matcher methodStringMatcher() {\n\t\treturn Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t}",
          "uniqueId": "9218455d51cd94b21b4536af793dd4c4c6820bf7_210_215_238_240_212_221"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private String parseMethod() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\tif (matcher.matches())\n\t\t\treturn matcher.group(1);\n\t\treturn null;\n\t}",
          "sourceCodeAfterRefactoring": "private String parseMethod() {\n\t\tMatcher matcher= methodStringMatcher();\n\t\tif (matcher.matches())\n\t\t\treturn matcher.group(1);\n\t\treturn null;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Matcher methodStringMatcher() {\n\t\treturn Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t}",
          "uniqueId": "9218455d51cd94b21b4536af793dd4c4c6820bf7_217_222_238_240_231_236"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "409a8e06c9f2ec5aa0d9db8a3d413f394c290f6d",
      "url": "https://github.com/junit-team/junit4/commit/409a8e06c9f2ec5aa0d9db8a3d413f394c290f6d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static PrintableResult testResult(Class<?> type) {\n\t\treturn new PrintableResult(type);\n\t}",
          "sourceCodeAfterRefactoring": "public static PrintableResult testResult(Class<?> type) {\n\t\treturn testResult(type, new Computer());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static PrintableResult testResult(Class<?> type, Computer computer) {\n\t\treturn new PrintableResult(type, computer);\n\t}",
          "uniqueId": "409a8e06c9f2ec5aa0d9db8a3d413f394c290f6d_16_18_21_23_17_19"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "e4c7fac80cac937faf413e3ddd58e0fd091bd367",
      "url": "https://github.com/junit-team/junit4/commit/e4c7fac80cac937faf413e3ddd58e0fd091bd367",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\t// TODO (May 26, 2009 11:16:13 PM): outsource to a class?\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t.get(test);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * @return the StatementInterceptors that can transform the block\n\t * that runs each method in the tested class.\n\t */\n\tprotected List<StatementInterceptor> interceptors(Object test) {\n\t\tList<StatementInterceptor> results= new ArrayList<StatementInterceptor>();\n\t\tfor (FrameworkField each : interceptorFields()) {\n\t\t\tresults.add(createInterceptor(test, each));\n\t\t}\n\t\treturn results;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate StatementInterceptor createInterceptor(Object test,\n\t\t\tFrameworkField each) {\n\t\ttry {\n\t\t\treturn (StatementInterceptor) each.get(test);\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t}\n\t}",
          "uniqueId": "e4c7fac80cac937faf413e3ddd58e0fd091bd367_298_312_345_353_329_339"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\t// TODO (May 26, 2009 11:16:13 PM): outsource to a class?\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t.get(test);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement withInterceptors(FrameworkMethod method, Object test,\n\t\t\tStatement statement) {\n\t\tStatement result= statement;\n\t\tfor (StatementInterceptor each : interceptors(test))\n\t\t\tresult= each.intercept(result, method);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * @return the StatementInterceptors that can transform the block\n\t * that runs each method in the tested class.\n\t */\n\tprotected List<StatementInterceptor> interceptors(Object test) {\n\t\tList<StatementInterceptor> results= new ArrayList<StatementInterceptor>();\n\t\tfor (FrameworkField each : interceptorFields()) {\n\t\t\tresults.add(createInterceptor(test, each));\n\t\t}\n\t\treturn results;\n\t}",
          "uniqueId": "e4c7fac80cac937faf413e3ddd58e0fd091bd367_298_312_329_339_321_327"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "cb1d4dfd390718002349f2cbb456ec9ea769ff2b",
      "url": "https://github.com/junit-team/junit4/commit/cb1d4dfd390718002349f2cbb456ec9ea769ff2b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public String getClassName() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\treturn matcher.matches()\n\t\t\t? matcher.group(2)\n\t\t\t: toString();\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * @return If this describes a method invocation, \n\t * the name of the class of the test instance\n\t */\n\tpublic String getClassName() {\n\t\tMatcher matcher= methodStringMatcher();\n\t\treturn matcher.matches()\n\t\t\t? matcher.group(2)\n\t\t\t: toString();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Matcher methodStringMatcher() {\n\t\treturn Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t}",
          "uniqueId": "cb1d4dfd390718002349f2cbb456ec9ea769ff2b_210_215_238_240_212_221"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private String parseMethod() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\tif (matcher.matches())\n\t\t\treturn matcher.group(1);\n\t\treturn null;\n\t}",
          "sourceCodeAfterRefactoring": "private String parseMethod() {\n\t\tMatcher matcher= methodStringMatcher();\n\t\tif (matcher.matches())\n\t\t\treturn matcher.group(1);\n\t\treturn null;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Matcher methodStringMatcher() {\n\t\treturn Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t}",
          "uniqueId": "cb1d4dfd390718002349f2cbb456ec9ea769ff2b_217_222_238_240_231_236"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "7c6809f47fde700f345ded8faaff468dc2d53c08",
      "url": "https://github.com/junit-team/junit4/commit/7c6809f47fde700f345ded8faaff468dc2d53c08",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expect(Class<? extends Throwable> type) {\n\t\tfMatcher= instanceOf(type);\n\t}",
          "sourceCodeAfterRefactoring": "public void expect(Class<? extends Throwable> type) {\n\t\texpect(instanceOf(type));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expect(Matcher<?> matcher) {\n\t\tif (fMatcher == null)\n\t\t\tfMatcher = matcher;\n\t\telse\n\t\t\tfMatcher = both(fMatcher).and(matches(matcher));\n\t}",
          "uniqueId": "7c6809f47fde700f345ded8faaff468dc2d53c08_21_23_21_26_28_30"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expectMessage(Matcher<String> matcher) {\n\t\tfMatcher= hasMessage(matcher);\n\t}",
          "sourceCodeAfterRefactoring": "public void expectMessage(Matcher<String> matcher) {\n\t\texpect(hasMessage(matcher));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expect(Matcher<?> matcher) {\n\t\tif (fMatcher == null)\n\t\t\tfMatcher = matcher;\n\t\telse\n\t\t\tfMatcher = both(fMatcher).and(matches(matcher));\n\t}",
          "uniqueId": "7c6809f47fde700f345ded8faaff468dc2d53c08_29_31_21_26_36_38"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "a423117429dc71bf3068eeae38c6443672beda7f",
      "url": "https://github.com/junit-team/junit4/commit/a423117429dc71bf3068eeae38c6443672beda7f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expectMessage(String message) {\n\t\tfMessage= message;\n\t}",
          "sourceCodeAfterRefactoring": "public void expectMessage(String substring) {\n\t\texpectMessage(containsString(substring));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expectMessage(Matcher<String> matcher) {\n\t\tfMatcher= hasMessage(matcher);\n\t}",
          "uniqueId": "a423117429dc71bf3068eeae38c6443672beda7f_18_20_29_31_25_27"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "a01928138beb41a189dc1fa43f92942b39393cbb",
      "url": "https://github.com/junit-team/junit4/commit/a01928138beb41a189dc1fa43f92942b39393cbb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expect(Class<? extends Throwable> type) {\n\t\tfMatcher= instanceOf(type);\n\t}",
          "sourceCodeAfterRefactoring": "public void expect(Class<? extends Throwable> type) {\n\t\texpect(instanceOf(type));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expect(Matcher<?> matcher) {\n\t\tif (fMatcher == null)\n\t\t\tfMatcher = matcher;\n\t\telse\n\t\t\tfMatcher = both(fMatcher).and(matches(matcher));\n\t}",
          "uniqueId": "a01928138beb41a189dc1fa43f92942b39393cbb_21_23_21_26_28_30"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expectMessage(Matcher<String> matcher) {\n\t\tfMatcher= hasMessage(matcher);\n\t}",
          "sourceCodeAfterRefactoring": "public void expectMessage(Matcher<String> matcher) {\n\t\texpect(hasMessage(matcher));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expect(Matcher<?> matcher) {\n\t\tif (fMatcher == null)\n\t\t\tfMatcher = matcher;\n\t\telse\n\t\t\tfMatcher = both(fMatcher).and(matches(matcher));\n\t}",
          "uniqueId": "a01928138beb41a189dc1fa43f92942b39393cbb_29_31_21_26_36_38"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "d5af0e46c1cd912ef0932ce868517b1e8335531e",
      "url": "https://github.com/junit-team/junit4/commit/d5af0e46c1cd912ef0932ce868517b1e8335531e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void expectMessage(String message) {\n\t\tfMessage= message;\n\t}",
          "sourceCodeAfterRefactoring": "public void expectMessage(String substring) {\n\t\texpectMessage(containsString(substring));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void expectMessage(Matcher<String> matcher) {\n\t\tfMatcher= hasMessage(matcher);\n\t}",
          "uniqueId": "d5af0e46c1cd912ef0932ce868517b1e8335531e_18_20_29_31_25_27"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5261a76c3014edc93f568ac76e8012d59dc2c831",
      "url": "https://github.com/junit-team/junit4/commit/5261a76c3014edc93f568ac76e8012d59dc2c831",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.collectInitializationErrors(errors);\n\t\t// TODO (May 18, 2009 10:44:37 PM): This misses superclasses\n\t\t// TODO (May 18, 2009 10:44:53 PM): duplication with below\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\tfor (Field each : fields) {\n\t\t\t// TODO (May 18, 2009 10:30:03 PM): validate, validate!\n\t\t\tvalidateField(each, errors);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tsuper.collectInitializationErrors(errors);\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\tvalidateField(each.getField(), errors);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<FrameworkField> interceptorFields() {\n\t\treturn getTestClass().getAnnotatedFields(Interceptor.class);\n\t}",
          "uniqueId": "5261a76c3014edc93f568ac76e8012d59dc2c831_20_31_59_61_21_26"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement intercept(Statement statement, Object target,\n\t\t\tFrameworkMethod method) {\n\t\tClass<?> javaClass= getTestClass().getJavaClass();\n\t\tStatement result= statement;\n\t\tField[] fields= javaClass.getFields();\n\t\tfor (Field each : fields) {\n\t\t\t// TODO (May 18, 2009 10:30:03 PM): validate, validate!\n\t\t\tif (each.getAnnotation(Interceptor.class) != null) {\n\t\t\t\ttry {\n\t\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t\t.get(target);\n\t\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement intercept(Statement statement, Object target,\n\t\t\tFrameworkMethod method) {\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t.get(target);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<FrameworkField> interceptorFields() {\n\t\treturn getTestClass().getAnnotatedFields(Interceptor.class);\n\t}",
          "uniqueId": "5261a76c3014edc93f568ac76e8012d59dc2c831_51_70_59_61_44_57"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1e54b68d2fe7c4238993b360c7be6fbb05d30528",
      "url": "https://github.com/junit-team/junit4/commit/1e54b68d2fe7c4238993b360c7be6fbb05d30528",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.collectInitializationErrors(errors);\n\t\t// TODO (May 18, 2009 10:44:37 PM): This misses superclasses\n\t\t// TODO (May 18, 2009 10:44:53 PM): duplication with below\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\tfor (Field each : fields) {\n\t\t\t// TODO (May 18, 2009 10:30:03 PM): validate, validate!\n\t\t\tvalidateField(each, errors);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tsuper.collectInitializationErrors(errors);\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\tvalidateField(each.getField(), errors);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<FrameworkField> interceptorFields() {\n\t\treturn getTestClass().getAnnotatedFields(Interceptor.class);\n\t}",
          "uniqueId": "1e54b68d2fe7c4238993b360c7be6fbb05d30528_20_31_59_61_21_26"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement intercept(Statement statement, Object target,\n\t\t\tFrameworkMethod method) {\n\t\tClass<?> javaClass= getTestClass().getJavaClass();\n\t\tStatement result= statement;\n\t\tField[] fields= javaClass.getFields();\n\t\tfor (Field each : fields) {\n\t\t\t// TODO (May 18, 2009 10:30:03 PM): validate, validate!\n\t\t\tif (each.getAnnotation(Interceptor.class) != null) {\n\t\t\t\ttry {\n\t\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t\t\t.get(target);\n\t\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "private Statement intercept(Statement statement, Object target,\n\t\t\tFrameworkMethod method) {\n\t\tStatement result= statement;\n\t\tfor (FrameworkField each : interceptorFields())\n\t\t\ttry {\n\t\t\t\tStatementInterceptor interceptor= (StatementInterceptor) each\n\t\t\t\t\t.get(target);\n\t\t\t\tresult= interceptor.intercept(result, method);\n\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"How did getFields return a field we couldn't access?\");\n\t\t\t}\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<FrameworkField> interceptorFields() {\n\t\treturn getTestClass().getAnnotatedFields(Interceptor.class);\n\t}",
          "uniqueId": "1e54b68d2fe7c4238993b360c7be6fbb05d30528_51_70_59_61_44_57"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "13bda470bfa1fe989ce80d616fb096af1b937146",
      "url": "https://github.com/junit-team/junit4/commit/13bda470bfa1fe989ce80d616fb096af1b937146",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n\t\treturn builder.runnerForClass(testClass);\n\t}",
          "sourceCodeAfterRefactoring": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n\t\treturn modify(builder.runnerForClass(testClass));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Runner modify(Runner runner) {\n\t\treturn runner;\n\t}",
          "uniqueId": "13bda470bfa1fe989ce80d616fb096af1b937146_22_24_22_24_26_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ad5971c88fb501f007cf1a75200349fb7cbb4b25",
      "url": "https://github.com/junit-team/junit4/commit/ad5971c88fb501f007cf1a75200349fb7cbb4b25",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n\t\treturn builder.runnerForClass(testClass);\n\t}",
          "sourceCodeAfterRefactoring": "protected Runner getRunner(RunnerBuilder builder, Class<?> testClass) throws Throwable {\n\t\treturn modify(builder.runnerForClass(testClass));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Runner modify(Runner runner) {\n\t\treturn runner;\n\t}",
          "uniqueId": "ad5971c88fb501f007cf1a75200349fb7cbb4b25_22_24_22_24_26_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6664bd272c43bcdf00f9ef9ce6f2d73af82036b1",
      "url": "https://github.com/junit-team/junit4/commit/6664bd272c43bcdf00f9ef9ce6f2d73af82036b1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t}",
          "sourceCodeAfterRefactoring": "private Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(getEffectiveClass(test), getName(test));\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Class<? extends Test> getEffectiveClass(Test test) {\n\t\t\t// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.\n\t\t\tif (\"warning\".equals(getName(test)))\n\t\t\t\ttry {\n\t\t\t\t\treturn (Class<? extends Test>) Class.forName(fTest.toString());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn test.getClass();\n\t\t\t\t}\n\t\t\treturn test.getClass();\n\t\t}",
          "uniqueId": "6664bd272c43bcdf00f9ef9ce6f2d73af82036b1_44_50_54_63_46_52"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6eb76c8b08c738823546fe5b935b653951fc773e",
      "url": "https://github.com/junit-team/junit4/commit/6eb76c8b08c738823546fe5b935b653951fc773e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(test.getClass(), getName(test));\n\t\t}",
          "sourceCodeAfterRefactoring": "private Description asDescription(Test test) {\n\t\t\tif (test instanceof Describable) {\n\t\t\t\tDescribable facade= (Describable) test;\n\t\t\t\treturn facade.getDescription();\n\t\t\t}\n\t\t\treturn Description.createTestDescription(getEffectiveClass(test), getName(test));\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Class<? extends Test> getEffectiveClass(Test test) {\n\t\t\t// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.\n\t\t\tif (\"warning\".equals(getName(test)))\n\t\t\t\ttry {\n\t\t\t\t\treturn (Class<? extends Test>) Class.forName(fTest.toString());\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\treturn test.getClass();\n\t\t\t\t}\n\t\t\treturn test.getClass();\n\t\t}",
          "uniqueId": "6eb76c8b08c738823546fe5b935b653951fc773e_44_50_54_63_46_52"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "90bf3119a6326671cc467386036302cc6040f752",
      "url": "https://github.com/junit-team/junit4/commit/90bf3119a6326671cc467386036302cc6040f752",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Class<?> parseClass() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\tif (matcher.matches())\n\t\t\ttry {\n\t\t\t\treturn Class.forName(matcher.group(2));\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// TODO (Nov 18, 2008 1:54:36 PM): something better\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\treturn null;\n\t}",
          "sourceCodeAfterRefactoring": "public Class<?> parseClass() {\n\t\tString name= getClassName();\n\t\tif (name == null)\n\t\t\treturn null;\n\t\ttry {\n\t\t\treturn Class.forName(name);\n\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t// TODO (Nov 18, 2008 1:54:36 PM): something better\n\t\t\te.printStackTrace();\n\t\t\treturn null;\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic String getClassName() {\n\t\tMatcher matcher= Pattern.compile(\"(.*)\\\\((.*)\\\\)\").matcher(toString());\n\t\treturn matcher.matches()\n\t\t\t? matcher.group(2)\n\t\t\t: null;\n\t}",
          "uniqueId": "90bf3119a6326671cc467386036302cc6040f752_201_211_215_220_202_213"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "421ab330509a53302f56b209595f55b23bfdfc0e",
      "url": "https://github.com/junit-team/junit4/commit/421ab330509a53302f56b209595f55b23bfdfc0e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(fTest);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Description getDescription() {\n\t\treturn makeDescription(getTest());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Test getTest() {\n\t\treturn fTest;\n\t}",
          "uniqueId": "421ab330509a53302f56b209595f55b23bfdfc0e_115_118_149_151_86_89"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (fTest instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) fTest;\n\t\t\tadapter.filter(filter);\n\t\t} else if (fTest instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) fTest;\n\t\t\tTestSuite filtered= new FilteredTestSuite(suite, filter);\n\t\t\tfTest= filtered;\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void filter(Filter filter) throws NoTestsRemainException {\n\t\tif (getTest() instanceof Filterable) {\n\t\t\tFilterable adapter= (Filterable) getTest();\n\t\t\tadapter.filter(filter);\n\t\t} else if (getTest() instanceof TestSuite) {\n\t\t\tTestSuite suite= (TestSuite) getTest();\n\t\t\tTestSuite filtered= new TestSuite(suite.getName());\n\t\t\tint n= suite.testCount();\n\t\t\tfor (int i= 0; i < n; i++) {\n\t\t\t\tTest test= suite.testAt(i);\n\t\t\t\tif (filter.shouldRun(makeDescription(test)))\n\t\t\t\t\tfiltered.addTest(test);\n\t\t\t}\n\t\t\tsetTest(filtered);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void setTest(Test test) {\n\t\tfTest = test;\n\t}",
          "uniqueId": "421ab330509a53302f56b209595f55b23bfdfc0e_144_153_145_147_121_136"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "41cbbf7e228b8f7908e672a79863ff970316b120",
      "url": "https://github.com/junit-team/junit4/commit/41cbbf7e228b8f7908e672a79863ff970316b120",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If\n\t * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,\n\t * they are considered equal.\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expecteds\n\t *            Object array or array of arrays (multi-dimensional array) with\n\t *            expected values.\n\t * @param actuals\n\t *            Object array or array of arrays (multi-dimensional array) with\n\t *            actual values\n\t */\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header= message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\"\n\t\t\t\t\t+ expectedsLength + \" actual.length=\" + actualsLength);\n\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If\n\t * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,\n\t * they are considered equal.\n\t * \n\t * @param message\n\t *            the identifying message for the {@link AssertionError} (<code>null</code>\n\t *            okay)\n\t * @param expecteds\n\t *            Object array or array of arrays (multi-dimensional array) with\n\t *            expected values.\n\t * @param actuals\n\t *            Object array or array of arrays (multi-dimensional array) with\n\t *            actual values\n\t */\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header= message == null ? \"\" : message + \": \";\n\t\tint expectedsLength= assertArraysAreSameLength(expecteds, actuals,\n\t\t\t\theader);\n\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\t// TODO (Nov 6, 2008 12:58:55 PM): Is this a DUP?\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static int assertArraysAreSameLength(Object expecteds,\n\t\t\tObject actuals, String header) {\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\"\n\t\t\t\t\t+ expectedsLength + \" actual.length=\" + actualsLength);\n\t\treturn expectedsLength;\n\t}",
          "uniqueId": "41cbbf7e228b8f7908e672a79863ff970316b120_336_384_413_425_368_410"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "df48b66e73c740acb15f065eb7a4bad433930891",
      "url": "https://github.com/junit-team/junit4/commit/df48b66e73c740acb15f065eb7a4bad433930891",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void run(Request request) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tputTestDuration(description, end - start);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\tcore.run(request);\n\t\ttry {\n\t\t\tsave();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tputTestDuration(description, end - start);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Request sortRequest(Request request) {\n\t\tif (request instanceof SortingRequest) { // We'll pay big karma points for this\n\t\t\treturn request;\n\t\t}\n\t\treturn request.sortWith(new TestComparator());\n\t}",
          "uniqueId": "df48b66e73c740acb15f065eb7a4bad433930891_72_105_115_120_78_113"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void run(Request request) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tputTestDuration(description, end - start);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\tcore.run(request);\n\t\ttry {\n\t\t\tsave();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void run(Request request) {\n\t\trun(request, new JUnitCore());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Result run(Request request, JUnitCore core) {\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tputTestDuration(description, end - start);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\ttry { \n\t\t\treturn core.run(sortRequest(request).getRunner());\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tsave();\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "df48b66e73c740acb15f065eb7a4bad433930891_72_105_78_113_74_76"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02",
      "url": "https://github.com/junit-team/junit4/commit/ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void run(Request request) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tfDurations.put(description, end - start);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tfFailures.put(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\tcore.run(request);\n\t}",
          "sourceCodeAfterRefactoring": "public void run(Request request) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tcore.addListener(new RunListener() {\n\t\t\tprivate Map<Description, Long> starts= new HashMap<Description, Long>();\n\n\t\t\t@Override\n\t\t\t\tpublic void testStarted(Description description) throws Exception {\n\t\t\t\tstarts.put(description, System.nanoTime()); // Get most accurate possible time\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void testFinished(Description description) throws Exception {\n\t\t\t\tlong end= System.nanoTime();\n\t\t\t\tlong start= starts.get(description);\n\t\t\t\tputTestDuration(description, end - start);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void testFailure(Failure failure) throws Exception {\n\t\t\t\tlong end= System.currentTimeMillis(); // This needs to be comparable across tests\n\t\t\t\tputTestFailureTimestamp(failure.getDescription(), end);\n\t\t\t}\n\t\t});\n\t\tcore.run(request);\n\t\ttry {\n\t\t\tsave();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO\n\t\t\te.printStackTrace();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void putTestDuration(Description description, long duration) {\n\t\tfDurations.put(description.toString(), duration);\n\t}",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_20_44_167_169_72_105"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Test public void preferNewTests() {\n\t\tRequest one= Request.method(TwoTests.class, \"succeed\");\n\t\tMaxCore max= new MaxCore();\n\t\tmax.run(one);\n\t\tRequest two= Request.aClass(TwoTests.class);\n\t\tList<Description> things= max.sort(two);\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertEquals(dontSucceed, things.get(0));\n\t\tassertEquals(2, things.size());\n\t}",
          "sourceCodeAfterRefactoring": "@Test public void preferNewTests() {\n\t\tRequest one= Request.method(TwoTests.class, \"succeed\");\n\t\tMaxCore max= MaxCore.createFresh();\n\t\tmax.run(one);\n\t\tRequest two= Request.aClass(TwoTests.class);\n\t\tList<Description> things= max.sort(two);\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertEquals(dontSucceed, things.get(0));\n\t\tassertEquals(2, things.size());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_33_42_55_57_36_45"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Test public void preferNewTestsOverTestsThatFailed() {\n\t\tRequest one= Request.method(TwoTests.class, \"dontSucceed\");\n\t\tMaxCore max= new MaxCore();\n\t\tmax.run(one);\n\t\tRequest two= Request.aClass(TwoTests.class);\n\t\tList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));\n\t\tassertEquals(2, things.size());\n\t}",
          "sourceCodeAfterRefactoring": "@Test public void preferNewTestsOverTestsThatFailed() {\n\t\tRequest one= Request.method(TwoTests.class, \"dontSucceed\");\n\t\tMaxCore max= MaxCore.createFresh();\n\t\tmax.run(one);\n\t\tRequest two= Request.aClass(TwoTests.class);\n\t\tList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));\n\t\tassertEquals(2, things.size());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_47_56_55_57_50_59"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Test public void preferRecentlyFailed() {\n\t\tRequest request= Request.aClass(TwoTests.class);\n\t\tMaxCore max= new MaxCore();\n\t\tmax.run(request);\n\t\tList<Description> tests= max.sort(request);\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertEquals(dontSucceed, tests.get(0));\n\t}",
          "sourceCodeAfterRefactoring": "@Test public void preferRecentlyFailed() {\n\t\tRequest request= Request.aClass(TwoTests.class);\n\t\tMaxCore max= MaxCore.createFresh();\n\t\tmax.run(request);\n\t\tList<Description> tests= max.sort(request);\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertEquals(dontSucceed, tests.get(0));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_58_65_55_57_61_68"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Test public void preferFast() {\n\t\tRequest request= Request.aClass(TwoUnEqualTests.class);\n\t\tMaxCore max= new MaxCore();\n\t\tmax.run(request);\n\t\tDescription thing= max.sort(request).get(1);\n\t\tassertEquals(Description.createTestDescription(TwoUnEqualTests.class, \"slow\"), thing);\n\t}",
          "sourceCodeAfterRefactoring": "@Test public void preferFast() {\n\t\tRequest request= Request.aClass(TwoUnEqualTests.class);\n\t\tMaxCore max= MaxCore.createFresh();\n\t\tmax.run(request);\n\t\tDescription thing= max.sort(request).get(1);\n\t\tassertEquals(Description.createTestDescription(TwoUnEqualTests.class, \"slow\"), thing);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_72_78_55_57_75_81"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Test public void twoTestsNotRun() {\n\t\tRequest request= Request.aClass(TwoTests.class);\n\t\tMaxCore max= new MaxCore();\n\t\tList<Description> things= max.sort(request);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertTrue(things.contains(succeed));\n\t\tassertTrue(things.contains(dontSucceed));\n\t\tassertEquals(2, things.size());\n\t}",
          "sourceCodeAfterRefactoring": "@Test public void twoTestsNotRunComeBackInRandomOrder() {\n\t\tRequest request= Request.aClass(TwoTests.class);\n\t\tMaxCore max= MaxCore.createFresh();\n\t\tList<Description> things= max.sort(request);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tDescription dontSucceed= Description.createTestDescription(TwoTests.class, \"dontSucceed\");\n\t\tassertTrue(things.contains(succeed));\n\t\tassertTrue(things.contains(dontSucceed));\n\t\tassertEquals(2, things.size());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nList<Description> things= max.sort(two);\n\t\tDescription succeed= Description.createTestDescription(TwoTests.class, \"succeed\");\n\t\tassertEquals(succeed, things.get(0));",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_22_31_55_57_25_34"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNew(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNew(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: fDurations.get(o1).compareTo(fDurations.get(o2));\n\t\t}",
          "sourceCodeAfterRefactoring": "public int compare(Description o1, Description o2) {\n\t\t\t// Always prefer new tests\n\t\t\tif (isNewTest(o1))\n\t\t\t\treturn -1;\n\t\t\tif (isNewTest(o2))\n\t\t\t\treturn 1;\n\t\t\t// Then most recently failed first\n\t\t\tint result= getFailure(o2).compareTo(getFailure(o1)); \n\t\t\treturn result != 0\n\t\t\t\t? result\n\t\t\t\t// Then shorter tests first\n\t\t\t\t: getTestDuration(o1).compareTo(getTestDuration(o2));\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Long getTestDuration(Description key) {\n\t\treturn fDurations.get(key.toString());\n\t}",
          "uniqueId": "ce7bda3346278aab6ccebedcd5b8c8d4ab27ba02_53_65_163_165_120_132"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "378e17964a4188bad9b3d966207a2f682072148e",
      "url": "https://github.com/junit-team/junit4/commit/378e17964a4188bad9b3d966207a2f682072148e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public List<Odds> getSpreads(Request request) {\n\t\tList<Description> leaves= findLeaves(request.getRunner().getDescription());\n\t\tCollections.sort(leaves, failureComparator());\n\t\tList<Odds> results= new ArrayList<Odds>();\n\t\tfor (Description leaf : leaves)\n\t\t\tresults.add(new Odds(leaf, 0.0));\n\t\treturn results;\n\t}",
          "sourceCodeAfterRefactoring": "public List<Odds> getSpreads(Request request) {\n\t\tList<Description> leaves= findLeaves(request);\n\t\tCollections.sort(leaves, failureComparator());\n\t\tList<Odds> results= new ArrayList<Odds>();\n\t\tfor (Description leaf : leaves)\n\t\t\tresults.add(new Odds(leaf, 0.0));\n\t\treturn results;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<Description> findLeaves(Request request) {\n\t\treturn findLeaves(request.getRunner().getDescription());\n\t}",
          "uniqueId": "378e17964a4188bad9b3d966207a2f682072148e_19_26_31_33_22_29"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "432e3e27df0b072f3bab066cd33214913f4c7f32",
      "url": "https://github.com/junit-team/junit4/commit/432e3e27df0b072f3bab066cd33214913f4c7f32",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Do not use. Testing purposes only.\n\t * @param system \n\t */\n\tpublic Result runMain(JUnitSystem system, String... args) {\n\t\tsystem.out().println(\"JUnit version \" + Version.id());\n\t\tList<Class<?>> classes= new ArrayList<Class<?>>();\n\t\tList<Failure> missingClasses= new ArrayList<Failure>();\n\t\tfor (String each : args)\n\t\t\ttry {\n\t\t\t\tclasses.add(Class.forName(each));\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tsystem.out().println(\"Could not find class: \" + each);\n\t\t\t\tDescription description= Description.createSuiteDescription(each);\n\t\t\t\tFailure failure= new Failure(description, e);\n\t\t\t\tmissingClasses.add(failure);\n\t\t\t}\n\t\tRunListener listener= new TextListener(system);\n\t\taddListener(listener);\n\t\tResult result= run(classes.toArray(new Class[0]));\n\t\tfor (Failure each : missingClasses)\n\t\t\tresult.getFailures().add(each);\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Do not use. Testing purposes only.\n\t * @param system \n\t */\n\tpublic Result runMain(JUnitSystem system, String... args) {\n\t\tsystem.out().println(\"JUnit version \" + Version.id());\n\t\tList<Class<?>> classes= new ArrayList<Class<?>>();\n\t\tList<Failure> missingClasses= new ArrayList<Failure>();\n\t\tfor (String each : args)\n\t\t\ttry {\n\t\t\t\tclasses.add(Class.forName(each));\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tsystem.out().println(\"Could not find class: \" + each);\n\t\t\t\tDescription description= Description.createSuiteDescription(each);\n\t\t\t\tFailure failure= new Failure(description, e);\n\t\t\t\tmissingClasses.add(failure);\n\t\t\t}\n\t\tRunListener listener= new TextListener(system);\n\t\taddListener(listener);\n\t\t// TODO too many Executioner creations\n\t\tResult result= run(new Executioner(), classes.toArray(new Class[0]));\n\t\tfor (Failure each : missingClasses)\n\t\t\tresult.getFailures().add(each);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Run all the tests in <code>classes</code>.\n\t * @param asdfasdf TODO\n\t * @param classes the classes containing tests\n\t * @return a {@link Result} describing the details of the test run and the failed tests.\n\t */\n\tpublic Result run(Executioner asdfasdf, Class<?>... classes) {\n\t\treturn run(Request.classes(asdfasdf, classes));\n\t}",
          "uniqueId": "432e3e27df0b072f3bab066cd33214913f4c7f32_69_92_124_132_81_105"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Run all the tests in <code>classes</code>.\n\t * @param classes the classes containing tests\n\t * @return a {@link Result} describing the details of the test run and the failed tests.\n\t */\n\tpublic Result run(Class<?>... classes) {\n\t\treturn run(Request.classes(classes));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Run all the tests in <code>classes</code>.\n\t * @param asdfasdf TODO\n\t * @param classes the classes containing tests\n\t * @return a {@link Result} describing the details of the test run and the failed tests.\n\t */\n\tpublic Result run(Class<?>... classes) {\n\t\treturn run(Request.classes(new Executioner(), classes));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Run all the tests in <code>classes</code>.\n\t * @param asdfasdf TODO\n\t * @param classes the classes containing tests\n\t * @return a {@link Result} describing the details of the test run and the failed tests.\n\t */\n\tpublic Result run(Executioner asdfasdf, Class<?>... classes) {\n\t\treturn run(Request.classes(asdfasdf, classes));\n\t}",
          "uniqueId": "432e3e27df0b072f3bab066cd33214913f4c7f32_101_108_124_132_114_122"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3dd6b9fca5ccbd02a4d1cb5c5b3c921e369662a0",
      "url": "https://github.com/junit-team/junit4/commit/3dd6b9fca5ccbd02a4d1cb5c5b3c921e369662a0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test public void constructorException() {\n\t\tJUnitCore core = new JUnitCore();\n\t\tResult result = core.run(new Class[] {FaultyConstructor.class});\n\t\tFailure failure = result.getFailures().get(0);\n\t\tassertEquals(\"Thrown during construction\", failure.getException().getMessage());\n\t}",
          "sourceCodeAfterRefactoring": "@Test\n\tpublic void constructorException() {\n\t\tString message= exceptionMessageFrom(FaultyConstructor.class);\n\t\tassertEquals(\"Thrown during construction\", message);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String exceptionMessageFrom(Class<?> testClass) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tResult result= core.run(testClass);\n\t\tFailure failure= result.getFailures().get(0);\n\t\tString message= failure.getException().getMessage();\n\t\treturn message;\n\t}",
          "uniqueId": "3dd6b9fca5ccbd02a4d1cb5c5b3c921e369662a0_26_31_60_66_43_47"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Test public void noRunnableMethods() {\n\t\tJUnitCore core = new JUnitCore();\n\t\tResult result = core.run(new Class[] {NoTests.class});\n\t\tFailure failure = result.getFailures().get(0);\n\t\tassertEquals(\"No runnable methods\", failure.getException().getMessage());\n\t}",
          "sourceCodeAfterRefactoring": "@Test\n\tpublic void noRunnableMethods() {\n\t\tassertEquals(\"No runnable methods\", exceptionMessageFrom(NoTests.class));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String exceptionMessageFrom(Class<?> testClass) {\n\t\tJUnitCore core= new JUnitCore();\n\t\tResult result= core.run(testClass);\n\t\tFailure failure= result.getFailures().get(0);\n\t\tString message= failure.getException().getMessage();\n\t\treturn message;\n\t}",
          "uniqueId": "3dd6b9fca5ccbd02a4d1cb5c5b3c921e369662a0_33_38_60_66_49_52"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "50b9c949876189d8c4871471ec346988e4ccae06",
      "url": "https://github.com/junit-team/junit4/commit/50b9c949876189d8c4871471ec346988e4ccae06",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Adds to {@code errors} if this method:\n\t * <ul>\n\t * <li>is not public, or\n\t * <li>takes parameters, or\n\t * <li>returns something other than void, or\n\t * <li>is static (given {@code isStatic is false}), or\n\t * <li>is not static (given {@code isStatic is true}).\n\t */\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Adds to {@code errors} if this method:\n\t * <ul>\n\t * <li>is not public, or\n\t * <li>takes parameters, or\n\t * <li>returns something other than void, or\n\t * <li>is static (given {@code isStatic is false}), or\n\t * <li>is not static (given {@code isStatic is true}).\n\t */\n\tpublic void validatePublicVoidNoArg(boolean isStatic, List<Throwable> errors) {\n\t\tvalidatePublicVoid(isStatic, errors);\n\t\tif (fMethod.getParameterTypes().length != 0)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should have no parameters\"));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void validatePublicVoid(boolean isStatic, List<Throwable> errors) {\n\t\tif (Modifier.isStatic(fMethod.getModifiers()) != isStatic) {\n\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName() + \"() \"\n\t\t\t\t\t+ state + \" be static\"));\n\t\t}\n\t\tif (!Modifier.isPublic(fMethod.getDeclaringClass().getModifiers()))\n\t\t\terrors.add(new Exception(\"Class \"\n\t\t\t\t\t+ fMethod.getDeclaringClass().getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (!Modifier.isPublic(fMethod.getModifiers()))\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be public\"));\n\t\tif (fMethod.getReturnType() != Void.TYPE)\n\t\t\terrors.add(new Exception(\"Method \" + fMethod.getName()\n\t\t\t\t\t+ \" should be void\"));\n\t}",
          "uniqueId": "50b9c949876189d8c4871471ec346988e4ccae06_56_84_72_88_56_70"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "095d3f8df0708f98d41f5894a892388b6985c44f",
      "url": "https://github.com/junit-team/junit4/commit/095d3f8df0708f98d41f5894a892388b6985c44f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Adds to {@code errors} if the class does not have exactly one public\n\t * constructor with no arguments.\n\t */\n\tprotected void validateConstructor(List<Throwable> errors) {\n\t\tConstructor<?>[] constructors= getTestClass().getJavaClass()\n\t\t\t\t.getConstructors();\n\t\tif (!(constructors.length == 1 && \n\t\t\t\tconstructors[0].getParameterTypes().length == 0)) {\n\t\t\tString gripe= \"Test class should have exactly one public zero-argument constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void validateConstructor(List<Throwable> errors) {\n\t\tvalidateOnlyOneConstructor(errors);\n\t\tvalidateZeroArgConstructor(errors);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Adds to {@code errors} if the test class's single constructor\n\t * takes parameters\n\t */\n\tprotected void validateZeroArgConstructor(List<Throwable> errors) {\n\t\tif (hasOneConstructor()\n\t\t\t\t&& !(getTestClass().getOnlyConstructor().getParameterTypes().length == 0)) {\n\t\t\tString gripe= \"Test class should have exactly one public zero-argument constructor\";\n\t\t\terrors.add(new Exception(gripe));\n\t\t}\n\t}",
          "uniqueId": "095d3f8df0708f98d41f5894a892388b6985c44f_116_128_127_137_115_118"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5d957024be0d1b181879d48b7915b3b8aad8f5d5",
      "url": "https://github.com/junit-team/junit4/commit/5d957024be0d1b181879d48b7915b3b8aad8f5d5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\t\n\t\tfor (Field each : fields)\n\t\t\tif (each.getAnnotation(DataPoint.class) != null && !Modifier.isStatic(each.getModifiers()))\n\t\t\t\terrors.add(new Error(\"DataPoint field \" + each.getName() + \" must be static\"));\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void collectInitializationErrors(List<Throwable> errors) {\n\t\tsuper.collectInitializationErrors(errors);\n\t\tvalidateDataPointFields(errors);\n\t\t// TODO: validate theory methods\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void validateDataPointFields(List<Throwable> errors) {\n\t\tField[] fields= getTestClass().getJavaClass().getDeclaredFields();\n\t\t\n\t\tfor (Field each : fields)\n\t\t\tif (each.getAnnotation(DataPoint.class) != null && !Modifier.isStatic(each.getModifiers()))\n\t\t\t\terrors.add(new Error(\"DataPoint field \" + each.getName() + \" must be static\"));\n\t}",
          "uniqueId": "5d957024be0d1b181879d48b7915b3b8aad8f5d5_27_34_34_40_27_32"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1fcd990f60518c941a44bae2596392021614a20b",
      "url": "https://github.com/junit-team/junit4/commit/1fcd990f60518c941a44bae2596392021614a20b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement classBlock(final RunNotifier notifier) {\n\t\tList<FrameworkMethod> befores= fTestClass\n\t\t\t\t.getAnnotatedMethods(BeforeClass.class);\n\t\tList<FrameworkMethod> afters= fTestClass\n\t\t\t\t.getAnnotatedMethods(AfterClass.class);\n\t\tStatement statement= runChildren(notifier);\n\t\tstatement= new RunBefores(statement, befores, null);\n\t\tstatement= new RunAfters(statement, afters, null);\n\t\treturn statement;\n\t}",
          "sourceCodeAfterRefactoring": "/** \n\t * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. \n\t * Here is an outline of the implementation:\n\t * <ul>\n\t * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>\n\t * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n\t * and superclasses before the previous step; if any throws an\n\t * Exception, stop execution and pass the exception on.\n\t * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n\t * and superclasses before any of the previous steps; all AfterClass methods are\n\t * always executed: exceptions thrown by previous steps are combined, if\n\t * necessary, with exceptions from AfterClass methods into a\n\t * {@link MultipleFailureException}.\n\t * </ul>\n\t * @param notifier\n\t * @return {@code Statement}\n\t */\n\tprotected Statement classBlock(final RunNotifier notifier) {\n\t\tStatement statement= childrenInvoker(notifier);\n\t\tstatement= withBeforeClasses(statement);\n\t\tstatement= withAfterClasses(statement);\n\t\treturn statement;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class\n\t * and superclasses before executing {@code statement}; if any throws an\n\t * Exception, stop execution and pass the exception on.\n\t */\n\tprotected Statement withBeforeClasses(Statement statement) {\n\t\tList<FrameworkMethod> befores= fTestClass\n\t\t.getAnnotatedMethods(BeforeClass.class);\n\t\tstatement= new RunBefores(statement, befores, null);\n\t\treturn statement;\n\t}",
          "uniqueId": "1fcd990f60518c941a44bae2596392021614a20b_84_93_120_130_96_118"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Statement classBlock(final RunNotifier notifier) {\n\t\tList<FrameworkMethod> befores= fTestClass\n\t\t\t\t.getAnnotatedMethods(BeforeClass.class);\n\t\tList<FrameworkMethod> afters= fTestClass\n\t\t\t\t.getAnnotatedMethods(AfterClass.class);\n\t\tStatement statement= runChildren(notifier);\n\t\tstatement= new RunBefores(statement, befores, null);\n\t\tstatement= new RunAfters(statement, afters, null);\n\t\treturn statement;\n\t}",
          "sourceCodeAfterRefactoring": "/** \n\t * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. \n\t * Here is an outline of the implementation:\n\t * <ul>\n\t * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>\n\t * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class\n\t * and superclasses before the previous step; if any throws an\n\t * Exception, stop execution and pass the exception on.\n\t * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class\n\t * and superclasses before any of the previous steps; all AfterClass methods are\n\t * always executed: exceptions thrown by previous steps are combined, if\n\t * necessary, with exceptions from AfterClass methods into a\n\t * {@link MultipleFailureException}.\n\t * </ul>\n\t * @param notifier\n\t * @return {@code Statement}\n\t */\n\tprotected Statement classBlock(final RunNotifier notifier) {\n\t\tStatement statement= childrenInvoker(notifier);\n\t\tstatement= withBeforeClasses(statement);\n\t\tstatement= withAfterClasses(statement);\n\t\treturn statement;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class\n\t * and superclasses before executing {@code statement}; all AfterClass methods are\n\t * always executed: exceptions thrown by previous steps are combined, if\n\t * necessary, with exceptions from AfterClass methods into a\n\t * {@link MultipleFailureException}.\n\t */\n\tprotected Statement withAfterClasses(Statement statement) {\n\t\tList<FrameworkMethod> afters= fTestClass\n\t\t.getAnnotatedMethods(AfterClass.class);\n\t\tstatement= new RunAfters(statement, afters, null);\n\t\treturn statement;\n\t}",
          "uniqueId": "1fcd990f60518c941a44bae2596392021614a20b_84_93_132_144_96_118"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "c96215c5d025336d8ab1d7d2ab57daee20869cea",
      "url": "https://github.com/junit-team/junit4/commit/c96215c5d025336d8ab1d7d2ab57daee20869cea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addToAnnotationLists(FrameworkMethod testMethod) {\n\t\tfor (Annotation each : testMethod.getMethod().getAnnotations())\n\t\t\taddToAnnotationList(each.annotationType(), testMethod);\n\t}",
          "sourceCodeAfterRefactoring": "private void addToAnnotationLists(FrameworkMethod testMethod) {\n\t\tfor (Annotation each : computeAnnotations(testMethod))\n\t\t\taddToAnnotationList(each.annotationType(), testMethod);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Annotation[] computeAnnotations(FrameworkMethod testMethod) {\n\t\treturn testMethod.getMethod().getAnnotations();\n\t}",
          "uniqueId": "c96215c5d025336d8ab1d7d2ab57daee20869cea_35_38_41_43_36_39"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8e3f361443ddf8bca21c3db661c75d374fe78dba",
      "url": "https://github.com/junit-team/junit4/commit/8e3f361443ddf8bca21c3db661c75d374fe78dba",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\tEachTestNotifier eachNotifier= new EachTestNotifier(notifier,\n\t\t\t\tdescription);\n\t\tnotifying(method, childBlock(method)).run(eachNotifier);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tprotected void runChild(FrameworkMethod method, RunNotifier notifier) {\n\t\tEachTestNotifier eachNotifier= makeNotifier(method, notifier);\n\t\tif (method.isIgnored()) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\teachNotifier.fireTestStarted();\n\t\ttry {\n\t\t\tchildBlock(method).evaluate();\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\teachNotifier.fireTestIgnored();\n\t\t} catch (Throwable e) {\n\t\t\teachNotifier.addFailure(e);\n\t\t} finally {\n\t\t\teachNotifier.fireTestFinished();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate EachTestNotifier makeNotifier(FrameworkMethod method,\n\t\t\tRunNotifier notifier) {\n\t\tDescription description= describeChild(method);\n\t\treturn new EachTestNotifier(notifier,\n\t\t\t\tdescription);\n\t}",
          "uniqueId": "8e3f361443ddf8bca21c3db661c75d374fe78dba_82_88_142_147_81_99"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "078e45bd31a9920e00633ad6ce658e22529304f2",
      "url": "https://github.com/junit-team/junit4/commit/078e45bd31a9920e00633ad6ce658e22529304f2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected List<FrameworkMethod> getChildren() {\n\t\treturn fTestMethods;\n\t}",
          "sourceCodeAfterRefactoring": "protected String getName() {\n\t\treturn getTestClass().getName();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected TestClass getTestClass() {\n\t\treturn fTestClass;\n\t}",
          "uniqueId": "078e45bd31a9920e00633ad6ce658e22529304f2_101_104_144_146_79_81"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "37a611801fbea6ecc9b6356d9616e761c8b59b91",
      "url": "https://github.com/junit-team/junit4/commit/37a611801fbea6ecc9b6356d9616e761c8b59b91",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static String join(String delimiter,\n\t\t\tCollection<Object> values) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tIterator<Object> iter = values.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tObject next = iter.next();\n\t\t\tbuffer.append(String.valueOf(next));\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tbuffer.append(delimiter);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}",
          "sourceCodeAfterRefactoring": "public static String join(String delimiter,\n\t\t\tCollection<Object> values) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tIterator<Object> iter = values.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tObject next = iter.next();\n\t\t\tbuffer.append(stringValueOf(next));\n\t\t\tif (iter.hasNext()) {\n\t\t\t\tbuffer.append(delimiter);\n\t\t\t}\n\t\t}\n\t\treturn buffer.toString();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static String stringValueOf(Object next) {\n\t\ttry {\n\t\t\treturn String.valueOf(next);\n\t\t} catch (Throwable e) {\n\t\t\treturn \"[toString failed]\";\n\t\t}\n\t}",
          "uniqueId": "37a611801fbea6ecc9b6356d9616e761c8b59b91_28_40_42_48_28_40"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5042f695491027730cca2918616399d869de3973",
      "url": "https://github.com/junit-team/junit4/commit/5042f695491027730cca2918616399d869de3973",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptArrayType(type) && field.getAnnotation(DataPoints.class) != null) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t} else if (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: (Jan 25, 2008 8:32:47 AM) extract these\n\n\t\tfor (FrameworkMethod dataPointMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoint.class))\n\t\t\tif ((dataPointMethod.getParameterTypes().length == 0 && sig\n\t\t\t\t\t.getType()\n\t\t\t\t\t.isAssignableFrom(dataPointMethod.getReturnType())))\n\t\t\t\tlist.add(new MethodParameterValue(dataPointMethod.getMethod()));\n\n\t\tfor (FrameworkMethod dataPointsMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoints.class))\n\t\t\ttry {\n\t\t\t\taddArrayValues(list, dataPointsMethod.invokeExplosively(null));\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// ignore and move on\n\t\t\t}\n\n\t\treturn list;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\n\t\taddFields(sig, list);\n\t\taddSinglePointMethods(sig, list);\n\t\taddMultiPointMethods(list);\n\n\t\treturn list;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addMultiPointMethods(List<PotentialAssignment> list) {\n\t\tfor (FrameworkMethod dataPointsMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoints.class))\n\t\t\ttry {\n\t\t\t\taddArrayValues(list, dataPointsMethod.invokeExplosively(null));\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// ignore and move on\n\t\t\t}\n\t}",
          "uniqueId": "5042f695491027730cca2918616399d869de3973_53_86_64_72_53_62"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptArrayType(type) && field.getAnnotation(DataPoints.class) != null) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t} else if (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: (Jan 25, 2008 8:32:47 AM) extract these\n\n\t\tfor (FrameworkMethod dataPointMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoint.class))\n\t\t\tif ((dataPointMethod.getParameterTypes().length == 0 && sig\n\t\t\t\t\t.getType()\n\t\t\t\t\t.isAssignableFrom(dataPointMethod.getReturnType())))\n\t\t\t\tlist.add(new MethodParameterValue(dataPointMethod.getMethod()));\n\n\t\tfor (FrameworkMethod dataPointsMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoints.class))\n\t\t\ttry {\n\t\t\t\taddArrayValues(list, dataPointsMethod.invokeExplosively(null));\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// ignore and move on\n\t\t\t}\n\n\t\treturn list;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\n\t\taddFields(sig, list);\n\t\taddSinglePointMethods(sig, list);\n\t\taddMultiPointMethods(list);\n\n\t\treturn list;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addSinglePointMethods(ParameterSignature sig,\n\t\t\tList<PotentialAssignment> list) {\n\t\tfor (FrameworkMethod dataPointMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoint.class)) {\n\t\t\tClass<?> type= sig.getType();\n\t\t\tif ((dataPointMethod.producesType(type)))\n\t\t\t\tlist.add(new MethodParameterValue(dataPointMethod.getMethod()));\n\t\t}\n\t}",
          "uniqueId": "5042f695491027730cca2918616399d869de3973_53_86_74_82_53_62"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptArrayType(type) && field.getAnnotation(DataPoints.class) != null) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t} else if (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// TODO: (Jan 25, 2008 8:32:47 AM) extract these\n\n\t\tfor (FrameworkMethod dataPointMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoint.class))\n\t\t\tif ((dataPointMethod.getParameterTypes().length == 0 && sig\n\t\t\t\t\t.getType()\n\t\t\t\t\t.isAssignableFrom(dataPointMethod.getReturnType())))\n\t\t\t\tlist.add(new MethodParameterValue(dataPointMethod.getMethod()));\n\n\t\tfor (FrameworkMethod dataPointsMethod : fClass\n\t\t\t\t.getAnnotatedMethods(DataPoints.class))\n\t\t\ttry {\n\t\t\t\taddArrayValues(list, dataPointsMethod.invokeExplosively(null));\n\t\t\t} catch (Throwable e) {\n\t\t\t\t// ignore and move on\n\t\t\t}\n\n\t\treturn list;\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\n\t\taddFields(sig, list);\n\t\taddSinglePointMethods(sig, list);\n\t\taddMultiPointMethods(list);\n\n\t\treturn list;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addFields(ParameterSignature sig,\n\t\t\tList<PotentialAssignment> list) {\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptArrayType(type)\n\t\t\t\t\t\t&& field.getAnnotation(DataPoints.class) != null) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t} else if (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "5042f695491027730cca2918616399d869de3973_53_86_84_98_53_62"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "cde32fb62ad8f5a05d700ce3189e131fa51739cb",
      "url": "https://github.com/junit-team/junit4/commit/cde32fb62ad8f5a05d700ce3189e131fa51739cb",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tsuper(klass);\n\t\tfTestMethods= computeTestMethods();\n\t\tvalidate();\n\t}",
          "sourceCodeAfterRefactoring": "public JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tthis(new TestClass(klass));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic JUnit4ClassRunner(TestClass testClass) throws InitializationError {\n\t\tsuper(testClass);\n\t\tfTestMethods= computeTestMethods();\n\t\tvalidate();\n\t}",
          "uniqueId": "cde32fb62ad8f5a05d700ce3189e131fa51739cb_28_32_33_37_29_31"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ParentRunner(Class<?> testClass) {\n\t\tfTestClass = new TestClass(testClass);\n\t}",
          "sourceCodeAfterRefactoring": "public ParentRunner(Class<?> testClass) {\n\t\tthis(new TestClass(testClass));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ParentRunner(TestClass testClass) {\n\t\tfTestClass = testClass;\n\t}",
          "uniqueId": "cde32fb62ad8f5a05d700ce3189e131fa51739cb_31_33_35_37_31_33"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "b8008562db24f9189b90dd0e3864a381681d527f",
      "url": "https://github.com/junit-team/junit4/commit/b8008562db24f9189b90dd0e3864a381681d527f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<Runner> runners(Class<?> klass, Class<?>[] annotatedClasses)\n\t\t\t\tthrows InitializationError {\n\t\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\t\taddParent(klass);\n\t\t\t\n\t\t\ttry {\n\t\t\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\t\t\tif (childRunner != null)\n\t\t\t\t\t\trunners.add(childRunner);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tremoveParent(klass);\n\t\t\t}\n\t\t\treturn runners;\n\t\t}",
          "sourceCodeAfterRefactoring": "private List<Runner> runners(Class<?> parent, Class<?>[] children)\n\t\t\t\tthrows InitializationError {\n\t\t\taddParent(parent);\n\t\t\t\n\t\t\ttry {\n\t\t\t\treturn runners(children);\n\t\t\t} finally {\n\t\t\t\tremoveParent(parent);\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<Runner> runners(Class<?>[] children) {\n\t\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\t\tfor (Class<?> each : children) {\n\t\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\t\tif (childRunner != null)\n\t\t\t\t\trunners.add(childRunner);\n\t\t\t}\n\t\t\treturn runners;\n\t\t}",
          "uniqueId": "b8008562db24f9189b90dd0e3864a381681d527f_62_77_59_67_48_57"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "95bd62b2ffd80394d1a17e9078a4d79478423030",
      "url": "https://github.com/junit-team/junit4/commit/95bd62b2ffd80394d1a17e9078a4d79478423030",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, klass.getName());\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tgetTestClass().validateStaticMethods(errors);\n\t\tgetTestClass().validateInstanceMethods(errors);\n\t\tassertValid(errors);\n\n\t\tfParameters= getParametersList();\n\n\t\tfor (int i = 0; i < fParameters.size(); i++)\n\t\t\t// TODO I almost finished deleting CompositeRunner.add(), but got hung up on this last invocation\n\t\t\tadd(new TestClassRunnerForParameters(klass, i));\n\t\t\n\t\tfConstructor= getTestClass().getOnlyConstructor();\n\t}",
          "sourceCodeAfterRefactoring": "private Parameterized(Class<?> klass, List<Object[]> parametersList) throws InitializationError {\n\t\tsuper(klass, runners(klass, parametersList));\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tnew TestClass(klass).validateStaticMethods(errors);\n\t\tnew TestClass(klass).validateInstanceMethods(errors);\n\t\tassertValid(errors);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static ArrayList<Runner> runners(Class<?> klass,\n\t\t\tList<Object[]> parametersList) throws InitializationError {\n\t\tArrayList<Runner> runners= new ArrayList<Runner>();\n\t\tfor (int i = 0; i < parametersList.size(); i++)\n\t\t\t// TODO: (Dec 11, 2007 10:08:16 PM) pass-through\n\t\t\trunners.add(new TestClassRunnerForParameters(klass, parametersList, i));\n\t\treturn runners;\n\t}",
          "uniqueId": "95bd62b2ffd80394d1a17e9078a4d79478423030_116_131_131_138_122_129"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Parameterized(Class<?> klass) throws Throwable {\n\t\tsuper(klass, klass.getName());\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tgetTestClass().validateStaticMethods(errors);\n\t\tgetTestClass().validateInstanceMethods(errors);\n\t\tassertValid(errors);\n\n\t\tfParameters= getParametersList();\n\n\t\tfor (int i = 0; i < fParameters.size(); i++)\n\t\t\t// TODO I almost finished deleting CompositeRunner.add(), but got hung up on this last invocation\n\t\t\tadd(new TestClassRunnerForParameters(klass, i));\n\t\t\n\t\tfConstructor= getTestClass().getOnlyConstructor();\n\t}",
          "sourceCodeAfterRefactoring": "public Parameterized(Class<?> klass) throws Throwable {\n\t\t// TODO: (Dec 11, 2007 10:06:16 PM) is this the only call?\n\t\tthis(klass, getParametersList(new TestClass(klass)));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Parameterized(Class<?> klass, List<Object[]> parametersList) throws InitializationError {\n\t\tsuper(klass, runners(klass, parametersList));\n\n\t\tList<Throwable> errors= new ArrayList<Throwable>();\n\t\tnew TestClass(klass).validateStaticMethods(errors);\n\t\tnew TestClass(klass).validateInstanceMethods(errors);\n\t\tassertValid(errors);\n\t}",
          "uniqueId": "95bd62b2ffd80394d1a17e9078a4d79478423030_116_131_122_129_115_118"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "478900d7d7af563a3b75b6ca9d7d44e37e2aff5b",
      "url": "https://github.com/junit-team/junit4/commit/478900d7d7af563a3b75b6ca9d7d44e37e2aff5b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public CompositeRunner(String name) {\n\t\tthis(null, name);\n\t}",
          "sourceCodeAfterRefactoring": "public CompositeRunner(String name, List<Runner> runners) {\n\t\tthis(null, name, runners);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic CompositeRunner(Class<?> klass, String name, List<Runner> runners) {\n\t\tthis(klass, name);\n\t\tfRunners= runners;\n\t}",
          "uniqueId": "478900d7d7af563a3b75b6ca9d7d44e37e2aff5b_19_21_24_27_29_31"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "44fabd25eb7d8c5291094b033007c32b7a1b8da2",
      "url": "https://github.com/junit-team/junit4/commit/44fabd25eb7d8c5291094b033007c32b7a1b8da2",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement classBlock(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() {\n\t\t\t\tfor (T each : getFilteredChildren())\n\t\t\t\t\trunChild(each, notifier);\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "protected Statement classBlock(final RunNotifier notifier) {\n\t\tStatement statement= runChildren(notifier);\n\t\tstatement= new RunBefores(statement, fTestClass, null);\n\t\tstatement= new RunAfters(statement, fTestClass, null);\n\t\treturn statement;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Statement runChildren(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t@Override\n\t\t\tpublic void evaluate() {\n\t\t\t\tfor (T each : getFilteredChildren())\n\t\t\t\t\trunChild(each, notifier);\n\t\t\t}\n\t\t};\n\t}",
          "uniqueId": "44fabd25eb7d8c5291094b033007c32b7a1b8da2_49_57_49_57_59_64"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic void run(RunNotifier notifier) {\n\t\t\tfor (FrameworkMethod method : fTestMethods)\n\t\t\t\trunChild(method, notifier);\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tprotected Statement classBlock(RunNotifier notifier) {\n\t\t\treturn runChildren(notifier);\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n* \t\tassertEquals(fExpected, Fibonacci.compute(fInput));\n * \t}\n * }\n * </pre>\n * \n * <p>\n * Each instance of <code>FibonacciTest</code> will be constructed using the\n * two-argument constructor and the data values in the\n * <code>@Parameters</code> method.",
          "uniqueId": "44fabd25eb7d8c5291094b033007c32b7a1b8da2_100_104_49_57_101_104"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "a7c07de664a4562c3ff171102729f06a5f572d9b",
      "url": "https://github.com/junit-team/junit4/commit/a7c07de664a4562c3ff171102729f06a5f572d9b",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void printFailures(Result result) {\n\t\tif (result.getFailureCount() == 0)\n\t\t\treturn;\n\t\tif (result.getFailureCount() == 1)\n\t\t\tgetWriter().println(\"There was \" + result.getFailureCount() + \" failure:\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + result.getFailureCount() + \" failures:\");\n\t\tint i= 1;\n\t\tfor (Failure each : result.getFailures())\n\t\t\tprintFailure(each, i++);\n\t}",
          "sourceCodeAfterRefactoring": "protected void printFailures(Result result) {\n\t\tprintExceptions(\"failure\", \"\", result.getFailures());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void printExceptions(String exceptionTypeName, String listPrefix,\n\t\t\tList<? extends Failure> exceptions) {\n\t\tif (exceptions.size() == 0)\n\t\t\treturn;\n\t\tif (exceptions.size() == 1)\n\t\t\tgetWriter().println(\"There was \" + exceptions.size() + \" \" + exceptionTypeName + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + exceptions.size() + \" \" + exceptionTypeName + \"s:\");\n\t\tint i= 1;\n\t\tfor (Failure each : exceptions)\n\t\t\tprintFailure(each, listPrefix + i++);\n\t}",
          "uniqueId": "a7c07de664a4562c3ff171102729f06a5f572d9b_60_70_68_79_60_62"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void printIgnorances(Result result) {\n\t\t// TODO: (Dec 7, 2007 10:23:17 AM) DUP\n\n\t\tif (result.getIgnoreCount() == 0)\n\t\t\treturn;\n\t\tif (result.getIgnoreCount() == 1)\n\t\t\tgetWriter().println(\"There was \" + result.getIgnoreCount() + \" ignored test:\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + result.getIgnoreCount() + \" ignored tests:\");\n\t\tint i= 1;\n\t\tfor (Ignorance each : result.getIgnorances())\n\t\t\tprintFailure(each, i++);\n\t}",
          "sourceCodeAfterRefactoring": "private void printIgnorances(Result result) {\n\t\tprintExceptions(\"ignored test\", \"IGNORED TEST \", result.getIgnorances());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void printExceptions(String exceptionTypeName, String listPrefix,\n\t\t\tList<? extends Failure> exceptions) {\n\t\tif (exceptions.size() == 0)\n\t\t\treturn;\n\t\tif (exceptions.size() == 1)\n\t\t\tgetWriter().println(\"There was \" + exceptions.size() + \" \" + exceptionTypeName + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + exceptions.size() + \" \" + exceptionTypeName + \"s:\");\n\t\tint i= 1;\n\t\tfor (Failure each : exceptions)\n\t\t\tprintFailure(each, listPrefix + i++);\n\t}",
          "uniqueId": "a7c07de664a4562c3ff171102729f06a5f572d9b_72_84_68_79_64_66"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9",
      "url": "https://github.com/junit-team/junit4/commit/8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * @throws NoTestsRemainException \n\t */\n\tprotected T filterChild(T child, Filter filter) throws NoTestsRemainException {\n\t\treturn child;\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_104_109_85_98"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * @throws NoTestsRemainException \n\t */\n\tprotected T filterChild(T child, Filter filter) throws NoTestsRemainException {\n\t\treturn child;\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_104_109_85_98"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean shouldRun(T each) {\n\t\treturn fFilter == null || fFilter.shouldRun(describeChild(each));\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_119_121_85_98"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean shouldRun(T each) {\n\t\treturn fFilter == null || fFilter.shouldRun(describeChild(each));\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_119_121_85_98"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> getFilteredChildren() {\n\t\tif (fChildren == null)\n\t\t\tfChildren = computeFilteredChildren();\n\t\treturn fChildren;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_85_98_79_83"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "sourceCodeAfterRefactoring": "private List<T> getFilteredChildren() {\n\t\tif (fChildren == null)\n\t\t\tfChildren = computeFilteredChildren();\n\t\treturn fChildren;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<T> computeFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (shouldRun(each)) {\n\t\t\t\ttry {\n\t\t\t\t\tfiltered.add(sortChild(filterChild(each, fFilter), fSorter));\n\t\t\t\t} catch (NoTestsRemainException e) {\n\t\t\t\t\t// don't add it\n\t\t\t\t}\n\t\t\t}\n\t\tif (fSorter != null)\n\t\t\tCollections.sort(filtered, comparator());\n\t\treturn filtered;\n\t}",
          "uniqueId": "8226e3e64a7d4ace29eb08ab6c9fc9d4055f20c9_76_82_85_98_79_83"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "897fa2227e26f221e5efa4f95a805f7ff1ccac5f",
      "url": "https://github.com/junit-team/junit4/commit/897fa2227e26f221e5efa4f95a805f7ff1ccac5f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Statement classBlock(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void evaluate() {\n\t\t\t\t\t\tfor (T each : getChildren())\n\t\t\t\t\t\t\trunChild(each, notifier);\n\t\t\t\t\t}\n\t\t\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "private Statement classBlock(final RunNotifier notifier) {\n\t\treturn new Statement() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void evaluate() {\n\t\t\t\t\t\tfor (T each : getFilteredChildren())\n\t\t\t\t\t\t\trunChild(each, notifier);\n\t\t\t\t\t}\n\t\t\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate List<T> getFilteredChildren() {\n\t\tArrayList<T> filtered= new ArrayList<T>();\n\t\tfor (T each : getChildren())\n\t\t\tif (fFilter == null || fFilter.shouldRun(describeChild(each)))\n\t\t\t\tfiltered.add(each);\n\t\treturn filtered;\n\t}",
          "uniqueId": "897fa2227e26f221e5efa4f95a805f7ff1ccac5f_36_44_76_82_41_49"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "b9ce87013e5389857956d785d14fc4f3fc2490c3",
      "url": "https://github.com/junit-team/junit4/commit/b9ce87013e5389857956d785d14fc4f3fc2490c3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\tnew JUnit4ClassRunner(getTestClass().getJavaClass()) {\n\t\t\t\t@Override\n\t\t\t\tprotected void collectInitializationErrors(\n\t\t\t\t\t\tList<Throwable> errors) {\n\t\t\t\t\t// TODO: (Oct 12, 2007 12:08:03 PM) DUP\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Statement childBlock(FrameworkMethod method) {\n\t\t\t\t\t// TODO: (Oct 12, 2007 2:00:52 PM) Name this Link\n\t\t\t\t\tfinal Statement link= super.childBlock(method);\n\t\t\t\t\treturn new Statement() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlink.evaluate();\n\t\t\t\t\t\t\t\tsuccesses++;\n\t\t\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\t\t\thandleAssumptionViolation(e);\n\t\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\t\t// TODO: (Oct 12, 2007 2:04:01 PM) nullsOk\n\t\t\t\t\t\t\t\t// as argument to Assignments constructor\n\n\t\t\t\t\t\t\t\treportParameterizedError(e, complete\n\t\t\t\t\t\t\t\t\t\t.getAllArguments(nullsOk()));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected Statement invoke(FrameworkMethod method, Object test) {\n\t\t\t\t\t// TODO: (Oct 12, 2007 12:07:28 PM) push method in\n\t\t\t\t\treturn methodCompletesWithParameters(complete, test);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object createTest() throws Exception {\n\t\t\t\t\t// TODO: (Nov 26, 2007 8:44:14 PM) no matching data should\n\t\t\t\t\t// ignore\n\t\t\t\t\t// TODO: (Oct 12, 2007 12:31:12 PM) DUP\n\t\t\t\t\t// TODO: (Oct 12, 2007 12:40:33 PM) honor assumption\n\t\t\t\t\t// violations in JUnit4ClassRunner constructor\n\t\t\t\t\t// invocations\n\n\t\t\t\t\treturn getTestClass().getJavaClass().getConstructors()[0]\n\t\t\t\t\t\t\t.newInstance(complete\n\t\t\t\t\t\t\t\t\t.getConstructorArguments(nullsOk()));\n\t\t\t\t}\n\t\t\t}.childBlock(fTestMethod).evaluate();\n\t\t}",
          "sourceCodeAfterRefactoring": "protected void runWithCompleteAssignment(final Assignments complete)\n\t\t\t\tthrows InstantiationException, IllegalAccessException,\n\t\t\t\tInvocationTargetException, NoSuchMethodException, Throwable {\n\t\t\tnew JUnit4ClassRunner(getTestClass().getJavaClass()) {\n\t\t\t\t@Override\n\t\t\t\tprotected void collectInitializationErrors(\n\t\t\t\t\t\tList<Throwable> errors) {\n\t\t\t\t\t// do nothing\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Statement childBlock(FrameworkMethod method) {\n\t\t\t\t\tfinal Statement link= super.childBlock(method);\n\t\t\t\t\treturn new Statement() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void evaluate() throws Throwable {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tlink.evaluate();\n\t\t\t\t\t\t\t\thandleDataPointSuccess();\n\t\t\t\t\t\t\t} catch (AssumptionViolatedException e) {\n\t\t\t\t\t\t\t\thandleAssumptionViolation(e);\n\t\t\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\t\t\treportParameterizedError(e, complete\n\t\t\t\t\t\t\t\t\t\t.getAllArguments());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected Statement invoke(FrameworkMethod method, Object test) {\n\t\t\t\t\treturn methodCompletesWithParameters(method, complete, test);\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic Object createTest() throws Exception {\n\t\t\t\t\t// TODO: (Nov 26, 2007 8:44:14 PM) no matching data should\n\t\t\t\t\t// ignore\n\n\t\t\t\t\treturn getTestClass().getConstructor().newInstance(\n\t\t\t\t\t\t\tcomplete.getConstructorArguments(nullsOk()));\n\t\t\t\t}\n\t\t\t}.childBlock(fTestMethod).evaluate();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void handleDataPointSuccess() {\n\t\t\tsuccesses++;\n\t\t}",
          "uniqueId": "b9ce87013e5389857956d785d14fc4f3fc2490c3_85_141_181_183_93_137"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "36beacd221a4837af2a6d684b3a4fb79775a5231",
      "url": "https://github.com/junit-team/junit4/commit/36beacd221a4837af2a6d684b3a4fb79775a5231",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static ArrayList<ParameterSignature> signatures(Method method) {\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < method.getParameterTypes().length; i++) {\n\t\t\tsigs.add(new ParameterSignature(method.getParameterTypes()[i],\n\t\t\t\t\tmethod.getParameterAnnotations()[i]));\n\t\t}\n\t\treturn sigs;\n\t}",
          "sourceCodeAfterRefactoring": "public static ArrayList<ParameterSignature> signatures(Method method) {\n\t\treturn signatures(method.getParameterTypes(), method\n\t\t\t\t.getParameterAnnotations());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static ArrayList<ParameterSignature> signatures(\n\t\t\tClass<?>[] parameterTypes, Annotation[][] parameterAnnotations) {\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < parameterTypes.length; i++) {\n\t\t\tsigs.add(new ParameterSignature(parameterTypes[i],\n\t\t\t\t\tparameterAnnotations[i]));\n\t\t}\n\t\treturn sigs;\n\t}",
          "uniqueId": "36beacd221a4837af2a6d684b3a4fb79775a5231_15_22_24_32_14_17"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public static List<ParameterSignature> signatures(\n\t\t\tConstructor<?> constructor) {\n\t\t// TODO: (Oct 12, 2007 12:33:06 PM) handle DUP above\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < constructor.getParameterTypes().length; i++) {\n\t\t\tsigs.add(new ParameterSignature(constructor.getParameterTypes()[i],\n\t\t\t\t\tconstructor.getParameterAnnotations()[i]));\n\t\t}\n\t\treturn sigs;\n\t}",
          "sourceCodeAfterRefactoring": "public static List<ParameterSignature> signatures(Constructor<?> constructor) {\n\t\treturn signatures(constructor.getParameterTypes(), constructor\n\t\t\t\t.getParameterAnnotations());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static ArrayList<ParameterSignature> signatures(\n\t\t\tClass<?>[] parameterTypes, Annotation[][] parameterAnnotations) {\n\t\tArrayList<ParameterSignature> sigs= new ArrayList<ParameterSignature>();\n\t\tfor (int i= 0; i < parameterTypes.length; i++) {\n\t\t\tsigs.add(new ParameterSignature(parameterTypes[i],\n\t\t\t\t\tparameterAnnotations[i]));\n\t\t}\n\t\treturn sigs;\n\t}",
          "uniqueId": "36beacd221a4837af2a6d684b3a4fb79775a5231_25_34_24_32_19_22"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "2807ff63d6b408a927fd3dd684a42a2366677657",
      "url": "https://github.com/junit-team/junit4/commit/2807ff63d6b408a927fd3dd684a42a2366677657",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\treturn fConstructor.newInstance(fParameters.get(fParameterSetNumber));\n\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\tpublic Object createTest() throws Exception {\n\t\t\treturn fConstructor.newInstance(computeParams());\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Object[] computeParams() throws Exception {\n\t\t\ttry {\n\t\t\t\treturn fParameters.get(fParameterSetNumber);\n\t\t\t} catch (ClassCastException e) {\n\t\t\t\tthrow new Exception(String.format(\n\t\t\t\t\t\t\"%s.%s() must return a Collection of arrays.\",\n\t\t\t\t\t\tfTestClass.getName(), getParametersMethod().getName()));\t\t\t\t\n\t\t\t}\n\t\t}",
          "uniqueId": "2807ff63d6b408a927fd3dd684a42a2366677657_71_74_76_84_71_74"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "53e85db0bec2e03bf93afc73dced9b4a0b231644",
      "url": "https://github.com/junit-team/junit4/commit/53e85db0bec2e03bf93afc73dced9b4a0b231644",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public CompositeRunner(String name) {\n\t\tsuper(null);\n\t\tfName= name;\n\t}",
          "sourceCodeAfterRefactoring": "public CompositeRunner(String name) {\n\t\tthis(null, name);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic CompositeRunner(Class<?> type, String name) {\n\t\tsuper(type);\n\t\tfName = name;\n\t}",
          "uniqueId": "53e85db0bec2e03bf93afc73dced9b4a0b231644_23_26_27_30_23_25"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "0dbe9eefa369da78ca67bf5487797a8de5b2d631",
      "url": "https://github.com/junit-team/junit4/commit/0dbe9eefa369da78ca67bf5487797a8de5b2d631",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void runWithCompleteAssignment(final Assignments complete, final FailureListener listener)\n\t\t\t\tthrows Throwable {\n\t\t\tfinal Object freshInstance= createTest();\n\t\t\t// TODO: (Oct 10, 2007 12:30:46 PM) reuse chain method from above\n\n\t\t\tnew WithBeforeAndAfter(new Link() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run(FailureListener listener) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlistener.addFailure(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, fTestMethod, freshInstance).run(new FailureListener() {\n\t\t\t\t@Override\n\t\t\t\tprotected void handleFailure(Throwable error) {\n\t\t\t\t\tif (!(error instanceof CouldNotGenerateValueException))\n\t\t\t\t\t\tlistener.addFailure(error);\n\t\t\t\t}\n\t\t\t}); \n\t\t}",
          "sourceCodeAfterRefactoring": "protected void runWithCompleteAssignment(final Assignments complete) throws InstantiationException,\n\t\t\t\tIllegalAccessException, InvocationTargetException,\n\t\t\t\tNoSuchMethodException, Throwable {\n\t\t\ttry {\n\t\t\t\tfinal Object freshInstance= createTest();\n\t\t\t\twithAfters(fTestMethod, freshInstance, withBefores(fTestMethod, freshInstance, methodCompletesWithParameters(complete, freshInstance))).run();\n\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Link methodCompletesWithParameters(final Assignments complete,\n\t\t\t\tfinal Object freshInstance) {\n\t\t\treturn new Link() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() throws Throwable {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinvokeWithActualParameters(freshInstance, complete);\n\t\t\t\t\t} catch (CouldNotGenerateValueException e) {\n\t\t\t\t\t\t// ignore \n\t\t\t\t\t\t// TODO: (Oct 12, 2007 9:58:11 AM) Do I ignore this elsewhere?\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}",
          "uniqueId": "0dbe9eefa369da78ca67bf5487797a8de5b2d631_88_109_104_117_93_102"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "bd8a96dbbfe93f134f75c768e5c1254cff8a9e9f",
      "url": "https://github.com/junit-team/junit4/commit/bd8a96dbbfe93f134f75c768e5c1254cff8a9e9f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// ignore and move on\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic List<PotentialAssignment> getValueSources(ParameterSignature sig) {\n\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\tfor (final Field field : fClass.getFields()) {\n\t\t\tif (Modifier.isStatic(field.getModifiers())) {\n\t\t\t\tClass<?> type= field.getType();\n\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t.forValue(getStaticFieldValue(field)));\n\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\taddArrayValues(list, getStaticFieldValue(field));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (final Method method : fClass.getMethods()) {\n\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\tlist.add(new MethodParameterValue(method));\n\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\ttry {\n\t\t\t\t\taddArrayValues(list, method.invoke(null));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// ignore and move on\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Object getStaticFieldValue(final Field field) {\n\t\ttry {\n\t\t\treturn field.get(null);\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t} catch (IllegalAccessException e) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t}\n\t}",
          "uniqueId": "bd8a96dbbfe93f134f75c768e5c1254cff8a9e9f_76_127_89_99_51_80"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "44e7458b19d5cd1900a765a440c96e85b81d25fc",
      "url": "https://github.com/junit-team/junit4/commit/44e7458b19d5cd1900a765a440c96e85b81d25fc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Link chain(TestMethod method) {\n\t\t// TODO: (Oct 5, 2007 11:09:00 AM) Rename Link\n\n\t\tLink link= anchor(method);\n\t\tlink= handleExceptions(link, method);\n\t\tlink= timeout(link, method);\n\t\t// TODO: (Oct 8, 2007 10:45:34 AM) parallelize (make beforeAndAfter method)\n\t\t// TODO: (Oct 8, 2007 10:54:54 AM) sort methods\n\n\t\tlink= new BeforeAndAfter(link, method);\n\t\treturn notifier(link, method);\n\t}",
          "sourceCodeAfterRefactoring": "protected Link chain(TestMethod method) {\n\t\t// TODO: (Oct 5, 2007 11:09:00 AM) Rename Link\n\n\t\tLink link= invoke(method);\n\t\tlink= possiblyExpectingExceptions(method, link);\n\t\tlink= withPotentialTimeout(method, link);\n\t\tlink= withBeforeAndAfter(method, link);\n\t\treturn notifying(method, link);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Link withBeforeAndAfter(TestMethod method, Link link) {\n\t\tlink= new WithBeforeAndAfter(link, method);\n\t\treturn link;\n\t}",
          "uniqueId": "44e7458b19d5cd1900a765a440c96e85b81d25fc_173_184_139_142_112_120"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "43b0fe352d5bced0c341640d0c630d23f2022a7e",
      "url": "https://github.com/junit-team/junit4/commit/43b0fe352d5bced0c341640d0c630d23f2022a7e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected TestMethod wrapMethod(Method method) {\n\t\treturn new TestMethod(method, fTestClass);\n\t}",
          "sourceCodeAfterRefactoring": "protected JUnit4MethodRunner wrapMethod(Method method) {\n\t\treturn getMethodRunner(method);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected JUnit4MethodRunner getMethodRunner(Method method) {\n\t\treturn new JUnit4MethodRunner(method, fTestClass);\n\t}",
          "uniqueId": "43b0fe352d5bced0c341640d0c630d23f2022a7e_91_93_95_97_91_93"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "void run(Roadie context) {\n\t\tif (isIgnored()) {\n\t\t\tcontext.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\t\tcontext.fireTestStarted();\n\t\ttry {\n\t\t\tlong timeout= getTimeout();\n\t\t\tif (timeout > 0)\n\t\t\t\trunWithTimeout(context, timeout);\n\t\t\telse\n\t\t\t\trunTestProtected(context);\n\t\t} finally {\n\t\t\tcontext.fireTestFinished();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void runWithNotification(Roadie context) {\n\t\tif (fTestMethod.isIgnored()) {\n\t\t\tcontext.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\t\tcontext.fireTestStarted();\n\t\ttry {\n\t\t\trunInsideNotification(context);\n\t\t} finally {\n\t\t\tcontext.fireTestFinished();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void runWithPotentialTimeout(Roadie context) {\n\t\tlong timeout= fTestMethod.getTimeout();\n\t\tif (timeout > 0)\n\t\t\trunWithActualTimeout(context, timeout);\n\t\telse\n\t\t\trunInsidePotentialTimeout(context);\n\t}",
          "uniqueId": "43b0fe352d5bced0c341640d0c630d23f2022a7e_129_144_59_65_30_41"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "void run(Roadie context) {\n\t\tif (isIgnored()) {\n\t\t\tcontext.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\t\tcontext.fireTestStarted();\n\t\ttry {\n\t\t\tlong timeout= getTimeout();\n\t\t\tif (timeout > 0)\n\t\t\t\trunWithTimeout(context, timeout);\n\t\t\telse\n\t\t\t\trunTestProtected(context);\n\t\t} finally {\n\t\t\tcontext.fireTestFinished();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void run(Roadie context) {\n\t\trunWithNotification(context);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void runWithNotification(Roadie context) {\n\t\tif (fTestMethod.isIgnored()) {\n\t\t\tcontext.fireTestIgnored();\n\t\t\treturn;\n\t\t}\n\t\tcontext.fireTestStarted();\n\t\ttry {\n\t\t\trunInsideNotification(context);\n\t\t} finally {\n\t\t\tcontext.fireTestFinished();\n\t\t}\n\t}",
          "uniqueId": "43b0fe352d5bced0c341640d0c630d23f2022a7e_129_144_30_41_26_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13",
      "url": "https://github.com/junit-team/junit4/commit/787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public boolean canAcceptField(Field field) {\n\t\treturn type.isAssignableFrom(field.getType());\n\t}",
          "sourceCodeAfterRefactoring": "public boolean canAcceptArrayType(Class<?> type) {\n\t\treturn type.isArray() && canAcceptType(type.getComponentType());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic boolean canAcceptType(Class<?> candidate) {\n\t\treturn type.isAssignableFrom(candidate);\n\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_46_48_32_34_44_46"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "void invokeWithActualParameters(Object target, Object[] params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tfMethod.invoke(target, params);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow e.getTargetException();\n\t\t\t}\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t} catch (Throwable e) {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fMethod.getName(), params);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void invokeWithActualParameters(Object target, Object... params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\tinvokeAndThrow(target, params);\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\thandleAssumptionViolation(e);\n\t\t} catch (Throwable e) {\n\t\t\treportParameterizedError(e, params);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void invokeAndThrow(Object target, Object... params)\n\t\t\tthrows IllegalAccessException, Throwable {\n\t\ttry {\n\t\t\tgetMethod().invoke(target, params);\n\t\t\tsuccesses++;\n\t\t} catch (InvocationTargetException e) {\n\t\t\tthrow e.getTargetException();\n\t\t}\n\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_93_109_111_119_100_109"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "void invokeWithActualParameters(Object target, Object[] params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tfMethod.invoke(target, params);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow e.getTargetException();\n\t\t\t}\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t} catch (Throwable e) {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fMethod.getName(), params);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void invokeWithActualParameters(Object target, Object... params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\tinvokeAndThrow(target, params);\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\thandleAssumptionViolation(e);\n\t\t} catch (Throwable e) {\n\t\t\treportParameterizedError(e, params);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void handleAssumptionViolation(AssumptionViolatedException e) {\n\t\tfInvalidParameters.add(e);\n\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_93_109_121_123_100_109"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "void invokeWithActualParameters(Object target, Object[] params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\ttry {\n\t\t\t\tfMethod.invoke(target, params);\n\t\t\t\tsuccesses++;\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\tthrow e.getTargetException();\n\t\t\t}\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\tfInvalidParameters.add(e);\n\t\t} catch (Throwable e) {\n\t\t\tif (params.length == 0)\n\t\t\t\tthrow e;\n\t\t\tthrow new ParameterizedAssertionError(e, fMethod.getName(), params);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void invokeWithActualParameters(Object target, Object... params)\n\t\t\tthrows Throwable {\n\t\ttry {\n\t\t\tinvokeAndThrow(target, params);\n\t\t} catch (AssumptionViolatedException e) {\n\t\t\thandleAssumptionViolation(e);\n\t\t} catch (Throwable e) {\n\t\t\treportParameterizedError(e, params);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void reportParameterizedError(Throwable e, Object... params)\n\t\t\tthrows Throwable {\n\t\tif (params.length == 0)\n\t\t\tthrow e;\n\t\tthrow new ParameterizedAssertionError(e, getMethod().getName(), params);\n\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_93_109_125_130_100_109"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t// do nothing, just look for more values\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// ignore and move on\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_79_118_111_116_82_109"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t// do nothing, just look for more values\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}",
          "sourceCodeAfterRefactoring": "@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// ignore and move on\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_79_118_118_128_82_109"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static ParameterSupplier fieldParameterSupplier(final Class<?> targetClass) {\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t// do nothing, just look for more values\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// ignore and move on\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nthrow new RuntimeException(\n\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t} catch (IllegalAccessException e) {",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_77_120_36_38_79_130"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public static ParameterSupplier fieldParameterSupplier(final Class<?> targetClass) {\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialParameterValue> getValueSources(final Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialParameterValue> list= new ArrayList<PotentialParameterValue>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tif (sig.canAcceptField(field)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add(PotentialParameterValue.forValue(field.get(test)));\n\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif (method.getParameterTypes().length == 0\n\t\t\t\t\t\t\t&& sig.canAcceptMethod(method)) {\n\t\t\t\t\t\t\tlist.add(new PotentialParameterValue() {\n\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\tpublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\treturn method.invoke(test);\n\t\t\t\t\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: argument length is checked\");\n\t\t\t\t\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\t\t\t\t\"unexpected: getMethods returned an inaccessible method\");\n\t\t\t\t\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\t\t\t\t\tthrow new CouldNotGenerateValueException();\n\t\t\t\t\t\t\t\t\t// do nothing, just look for more values\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\t\t};\n\t}",
          "sourceCodeAfterRefactoring": "public ParameterSupplier fieldParameterSupplier() {\n\t\tfinal Class<? extends Object> targetClass= target.getClass();\n\t\treturn new ParameterSupplier() {\n\t\t\t@Override\n\t\t\tpublic List<PotentialAssignment> getValueSources(\n\t\t\t\t\tfinal Object test, ParameterSignature sig) {\n\t\t\t\tList<PotentialAssignment> list= new ArrayList<PotentialAssignment>();\n\t\t\t\tfor (final Field field : targetClass.getFields()) {\n\t\t\t\t\tClass<?> type= field.getType();\n\t\t\t\t\tif (sig.canAcceptType(type)) {\n\t\t\t\t\t\tlist.add(PotentialAssignment\n\t\t\t\t\t\t\t\t.forValue(getFieldValue(field, test)));\n\t\t\t\t\t} else if (sig.canAcceptArrayType(type)) {\n\t\t\t\t\t\taddArrayValues(list, getFieldValue(field, test));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (final Method method : targetClass.getMethods()) {\n\t\t\t\t\tif ((method.getParameterTypes().length == 0 && sig.getType()\n\t\t\t\t\t\t\t.isAssignableFrom(method.getReturnType()))\n\t\t\t\t\t\t\t&& method.isAnnotationPresent(DataPoint.class)) {\n\t\t\t\t\t\tlist.add(new MethodParameterValue(method, test));\n\t\t\t\t\t} else if (method.isAnnotationPresent(DataPoints.class)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\taddArrayValues(list, method.invoke(test));\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t// ignore and move on\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn list;\n\t\t\t}\n\n\t\t\tprivate void addArrayValues(List<PotentialAssignment> list,\n\t\t\t\t\tObject array) {\n\t\t\t\tfor (int i= 0; i < Array.getLength(array); i++)\n\t\t\t\t\tlist.add(PotentialAssignment.forValue(Array.get(array,\n\t\t\t\t\t\t\ti)));\n\t\t\t}\n\n\t\t\tprivate Object getFieldValue(final Field field, final Object object) {\n\t\t\t\ttry {\n\t\t\t\t\treturn field.get(object);\n\t\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: field from getClass doesn't exist on object\");\n\t\t\t\t} catch (IllegalAccessException e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\t\"unexpected: getFields returned an inaccessible field\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Object getValue() throws CouldNotGenerateValueException {\n\t\t\ttry {\n\t\t\t\treturn fMethod.invoke(fTest);",
          "uniqueId": "787ed4e5bc2b68e8b5cdb6190ff1fc053f1a5b13_77_120_32_34_79_130"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "7ce9e33e556cf1817d94f769e09c9d22b8d2764d",
      "url": "https://github.com/junit-team/junit4/commit/7ce9e33e556cf1817d94f769e09c9d22b8d2764d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void invoke(Roadie context) throws IllegalArgumentException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tfMethod.invoke(context.getTarget());\n\t}",
          "sourceCodeAfterRefactoring": "protected void invoke(Roadie context) throws IllegalArgumentException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tinvoke(context.getTarget());\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void invoke(Object target) throws IllegalAccessException,\n\t\t\tInvocationTargetException {\n\t\tfMethod.invoke(target);\n\t}",
          "uniqueId": "7ce9e33e556cf1817d94f769e09c9d22b8d2764d_68_71_73_76_68_71"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "7a2a3811a762d7988dc153d59c4222a6ab96bf82",
      "url": "https://github.com/junit-team/junit4/commit/7a2a3811a762d7988dc153d59c4222a6ab96bf82",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void runWithTimeout(long timeout) {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\tExecutorService service= Executors.newSingleThreadExecutor();\n\t\t\tCallable<Object> callable= new Callable<Object>() {\n\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\trunTestMethod();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t};\n\t\t\tFuture<Object> result= service.submit(callable);\n\t\t\tservice.shutdown();\n\t\t\ttry {\n\t\t\t\tboolean terminated= service.awaitTermination(timeout,\n\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\tif (!terminated)\n\t\t\t\t\tservice.shutdownNow();\n\t\t\t\tresult.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation\n\t\t\t} catch (TimeoutException e) {\n\t\t\t\taddFailure(new Exception(String.format(\"test timed out after %d milliseconds\", timeout)));\n\t\t\t} catch (Exception e) {\n\t\t\t\taddFailure(e);\n\t\t\t}\t\t\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void runWithTimeout(final long timeout) {\n\t\trunBeforesThenTestThenAfters(new Runnable() {\n\t\t\n\t\t\tpublic void run() {\n\t\t\t\tExecutorService service= Executors.newSingleThreadExecutor();\n\t\t\t\tCallable<Object> callable= new Callable<Object>() {\n\t\t\t\t\tpublic Object call() throws Exception {\n\t\t\t\t\t\trunTestMethod();\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tFuture<Object> result= service.submit(callable);\n\t\t\t\tservice.shutdown();\n\t\t\t\ttry {\n\t\t\t\t\tboolean terminated= service.awaitTermination(timeout,\n\t\t\t\t\t\t\tTimeUnit.MILLISECONDS);\n\t\t\t\t\tif (!terminated)\n\t\t\t\t\t\tservice.shutdownNow();\n\t\t\t\t\tresult.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation\n\t\t\t\t} catch (TimeoutException e) {\n\t\t\t\t\taddFailure(new Exception(String.format(\"test timed out after %d milliseconds\", timeout)));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\taddFailure(e);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void runBeforesThenTestThenAfters(Runnable test) {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\ttest.run();\n\t\t} catch (FailedBefore e) {\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"test should never throw an exception to this level\");\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\t\t\n\t}",
          "uniqueId": "7a2a3811a762d7988dc153d59c4222a6ab96bf82_48_75_84_94_48_74"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void runTest() {\n\t\t// TODO (Jul 2, 2007 4:54:13 PM):  duplicated in timeout branch?\n\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void runTest() {\n\t\trunBeforesThenTestThenAfters(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\trunTestMethod();\n\t\t\t}\n\t\t});\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic void runBeforesThenTestThenAfters(Runnable test) {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\ttest.run();\n\t\t} catch (FailedBefore e) {\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"test should never throw an exception to this level\");\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\t\t\n\t}",
          "uniqueId": "7a2a3811a762d7988dc153d59c4222a6ab96bf82_77_87_84_94_76_82"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "6acc164b4125da775cccd4035c1b99e9d404bacd",
      "url": "https://github.com/junit-team/junit4/commit/6acc164b4125da775cccd4035c1b99e9d404bacd",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tfTestClass= new TestClass(klass);\n\t\tfTestMethods= fTestClass.getTestMethods();\n\t\tvalidate();\n\t}",
          "sourceCodeAfterRefactoring": "public JUnit4ClassRunner(Class<?> klass) throws InitializationError {\n\t\tfTestClass= new TestClass(klass);\n\t\tfTestMethods= getTestMethods();\n\t\tvalidate();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected List<Method> getTestMethods() {\n\t\treturn fTestClass.getTestMethods();\n\t}",
          "uniqueId": "6acc164b4125da775cccd4035c1b99e9d404bacd_24_28_30_32_24_28"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f",
      "url": "https://github.com/junit-team/junit4/commit/521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tfor (Runner each : fRunners)\n\t\t\teach.run(notifier);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void run(RunNotifier notifier) {\n\t\trunChildren(notifier);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void runChildren(RunNotifier notifier) {\n\t\tfor (Runner each : fRunners)\n\t\t\teach.run(notifier);\n\t}",
          "uniqueId": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f_26_30_31_34_26_29"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\tsuper(addParent(klass), Request.classes(klass.getName(), annotatedClasses).getRunner());\n\t\tparents.remove(klass);\n\t}",
          "sourceCodeAfterRefactoring": "protected Suite(Class<?> klass, Class<?>[] annotatedClasses) throws InitializationError {\n\t\t// we need to add parent be\n\t\tsuper(klass.getName());\n\t\t\n\t\taddParent(klass);\n\t\tfor (Class<?> each : annotatedClasses) {\n\t\t\tRunner childRunner= Request.aClass(each).getRunner();\n\t\t\tif (childRunner != null)\n\t\t\t\tadd(childRunner);\n\t\t}\n\t\tremoveParent(klass);\n\n\t\tfTestClass= new TestClass(klass);\n\t\tMethodValidator methodValidator= new MethodValidator(fTestClass);\n\t\tmethodValidator.validateStaticMethods();\n\t\tmethodValidator.assertValid();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void removeParent(Class<?> klass) {\n\t\tparents.remove(klass);\n\t}",
          "uniqueId": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f_50_53_73_75_49_65"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic void run(RunNotifier notifier) {\n\t\tif (fTestMethods.isEmpty())\n\t\t\tnotifier.testAborted(getDescription(), new Exception(\"No runnable methods\"));\n\t\tfor (Method method : fTestMethods)\n\t\t\tinvokeTestMethod(method, notifier);\n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic void run(final RunNotifier notifier) {\n\t\tnew ClassRoadie(notifier, fTestClass, getDescription(), new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\trunMethods(notifier);\n\t\t\t}\n\t\t}).runProtected();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void runMethods(final RunNotifier notifier) {\n\t\tfor (Method method : fTestMethods)\n\t\t\tinvokeTestMethod(method, notifier);\n\t}",
          "uniqueId": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f_30_36_44_47_35_42"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void runUnprotected() {\n\t\ttry {\n\t\t\texecuteMethodBody();\n\t\t\tif (expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + expectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + expectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void runTest() {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void runTestMethod() {\n\t\ttry {\n\t\t\tfMethod.invoke(fTest);\n\t\t\tif (fTestMethod.expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + fTestMethod.getExpectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!fTestMethod.expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (fTestMethod.isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + fTestMethod.getExpectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}",
          "uniqueId": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f_78_96_82_99_72_80"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tprotected void runUnprotected() {\n\t\ttry {\n\t\t\texecuteMethodBody();\n\t\t\tif (expectsException())\n\t\t\t\taddFailure(new AssertionError(\"Expected exception: \" + expectedException().getName()));\n\t\t} catch (InvocationTargetException e) {\n\t\t\tThrowable actual= e.getTargetException();\n\t\t\tif (!expectsException())\n\t\t\t\taddFailure(actual);\n\t\t\telse if (isUnexpected(actual)) {\n\t\t\t\tString message= \"Unexpected exception, expected<\" + expectedException().getName() + \"> but was<\"\n\t\t\t\t\t+ actual.getClass().getName() + \">\";\n\t\t\t\taddFailure(new Exception(message, actual));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\taddFailure(e);\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void runTest() {\n\t\ttry {\n\t\t\trunBefores();\n\t\t\trunTestMethod();\n\t\t} catch (FailedBefore e) {\n\t\t} finally {\n\t\t\trunAfters();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void runAfters() {\n\t\tList<Method> afters= fTestMethod.getAfters();\n\t\tfor (Method after : afters)\n\t\t\ttry {\n\t\t\t\tafter.invoke(fTest);\n\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\taddFailure(e.getTargetException());\n\t\t\t} catch (Throwable e) {\n\t\t\t\taddFailure(e); // Untested, but seems impossible\n\t\t\t}\n\t}",
          "uniqueId": "521fdb5aae536bd5055f6d0e4f09c5a7bdb5799f_78_96_115_125_72_80"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "a9482d75217d0ae1ad8220515ed22a9245a822fc",
      "url": "https://github.com/junit-team/junit4/commit/a9482d75217d0ae1ad8220515ed22a9245a822fc",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "@Override\n\tpublic Runner getRunner() {\n\t\tClass<? extends Runner> runnerClass= getRunnerClass(fTestClass);\n\t\ttry {\n\t\t\tConstructor<? extends Runner> constructor= runnerClass.getConstructor(Class.class); // TODO good error message if no such constructor\n\t\t\treturn constructor.newInstance(new Object[] { fTestClass });\n\t\t} catch (StackOverflowError e) {\n\t\t\tthrow new RuntimeException();\n\t\t} catch (Exception e) {\n\t\t\treturn Request.errorReport(fTestClass, e).getRunner();\n\t\t} \n\t}",
          "sourceCodeAfterRefactoring": "@Override\n\tpublic Runner getRunner() {\n\t\treturn buildRunner(getRunnerClass(fTestClass)); \n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic Runner buildRunner(Class<? extends Runner> runnerClass) {\n\t\ttry {\n\t\t\treturn runnerClass.getConstructor(Class.class).newInstance(new Object[] { fTestClass });\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tString simpleName= runnerClass.getSimpleName();\n\t\t\tInitializationError error= new InitializationError(String.format(\n\t\t\t\t\tCONSTRUCTOR_ERROR_FORMAT, simpleName, simpleName));\n\t\t\treturn Request.errorReport(fTestClass, error).getRunner();\n\t\t} catch (Exception e) {\n\t\t\treturn Request.errorReport(fTestClass, e).getRunner();\n\t\t}\n\t}",
          "uniqueId": "a9482d75217d0ae1ad8220515ed22a9245a822fc_26_37_31_42_26_29"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "071887a1353d6e34de306e93ef0a9818cf75fdea",
      "url": "https://github.com/junit-team/junit4/commit/071887a1353d6e34de306e93ef0a9818cf75fdea",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If <code>expecteds</code> and\n\t *  <code>actuals</code> are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values.\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (expected.getClass().isArray() && actual.getClass().isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If <code>expecteds</code> and\n\t *  <code>actuals</code> are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values.\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (isArray(expected) && isArray(actual)) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static boolean isArray(Object expected) {\n\t\treturn expected != null && expected.getClass().isArray();\n\t}",
          "uniqueId": "071887a1353d6e34de306e93ef0a9818cf75fdea_273_312_314_316_273_312"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3d7fee93ddc21a6e849c36d5ae58b37b3d189665",
      "url": "https://github.com/junit-team/junit4/commit/3d7fee93ddc21a6e849c36d5ae58b37b3d189665",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two objects are equal. If they are not, an {@link AssertionError} \n\t * is thrown with the given message. If <code>expected</code> and <code>actual</code>\n\t * are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && expected.equals(actual))\n\t\t\treturn;\n\t\telse if (expected instanceof String && actual instanceof String) {\n\t\t\tString cleanMessage= message == null ? \"\" : message;\n\t\t\tthrow new ComparisonFailure(cleanMessage, (String)expected, (String)actual);\n\t\t}\n\t\telse\n\t\t\tfailNotEquals(message, expected, actual);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two objects are equal. If they are not, an {@link AssertionError} \n\t * is thrown with the given message. If <code>expected</code> and <code>actual</code>\n\t * are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expected expected value\n\t * @param actual actual value\n\t */\n\tstatic public void assertEquals(String message, Object expected, Object actual) {\n\t\tif (expected == null && actual == null)\n\t\t\treturn;\n\t\tif (expected != null && isEquals(expected, actual))\n\t\t\treturn;\n\t\telse if (expected instanceof String && actual instanceof String) {\n\t\t\tString cleanMessage= message == null ? \"\" : message;\n\t\t\tthrow new ComparisonFailure(cleanMessage, (String)expected, (String)actual);\n\t\t}\n\t\telse\n\t\t\tfailNotEquals(message, expected, actual);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate static boolean isEquals(Object expected, Object actual) {\n\t\tif (expected instanceof Number && actual instanceof Number)\n\t\t\treturn ((Number) expected).longValue() == ((Number) actual).longValue();\n\t\treturn expected.equals(actual);\n\t}",
          "uniqueId": "3d7fee93ddc21a6e849c36d5ae58b37b3d189665_79_98_102_106_81_100"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If <code>expecteds</code> and\n\t *  <code>actuals</code> are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values.\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(String message, Object[] expecteds, Object[] actuals) {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tif (actuals.length != expecteds.length)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expecteds.length + \" actual.length=\" + actuals.length);\n\n\t\tfor (int i= 0; i < expecteds.length; i++) {\n\t\t\tObject o1= expecteds[i];\n\t\t\tObject o2= actuals[i];\n\t\t\tif (o1.getClass().isArray() && o2.getClass().isArray()) {\n\t\t\t\tObject[] expected= (Object[]) o1;\n\t\t\t\tObject[] actual= (Object[]) o2;\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(o1, o2);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If <code>expecteds</code> and\n\t *  <code>actuals</code> are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values.\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertArrayEquals(String message, Object[] expecteds,\n\t\t\tObject[] actuals) throws ArrayComparisonFailure {\n\t\tinternalArrayEquals(message, expecteds, actuals);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Asserts that two object arrays are equal. If they are not, an\n\t * {@link AssertionError} is thrown with the given message. If <code>expecteds</code> and\n\t *  <code>actuals</code> are <code>null</code>, they are considered equal.\n\t * @param message the identifying message or <code>null</code> for the {@link AssertionError}\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values.\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tprivate static void internalArrayEquals(String message, Object expecteds,\n\t\t\tObject actuals) throws ArrayComparisonFailure {\n\t\tif (expecteds == actuals)\n\t\t\treturn;\n\t\tString header = message == null ? \"\" : message + \": \";\n\t\tif (expecteds == null)\n\t\t\tfail(header + \"expected array was null\");\n\t\tif (actuals == null)\n\t\t\tfail(header + \"actual array was null\");\n\t\tint actualsLength= Array.getLength(actuals);\n\t\tint expectedsLength= Array.getLength(expecteds);\n\t\tif (actualsLength != expectedsLength)\n\t\t\tfail(header + \"array lengths differed, expected.length=\" + expectedsLength + \" actual.length=\" + actualsLength);\n\t\n\t\tfor (int i= 0; i < expectedsLength; i++) {\n\t\t\tObject expected= Array.get(expecteds, i);\n\t\t\tObject actual= Array.get(actuals, i);\n\t\t\tif (expected.getClass().isArray() && actual.getClass().isArray()) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalArrayEquals(message, expected, actual);\n\t\t\t\t} catch (ArrayComparisonFailure e) {\n\t\t\t\t\te.addDimension(i);\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\ttry {\n\t\t\t\t\tassertEquals(expected, actual);\n\t\t\t\t} catch (AssertionError e) {\n\t\t\t\t\tthrow new ArrayComparisonFailure(header, e, i);\n\t\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "3d7fee93ddc21a6e849c36d5ae58b37b3d189665_111_149_273_312_119_130"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} \n\t * is thrown.  If <code>expected</code> and <code>actual</code> are <code>null</code>, \n\t * they are considered equal.\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertEquals(Object[] expecteds, Object[] actuals) {\n\t\tassertEquals(null, expecteds, actuals);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} \n\t * is thrown.  If <code>expected</code> and <code>actual</code> are <code>null</code>, \n\t * they are considered equal.\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t * @deprecated use assertArrayEquals\n\t */\n\t@Deprecated\n\tpublic static void assertEquals(Object[] expecteds, Object[] actuals) {\n\t\tassertArrayEquals(expecteds, actuals);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Asserts that two object arrays are equal. If they are not, an {@link AssertionError} \n\t * is thrown.  If <code>expected</code> and <code>actual</code> are <code>null</code>, \n\t * they are considered equal.\n\t * @param expecteds Object array or array of arrays (multi-dimensional array) with expected values\n\t * @param actuals Object array or array of arrays (multi-dimensional array) with actual values\n\t */\n\tpublic static void assertArrayEquals(Object[] expecteds, Object[] actuals) {\n\t\tassertArrayEquals(null, expecteds, actuals);\n\t}",
          "uniqueId": "3d7fee93ddc21a6e849c36d5ae58b37b3d189665_151_160_132_141_471_482"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "88f0fe3ced24506ddf9791f7a088163f4e7b1f20",
      "url": "https://github.com/junit-team/junit4/commit/88f0fe3ced24506ddf9791f7a088163f4e7b1f20",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected void invokeTestMethod(Method method, RunNotifier notifier) {\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= createTest();\n\t\t} catch (InvocationTargetException e) {\n\t\t\ttestAborted(notifier, methodDescription(method), e.getCause());\n\t\t\treturn;\t\t\t\n\t\t} catch (Exception e) {\n\t\t\ttestAborted(notifier, methodDescription(method), e);\n\t\t\treturn;\n\t\t}\n\t\tcreateMethodRunner(test, method, notifier).run();\n\t}",
          "sourceCodeAfterRefactoring": "protected void invokeTestMethod(Method method, RunNotifier notifier) {\n\t\tObject test;\n\t\ttry {\n\t\t\ttest= createTest();\n\t\t} catch (InvocationTargetException e) {\n\t\t\ttestAborted(notifier, method, e.getCause());\n\t\t\treturn;\n\t\t} catch (Throwable e) {\n\t\t\ttestAborted(notifier, method, e);\n\t\t\treturn;\n\t\t}\n\n\t\tTestMethod testMethod= new TestMethod(test, method,\n\t\t\t\tmethodDescription(method));\n\t\ttry {\n\t\t\tMethodRunner runner= testMethod.findCustomRunner(this);\n\t\t\tif (runner == null)\n\t\t\t\tcreateMethodRunner(test, method, notifier).run();\n\t\t\telse {\n\t\t\t\trunner.run(testMethod, notifier);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tThrowable exception= new RuntimeException(\n\t\t\t\t\t\"Exception creating custom method runner\", e);\n\t\t\ttestAborted(notifier, method, exception);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void testAborted(RunNotifier notifier, Method method,\n\t\t\tThrowable cause) {\n\t\ttestAborted(notifier, methodDescription(method), cause);\n\t}",
          "uniqueId": "88f0fe3ced24506ddf9791f7a088163f4e7b1f20_64_76_97_100_69_95"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "890b7b977e42360aa8975c8535fc66bfd8d8cb3e",
      "url": "https://github.com/junit-team/junit4/commit/890b7b977e42360aa8975c8535fc66bfd8d8cb3e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void validateTestMethods(Class<? extends Annotation> annotation,\n\t\t\tboolean isStatic) {\n\t\tList<Method> methods= fIntrospector.getTestMethods(annotation);\n\t\tfor (Method each : methods) {\n\t\t\tif (Modifier.isStatic(each.getModifiers()) != isStatic) {\n\t\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ state + \" be static\"));\n\t\t\t}\n\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (!Modifier.isPublic(each.getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (each.getReturnType() != Void.TYPE)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be void\"));\n\t\t\tif (each.getParameterTypes().length != 0)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should have no parameters\"));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private boolean runsAsStatic(Method method) {\n\t\treturn isStatic(method) && !(method.getParameterTypes().length == 1);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isStatic(Method method) {\n\t\treturn Modifier.isStatic(method.getModifiers());\n\t}",
          "uniqueId": "890b7b977e42360aa8975c8535fc66bfd8d8cb3e_59_81_95_97_91_93"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void validateTestMethods(Class<? extends Annotation> annotation,\n\t\t\tboolean isStatic) {\n\t\tList<Method> methods= fIntrospector.getTestMethods(annotation);\n\t\tfor (Method each : methods) {\n\t\t\tif (Modifier.isStatic(each.getModifiers()) != isStatic) {\n\t\t\t\tString state= isStatic ? \"should\" : \"should not\";\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ state + \" be static\"));\n\t\t\t}\n\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (!Modifier.isPublic(each.getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (each.getReturnType() != Void.TYPE)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be void\"));\n\t\t\tif (each.getParameterTypes().length != 0)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should have no parameters\"));\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "private void validateTestMethods(Class<? extends Annotation> annotation,\n\t\t\tboolean shouldBeStatic) {\n\t\tList<Method> methods= fIntrospector.getTestMethods(annotation);\n\t\tfor (Method each : methods) {\n\t\t\tif (shouldBeStatic && !isStatic(each))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ \"should be static\"));\n\t\t\tif (!shouldBeStatic && runsAsStatic(each))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName() + \"() \"\n\t\t\t\t\t\t+ \"should not be static\"));\n\t\t\tif (!Modifier.isPublic(each.getDeclaringClass().getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Class \" + each.getDeclaringClass().getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (!Modifier.isPublic(each.getModifiers()))\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be public\"));\n\t\t\tif (each.getReturnType() != Void.TYPE)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should be void\"));\n\t\t\tif (effectiveParameterCount(each, shouldBeStatic) != 0)\n\t\t\t\tfErrors.add(new Exception(\"Method \" + each.getName()\n\t\t\t\t\t\t+ \" should have no parameters\"));\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate boolean isStatic(Method method) {\n\t\treturn Modifier.isStatic(method.getModifiers());\n\t}",
          "uniqueId": "890b7b977e42360aa8975c8535fc66bfd8d8cb3e_59_81_95_97_59_82"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public List<Method> getTestMethods(Class<? extends Annotation> annotationClass) {\n\t\tList<Method> results= new ArrayList<Method>();\n\t\tfor (Class<?> eachClass : getSuperClasses(fTestClass)) {\n\t\t\tMethod[] methods= eachClass.getDeclaredMethods();\n\t\t\tfor (Method eachMethod : methods) {\n\t\t\t\tAnnotation annotation= eachMethod.getAnnotation(annotationClass);\n\t\t\t\tif (annotation != null && ! isShadowed(eachMethod, results)) \n\t\t\t\t\tresults.add(eachMethod);\n\t\t\t}\n\t\t}\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}",
          "sourceCodeAfterRefactoring": "public List<Method> getTestMethods(\n\t\t\tClass<? extends Annotation> annotationClass) {\n\t\tList<Method> results= new MethodCollector(annotationClass).addMethods(\n\t\t\t\tfTestClass).getMethods();\n\t\tif (runsTopToBottom(annotationClass))\n\t\t\tCollections.reverse(results);\n\t\treturn results;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic MethodCollector addMethods(Class<?> testClass) {\n\t\t\tfor (Method eachMethod : testClass.getDeclaredMethods()) {\n\t\t\t\tAnnotation annotation= eachMethod\n\t\t\t\t\t\t.getAnnotation(annotationClass);\n\t\t\t\tif (annotation != null && !isShadowed(eachMethod))\n\t\t\t\t\tmethods.add(eachMethod);\n\t\t\t}\n\t\t\t\n\t\t\taddSuperclasses(testClass);\t\t\t\n\t\t\taddMixins(testClass);\n\t\t\treturn this;\n\t\t}",
          "uniqueId": "890b7b977e42360aa8975c8535fc66bfd8d8cb3e_23_36_25_36_84_91"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "c3c1b5edd8053bbce99d954d4abc2361ead06fd5",
      "url": "https://github.com/junit-team/junit4/commit/c3c1b5edd8053bbce99d954d4abc2361ead06fd5",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void reset() {\n\t\tfError= false;\n\t\tsetForeground(getStatusColor());\n\t\tsetValue(0);\n\t}",
          "sourceCodeAfterRefactoring": "public void reset() {\n\t\tfError= false;\n\t\tupdateBarColor();\n\t\tsetValue(0);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void updateBarColor() {\n\t\tsetForeground(getStatusColor());\n\t}",
          "uniqueId": "c3c1b5edd8053bbce99d954d4abc2361ead06fd5_24_28_43_45_24_28"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void step(int value, boolean successful) {\n\t\tsetValue(value);\n\t\tif (!fError && !successful) {\n\t\t\tfError= true;\n\t\t\tsetForeground(getStatusColor());\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "public void step(int value, boolean successful) {\n\t\tsetValue(value);\n\t\tif (!fError && !successful) {\n\t\t\tfError= true;\n\t\t\tupdateBarColor();\n\t\t}\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void updateBarColor() {\n\t\tsetForeground(getStatusColor());\n\t}",
          "uniqueId": "c3c1b5edd8053bbce99d954d4abc2361ead06fd5_35_41_43_45_35_41"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "5d0898b619950ecadbb2365d055ec20706352049",
      "url": "https://github.com/junit-team/junit4/commit/5d0898b619950ecadbb2365d055ec20706352049",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "static private void failNotEquals(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\" \";\n\t\tfail(formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\");\n\t}",
          "sourceCodeAfterRefactoring": "static private void failNotEquals(String message, Object expected, Object actual) {\n\t\tfail(format(message, expected, actual));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nstatic String format(String message, Object expected, Object actual) {\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\" \";\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}",
          "uniqueId": "5d0898b619950ecadbb2365d055ec20706352049_281_286_285_290_281_283"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8c1784e4b026417ed381ac5f0a7e2dda9084d7b0",
      "url": "https://github.com/junit-team/junit4/commit/8c1784e4b026417ed381ac5f0a7e2dda9084d7b0",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Returns \"...\" in place of common prefix and \"...\" in\n\t * place of common suffix between expected and actual.\n\t * \n\t * @see java.lang.Throwable#getMessage()\n\t */\n\tpublic String getMessage() {\n\t\tString formatted= \"\";\n\t\tString message= super.getMessage();\n\t\t\n\t\tint end= Math.min(fExpected.length(), fActual.length());\n\t\t\n\t\tint i= 0;\n\t\tfor(; i < end; i++) {\n\t\t\tif (fExpected.charAt(i) != fActual.charAt(i))\n\t\t\t\tbreak;\n\t\t}\n\t\tint j= fExpected.length()-1;\n\t\tint k= fActual.length()-1;\n\t\tfor (; k >= i && j >= i; k--,j--) {\n\t\t\tif (fExpected.charAt(j) != fActual.charAt(k))\n\t\t\t\tbreak;\n\t\t}\n\t\tString actual, expected;\n\t\t\n\t\t// equal strings\n\t\tif (j < i && k < i) {\n\t\t\texpected= fExpected;\n\t\t\tactual= fActual;\n\t\t} else {\n\t\t\texpected= fExpected.substring(i, j+1);\n\t\t\tactual= fActual.substring(i, k+1);\n\t\t\tif (i <= end && i > 0) {\n\t\t\t\texpected= \"...\"+expected;\n\t\t\t\tactual= \"...\"+actual;\n\t\t\t}\n\t\t\t\n\t\t\tif (j < fExpected.length()-1)\n\t\t\t\texpected= expected+\"...\";\n\t\t\tif (k < fActual.length()-1)\n\t\t\t\tactual= actual+\"...\";\n\t\t}\t\n\t\tif (message != null)\n\t\t\tformatted= message+\": \";\t\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Returns \"...\" in place of common prefix and \"...\" in\n\t * place of common suffix between expected and actual.\n\t * \n\t * @see java.lang.Throwable#getMessage()\n\t */\n\tpublic String getMessage() {\n\t\tif (fExpected == null || fActual == null)\n\t\t\treturn format(fActual, fExpected);\n\t\t\t\n\t\tint end= Math.min(fExpected.length(), fActual.length());\n\t\t\n\t\tint i= 0;\n\t\tfor(; i < end; i++) {\n\t\t\tif (fExpected.charAt(i) != fActual.charAt(i))\n\t\t\t\tbreak;\n\t\t}\n\t\tint j= fExpected.length()-1;\n\t\tint k= fActual.length()-1;\n\t\tfor (; k >= i && j >= i; k--,j--) {\n\t\t\tif (fExpected.charAt(j) != fActual.charAt(k))\n\t\t\t\tbreak;\n\t\t}\n\t\tString actual, expected;\n\t\t\n\t\t// equal strings\n\t\tif (j < i && k < i) {\n\t\t\texpected= fExpected;\n\t\t\tactual= fActual;\n\t\t} else {\n\t\t\texpected= fExpected.substring(i, j+1);\n\t\t\tactual= fActual.substring(i, k+1);\n\t\t\tif (i <= end && i > 0) {\n\t\t\t\texpected= \"...\"+expected;\n\t\t\t\tactual= \"...\"+actual;\n\t\t\t}\n\t\t\t\n\t\t\tif (j < fExpected.length()-1)\n\t\t\t\texpected= expected+\"...\";\n\t\t\tif (k < fActual.length()-1)\n\t\t\t\tactual= actual+\"...\";\n\t\t}\t\n\t\treturn format(actual, expected);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate String format(String actual, String expected) {\n\t\tString message= super.getMessage();\n\t\tString formatted= \"\";\n\t\tif (message != null)\n\t\t\tformatted= message+\": \";\t\n\t\treturn formatted+\"expected:<\"+expected+\"> but was:<\"+actual+\">\";\n\t}",
          "uniqueId": "8c1784e4b026417ed381ac5f0a7e2dda9084d7b0_24_69_69_75_24_67"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "ebe724e4b925fca5c9aeb6f7e282a5f0ae132232",
      "url": "https://github.com/junit-team/junit4/commit/ebe724e4b925fca5c9aeb6f7e282a5f0ae132232",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Class load(String suiteClassName) throws ClassNotFoundException {\n\t\tTestCaseClassLoader loader= new TestCaseClassLoader();\n\t\treturn loader.loadClass(suiteClassName, true);\n\t}",
          "sourceCodeAfterRefactoring": "public Class load(String suiteClassName) throws ClassNotFoundException {\n\t\treturn createLoader().loadClass(suiteClassName, true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected TestCaseClassLoader createLoader() {\n\t\tTestCaseClassLoader loader= new TestCaseClassLoader();\n\t\tThread.currentThread().setContextClassLoader(loader);\n\t\treturn loader;\n\t}",
          "uniqueId": "ebe724e4b925fca5c9aeb6f7e282a5f0ae132232_7_10_16_20_8_10"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public Class reload(Class aClass) throws ClassNotFoundException {\n\t\tTestCaseClassLoader loader= new TestCaseClassLoader();\n\t\treturn loader.loadClass(aClass.getName(), true);\n\t}",
          "sourceCodeAfterRefactoring": "public Class reload(Class aClass) throws ClassNotFoundException {\n\t\treturn createLoader().loadClass(aClass.getName(), true);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected TestCaseClassLoader createLoader() {\n\t\tTestCaseClassLoader loader= new TestCaseClassLoader();\n\t\tThread.currentThread().setContextClassLoader(loader);\n\t\treturn loader;\n\t}",
          "uniqueId": "ebe724e4b925fca5c9aeb6f7e282a5f0ae132232_11_14_16_20_12_14"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "805855019d9ce016c997b3ea209e3e6baeb4639d",
      "url": "https://github.com/junit-team/junit4/commit/805855019d9ce016c997b3ea209e3e6baeb4639d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Constructs a TestRunner using the given stream for all the output\n\t */\n\tpublic TestRunner(PrintStream writer) {\n\t\tif (writer == null)\n\t\t\tthrow new IllegalArgumentException(\"Writer can't be null\");\n\t\tfPrinter= new ResultPrinter(writer);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Constructs a TestRunner using the given stream for all the output\n\t */\n\tpublic TestRunner(PrintStream writer) {\n\t\tthis(new ResultPrinter(writer));\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Constructs a TestRunner using the given ResultPrinter all the output\n\t */\n\tpublic TestRunner(ResultPrinter printer) {\n\t\tfPrinter= printer;\n\t}",
          "uniqueId": "805855019d9ce016c997b3ea209e3e6baeb4639d_41_48_49_54_42_47"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "3944908ba2c55a76382f51f46d0693803a8dd3f4",
      "url": "https://github.com/junit-team/junit4/commit/3944908ba2c55a76382f51f46d0693803a8dd3f4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Prints the errors to the standard output\n\t */\n\tpublic void printErrors(TestResult result) {\n\t    if (result.errorCount() != 0) {\n\t        if (result.errorCount() == 1)\n\t\t        getWriter().println(\"There was \"+result.errorCount()+\" error:\");\n\t        else\n\t\t        getWriter().println(\"There were \"+result.errorCount()+\" errors:\");\n\n\t\t\tint i= 1;\n\t\t\tfor (Enumeration e= result.errors(); e.hasMoreElements(); i++) {\n\t\t\t    TestFailure failure= (TestFailure)e.nextElement();\n\t\t\t\tgetWriter().println(i+\") \"+failure.failedTest());\n\t\t\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(failure.trace()));\n\t\t    }\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void printBooBoos(Enumeration booBoos, int count, String type) {\n\t\tif (count == 0) return;\n\t\tif (count == 1)\n\t\t\tgetWriter().println(\"There was \" + count + \" \" + type + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + count + \" \" + type + \"s:\");\n\t\tfor (int i= 1; booBoos.hasMoreElements(); i++) {\n\t\t\tprintBooBoo((TestFailure) booBoos.nextElement(), i);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void printBooBoo(TestFailure booBoo,int count) {\n\t\tgetWriter().print(count + \") \" + booBoo.failedTest());\n\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(booBoo.trace()));\n\t}",
          "uniqueId": "3944908ba2c55a76382f51f46d0693803a8dd3f4_47_64_79_82_68_77"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Prints the errors to the standard output\n\t */\n\tpublic void printErrors(TestResult result) {\n\t    if (result.errorCount() != 0) {\n\t        if (result.errorCount() == 1)\n\t\t        getWriter().println(\"There was \"+result.errorCount()+\" error:\");\n\t        else\n\t\t        getWriter().println(\"There were \"+result.errorCount()+\" errors:\");\n\n\t\t\tint i= 1;\n\t\t\tfor (Enumeration e= result.errors(); e.hasMoreElements(); i++) {\n\t\t\t    TestFailure failure= (TestFailure)e.nextElement();\n\t\t\t\tgetWriter().println(i+\") \"+failure.failedTest());\n\t\t\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(failure.trace()));\n\t\t    }\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void printErrors(TestResult result) {\n\t\tprintBooBoos(result.errors(), result.errorCount(), \"error\");\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void printBooBoos(Enumeration booBoos, int count, String type) {\n\t\tif (count == 0) return;\n\t\tif (count == 1)\n\t\t\tgetWriter().println(\"There was \" + count + \" \" + type + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + count + \" \" + type + \"s:\");\n\t\tfor (int i= 1; booBoos.hasMoreElements(); i++) {\n\t\t\tprintBooBoo((TestFailure) booBoos.nextElement(), i);\n\t\t}\n\t}",
          "uniqueId": "3944908ba2c55a76382f51f46d0693803a8dd3f4_47_64_68_77_60_62"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Prints failures to the standard output\n\t */\n\tpublic void printFailures(TestResult result) {\n\t\tif (result.failureCount() != 0) {\n\t\t\tif (result.failureCount() == 1)\n\t\t\t\tgetWriter().println(\"There was \" + result.failureCount() + \" failure:\");\n\t\t\telse\n\t\t\t\tgetWriter().println(\"There were \" + result.failureCount() + \" failures:\");\n\t\t\tint i = 1;\n\t\t\tfor (Enumeration e= result.failures(); e.hasMoreElements(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure) e.nextElement();\n\t\t\t\tgetWriter().print(i + \") \" + failure.failedTest());\n\t\t\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(failure.trace()));\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void printBooBoos(Enumeration booBoos, int count, String type) {\n\t\tif (count == 0) return;\n\t\tif (count == 1)\n\t\t\tgetWriter().println(\"There was \" + count + \" \" + type + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + count + \" \" + type + \"s:\");\n\t\tfor (int i= 1; booBoos.hasMoreElements(); i++) {\n\t\t\tprintBooBoo((TestFailure) booBoos.nextElement(), i);\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void printBooBoo(TestFailure booBoo,int count) {\n\t\tgetWriter().print(count + \") \" + booBoo.failedTest());\n\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(booBoo.trace()));\n\t}",
          "uniqueId": "3944908ba2c55a76382f51f46d0693803a8dd3f4_65_81_79_82_68_77"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Prints failures to the standard output\n\t */\n\tpublic void printFailures(TestResult result) {\n\t\tif (result.failureCount() != 0) {\n\t\t\tif (result.failureCount() == 1)\n\t\t\t\tgetWriter().println(\"There was \" + result.failureCount() + \" failure:\");\n\t\t\telse\n\t\t\t\tgetWriter().println(\"There were \" + result.failureCount() + \" failures:\");\n\t\t\tint i = 1;\n\t\t\tfor (Enumeration e= result.failures(); e.hasMoreElements(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure) e.nextElement();\n\t\t\t\tgetWriter().print(i + \") \" + failure.failedTest());\n\t\t\t\tgetWriter().print(BaseTestRunner.getFilteredTrace(failure.trace()));\n\t\t\t}\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "protected void printFailures(TestResult result) {\n\t\tprintBooBoos(result.failures(), result.failureCount(), \"failure\");\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void printBooBoos(Enumeration booBoos, int count, String type) {\n\t\tif (count == 0) return;\n\t\tif (count == 1)\n\t\t\tgetWriter().println(\"There was \" + count + \" \" + type + \":\");\n\t\telse\n\t\t\tgetWriter().println(\"There were \" + count + \" \" + type + \"s:\");\n\t\tfor (int i= 1; booBoos.hasMoreElements(); i++) {\n\t\t\tprintBooBoo((TestFailure) booBoos.nextElement(), i);\n\t\t}\n\t}",
          "uniqueId": "3944908ba2c55a76382f51f46d0693803a8dd3f4_65_81_68_77_64_66"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "9a866f6c679298e64194fbfa5ef82262a792824d",
      "url": "https://github.com/junit-team/junit4/commit/9a866f6c679298e64194fbfa5ef82262a792824d",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Runs a single test and collects its results.\n\t * This method can be used to start a test run\n\t * from your program.\n\t * <pre>\n\t * public static void main (String[] args) {\n\t *     test.textui.TestRunner.run(suite());\n\t * }\n\t * </pre>\n\t */\n\tstatic public TestResult run(Test suite) {\n\t\tTestRunner aTestRunner= new TestRunner();\n\t\treturn aTestRunner.doRun(suite, false);\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Runs a single test and collects its results.\n\t * This method can be used to start a test run\n\t * from your program.\n\t * <pre>\n\t * public static void main (String[] args) {\n\t *     test.textui.TestRunner.run(suite());\n\t * }\n\t * </pre>\n\t */\n\tstatic public TestResult run(Test test) {\n\t\tTestRunner runner= new TestRunner();\n\t\treturn runner.doRun(test);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic TestResult doRun(Test test) {\n\t\treturn doRun(test, false);\n\t}",
          "uniqueId": "9a866f6c679298e64194fbfa5ef82262a792824d_190_203_84_86_194_207"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "8c46dd2f3212fa331528fc92019d4f22abe2ffc1",
      "url": "https://github.com/junit-team/junit4/commit/8c46dd2f3212fa331528fc92019d4f22abe2ffc1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t//---- first section\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t//---- second section\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t//---- third section\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= new Panel(new FlowLayout());\n\t\tnumbersPanel.add(new Label(\"Runs:\"));\t\t\tnumbersPanel.add(fNumberOfRuns);\n\t\tnumbersPanel.add(new Label(\"   Errors:\"));\t\tnumbersPanel.add(fNumberOfErrors);\n\t\tnumbersPanel.add(new Label(\"   Failures:\"));\tnumbersPanel.add(fNumberOfFailures);\n\n\n\t\t//---- fourth section\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t//---- fifth section\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// ---------\n\t\tfLogo= new Logo();\n\n\t\t//---- overall layout\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.CENTER);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}",
          "sourceCodeAfterRefactoring": "protected Frame createUI(String suiteName) {\n\t\tFrame frame= new Frame(\"JUnit\");\n\t\tImage icon= loadFrameIcon();\n\t\tif (icon != null)\n\t\t\tframe.setIconImage(icon);\n\n\t\tframe.setLayout(new BorderLayout(0, 0));\n\t\tframe.setBackground(SystemColor.control);\n\t\tfinal Frame finalFrame= frame;\n\n\t\tframe.addWindowListener(\n\t\t\tnew WindowAdapter() {\n\t\t\t\tpublic void windowClosing(WindowEvent e) {\n\t\t\t\t\tfinalFrame.dispose();\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tMenuBar mb = new MenuBar();\n\t\tcreateMenus(mb);\n\t\tframe.setMenuBar(mb);\n\n\t\t//---- first section\n\t\tLabel suiteLabel= new Label(\"Test class name:\");\n\n\t\tfSuiteField= new TextField(suiteName != null ? suiteName : \"\");\n\t\tfSuiteField.selectAll();\n\t\tfSuiteField.requestFocus();\n\t\tfSuiteField.setFont(PLAIN_FONT);\n\t\tfSuiteField.setColumns(40);\n\t\tfSuiteField.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfSuiteField.addTextListener(\n\t\t\tnew TextListener() {\n\t\t\t\tpublic void textValueChanged(TextEvent e) {\n\t\t\t\t\tfRun.setEnabled(fSuiteField.getText().length() > 0);\n\t\t\t\t\tfStatusLine.setText(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRun= new Button(\"Run\");\n\t\tfRun.setEnabled(false);\n\t\tfRun.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trunSuite();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tboolean useLoader= useReloadingTestSuiteLoader();\n\t\tfUseLoadingRunner= new Checkbox(\"Reload classes every run\", useLoader);\n\t\tif (inVAJava())\n\t\t\tfUseLoadingRunner.setVisible(false);\n\n\t\t//---- second section\n\t\tfProgressIndicator= new ProgressBar();\n\n\t\t//---- third section\n\t\tfNumberOfErrors= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfErrors.setText(\"0\");\n\t\tfNumberOfErrors.setFont(PLAIN_FONT);\n\n\t\tfNumberOfFailures= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfFailures.setText(\"0\");\n\t\tfNumberOfFailures.setFont(PLAIN_FONT);\n\n\t\tfNumberOfRuns= new Label(\"0000\", Label.RIGHT);\n\t\tfNumberOfRuns.setText(\"0\");\n\t\tfNumberOfRuns.setFont(PLAIN_FONT);\n\n\t\tPanel numbersPanel= createCounterPanel();\n\n\t\t//---- fourth section\n\t\tLabel failureLabel= new Label(\"Errors and Failures:\");\n\n\t\tfFailureList= new List(5);\n\t\tfFailureList.addItemListener(\n\t\t\tnew ItemListener() {\n\t\t\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\t\t\tfailureSelected();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tfRerunButton= new Button(\"Run\");\n\t\tfRerunButton.setEnabled(false);\n\t\tfRerunButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\trerun();\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\tPanel failedPanel= new Panel(new GridLayout(0, 1, 0, 2));\n\t\tfailedPanel.add(fRerunButton);\n\n\t\tfTraceArea= new TextArea();\n\t\tfTraceArea.setRows(5);\n\t\tfTraceArea.setColumns(60);\n\n\t\t//---- fifth section\n\t\tfStatusLine= new TextField();\n\t\tfStatusLine.setFont(PLAIN_FONT);\n\t\tfStatusLine.setEditable(false);\n\t\tfStatusLine.setForeground(Color.red);\n\n\t\tfQuitButton= new Button(\"Exit\");\n\t\tfQuitButton.addActionListener(\n\t\t\tnew ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\n\t\t// ---------\n\t\tfLogo= new Logo();\n\n\t\t//---- overall layout\n\t\tPanel panel= new Panel(new GridBagLayout());\n\n\t\taddGrid(panel, suiteLabel,\t\t 0, 0, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fSuiteField, \t 0, 1, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fRun, \t\t\t 2, 1, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fUseLoadingRunner, 0, 2, 2, GridBagConstraints.NONE, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fProgressIndicator, 0, 3, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fLogo, \t\t\t 2, 3, 1, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.NORTH);\n\n\t\taddGrid(panel, numbersPanel,\t 0, 4, 2, GridBagConstraints.NONE, \t\t\t0.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, failureLabel, \t 0, 5, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, fFailureList, \t 0, 6, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\t\taddGrid(panel, failedPanel, \t 2, 6, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fTraceArea, \t     0, 7, 2, GridBagConstraints.BOTH, \t\t\t1.0, GridBagConstraints.WEST);\n\n\t\taddGrid(panel, fStatusLine, \t 0, 8, 2, GridBagConstraints.HORIZONTAL, \t1.0, GridBagConstraints.CENTER);\n\t\taddGrid(panel, fQuitButton, \t 2, 8, 1, GridBagConstraints.HORIZONTAL, \t0.0, GridBagConstraints.CENTER);\n\n\t\tframe.add(panel, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\treturn frame;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected Panel createCounterPanel() throws HeadlessException {\n\t\tPanel numbersPanel= new Panel(new GridBagLayout());\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Runs:\"),\n\t\t\t0, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 0, 0, 0) \n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfRuns, \n          \t1, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Errors:\"),\n          \t2, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfErrors,\n          \t3, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 40)\n\t\t);\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tnew Label(\"Failures:\"),\n          \t4, 0, 1, 1, 0.0, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.NONE,\n          \tnew Insets(0, 8, 0, 0)\n\t\t);\t\n\t\taddToCounterPanel(\n\t\t\tnumbersPanel,\n\t\t\tfNumberOfFailures,\n          \t5, 0, 1, 1, 0.33, 0.0,\n          \tGridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL,\n          \tnew Insets(0, 8, 0, 0) \n\t\t);\n\t\treturn numbersPanel;\n\t}",
          "uniqueId": "8c46dd2f3212fa331528fc92019d4f22abe2ffc1_142_294_292_337_142_290"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "0807a8cd01b6d63d54f9a3580540fa35b7fb292e",
      "url": "https://github.com/junit-team/junit4/commit/0807a8cd01b6d63d54f9a3580540fa35b7fb292e",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private static void readPreferences() {\n \t\tInputStream is= null;\n \t\ttry {\n \t\t\tis= new FileInputStream(getPreferencesFile());\n \t\t\tfPreferences= new Properties(fPreferences);\n\t\t\tfPreferences.load(is);\n\t\t} catch (IOException e) {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t}\n\t\t}\n \t}",
          "sourceCodeAfterRefactoring": "private static void readPreferences() {\n \t\tInputStream is= null;\n \t\ttry {\n \t\t\tis= new FileInputStream(getPreferencesFile());\n \t\t\tsetPreferences(new Properties(getPreferences()));\n\t\t\tgetPreferences().load(is);\n\t\t} catch (IOException e) {\n\t\t\ttry {\n\t\t\t\tif (is != null)\n\t\t\t\t\tis.close();\n\t\t\t} catch (IOException e1) {\n\t\t\t}\n\t\t}\n \t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static void setPreferences(Properties preferences) {\n\t\tfPreferences = preferences;\n\t}",
          "uniqueId": "0807a8cd01b6d63d54f9a3580540fa35b7fb292e_189_202_28_30_220_233"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected PrintStream writer() {\n\t\treturn fWriter;\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * @deprecated Use getWriter()\n\t */\n\tprotected PrintStream writer() {\n\t\treturn getWriter();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected PrintStream getWriter() {\n\t\treturn fWriter;\n\t}",
          "uniqueId": "0807a8cd01b6d63d54f9a3580540fa35b7fb292e_248_250_248_250_252_257"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "a1fef439624fe411d0bea8651324e28b134e8b4a",
      "url": "https://github.com/junit-team/junit4/commit/a1fef439624fe411d0bea8651324e28b134e8b4a",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Filters stack frames from internal JUnit classes\n\t */\n\tpublic static String filterStack(String stack) {\n\t\tif (!getPreference(\"filterstack\").equals(\"true\") || fgFilterStack == false)\n\t\t\treturn stack;\n\t\t\t\n\t\tStringWriter sw= new StringWriter();\n\t\tPrintWriter pw= new PrintWriter(sw);\n\t\tStringReader sr= new StringReader(stack);\n\t\tBufferedReader br= new BufferedReader(sr);\n\t\t\n\t\tString line;\n\t\ttry {\t\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tif (!filterLine(line))\n\t\t\t\t\tpw.println(line);\n\t\t\t}\n\t\t} catch (Exception IOException) {\n\t\t\treturn stack; // return the stack unfiltered\n\t\t}\n\t\treturn sw.toString();\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Filters stack frames from internal JUnit classes\n\t */\n\tpublic static String getFilteredTrace(String stack) {\n\t\tif (showStackRaw())\n\t\t\treturn stack;\n\t\t\t\n\t\tStringWriter sw= new StringWriter();\n\t\tPrintWriter pw= new PrintWriter(sw);\n\t\tStringReader sr= new StringReader(stack);\n\t\tBufferedReader br= new BufferedReader(sr);\n\t\t\n\t\tString line;\n\t\ttry {\t\n\t\t\twhile ((line= br.readLine()) != null) {\n\t\t\t\tif (!filterLine(line))\n\t\t\t\t\tpw.println(line);\n\t\t\t}\n\t\t} catch (Exception IOException) {\n\t\t\treturn stack; // return the stack unfiltered\n\t\t}\n\t\treturn sw.toString();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected static boolean showStackRaw() {\n\t\treturn !getPreference(\"filterstack\").equals(\"true\") || fgFilterStack == false;\n\t}",
          "uniqueId": "a1fef439624fe411d0bea8651324e28b134e8b4a_243_265_266_268_242_264"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "public Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.thrownException().getMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.thrownException() instanceof AssertionFailedError) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}",
          "sourceCodeAfterRefactoring": "public Component getListCellRendererComponent(\n\t\t\tJList list, Object value, int modelIndex, \n\t\t\tboolean isSelected, boolean cellHasFocus) {\n\t\n\t\t\tTestFailure failure= (TestFailure)value;\n\t\t\tString text= failure.failedTest().toString();\n\t\t\tString msg= failure.exceptionMessage();\n\t\t\tif (msg != null) \n\t\t\t\ttext+= \":\" + BaseTestRunner.truncate(msg); \n\t \n\t\t\tif (failure.isFailure()) { \n\t\t\t\tif (fFailureIcon != null)\n\t\t    \t\t\tsetIcon(fFailureIcon);\n\t\t\t} else {\n\t\t    \t\tif (fErrorIcon != null)\n\t\t    \t\t\tsetIcon(fErrorIcon);\n\t\t    \t}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);\n\t\t\tsetToolTipText(text);\n\t\t\treturn c;\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n}\n\t\t    \tComponent c= super.getListCellRendererComponent(list, text, modelIndex, isSelected, cellHasFocus);\n\t\t\tsetText(text);",
          "uniqueId": "a1fef439624fe411d0bea8651324e28b134e8b4a_34_55_50_52_34_55"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "f381b14b797ee0b9116221ec317b09acdf4e3ff3",
      "url": "https://github.com/junit-team/junit4/commit/f381b14b797ee0b9116221ec317b09acdf4e3ff3",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "public void rerun() {\n\t\tint index= fFailureList.getSelectedIndex();\n\t\tif (index == -1)\n\t\t\treturn;\n\t\n\t\tTest test= (Test)fFailedTests.elementAt(index);\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\tObject[] args= new Object[]{((TestCase)test).getName()};\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1)\n\t\t\tshowStatus(message+\" had an error\");\n\t\telse\n\t\t\tshowStatus(message+\" had a failure\");\n\t}",
          "sourceCodeAfterRefactoring": "public void rerun() {\n\t\tint index= fFailureList.getSelectedIndex();\n\t\tif (index == -1)\n\t\t\treturn;\n\n\t\tTest test= (Test)fFailedTests.elementAt(index);\n\t\trerunTest(test);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\tObject[] args= new Object[]{((TestCase)test).getName()};\n\t\t\treloadedTest= (Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1)\n\t\t\tshowStatus(message+\" had an error\");\n\t\telse\n\t\t\tshowStatus(message+\" had a failure\");\n\t}",
          "uniqueId": "f381b14b797ee0b9116221ec317b09acdf4e3ff3_330_361_339_365_330_337"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "1ebb01554a9ec2b5b2c83e7331efb80c7fda3222",
      "url": "https://github.com/junit-team/junit4/commit/1ebb01554a9ec2b5b2c83e7331efb80c7fda3222",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Returns a string representation of the test case\n\t */\n\tpublic String toString() {\n\t    return getName()+\"(\"+getClass().getName()+\")\";\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Returns a string representation of the test case\n\t */\n\tpublic String toString() {\n\t    return getDisplayName();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Return a string suitable for displaying to a user\n\t */\n\tpublic String getDisplayName() {\n\t    return getName()+\"(\"+getClass().getName()+\")\";\n\t}",
          "uniqueId": "1ebb01554a9ec2b5b2c83e7331efb80c7fda3222_182_187_188_193_182_187"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "538187aac8c4858e9e366c4e4ee4e50cf40331c6",
      "url": "https://github.com/junit-team/junit4/commit/538187aac8c4858e9e366c4e4ee4e50cf40331c6",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected TestResult doRun(Test suite, boolean wait) {\n\t\tTestResult result= createTestResult();\n\t\tresult.addListener(this);\n\t\tlong startTime= System.currentTimeMillis();\n\t\tsuite.run(result);\n\t\tlong endTime= System.currentTimeMillis();\n\t\tlong runTime= endTime-startTime;\n\t\twriter().println();\n\t\twriter().println(\"Time: \"+elapsedTimeAsString(runTime));\n\t\tprint(result);\n\n\t\twriter().println();\n\n\t\tif (wait) {\n\t\t\twriter().println(\"<RETURN> to continue\");\n\t\t\ttry {\n\t\t\t\tSystem.in.read();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}",
          "sourceCodeAfterRefactoring": "public TestResult doRun(Test suite, boolean wait) {\n\t\tTestResult result= createTestResult();\n\t\tresult.addListener(this);\n\t\tlong startTime= System.currentTimeMillis();\n\t\tsuite.run(result);\n\t\tlong endTime= System.currentTimeMillis();\n\t\tlong runTime= endTime-startTime;\n\t\twriter().println();\n\t\twriter().println(\"Time: \"+elapsedTimeAsString(runTime));\n\t\tprint(result);\n\n\t\twriter().println();\n\n\t\tpause(wait);\n\t\treturn result;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected void pause(boolean wait) {\n\t\tif (wait) {\n\t\t\twriter().println(\"<RETURN> to continue\");\n\t\t\ttry {\n\t\t\t\tSystem.in.read();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t}\n\t\t}\n\t}",
          "uniqueId": "538187aac8c4858e9e366c4e4ee4e50cf40331c6_70_92_87_96_70_85"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "04f4f3197084ad9ad7c050ce1a40d6f4421662f4",
      "url": "https://github.com/junit-team/junit4/commit/04f4f3197084ad9ad7c050ce1a40d6f4421662f4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t */\n\tpublic String toString() {\n\t\tif (fName != null)\n\t\t\treturn fName;\n\t\treturn super.toString();\n\t }",
          "sourceCodeAfterRefactoring": "/**\n\t */\n\tpublic String toString() {\n\t\tif (getName() != null)\n\t\t\treturn getName();\n\t\treturn super.toString();\n\t }",
          "diffSourceCode": "ExtractedCodeFragments:\n/**\n\t * Returns the name of the suite. Not all\n\t * test suites have a name and this method\n\t * can return null.\n\t */\n\tpublic String getName() {\n\t\treturn fName;\n\t}",
          "uniqueId": "04f4f3197084ad9ad7c050ce1a40d6f4421662f4_181_187_190_197_181_187"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "bfc94ee739d62127c7477300b26127bd560765a1",
      "url": "https://github.com/junit-team/junit4/commit/bfc94ee739d62127c7477300b26127bd560765a1",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Returns the loader to be used.\n\t */\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading)\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Returns the loader to be used.\n\t */\n\tpublic TestSuiteLoader getLoader() {\n\t\tif (useReoadingTestSuiteLoader())\n\t\t\treturn new ReloadingTestSuiteLoader();\n\t\treturn new StandardTestSuiteLoader();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprotected boolean useReoadingTestSuiteLoader() {\n\t\treturn getPreference(\"loading\").equals(\"true\") && !inVAJava() && fLoading;\n\t}",
          "uniqueId": "bfc94ee739d62127c7477300b26127bd560765a1_135_142_147_149_138_145"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4",
      "url": "https://github.com/junit-team/junit4/commit/4b1869ebb8002e5d0b82ab55460f6126043c9ec4",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t// prune the history\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > HISTORY_LENGTH; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}",
          "sourceCodeAfterRefactoring": "private void addToHistory(final String suite) {\n\t\tfor (int i= 0; i < fSuiteCombo.getItemCount(); i++) {\n\t\t\tif (suite.equals(fSuiteCombo.getItemAt(i))) {\n\t\t\t\tfSuiteCombo.removeItemAt(i);\n\t\t\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\t\t\tfSuiteCombo.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfSuiteCombo.insertItemAt(suite, 0);\n\t\tfSuiteCombo.setSelectedIndex(0);\n\t\tpruneHistory();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void pruneHistory() {\n\t\tint historyLength= getPreference(\"maxhistory\", HISTORY_LENGTH);\n\t\tif (historyLength < 1)\n\t\t\thistoryLength= 1;\n\t\tfor (int i= fSuiteCombo.getItemCount()-1; i > historyLength-1; i--) \n\t\t\tfSuiteCombo.removeItemAt(i);\n\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_155_168_128_134_114_126"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "protected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}",
          "sourceCodeAfterRefactoring": "protected JLabel createLogo() {\n\t\tJLabel label;\n\t\tIcon icon= getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\tif (icon != null) \n\t\t\tlabel= new JLabel(icon);\n\t\telse\n\t\t\tlabel= new JLabel(\"JV\");\n\t\tlabel.setToolTipText(\"JUnit Version \"+Version.id());\n\t\treturn label;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_318_321_762_769_250_259"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private Image loadFrameIcon() {\n\t\tToolkit toolkit= Toolkit.getDefaultToolkit();\n\t\ttry {\n\t\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"smalllogo.gif\");\n\t\t\treturn toolkit.createImage((ImageProducer) url.getContent());\n\t\t} catch (Exception ex) {\n\t\t}\n\t\treturn null;\n\t}",
          "sourceCodeAfterRefactoring": "private Image loadFrameIcon() {\n\t\tImageIcon icon= (ImageIcon)getIconResource(BaseTestRunner.class, \"smalllogo.gif\");\n\t\tif (icon != null)\n\t\t\treturn icon.getImage();\n\t\treturn null;\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic static Icon getIconResource(Class clazz, String name) {\n\t\tURL url= clazz.getResource(name);\n\t\tif (url == null) {\n\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\treturn null;\n\t\t} \n\t\treturn new ImageIcon(url);\n\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_509_517_762_769_476_481"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "private void rerun() {\n\t\tint index= fFailureList.getSelectedIndex();\n\t\tif (index == -1)\n\t\t\treturn;\n\t\n\t\tTestFailure failure= (TestFailure)fFailures.elementAt(index);\n\t\tTest test= failure.failedTest();\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= fTestLoader.reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).name()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1)\n\t\t\tshowStatus(message+\" had an error\");\n\t\telse\n\t\t\tshowStatus(message+\" had a failure\");\n\t}",
          "sourceCodeAfterRefactoring": "private void rerun() {\n\t\tTestRunView view= (TestRunView)fTestRunViews.elementAt(fTestViewTab.getSelectedIndex());\n\t\tTest rerunTest= view.getSelectedTest();\n\t\tif (rerunTest != null)\n\t\t\trerunTest(rerunTest);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nprivate void rerunTest(Test test) {\n\t\tif (!(test instanceof TestCase)) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTest reloadedTest= null;\n\t\ttry {\n\t\t\tClass reloadedTestClass= getLoader().reload(test.getClass());\n\t\t\tClass[] classArgs= { String.class };\n\t\t\tObject[] args= new Object[]{((TestCase)test).name()};\n\t\t\tConstructor constructor= reloadedTestClass.getConstructor(classArgs);\n\t\t\treloadedTest=(Test)constructor.newInstance(args);\n\t\t} catch(Exception e) {\n\t\t\tshowInfo(\"Could not reload \"+ test.toString());\n\t\t\treturn;\n\t\t}\n\t\tTestResult result= new TestResult();\n\t\treloadedTest.run(result);\n\t\t\n\t\tString message= reloadedTest.toString();\n\t\tif(result.wasSuccessful())\n\t\t\tshowInfo(message+\" was successful\");\n\t\telse if (result.errorCount() == 1) \n\t\t\tshowStatus(message+\" had an error\"); \n\t\telse \n\t\t\tshowStatus(message+\" had a failure\");\n\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_575_607_536_562_529_534"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Hook to plug in a UI component on the run line\n\t */\n\tprotected Component createRunExtension() {\n\t\treturn null;\n\t}",
          "sourceCodeAfterRefactoring": "private void showFailureDetail(Test test) {\n\t\tif (test != null) {\n\t\t\tListModel failures= getFailures();\n\t\t\tfor (int i= 0; i < failures.getSize(); i++) {\n\t\t\t\tTestFailure failure= (TestFailure)failures.getElementAt(i);\n\t\t\t\tif (failure.failedTest() == test) {\n\t\t\t\t\tfFailureView.showFailure(failure);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfFailureView.clear();\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\npublic ListModel getFailures() {\n\t\treturn fFailures;\n\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_361_366_441_443_678_690"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "TestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}",
          "sourceCodeAfterRefactoring": "TestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tloadIcons();\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nvoid loadIcons() {\n\t\t\tfErrorIcon= TestRunner.getIconResource(getClass(), \"icons/error.gif\");\n\t    \t\tfOkIcon= TestRunner.getIconResource(getClass(), \"icons/ok.gif\");\n\t    \t\tfFailureIcon= TestRunner.getIconResource(getClass(), \"icons/failure.gif\");\n\t\t}",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_32_37_29_33_24_27"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\n\t\tfTestLoader= BaseTestRunner.getLoader();\n\t\tString suiteName= null;\n\t\tif (args.length == 1) \n\t\t\tsuiteName= args[0];\n\t\telse if (args.length == 2 && args[0].equals(\"-c\")) \n\t\t\tsuiteName= extractClassName(args[1]);\n\t\t\t\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.setLocation(200, 200);\n\t\tfFrame.setVisible(true);\n\t\n\t\tif (suiteName != null) {\n\t\t\tsetSuiteName(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\n\t\tString suiteName= processArguments(args);\t\t\t\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.setLocation(200, 200);\n\t\tfFrame.setVisible(true);\n\t\n\t\tif (suiteName != null) {\n\t\t\tsetSuiteName(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nc.gridx= x; c.gridy= y;\n\t\tc.gridwidth= w;\n\t\tc.anchor= anchor;\n\t\tc.weightx= wx;\n\t\tc.fill= fill;\n\t\tif (fill == GridBagConstraints.BOTH || fill == GridBagConstraints.VERTICAL)\n\t\t\tc.weighty= 1.0;\n\t\tc.insets= new Insets(y == 0 ? GAP : 0, x == 0 ? GAP : 0, GAP, GAP);\n\t\tp.add(co, c);\n\t}\n\t\n\tprivate void appendFailure(String kind, Test test, Throwable t) {\n\t\tkind+= \": \" + test;\n\t\tString msg= t.getMessage();\n\t\tif (msg != null) {\n\t\t\tkind+= \":\" + truncate(msg); \n\t\t}\n\t\tfFailureList.add(kind);\n\t\tfExceptions.addElement(t);\n\t\tfFailedTests.addElement(test);\n\t\tif (fFailureList.getItemCount() == 1) {",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_454_473_68_88_456_469"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\n\t\tfTestLoader= BaseTestRunner.getLoader();\n\t\t\n\t\tString suiteName= null;\n\t\tif (args.length == 1) \n\t\t\tsuiteName= args[0];\n\t\telse if (args.length == 2 && args[0].equals(\"-c\")) \n\t\t\tsuiteName= extractClassName(args[1]);\n\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuiteName(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}",
          "sourceCodeAfterRefactoring": "/**\n\t * Starts the TestRunner\n\t */\n\tpublic void start(String[] args) {\t\t\n\t\tString suiteName= processArguments(args);\n\t\tfFrame= createUI(suiteName);\n\t\tfFrame.pack(); \n\t\tfFrame.setVisible(true);\n\n\t\tif (suiteName != null) {\n\t\t\tsetSuite(suiteName);\n\t\t\trunSuite();\n\t\t}\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setErrorValue(fTestResult.errorCount());\n\t\t\t\t\tappendFailure(\"Error\", test, t);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\t\n\tpublic void addFailure(final Test test, final AssertionFailedError t) {\n\t\tSwingUtilities.invokeLater(\n\t\t\tnew Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\tfCounterPanel.setFailureValue(fTestResult.failureCount());\n\t\t\t\t\tappendFailure(\"Failure\", test, t);\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t);\n\t}\n\t\n\tpublic void startTest(Test test) {",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_766_786_68_88_700_713"
        },
        {
          "type": "Extract And Move Method",
          "sourceCodeBeforeRefactoring": "protected JLabel createLogo() {\n\t\tjava.net.URL url= BaseTestRunner.class.getResource(\"logo.gif\");\n\t\treturn new JLabel(new ImageIcon(url));\n\t}",
          "sourceCodeAfterRefactoring": "protected JLabel createLogo() {\n\t\tIcon icon= TestRunner.getIconResource(BaseTestRunner.class, \"logo.gif\");\n\t\treturn new JLabel(icon);\n\t}",
          "diffSourceCode": "ExtractedCodeFragments:\n",
          "uniqueId": "4b1869ebb8002e5d0b82ab55460f6126043c9ec4_76_79_762_769_72_75"
        }
      ]
    },
    {
      "repository": "https://github.com/junit-team/junit4.git",
      "sha1": "de48375b1b601c32daf718c70c62f7f4b80b58aa",
      "url": "https://github.com/junit-team/junit4/commit/de48375b1b601c32daf718c70c62f7f4b80b58aa",
      "refactorings": [
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "TestTreeCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"ok.gif\");\n\t    \tfOkIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"failure.gif\");\n\t    \tfFailureIcon= new ImageIcon(url);\n\t\t}",
          "sourceCodeAfterRefactoring": "TestTreeCellRenderer() {\n\t    \t\tsuper();\n\t    \t\tfErrorIcon= loadIcon(\"error.gif\");\n\t    \t\tfOkIcon= loadIcon(\"ok.gif\");\n\t    \t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} \n\t\t\treturn new ImageIcon(url);\n\t\t}",
          "uniqueId": "de48375b1b601c32daf718c70c62f7f4b80b58aa_32_40_39_46_32_37"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "FailureListCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"failure.gif\");\n\t\t\tfFailureIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t\t}",
          "sourceCodeAfterRefactoring": "void loadIcons() {\n\t\t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t\tfErrorIcon= loadIcon(\"error.gif\");\t\t\t\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} return new ImageIcon(url);\n\t\t}",
          "uniqueId": "de48375b1b601c32daf718c70c62f7f4b80b58aa_62_68_72_78_67_70"
        },
        {
          "type": "Extract Method",
          "sourceCodeBeforeRefactoring": "FailureListCellRenderer() {\n\t    \tsuper();\n\t    \tURL url= getClass().getResource(\"failure.gif\");\n\t\t\tfFailureIcon= new ImageIcon(url);\n\t    \turl= getClass().getResource(\"error.gif\");\n\t    \tfErrorIcon= new ImageIcon(url);\n\t\t}",
          "sourceCodeAfterRefactoring": "void loadIcons() {\n\t\t\tfFailureIcon= loadIcon(\"failure.gif\");\n\t\t\tfErrorIcon= loadIcon(\"error.gif\");\t\t\t\n\t\t}",
          "diffSourceCode": "ExtractedCodeFragments:\nImageIcon loadIcon(String name) {\n\t\t\tURL url= getClass().getResource(name);\n\t\t\tif (url == null) {\n\t\t\t\tSystem.err.println(\"Warning: could not load \\\"\"+name+\"\\\" icon\");\n\t\t\t\treturn null;\n\t\t\t} return new ImageIcon(url);\n\t\t}",
          "uniqueId": "de48375b1b601c32daf718c70c62f7f4b80b58aa_62_68_72_78_67_70"
        }
      ]
    }
  ]
}